<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="65d5283e253c2c7ea16ba664f4bae3d2f67005ec" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36560818" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementuje <see cref="T:System.IO.TextReader" /> które odczytuje z strumień bajtów przy użyciu określonego kodowania znaków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader> zaprojektowano pod kątem wprowadzanie znaków przy użyciu określonego kodowania, podczas gdy <xref:System.IO.Stream> klasy jest przeznaczona dla bajtu danych wejściowych i wyjściowych. Użyj <xref:System.IO.StreamReader> do odczytywania z pliku tekstowego standardowe wiersze danych.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 <xref:System.IO.StreamReader> Wartość domyślna to kodowania UTF-8, chyba że określono inaczej, zamiast przyjęto wartość domyślną stronę kodową ANSI dla bieżącego systemu. UTF-8 poprawnie obsługuje znaki Unicode i zapewnia spójne wyniki w zlokalizowanej wersji systemu operacyjnego. Jeśli bieżący kodowania znaków przy użyciu <xref:System.IO.StreamReader.CurrentEncoding%2A> właściwości, wartość nie jest niezawodnej dopiero po pierwszym <xref:System.IO.StreamReader.Read%2A> metody, ponieważ kodowanie automatyczne wykrywanie nie odbywa się przed pierwszym wywołaniu <xref:System.IO.StreamReader.Read%2A> metody.  
  
 Domyślnie <xref:System.IO.StreamReader> nie jest wątku bezpieczne. Zobacz <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> dla otoki obsługującej wielowątkowość.  
  
 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> i <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia metody odczytu i zapisu liczba znaków, określony przez `count` parametru. Są to się różnić od <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> i <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, który odczytu i zapisu liczba bajtów określona przez `count` parametru. Użyj <xref:System.IO.BufferedStream> metody tylko do odczytu i zapisu całkowitą liczbę bajtów elementów tablicy.  
  
> [!NOTE]
>  Podczas odczytu z <xref:System.IO.Stream>, jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia <xref:System.IO.StreamReader> odczytać tekstu z pliku. Konstruktor używany w tym przykładzie nie jest obsługiwane do użycia w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 Poniższy przykład tworzy <xref:System.IO.StreamReader> obiektu i wywołania jego <xref:System.IO.StreamReader.ReadAsync%2A> metodę, aby odczytać plik asynchronicznie.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> za pomocą właściwości `stream` parametru i rozmiaru buforu wewnętrznego 1024 bajty.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełna ścieżka jest określona przez `path` parametru. Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding> i rozmiaru buforu 1024 bajty.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego obiektu stream, o opcję wykrywania znacznik kolejności bajtów określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> za pomocą właściwości `stream` parametru i rozmiaru buforu wewnętrznego 1024 bajty.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego obiektu stream, przy użyciu kodowania określony znak.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie znaków jest ustawiana przez `encoding` parametr, a rozmiar buforu ma ustawioną wartość 1024 bajty. <xref:System.IO.StreamReader> Obiektu próbuje wykryć kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla nazwy pliku o opcję wykrywania znacznik kolejności bajtów określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> za pomocą właściwości `stream` parametru i rozmiaru buforu wewnętrznego 1024 bajty.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie <xref:System.Text.UTF8Encoding> jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku, przy użyciu kodowania określony znak.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametru i rozmiaru buforu wewnętrznego 1024 bajty. <xref:System.IO.StreamReader> Obiektu próbuje wykryć kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia z określony znak kodowania i typ byte kolejności wykrywania opcją oznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametru <xref:System.IO.StreamReader.BaseStream%2A> za pomocą właściwości `stream` parametru i rozmiaru buforu wewnętrznego 1024 bajty.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla nazwy pliku z określony znak kodowania i typ byte kolejności wykrywania opcją oznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametru i rozmiaru buforu wewnętrznego 1024 bajty.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <param name="bufferSize">Minimalny rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego obiektu stream, znakiem określonego kodowania opcję wykrywania znacznik kolejności bajtów, a rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar buforu w znakach 16-bitowych jest ustawiana przez `bufferSize` parametru. Jeśli `bufferSize` jest mniejsza niż minimalny dozwolony rozmiar (128 znaków), służy minimalny dozwolony rozmiar.  
  
 Ten konstruktor umożliwia zmianę po raz pierwszy odczytać z kodowaniem <xref:System.IO.StreamReader> obiektu. `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!NOTE]
>  Podczas odczytu z <xref:System.IO.Stream>, jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest mniejsza lub równa zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <param name="bufferSize">Rozmiar buforu minimalną liczbę znaków 16-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku, w tym znakiem kodowanie opcję wykrywania znacznik kolejności bajtów, a rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametru.  
  
 Ten konstruktor umożliwia zmianę po raz pierwszy odczytać z kodowaniem <xref:System.IO.StreamReader> obiektu. `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 Rozmiar buforu w znakach 16-bitowych jest ustawiana przez `bufferSize` parametru. Jeśli `bufferSize` jest mniejsza niż minimalny dozwolony rozmiar (128 znaków), służy minimalny dozwolony rozmiar.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, takich jak w mapowany dysk.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> jest mniejsza lub równa zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">
          <see langword="true" /> Aby wyszukać znaczniki kolejności bajtów na początku pliku. w przeciwnym razie <see langword="false" />.</param>
        <param name="bufferSize">Minimalny rozmiar buforu.</param>
        <param name="leaveOpen">
          <see langword="true" /> Aby pozostaw otwarte po strumienia <see cref="T:System.IO.StreamReader" /> obiekt jest usunięty; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> dla określonego obiektu stream na podstawie określonego kodowania znaków, opcję wykrywania znacznik kolejności bajtów i rozmiar buforu, a opcjonalnie pozostawia strumienia Otwórz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ustawisz `leaveOpen` parametr `true`, <xref:System.IO.StreamReader> obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
 Rozmiar buforu w znakach 16-bitowych jest ustawiana przez `bufferSize` parametru. Jeśli `bufferSize` jest mniejsza niż minimalny dozwolony rozmiar (128 znaków), służy minimalny dozwolony rozmiar.  
  
 Ten konstruktor umożliwia zmianę po raz pierwszy odczytać z kodowaniem <xref:System.IO.StreamReader> obiektu. Jeśli `detectEncodingFromByteOrderMarks` parametr jest `true`, konstruktora wykrywa kodowanie, analizując pierwsze trzy bajty strumienia. Automatycznie rozpoznaje UTF-8, little endian Unicode i oznacza big-endian tekst Unicode, jeśli plik, który rozpoczyna się od kolejności bajtów odpowiednie. W przeciwnym razie dostarczane przez użytkownika kodowanie jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
> [!NOTE]
>  Podczas odczytu z <xref:System.IO.Stream>, jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki mogą nie być prawidłowo interpretowane i może spowodować wyjątek zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca źródłowego strumienia.</summary>
        <value>Zasadniczy strumień.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do źródłowego strumienia. <xref:System.IO.StreamReader> Klasy danych wejściowych buforów z zasadniczy strumień podczas wywoływania jednej z <xref:System.IO.StreamReader.Read%2A> metody. Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; jednak ta metoda spowalnia działanie i powinna być wywoływana tylko wtedy, gdy jest to bezwzględnie konieczne. <xref:System.IO.StreamReader> Konstruktorów, które mają `detectEncodingFromByteOrderMarks` parametru można zmienić po raz pierwszy odczytać z kodowaniem <xref:System.IO.StreamReader> obiektu.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.IO.StreamReader" /> obiektu i odpowiedni strumień i zwalnia wszystkie zasoby systemu skojarzone z czytnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> metody.  
  
 Ta implementacja <xref:System.IO.StreamReader.Close%2A> wywołania <xref:System.IO.StreamReader.Dispose%2A> metody przekazywanie `true` wartość.  
  
 Opróżnianie strumienia nie opróżnić jego podstawowym kodera, chyba że jawnie wywołać <xref:System.IO.StreamReader.Close%2A>. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> do `true` oznacza, że dane zostaną opróżnione z buforu w strumieniu, ale nie zostaną opróżnione kodera stanu. Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko wtedy, gdy odbiera koder sąsiedniego znaku ani znaków.  
  
 Po wywołaniu <xref:System.IO.StreamReader.Close%2A>, jakichkolwiek działań na czytnik może zgłaszać wyjątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący znak kodowania, które bieżący <see cref="T:System.IO.StreamReader" /> używa obiektu.</summary>
        <value>Bieżący znak kodowanie używane przez bieżącego czytnika. Po pierwszym wywołaniu dowolnej wartości mogą być różne <see cref="Overload:System.IO.StreamReader.Read" /> metody <see cref="T:System.IO.StreamReader" />, ponieważ kodowania automatycznego wykrywania nie odbywa się przed pierwszym wywołaniu <see cref="Overload:System.IO.StreamReader.Read" /> metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera kodowanie określonego <xref:System.IO.StreamReader> obiektu.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści buforu wewnętrznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metoda bufor wewnętrzny przeznaczony <xref:System.IO.StreamReader> obiektu. Należy wywołać tej metody tylko wtedy, gdy pozycja buforu wewnętrznego i <xref:System.IO.StreamReader.BaseStream%2A> nie są zgodne. Te pozycje może stać się niezgodne, gdy odczytywać dane w buforze, a następnie wyszukiwać nowej pozycji w strumieniu podstawowym. Ta metoda spowalnia działanie i należy używać tylko wtedy, gdy jest to bezwzględnie konieczne, np. Jeśli chcesz odczytać część zawartość <xref:System.IO.StreamReader> obiektu więcej niż raz.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono scenariusz gdzie <xref:System.IO.StreamReader.DiscardBufferedData%2A> można wywołać metody, aby zsynchronizować wewnętrznego buforu i zasadniczy strumień. Plik w tym przykładzie jest używany w celu zilustrowania pozycji i składa się z tekstu `abcdefghijklmnopqrstuvwxyz`. Wywołując <xref:System.IO.StreamReader.DiscardBufferedData%2A> po danych jest do odczytu, przykładzie działa zgodnie z oczekiwaniami. Po pierwszych 15 znaków są odczytywane, pozycja jest ustawiany na wartość przesunięcia 2 i wszystkich pozostałych znaków do odczytu. Jeśli usuniesz wywołanie <xref:System.IO.StreamReader.DiscardBufferedData%2A>, przykładzie nie działa zgodnie z oczekiwaniami. Najpierw 15 znaków do odczytu, ale tylko pozycja zasadniczy strumień zostanie zresetowana. Bufor wewnętrzny <xref:System.IO.StreamReader> obiekt jest nadal na 16 znaków. W związku z tym <xref:System.IO.StreamReader.ReadToEnd%2A> zwraca wszystkie znaki w buforze, a także znaków w strumieniu podstawowym, zaczynając od pozycji resetowania.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zamyka zasadniczy strumień, zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.StreamReader" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.IDisposable.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. <xref:System.IDisposable.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.StreamReader.Dispose%2A> metody z `disposing` parametr ma wartość true. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.StreamReader.Dispose%2A> z `disposing` ustawiony na wartość false.  
  
 Gdy `disposing` parametr jest `true`, ten — metoda zwalnia wszystkie zasoby w posiadaniu żadnego zarządzane obiekty, które <xref:System.IO.StreamReader> obiektu odwołania. Ta metoda wywołuje <xref:System.IDisposable.Dispose%2A> metody każdego odwołuje się do obiektu.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Usuwania można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, nie można odwoływać się do obiektów, które zostały wcześniej zlikwidowane w starszych wywołanie metody Dispose [cref,...]. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> Zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see cref="M:System.IDisposable.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia się niezarządzane Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie strumień jest końcem strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli bieżącą pozycję w strumieniu znajduje się na końcu strumienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Zasadniczy strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.IO.StreamReader" /> obiekt wokół pustego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas odczytu metody są wywoływane na <xref:System.IO.StreamReader.Null>, zwracany jest zawsze zero. Gdy <xref:System.IO.StreamReader.ReadLine%2A> jest wywoływana <xref:System.IO.StreamReader.Null>, `null` jest zwracany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca następny znak dostępne, ale nie zużywa.</summary>
        <returns>Liczba całkowita reprezentująca następny znak do odczytania lub -1, jeśli nie są znaki do odczytu lub strumień nie obsługuje wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader.Peek%2A> — Metoda zwraca wartość w celu określenia, czy do końca pliku lub inny błąd wystąpił. Umożliwia użytkownikowi najpierw sprawdź, czy zwrócone wartości jest wartość -1 przed rzutowania go do <xref:System.Char> typu.  
  
 Ta metoda zastępuje <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 Bieżąca pozycja <xref:System.IO.StreamReader> obiektu nie ulega zmianie przez <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod odczytuje wierszy z pliku, dopóki nie zostanie osiągnięty koniec pliku.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje następny znak lub dalej zestawu znaków ze strumienia wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny znak ze strumienia wejściowego i zwiększa położenie znaku o jeden znak.</summary>
        <returns>Następny znak ze strumienia wejściowego reprezentowane jako <see cref="T:System.Int32" /> obiektu lub -1, jeśli żadne więcej znaki nie są dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Ta metoda zwraca liczbę całkowitą, dzięki czemu może on zwrócić wartość -1, jeśli osiągnięto koniec strumienia. Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; jednak ta metoda spowalnia działanie i powinna być wywoływana tylko wtedy, gdy jest to bezwzględnie konieczne.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano prosty użycie <xref:System.IO.StreamReader.Read%2A> metody.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 Poniższy przykład kodu pokazuje, odczyt za pomocą pojedynczego znaku <xref:System.IO.StreamReader.Read> przeciążenie metody, formatowanie liczb całkowitych ASCII wyjściowej jako dziesiętne i szesnastkowej.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeksu + liczba - 1</c>) zastąpione przez znaki odczytane z bieżącego źródła.</param>
        <param name="index">Indeks <c>buforu</c> pod którym ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania.</param>
        <summary>Odczytuje maksymalnej liczby znaków z bieżącego strumienia w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Liczba znaków, które zostały odczytu lub 0, jeśli na końcu strumienia i danych nie została odczytana. Liczba będzie równa mniejsze niż lub równe <paramref name="count" /> parametru, w zależności od tego, czy dane są dostępne w ramach strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Ta metoda zwraca liczbę całkowitą, dzięki czemu może on zwrócić 0, jeśli osiągnięto koniec strumienia.  
  
 Korzystając z <xref:System.IO.StreamReader.Read%2A> metody jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak buforu wewnętrznego strumienia, którego buforu wewnętrznego ustawiono rozmiar żądanego bloku i zawsze odczytać mniejszy niż rozmiar bloku. Jeśli rozmiar buforu wewnętrznego była nieokreślony, gdy strumień został utworzony, jego domyślny rozmiar to 4 kilobajtów (4096 bajtów). Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; jednak ta metoda spowalnia działanie i powinna być wywoływana tylko wtedy, gdy jest to bezwzględnie konieczne.  
  
 Ta metoda zwraca po albo liczba znaków, określony przez `count` parametru są odczytywane lub zostanie osiągnięty koniec pliku. <xref:System.IO.TextReader.ReadBlock%2A> to blokującego wersja <xref:System.IO.StreamReader.Read%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod odczytuje pięć znaków w czasie, dopóki nie zostanie osiągnięty koniec pliku.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość buforu pomniejszona o <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Występuje błąd We/Wy, takich jak strumień jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeksu</c> + <c>liczba</c> - 1) zastępowaną przez znaki odczytywane z bieżącego źródła.</param>
        <param name="index">Pozycja w <c>buforu</c> pod którym ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Jeśli zostanie osiągnięty koniec strumienia, przed zapisaniem określoną liczbę znaków w buforze, zwraca bieżącą metodę.</param>
        <summary>Asynchronicznie odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę znaków do odczytu w buforze. Wartość wyniku może być mniejsza niż liczba znaków żądana liczba znaków, które są aktualnie dostępne jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie kończy się po jednej liczba znaków, określony przez `count` parametru są odczytywane lub osiągnięto koniec strumienia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób odczytać wszystkie znaki w pliku przy użyciu <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody. Sprawdza, czy każdy znak jest literą, cyfrą lub biały znak, przed dodaniem znak na wystąpienie <xref:System.Text.StringBuilder> klasy.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="index" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeksu + liczba - 1</c>) zastąpione przez znaki odczytane z bieżącego źródła.</param>
        <param name="index">Pozycja w <c>buforu</c> pod którym ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania.</param>
        <summary>Odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Liczba znaków, które zostały przeczytane. Liczba będzie równa mniejsze niż lub równe <paramref name="count" />, w zależności od tego, czy wszystkie znaki wejściowy został odczytany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja zasadniczy strumień jest zaawansowane według liczby znaków, które zostały odczytane w `buffer`.  
  
 Bloki metody do momentu `count` znaki są odczytywane lub osiągnięto koniec strumienia. Jest to blokującego wersji <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość buforu pomniejszona o <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.StreamReader" /> Jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeksu</c> + <c>liczba</c> - 1) zastępowaną przez znaki odczytywane z bieżącego źródła.</param>
        <param name="index">Pozycja w <c>buforu</c> pod którym ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Jeśli zostanie osiągnięty koniec strumienia, przed zapisaniem określoną liczbę znaków w buforze, metoda zwraca wartość.</param>
        <summary>Asynchronicznie odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę znaków do odczytu w buforze. Wartość wyniku może być mniejsza niż liczba znaków żądana liczba znaków, które są aktualnie dostępne jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie nie zostanie ukończone do momentu liczba znaków, określony przez `count` parametru są odczytywane lub osiągnięto koniec strumienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="index" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wiersz znaków z bieżącego strumienia i zwraca dane jako ciąg.</summary>
        <returns>Następnego wiersza ze strumienia wejściowego lub <see langword="null" /> gdy zostanie osiągnięty koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiersz jest zdefiniowany jako sekwencja znaków, a następnie wiersz źródła danych ("\n"), powrotu karetki ("\r") lub znak powrotu karetki poprzedzającą wiersz źródła danych ("\r\n"). Ciąg, który jest zwracany zawiera Trwa przerywanie działania powrotu karetki i wysuwu wiersza. Zwrócona wartość jest `null` gdy zostanie osiągnięty koniec strumienia wejściowego.  
  
 Ta metoda zastępuje <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Jeśli bieżąca metoda zgłasza <xref:System.OutOfMemoryException>, pozycja czytelnika w podstawowych <xref:System.IO.Stream> obiektu jest zaawansowane według liczby znaków metody był w stanie odczytywać, ale znaki odczytane już do wewnętrznej <xref:System.IO.StreamReader.ReadLine%2A> buforu zostaną odrzucone. . Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; jednak ta metoda spowalnia działanie i powinna być wywoływana tylko wtedy, gdy jest to bezwzględnie konieczne.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod odczytuje wierszy z pliku, dopóki nie zostanie osiągnięty koniec pliku.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje wiersz znaków z bieżącego strumienia i zwraca dane jako ciąg.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera następnego wiersza ze strumienia lub jest <see langword="null" /> Jeśli odczytano wszystkich znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób odczytać pierwszy wiersz pliku przy użyciu <xref:System.IO.StreamReader.ReadLineAsync> metody.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków w następnym wierszu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie znaki od bieżącej pozycji na koniec strumienia.</summary>
        <returns>Pozostała część strumienia jako ciąg, z bieżącej pozycji na końcu. Jeśli bieżące położenie jest na końcu strumienia, zwraca ciąg pusty ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> działa najlepiej, gdy zachodzi potrzeba odczytania wszystkich danych wejściowych od bieżącej pozycji na koniec strumienia. Jeśli wymagane jest większą kontrolę nad liczbę znaków są odczytany ze strumienia, użyj <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody, które zazwyczaj wynikiem lepszą wydajność.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> przyjęto założenie, strumienia wie, po osiągnięciu punktu końcowego. Interakcyjne protokołów, w których serwer wysyła dane tylko wtedy, gdy zażądać go, a nie zamknąć połączenie <xref:System.IO.StreamReader.ReadToEnd%2A> mogą blokować przez czas nieokreślony, ponieważ nie uzyskano punktu końcowego i należy unikać.  
  
 Należy pamiętać, że przy użyciu <xref:System.IO.StreamReader.Read%2A> metody jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia. Jeśli rozmiar buforu został nieokreślony, gdy strumień został utworzony, jego domyślny rozmiar to 4 kilobajtów (4096 bajtów).  
  
 Jeśli bieżąca metoda zgłasza <xref:System.OutOfMemoryException>, pozycja czytelnika w podstawowych <xref:System.IO.Stream> obiektu jest zaawansowane według liczby znaków metody był w stanie odczytywać, ale znaki odczytane już do wewnętrznej <xref:System.IO.StreamReader.ReadLine%2A> buforu zostaną odrzucone. . Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; jednak ta metoda spowalnia działanie i powinna być wywoływana tylko wtedy, gdy jest to bezwzględnie konieczne.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod odczytuje aż do końca pliku w jednej operacji.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie znaki od bieżącej pozycji do końca strumienia asynchronicznie i zwraca je w postaci jednego ciągu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametru zawiera ciąg znaków z bieżącego położenia koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak można odczytać zawartości pliku przy użyciu <xref:System.IO.StreamReader.ReadToEndAsync> metody.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
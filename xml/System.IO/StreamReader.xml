<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="167938056e09839fdcccc2b6bcbd6e510700380d" />
    <Meta Name="ms.sourcegitcommit" Value="84c54c0c7d64827a5637d1f05e74e1f0598606a1" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/27/2018" />
    <Meta Name="ms.locfileid" Value="42944580" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementuje <see cref="T:System.IO.TextReader" /> który odczytuje znaki ze strumienia bajtów przy użyciu określonego kodowania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader> jest przeznaczona dla danych wejściowych znak, przy użyciu określonego kodowania, natomiast <xref:System.IO.Stream> klasa jest przeznaczona do obsługi bajtowych danych wejściowych i wyjściowych. Użyj <xref:System.IO.StreamReader> do odczytywania wierszy zawierających informacje z pliku tekstowego standardowych.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
 <xref:System.IO.StreamReader> Wartość domyślna to kodowanie UTF-8, chyba że określono inaczej, zamiast używać domyślnej strony kodowej ANSI dla bieżącego systemu. UTF-8 poprawnie obsługuje znaki Unicode i zapewnia spójne wyniki w zlokalizowanych wersjach systemu operacyjnego. Jeśli bieżący kodowanie znaków za pomocą <xref:System.IO.StreamReader.CurrentEncoding%2A> właściwości wartość nie jest niezawodne, aż po pierwszym <xref:System.IO.StreamReader.Read%2A> metody, ponieważ automatyczne wykrywanie kodowania, nie jest wykonywane aż do pierwsze wywołanie w celu <xref:System.IO.StreamReader.Read%2A> metody.  
  
 Domyślnie <xref:System.IO.StreamReader> nie jest wątek bezpieczne. Zobacz <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> dla otoki metodą o bezpiecznych wątkach.  
  
 <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> i <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia metody odczytu i zapisu liczba znaków określoną przez `count` parametru. Są to się różnić od <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> i <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, którego odczyt i zapis liczbę bajtów określoną przez `count` parametru. Użyj <xref:System.IO.BufferedStream> metody tylko do odczytu i zapisu całkowitą liczbę bajtów z elementów tablicy.  
  
> [!NOTE]
>  Podczas odczytu z <xref:System.IO.Stream>, jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto wystąpienia <xref:System.IO.StreamReader> do odczytywania tekstu z pliku. Konstruktor używany w tym przykładzie nie jest obsługiwane do użytku w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 Poniższy przykład tworzy wystąpienie <xref:System.IO.StreamReader> obiektów i wywołuje jego <xref:System.IO.StreamReader.ReadAsync%2A> metody do asynchronicznego odczytu pliku.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> właściwość za pomocą `stream` parametr i rozmiar wewnętrznego buforu do 1024 bajty.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na podany <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełna ścieżka jest określona przez `path` parametru. Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding> i rozmiaru buforu 1024 bajty.  
  
 `path` Parametr może być nazwa pliku, w tym pliku w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany do pliku przechowywanego na dysku; może to być dowolnej części systemu, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera niepoprawne lub nieprawidłowa składnia nazwy pliku, nazwa katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia, z opcją wykrywanie znaku kolejność określoną liczbę bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> właściwość za pomocą `stream` parametr i rozmiar wewnętrznego buforu do 1024 bajty.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na podany <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia, z kodowaniem określonego znaku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie znaków jest ustawiana przez `encoding` parametr i rozmiar buforu jest ustawiona na 1024 bajty. <xref:System.IO.StreamReader> Obiekt próbuje wykryć kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na podany <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku, z opcją wykrywanie znaku kolejność określoną liczbę bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie <xref:System.Text.UTF8Encoding>, <xref:System.IO.StreamReader.BaseStream%2A> właściwość za pomocą `stream` parametr i rozmiar wewnętrznego buforu do 1024 bajty.  
  
 `path` Parametr może być nazwa pliku, w tym pliku w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany do pliku przechowywanego na dysku; może to być dowolnej części systemu, który obsługuje dostęp za pomocą strumieni.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie <xref:System.Text.UTF8Encoding> jest używany. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera niepoprawne lub nieprawidłowa składnia nazwy pliku, nazwa katalogu lub etykiety woluminu.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku, z kodowaniem określonego znaku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametr i rozmiar wewnętrznego buforu do 1024 bajty. <xref:System.IO.StreamReader> Obiekt próbuje wykryć kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 `path` Parametr może być nazwa pliku, w tym pliku w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany do pliku przechowywanego na dysku; może to być dowolnej części systemu, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera niepoprawne lub nieprawidłowa składnia nazwy pliku, nazwa katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia, z określonego znaku kodowania i bajtów kolejności wykrywania opcją oznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametru <xref:System.IO.StreamReader.BaseStream%2A> właściwość za pomocą `stream` parametr i rozmiar wewnętrznego buforu do 1024 bajty.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na podany <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku, z określonego znaku kodowania i bajtów kolejności wykrywania opcją oznaczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametr i rozmiar wewnętrznego buforu do 1024 bajty.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 `path` Parametr może być nazwa pliku, w tym pliku w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany do pliku przechowywanego na dysku; może to być dowolnej części systemu, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera niepoprawne lub nieprawidłowa składnia nazwy pliku, nazwa katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <param name="bufferSize">Minimalny rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia z określonego znaku, kodowanie, opcję wykrywania znacznik kolejności bajtów, a rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar buforu w znakach 16-bitowych jest ustawiana przez `bufferSize` parametru. Jeśli `bufferSize` jest mniejszy niż minimalny dozwolony rozmiar (128 znaków), używana jest minimalny dozwolony rozmiar.  
  
 Ten konstruktor pozwala na zmianę, po raz pierwszy odczytu z kodowaniem <xref:System.IO.StreamReader> obiektu. `detectEncodingFromByteOrderMarks` Parametr wykrywa, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 <xref:System.IO.StreamReader> Obiektu wywołania <xref:System.IO.Stream.Dispose> na podany <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!NOTE]
>  Podczas odczytu z <xref:System.IO.Stream>, jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest mniejsza niż lub równy zeru.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <param name="bufferSize">Minimalny rozmiar buforu w znakach 16-bitowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku, w tym znakiem kodowanie opcję wykrywania znacznik kolejności bajtów, a rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowania określony przez `encoding` parametru.  
  
 Ten konstruktor pozwala na zmianę, po raz pierwszy odczytu z kodowaniem <xref:System.IO.StreamReader> obiektu. `detectEncodingFromByteOrderMarks` Parametr wykrywa, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
 Rozmiar buforu w znakach 16-bitowych jest ustawiana przez `bufferSize` parametru. Jeśli `bufferSize` jest mniejszy niż minimalny dozwolony rozmiar (128 znaków), używana jest minimalny dozwolony rozmiar.  
  
 `path` Parametr może być nazwa pliku, w tym pliku w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany do pliku przechowywanego na dysku; może to być dowolnej części systemu, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, to <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera niepoprawne lub nieprawidłowa składnia nazwy pliku, nazwa katalogu lub etykiety woluminu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> jest mniejsza niż lub równy zeru.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do odczytu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">
          <see langword="true" /> Aby wyszukać znaczniki kolejności bajtów na początku pliku. w przeciwnym razie <see langword="false" />.</param>
        <param name="bufferSize">Minimalny rozmiar buforu.</param>
        <param name="leaveOpen">
          <see langword="true" /> Aby pozostawić otwarty po strumienia <see cref="T:System.IO.StreamReader" /> obiekt jest usunięte; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia oparte na określony znak kodowania, opcję wykrywania znacznik kolejności bajtów i rozmiar buforu, a następnie opcjonalnie pozostawia strumienia Otwórz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ile nie ustawisz `leaveOpen` parametr `true`, <xref:System.IO.StreamReader> obiektu wywołania <xref:System.IO.Stream.Dispose> na podany <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
 Rozmiar buforu w znakach 16-bitowych jest ustawiana przez `bufferSize` parametru. Jeśli `bufferSize` jest mniejszy niż minimalny dozwolony rozmiar (128 znaków), używana jest minimalny dozwolony rozmiar.  
  
 Ten konstruktor pozwala na Zmień kodowanie po raz pierwszy możesz odczytywać <xref:System.IO.StreamReader> obiektu. Jeśli `detectEncodingFromByteOrderMarks` parametr jest `true`, Konstruktor wykryje, kodowanie, analizując pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian Unicode, tekst little-endian UTF-32 i big-endian UTF-32 jeśli zaczyna się znaczniki kolejności bajtów odpowiedni plik. W przeciwnym razie dostarczone przez użytkownika jest używane kodowanie. Zobacz <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> metody, aby uzyskać więcej informacji.  
  
> [!NOTE]
>  Podczas odczytu z <xref:System.IO.Stream>, jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki nie mogą być interpretowane prawidłowo i może spowodować zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca zasadniczy strumień.</summary>
        <value>Zasadniczy strumień.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do źródłowego strumienia. <xref:System.IO.StreamReader> Klasy bufory dane wejściowe zasadniczy strumień po wywołaniu jednej z <xref:System.IO.StreamReader.Read%2A> metody. Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; Jednakże, ta metoda zmniejsza wydajność i powinna być wywoływana tylko wtedy, gdy jest to absolutnie konieczne. <xref:System.IO.StreamReader> Konstruktorów, które mają `detectEncodingFromByteOrderMarks` parametru można zmienić po raz pierwszy odczytu z kodowaniem <xref:System.IO.StreamReader> obiektu.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.IO.StreamReader" /> obiektu oraz podstawowego strumienia i wersje zasobów systemu skojarzone z czytnika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> metody.  
  
 Ta implementacja <xref:System.IO.StreamReader.Close%2A> wywołania <xref:System.IO.StreamReader.Dispose%2A> metoda przekazywania `true` wartość.  
  
 Opróżnianie strumienia nie opróżnić jego podstawowej kodera, chyba że jawnie wywołać <xref:System.IO.StreamReader.Close%2A>. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> do `true` oznacza, że dane zostaną opróżnione z buforu do strumienia, ale nie zostaną opróżnione stanu kodera. Dzięki temu kodera zapewnienie jego stan (częściowa znaków), aby ją poprawnie kodowanie kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w których niektóre znaki mogą być zakodowane tylko wtedy, gdy kodera odbiera sąsiadujących znak lub znaki.  
  
 Po wywołaniu <xref:System.IO.StreamReader.Close%2A>, żadnych operacji na czytnik mogą zgłaszać wyjątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący znak kodowania, które bieżący <see cref="T:System.IO.StreamReader" /> używa obiektu.</summary>
        <value>Bieżący znak kodowanie używane przez bieżącego czytnika. Po pierwsze wywołanie do dowolnej wartości mogą być różne <see cref="Overload:System.IO.StreamReader.Read" /> metody <see cref="T:System.IO.StreamReader" />, ponieważ kodowania automatycznego wykrywania nie jest wykonywane aż do pierwsze wywołanie <see cref="Overload:System.IO.StreamReader.Read" /> metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera kodowanie określonego <xref:System.IO.StreamReader> obiektu.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści bufor wewnętrzny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodę, aby zresetować bufor wewnętrzny przeznaczony <xref:System.IO.StreamReader> obiektu. Musisz wywołać tej metody tylko wtedy, gdy pozycja buforu wewnętrznego i <xref:System.IO.StreamReader.BaseStream%2A> nie są zgodne. Te pozycje może stać się niezgodne, podczas odczytu danych w buforze, a następnie wyszukiwanie nowej pozycji zasadniczy strumień. Ta metoda zmniejsza wydajność i należy używać tylko wtedy, gdy jest to absolutnie konieczne, np. Jeśli chcesz odczytać część zawartości <xref:System.IO.StreamReader> obiektu więcej niż jeden raz.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono scenariusz, gdzie <xref:System.IO.StreamReader.DiscardBufferedData%2A> można wywołać metody, aby zsynchronizować wewnętrznego buforu i zasadniczy strumień. Plik w tym przykładzie jest używany w celu zilustrowania pozycji i składa się z tekstu `abcdefghijklmnopqrstuvwxyz`. Przez wywołanie metody <xref:System.IO.StreamReader.DiscardBufferedData%2A> po odczycie danych przykład działa zgodnie z oczekiwaniami. Po pierwsze 15 znaków są odczytywane, pozycja jest resetowana do wartości przesunięcia z 2, a wszystkie pozostałe znaki są odczytywane. Jeśli usuniesz wywołanie <xref:System.IO.StreamReader.DiscardBufferedData%2A>, przykładu nie działa zgodnie z oczekiwaniami. Są odczytywane przez pierwsze 15 znaków, ale tylko pozycja zasadniczy strumień jest resetowana. Bufor wewnętrzny <xref:System.IO.StreamReader> obiekt nadal znajduje się na 16 znaków. W związku z tym <xref:System.IO.StreamReader.ReadToEnd%2A> zwraca wszystkie znaki w buforze, a także znaków w zasadniczy strumień, zaczynając od pozycji resetowania.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zamyka zasadniczy strumień, zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.StreamReader" />i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną <xref:System.IDisposable.Dispose%2A> metody i <xref:System.Object.Finalize%2A> metody. <xref:System.IDisposable.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.StreamReader.Dispose%2A> metody z `disposing` parametr ma wartość true. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.StreamReader.Dispose%2A> z `disposing` ustawiony na wartość false.  
  
 Gdy `disposing` parametr jest `true`ten wersji metody, wszystkie zasoby utrzymywane przez dowolny zarządzane obiekty, które <xref:System.IO.StreamReader> obiektu odwołania. Ta metoda wywołuje <xref:System.IDisposable.Dispose%2A> metoda każdego obiektu, do którego istnieje odwołanie.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Usuwania można wywołać wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do usuwania [cref,...]. Aby uzyskać więcej informacji o sposobie wdrażania <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Aby uzyskać więcej informacji na temat <see cref="M:System.IDisposable.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie strumień jest na końcu strumienia.</summary>
        <value>
          <see langword="true" /> Jeśli bieżąca pozycja strumień jest na końcu strumienia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Zasadniczy strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see cref="T:System.IO.StreamReader" /> obiekt wokół pustego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas czytania metody są wywoływane na <xref:System.IO.StreamReader.Null>, zwracany jest zawsze zero. Gdy <xref:System.IO.StreamReader.ReadLine%2A> jest wywoływane na <xref:System.IO.StreamReader.Null>, `null` jest zwracana.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca następny znak dostępne, ale nie używa.</summary>
        <returns>Liczba całkowita reprezentująca następny znak do odczytania, lub wartość -1 w przypadku żadnych znaków do odczytu, lub jeśli strumień nie obsługuje wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader.Peek%2A> Metoda zwraca wartość liczby całkowitej w celu określenia, czy do końca pliku lub inny błąd wystąpił. Dzięki temu użytkownik może najpierw sprawdzić, czy zwracana wartość jest wartość -1 przed rzutowania go na <xref:System.Char> typu.  
  
 Ta metoda zastępuje <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 Bieżące położenie <xref:System.IO.StreamReader> obiektu nie jest zmieniany przez <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje wiersze z pliku, dopóki nie zostanie osiągnięty koniec pliku.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje następny znak lub następny zestaw znaków ze strumienia wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny znak ze strumienia wejściowego i zwiększa położenie znaku o jeden znak.</summary>
        <returns>Następny znak ze strumienia wejściowego reprezentowane jako <see cref="T:System.Int32" /> obiekt lub wartość -1, jeśli dostępnych jest więcej znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Ta metoda zwraca liczbę całkowitą, aby je zwracają wartość -1, jeśli osiągnięto koniec strumienia. Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; Jednakże, ta metoda zmniejsza wydajność i powinna być wywoływana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie prostego <xref:System.IO.StreamReader.Read%2A> metody.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 Poniższy przykład kodu demonstruje, odczytu, przy użyciu pojedynczego znaku <xref:System.IO.StreamReader.Read> przeciążenia metody, formatowanie liczb całkowitych ASCII, dane wyjściowe jako wartości dziesiętnej i szesnastkowe.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeks i licznik — 1</c>) zastąpione przez znaki odczytane z bieżącego źródła.</param>
        <param name="index">Indeks <c>buforu</c> jaką ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania.</param>
        <summary>Odczytuje maksymalnej liczby znaków ze strumienia bieżącego w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Liczba znaków, które zostały odczytu lub 0, jeśli komputer znajduje się na końcu strumienia i żadne dane nie zostały odczytane. Numer jest mniejsza niż lub równe <paramref name="count" /> parametru, w zależności od tego, czy dane są dostępne w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Ta metoda zwraca liczbę całkowitą, aby je zwracają 0, jeśli osiągnięto koniec strumienia.  
  
 Korzystając z <xref:System.IO.StreamReader.Read%2A> metody jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia, gdzie wewnętrznego buforu jest równa rozmiarowi żądanego bloku i zawsze odczytać mniejszy niż rozmiar bloku. Jeśli rozmiar wewnętrznego buforu był nieokreślony, gdy strumień został skonstruowany, jego domyślny rozmiar to 4 kilobajty (4096 bajtów). Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; Jednakże, ta metoda zmniejsza wydajność i powinna być wywoływana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Ta metoda zwraca po albo liczba znaków określoną przez `count` parametru są odczytywane lub zostanie osiągnięty koniec pliku. <xref:System.IO.TextReader.ReadBlock%2A> jest to wersja blokowania <xref:System.IO.StreamReader.Read%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje pięć znaków, aż zostanie osiągnięty koniec pliku.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość buforu pomniejszona o <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy, takich jak strumień jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeksu</c> + <c>liczba</c> - 1) zastępowaną przez znaki Odczyt z bieżącego źródła.</param>
        <param name="index">Pozycja w <c>buforu</c> jaką ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Jeśli osiągnięty zostanie koniec strumienia przed zapisaniem określoną liczbę znaków w buforze, bieżąca metoda zwraca wartość.</param>
        <summary>Asynchronicznie odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę znaków czytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba znaków, jeśli liczba znaków, obecnie dostępna jest mniejsza niż żądana liczba lub może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie kończy się po upływie liczby znaków, określony przez `count` parametru są odczytywane lub osiągnięty zostanie koniec strumienia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak odczytywać wszystkie znaki w pliku przy użyciu <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody. Sprawdza, czy każdy znak jest literą, cyfrą lub biały znak, przed dodaniem znak do wystąpienia <xref:System.Text.StringBuilder> klasy.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="index" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeks i licznik — 1</c>) zastąpione przez znaki odczytane z bieżącego źródła.</param>
        <param name="index">Pozycja w <c>buforu</c> jaką ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania.</param>
        <summary>Odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Liczba znaków, które zostały odczytane. Numer jest mniejsza niż lub równe <paramref name="count" />, w zależności od tego, czy wszystkie znaki wejściowy został odczytany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja zasadniczy strumień jest zaawansowany według liczby znaków, które zostały odczytane w `buffer`.  
  
 Bloki metody do momentu `count` znaki są odczytywane lub osiągnięto koniec strumienia. To jest wersja blokowania <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość buforu pomniejszona o <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.StreamReader" /> Jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Po powrocie z tej metody zawiera określoną tablicę znaków z wartością pomiędzy <c>indeksu</c> i (<c>indeksu</c> + <c>liczba</c> - 1) zastępowaną przez znaki Odczyt z bieżącego źródła.</param>
        <param name="index">Pozycja w <c>buforu</c> jaką ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Jeśli osiągnięty zostanie koniec strumienia przed zapisaniem określoną liczbę znaków w buforze, metoda zwraca wartość.</param>
        <summary>Asynchronicznie odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę znaków czytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba znaków, jeśli liczba znaków, obecnie dostępna jest mniejsza niż żądana liczba lub może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie nie zostanie ukończone do momentu liczba znaków określoną przez `count` parametru są odczytywane lub osiągnięto koniec strumienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="index" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wiersz znaków z bieżącego strumienia i zwraca dane jako ciąg.</summary>
        <returns>Następny wiersz ze strumienia wejściowego lub <see langword="null" /> Jeśli osiągnięty zostanie koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiersz jest zdefiniowany jako sekwencja znaków, a następnie wiersz źródła danych ("\n"), karetki ("\r") lub znak powrotu karetki bezpośrednio po nim wiersz źródła danych ("\r\n"). Ciąg, który jest zwracany nie zawiera kończącego znaku powrotu karetki i wysuwu wiersza. Zwrócona wartość jest `null` Jeśli osiągnięty zostanie koniec strumienia wejściowego.  
  
 Ta metoda zastępuje <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Jeśli bieżąca metoda zgłasza <xref:System.OutOfMemoryException>, pozycja czytelnika w źródłowym <xref:System.IO.Stream> obiektu jest zaawansowany według liczby znaków, metoda nie może odczytać, ale znaki już odczytywany przez wewnętrzny <xref:System.IO.StreamReader.ReadLine%2A> buforu są odrzucane. . Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; Jednakże, ta metoda zmniejsza wydajność i powinna być wywoływana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje wiersze z pliku, dopóki nie zostanie osiągnięty koniec pliku.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie odczytuje wiersz znaków z bieżącego strumienia i zwraca dane jako ciąg.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera następny wiersz ze strumienia lub jest <see langword="null" /> Jeśli znasz wszystkich znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak odczytywać pierwszy wiersz pliku przy użyciu <xref:System.IO.StreamReader.ReadLineAsync> metody.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków w następnym wierszu jest większy niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie znaki od bieżącej pozycji do końca strumienia.</summary>
        <returns>Pozostała część strumienia jako ciąg znaków, z bieżącego położenia na końcu. Jeśli bieżące położenie jest na końcu strumienia, zwraca pusty ciąg ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> działa najlepiej, gdy zachodzi potrzeba odczytania wszystkich danych wejściowych z bieżącego położenia na końcu strumienia. Użyj razie większą kontrolę nad liczbę znaków są odczytywane ze strumienia <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia metody, co zwykle powoduje lepszą wydajność.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A> przyjęto założenie, strumień wie, kiedy osiągnął koniec. Interaktywne protokołów, w których serwer wysyła dane tylko wtedy, gdy zażądać go i nie zamyka połączenia <xref:System.IO.StreamReader.ReadToEnd%2A> może spowodować zablokowanie przez czas nieokreślony, ponieważ nie dociera do punktu końcowego i należy ich unikać.  
  
 Należy pamiętać, że podczas korzystania <xref:System.IO.StreamReader.Read%2A> metody jest bardziej wydajne, aby użyć buforu, który jest taki sam rozmiar jak wewnętrznego buforu strumienia. Jeśli rozmiar bufora podczas nieokreślony strumień został skonstruowany, jego domyślny rozmiar to 4 kilobajty (4096 bajtów).  
  
 Jeśli bieżąca metoda zgłasza <xref:System.OutOfMemoryException>, pozycja czytelnika w źródłowym <xref:System.IO.Stream> obiektu jest zaawansowany według liczby znaków, metoda nie może odczytać, ale znaki już odczytywany przez wewnętrzny <xref:System.IO.StreamReader.ReadLine%2A> buforu są odrzucane. . Jeśli pozycja zasadniczy strumień manipulować po odczytaniu danych w buforze, pozycja zasadniczy strumień mogą nie odpowiadać pozycja buforu wewnętrznego. Aby zresetować wewnętrznego buforu, należy wywołać <xref:System.IO.StreamReader.DiscardBufferedData%2A> metody; Jednakże, ta metoda zmniejsza wydajność i powinna być wywoływana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje aż do końca pliku w ramach jednej operacji.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie znaki od bieżącej pozycji do końca strumienia asynchronicznego i zwraca je jako jeden ciąg.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametru zawiera ciąg znaków z bieżącego położenia na końcu strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak odczytywać zawartość pliku przy użyciu <xref:System.IO.StreamReader.ReadToEndAsync> metody.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
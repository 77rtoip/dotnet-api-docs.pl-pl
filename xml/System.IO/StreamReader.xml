<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="55c5793c8442e2c63b2aa7f0ce83d3fa8a62954d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69242929" /></Metadata><TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementuje element <see cref="T:System.IO.TextReader" /> , który odczytuje znaki ze strumienia bajtów w określonym kodowaniu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader>jest przeznaczony do wprowadzania znaków w określonym kodowaniu, podczas gdy <xref:System.IO.Stream> Klasa jest zaprojektowana dla danych wejściowych i wyjściowych bajtów. Służy <xref:System.IO.StreamReader> do odczytywania wierszy informacji z standardowego pliku tekstowego.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 <xref:System.IO.StreamReader>Domyślnie kodowanie UTF-8, chyba że określono inaczej, zamiast domyślnego strony kodowej ANSI dla bieżącego systemu. UTF-8 obsługuje znaki Unicode i zapewnia spójne wyniki w zlokalizowanych wersjach systemu operacyjnego. Jeśli otrzymasz bieżące kodowanie znaków przy użyciu <xref:System.IO.StreamReader.CurrentEncoding%2A> właściwości, wartość jest niezawodna do momentu pierwszej <xref:System.IO.StreamReader.Read%2A> metody, ponieważ Autowykrywanie kodowania nie zostanie wykonane do momentu pierwszego wywołania <xref:System.IO.StreamReader.Read%2A> metody.  
  
 Domyślnie <xref:System.IO.StreamReader> nie jest to wątek bezpieczny. Zobacz <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> , aby znaleźć bezpieczny wątkowo otokę.  
  
 Metody <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> `count` i <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążania odczytają i zapisują liczbę znaków określoną przez parametr. Są one odróżnione od <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> i <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, które odczytują i zapisują liczbę bajtów określoną przez `count` parametr. <xref:System.IO.BufferedStream> Użyj metod tylko do odczytu i zapisu całkowitej liczby elementów tablicy bajtowej.  
  
> [!NOTE]
>  Podczas odczytywania z <xref:System.IO.Stream>, bardziej wydajne jest użycie bufora o takim samym rozmiarze jak wewnętrzny bufor strumienia.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład używa wystąpienia programu <xref:System.IO.StreamReader> w celu odczytania tekstu z pliku. Konstruktor używany w tym przykładzie nie jest obsługiwany w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacjach.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 Poniższy przykład tworzy wystąpienie <xref:System.IO.StreamReader> obiektu i wywołuje jego <xref:System.IO.StreamReader.ReadAsync%2A> metodę, aby asynchronicznie odczytywać plik.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który ma zostać odczytany.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie do <xref:System.Text.UTF8Encoding> <xref:System.IO.StreamReader.BaseStream%2A> , właściwość używająca `stream` parametru i wewnętrzny rozmiar buforu do 1024 bajtów.  
  
 Obiekt wywołuje <xref:System.IO.Stream.Dispose> dla podanego <xref:System.IO.Stream> obiektu, <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> gdy jest wywoływana. <xref:System.IO.StreamReader>  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" />nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku do odczytu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełna ścieżka pliku jest określana przez `path` parametr. Ten konstruktor inicjuje kodowanie do <xref:System.Text.UTF8Encoding> i rozmiar buforu do 1024 bajtów.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />zawiera niepoprawną lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który ma zostać odczytany.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia, z określoną opcją wykrywania typu kolejności bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie do <xref:System.Text.UTF8Encoding> <xref:System.IO.StreamReader.BaseStream%2A> , właściwość używająca `stream` parametru i wewnętrzny rozmiar buforu do 1024 bajtów.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 Obiekt wywołuje <xref:System.IO.Stream.Dispose> dla podanego <xref:System.IO.Stream> obiektu, <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> gdy jest wywoływana. <xref:System.IO.StreamReader>  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" />nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który ma zostać odczytany.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia z określonym kodowaniem znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie znaków jest ustawiane przez `encoding` parametr, a rozmiar buforu jest ustawiony na 1024 bajtów. <xref:System.IO.StreamReader> Obiekt próbuje wykryć kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 Obiekt wywołuje <xref:System.IO.Stream.Dispose> dla podanego <xref:System.IO.Stream> obiektu, <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> gdy jest wywoływana. <xref:System.IO.StreamReader>  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" />nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku do odczytu.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku z opcją wykrywania określonego typu kolejności bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie do <xref:System.Text.UTF8Encoding> <xref:System.IO.StreamReader.BaseStream%2A> , właściwość używająca `stream` parametru i wewnętrzny rozmiar buforu do 1024 bajtów.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie jest używany. <xref:System.Text.UTF8Encoding> Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />zawiera niepoprawną lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku do odczytu.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku z określonym kodowaniem znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie określone przez `encoding` parametr i wewnętrzny rozmiar buforu do 1024 bajtów. <xref:System.IO.StreamReader> Obiekt próbuje wykryć kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera niepoprawną lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który ma zostać odczytany.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia, z określonym kodowaniem znaków i opcją wykrycia typu kolejności bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie określone przez `encoding` parametr <xref:System.IO.StreamReader.BaseStream%2A> , właściwość używająca `stream` parametru i wewnętrzny rozmiar buforu do 1024 bajtów.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 Obiekt wywołuje <xref:System.IO.Stream.Dispose> dla podanego <xref:System.IO.Stream> obiektu, <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> gdy jest wywoływana. <xref:System.IO.StreamReader>  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" />nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku do odczytu.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku z opcją wykrycia określonego kodowania znaków i znacznika kolejności bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie określone przez `encoding` parametr i wewnętrzny rozmiar buforu do 1024 bajtów.  
  
 `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera niepoprawną lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który ma zostać odczytany.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <param name="bufferSize">Minimalny rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia, z określonym kodowaniem znaków, opcjami wykrywania i rozmiarem buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozmiar buforu w liczbie 16-bitowych znaków jest ustawiany przez `bufferSize` parametr. Jeśli `bufferSize` wartość jest mniejsza niż minimalny dozwolony rozmiar (128 znaków), jest używany Minimalny dozwolony rozmiar.  
  
 Ten konstruktor pozwala na zmianę kodowania podczas pierwszego odczytu z <xref:System.IO.StreamReader> obiektu. `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 Obiekt wywołuje <xref:System.IO.Stream.Dispose> dla podanego <xref:System.IO.Stream> obiektu, <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> gdy jest wywoływana. <xref:System.IO.StreamReader>  
  
> [!NOTE]
>  Podczas odczytywania z <xref:System.IO.Stream>, bardziej wydajne jest użycie bufora o takim samym rozmiarze jak wewnętrzny bufor strumienia.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest mniejsze lub równe zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka pliku do odczytu.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks">Wskazuje, czy na początku pliku mają być szukane znaczniki kolejności bajtów.</param>
        <param name="bufferSize">Minimalny rozmiar buforu (w liczbie 16 znaków).</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonej nazwy pliku z określonym kodowaniem znaków, opcjami wykrywania znaczników kolejności bajtów i rozmiarem buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje kodowanie określone przez `encoding` parametr.  
  
 Ten konstruktor pozwala na zmianę kodowania podczas pierwszego odczytu z <xref:System.IO.StreamReader> obiektu. `detectEncodingFromByteOrderMarks` Parametr wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
 Rozmiar buforu w liczbie 16-bitowych znaków jest ustawiany przez `bufferSize` parametr. Jeśli `bufferSize` wartość jest mniejsza niż minimalny dozwolony rozmiar (128 znaków), jest używany Minimalny dozwolony rozmiar.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie musi być plikiem przechowywanym na dysku; może to być dowolna część systemu, która obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje tego <xref:System.IO.StreamReader> konstruktora.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pustym ciągiem ("").</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera niepoprawną lub nieprawidłową składnię nazwy pliku, nazwy katalogu lub etykiety woluminu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffersize" />jest mniejsze lub równe zero.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który ma zostać odczytany.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="detectEncodingFromByteOrderMarks"><see langword="true" />Aby wyszukać znaczniki kolejności bajtów na początku pliku; w przeciwnym razie. <see langword="false" /></param>
        <param name="bufferSize">Minimalny rozmiar buforu.</param>
        <param name="leaveOpen"><see langword="true" />Aby pozostawić strumień otwarty po usunięciu <see cref="T:System.IO.StreamReader" /> obiektu; <see langword="false" />w przeciwnym razie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.StreamReader" /> klasy dla określonego strumienia w oparciu o określone kodowanie znaków, opcję wykrywania znacznika kolejności bajtów i rozmiar buforu, opcjonalnie pozostawiając otwarcie strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `leaveOpen` <xref:System.IO.Stream> <xref:System.IO.Stream.Dispose> <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> parametr nie zostanie ustawiony <xref:System.IO.StreamReader> na ,obiektwywołujedlapodanegoobiektu,gdyjestwywoływana.`true`  
  
 Rozmiar buforu w liczbie 16-bitowych znaków jest ustawiany przez `bufferSize` parametr. Jeśli `bufferSize` wartość jest mniejsza niż minimalny dozwolony rozmiar (128 znaków), jest używany Minimalny dozwolony rozmiar.  
  
 Ten konstruktor umożliwia zmianę kodowania przy pierwszym odczycie z <xref:System.IO.StreamReader> obiektu. Jeśli parametr ma `true`wartość, Konstruktor wykrywa kodowanie, sprawdzając pierwsze cztery bajty strumienia. `detectEncodingFromByteOrderMarks` Automatycznie rozpoznaje UTF-8, little-endian Unicode, big-endian w formacie Unicode, Little-32 i UTF-32 tekstu, jeśli plik zaczyna się od odpowiednich znaków kolejności bajtów. W przeciwnym razie używane jest kodowanie dostarczone przez użytkownika. Aby uzyskać <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> więcej informacji, zobacz metodę.  
  
> [!NOTE]
>  Podczas odczytywania z <xref:System.IO.Stream>, bardziej wydajne jest użycie bufora o takim samym rozmiarze jak wewnętrzny bufor strumienia.  
  
> [!CAUTION]
>  W przypadku kompilowania zestawu znaków z określonym ustawieniem kultury i pobrania tych samych znaków przy użyciu innego ustawienia kulturowego, znaki mogą nie być poprawnie interpretowane i mogą powodować wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca strumień źródłowy.</summary>
        <value>Źródłowy strumień.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do uzyskiwania dostępu do podstawowego strumienia. Klasa buforuje dane wejściowe z bazowego strumienia po wywołaniu jednej <xref:System.IO.StreamReader.Read%2A> z metod. <xref:System.IO.StreamReader> W przypadku manipulowania pozycją źródłowego strumienia po odczytaniu danych do bufora pozycja strumienia podstawowego może nie odpowiadać pozycji buforu wewnętrznego. Aby zresetować bufor wewnętrzny, wywołaj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodę, jednak ta metoda spowalnia wydajność i powinna zostać wywołana tylko wtedy, gdy jest to absolutnie konieczne. Konstruktory, które `detectEncodingFromByteOrderMarks` mają parametr mogą zmienić kodowanie <xref:System.IO.StreamReader> podczas pierwszego odczytu z obiektu. <xref:System.IO.StreamReader>  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.IO.StreamReader" /> Zamyka obiekt i źródłowy strumień oraz zwalnia wszystkie zasoby systemowe skojarzone z czytnikiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ta metoda przesłania <xref:System.IO.TextReader.Close%2A?displayProperty=nameWithType> metodę.  
  
Ta implementacja <xref:System.IO.StreamReader.Close%2A> <xref:System.IO.StreamReader.Dispose%2A> wywołuje metodę, przekazując `true` wartość.  
  
Po wywołaniu metody <xref:System.IO.StreamReader.Close%2A>wszystkie operacje na czytniku mogą spowodować wystąpienie wyjątków.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżące kodowanie znaków używane przez bieżący <see cref="T:System.IO.StreamReader" /> obiekt.</summary>
        <value>Bieżące kodowanie znaków używane przez bieżący czytnik. Wartość może być różna po pierwszym wywołaniu dowolnej <see cref="Overload:System.IO.StreamReader.Read" /> <see cref="T:System.IO.StreamReader" />metody, ponieważ Autowykrywanie kodowania nie jest wykonywane do momentu pierwszego wywołania <see cref="Overload:System.IO.StreamReader.Read" /> metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera kodowanie określonego <xref:System.IO.StreamReader> obiektu.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści bufor wewnętrzny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.IO.StreamReader.DiscardBufferedData%2A> , aby zresetować bufor wewnętrzny <xref:System.IO.StreamReader> dla obiektu. Należy wywołać tę metodę tylko wtedy, gdy pozycja bufora wewnętrznego i <xref:System.IO.StreamReader.BaseStream%2A> nie jest zgodna. Te pozycje mogą być niezgodne, gdy odczytujesz dane do buforu, a następnie szukasz nowego położenia w strumieniu źródłowym. Ta metoda spowalnia wydajność i powinna być używana tylko wtedy, gdy jest to absolutnie konieczne, na przykład wtedy, gdy chcesz odczytać część zawartości <xref:System.IO.StreamReader> obiektu więcej niż raz.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono scenariusz, <xref:System.IO.StreamReader.DiscardBufferedData%2A> w którym metoda musi zostać wywołana w celu zsynchronizowania buforu wewnętrznego i bazowego strumienia. Plik w przykładzie jest używany do zilustrowania położenia i składa się z tekstu `abcdefghijklmnopqrstuvwxyz`. <xref:System.IO.StreamReader.DiscardBufferedData%2A> Po odczytaniu danych, przykład działa zgodnie z oczekiwaniami. Po odczytaniu pierwszych 15 znaków pozycja jest resetowana do wartości przesunięcia 2 i wszystkie pozostałe znaki są odczytywane. W przypadku usunięcia wywołania do <xref:System.IO.StreamReader.DiscardBufferedData%2A>programu przykład nie działa zgodnie z oczekiwaniami. Odczytane są pierwsze 15 znaków, ale tylko pozycja strumienia źródłowego jest resetowana. Wewnętrzny bufor <xref:System.IO.StreamReader> obiektu jest nadal na szesnastym znaku. W związku <xref:System.IO.StreamReader.ReadToEnd%2A> z tym zwraca wszystkie znaki w buforze oraz znaki w źródłowym strumieniu, rozpoczynając od pozycji Reset.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zamyka źródłowy strumień, zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.StreamReader" />program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.IDisposable.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę. <xref:System.IDisposable.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.StreamReader.Dispose%2A> `disposing` z parametrem ustawionym na wartość true. <xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.StreamReader.Dispose%2A> z`disposing` ustawioną na wartość false.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez obiekty zarządzane, do których <xref:System.IO.StreamReader> odwołuje się obiekt. `disposing` Ta metoda wywołuje <xref:System.IDisposable.Dispose%2A> metodę każdego przywoływanego obiektu.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Metoda Dispose może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej zlikwidowane we wcześniejszej wywołaniu metody Dispose [cref,...]. Więcej informacji o sposobach implementacji <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> można znaleźć w temacie [Implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see cref="M:System.IDisposable.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące położenie strumienia znajduje się na końcu strumienia.</summary>
        <value><see langword="true" />Jeśli bieżące położenie strumienia znajduje się na końcu strumienia; w <see langword="false" />przeciwnym razie.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień źródłowy został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.IO.StreamReader" /> Obiekt wokół pustego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy metody odczytu są wywoływane w <xref:System.IO.StreamReader.Null>dniu, wartość zerowa jest zawsze zwracana. Gdy <xref:System.IO.StreamReader.ReadLine%2A> jest wywoływana w <xref:System.IO.StreamReader.Null>, `null` jest zwracana.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca następny dostępny znak, ale go nie używa.</summary>
        <returns>Liczba całkowita reprezentująca następny znak do odczytu lub-1, jeśli nie ma znaków do odczytu lub strumień nie obsługuje wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamReader.Peek%2A> Metoda zwraca liczbę całkowitą, aby określić, czy koniec pliku lub Wystąpił inny błąd. Dzięki temu użytkownik może najpierw sprawdzić, czy zwrócona wartość to-1 przed rzutem na <xref:System.Char> typ.  
  
 Ta metoda przesłania <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 Bieżąca pozycja <xref:System.IO.StreamReader> obiektu nie jest zmieniana przez <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje wiersze z pliku do momentu osiągnięcia końca pliku.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje następny znak lub następny zestaw znaków ze strumienia wejściowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje następny znak ze strumienia wejściowego i przesuwa pozycję znaku o jeden znak.</summary>
        <returns>Następny znak ze strumienia wejściowego reprezentowany jako <see cref="T:System.Int32" /> obiekt lub-1, jeśli nie ma więcej znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Ta metoda zwraca liczbę całkowitą, aby można było zwrócić wartość-1, jeśli osiągnięto koniec strumienia. W przypadku manipulowania pozycją źródłowego strumienia po odczytaniu danych do bufora pozycja strumienia podstawowego może nie odpowiadać pozycji buforu wewnętrznego. Aby zresetować bufor wewnętrzny, wywołaj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodę, jednak ta metoda spowalnia wydajność i powinna zostać wywołana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje proste użycie <xref:System.IO.StreamReader.Read%2A> metody.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 Poniższy przykład kodu ilustruje odczytywanie pojedynczego znaku przy użyciu <xref:System.IO.StreamReader.Read> przeciążenia metody, formatowanie danych wyjściowych ASCII w postaci dziesiętnej i szesnastkowej.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Gdy ta metoda zwraca, zawiera określoną tablicę znaków z wartościami między <paramref name="index" /> i (<c>index + count-1</c>) zastąpione przez znaki odczytywane z bieżącego źródła.</param>
        <param name="index">Indeks <paramref name="buffer" /> , pod którym rozpocznie się zapisywanie.</param>
        <param name="count">Maksymalna liczba znaków do odczytania.</param>
        <summary>Odczytuje określoną liczbę znaków z bieżącego strumienia do buforu, rozpoczynając od określonego indeksu.</summary>
        <returns>Liczba znaków, które zostały odczytane lub 0 Jeśli na końcu strumienia i żadne dane nie zostały odczytane. Liczba będzie mniejsza lub równa <paramref name="count" /> parametrowi, w zależności od tego, czy dane są dostępne w strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Ta metoda zwraca liczbę całkowitą, dzięki czemu może zwrócić wartość 0, jeśli osiągnięto koniec strumienia.  
  
 W przypadku korzystania <xref:System.IO.StreamReader.Read%2A> z metody, bardziej wydajne jest użycie bufora o takim samym rozmiarze jak wewnętrzny bufor strumienia, gdzie bufor wewnętrzny jest ustawiony na żądany rozmiar bloku i zawsze odczytywany mniej niż rozmiar bloku. Jeśli rozmiar buforu wewnętrznego nie został określony, gdy strumień został skonstruowany, jego domyślny rozmiar to 4 kilobajty (4096 bajtów). W przypadku manipulowania pozycją źródłowego strumienia po odczytaniu danych do bufora pozycja strumienia podstawowego może nie odpowiadać pozycji buforu wewnętrznego. Aby zresetować bufor wewnętrzny, wywołaj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodę, jednak ta metoda spowalnia wydajność i powinna zostać wywołana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Ta metoda wraca po odczytaniu liczby znaków określonej przez `count` parametr lub osiągnięciu końca pliku. <xref:System.IO.TextReader.ReadBlock%2A>jest blokującą wersją programu <xref:System.IO.StreamReader.Read%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje pięć znaków jednocześnie do momentu osiągnięcia końca pliku.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość buforu minus <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak strumień jest zamknięty.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Gdy ta metoda zwraca, <paramref name="index" /> zawiera określoną tablicę znaków z wartościami między i (<paramref name="index" />  +  <paramref name="count" /> -1) zastąpione przez znaki odczytane z bieżącego źródła.</param>
        <param name="index">Położenie, w <paramref name="buffer" /> którym rozpocznie się zapisywanie.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Jeśli osiągnięto koniec strumienia przed określoną liczbą znaków w buforze, bieżąca metoda zwraca.</param>
        <summary>Odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia asynchronicznie i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <paramref name="TResult" /> parametru zawiera łączną liczbę znaków odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba żądanych znaków, jeśli liczba aktualnie dostępnych znaków jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie kończy się po odczytaniu liczby znaków określonej przez `count` parametr lub osiągnięciu końca strumienia.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak odczytać wszystkie znaki w pliku przy użyciu <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody. Sprawdza, czy każdy znak jest literą, cyfrą lub białym znakiem przed dodaniem znaku do wystąpienia <xref:System.Text.StringBuilder> klasy.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="index" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Gdy ta metoda zwraca, zawiera określoną tablicę znaków z wartościami między <paramref name="index" /> i (<c>index + count-1</c>) zastąpione przez znaki odczytywane z bieżącego źródła.</param>
        <param name="index">Położenie, w <paramref name="buffer" /> którym rozpocznie się zapisywanie.</param>
        <param name="count">Maksymalna liczba znaków do odczytania.</param>
        <summary>Odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Liczba znaków, które zostały odczytane. Liczba będzie mniejsza lub równa <paramref name="count" />, w zależności od tego, czy wszystkie znaki wejściowe zostały odczytane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja strumienia podstawowego jest zaawansowana przez liczbę znaków, do `buffer`których zostały odczytane.  
  
 Metoda jest blokowana do `count` momentu odczytania lub osiągnięcia końca strumienia. Jest to blokowa wersja programu <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość buforu minus <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.IO.StreamReader" /> Jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Gdy ta metoda zwraca, <paramref name="index" /> zawiera określoną tablicę znaków z wartościami między i (<paramref name="index" />  +  <paramref name="count" /> -1) zastąpione przez znaki odczytane z bieżącego źródła.</param>
        <param name="index">Położenie, w <paramref name="buffer" /> którym rozpocznie się zapisywanie.</param>
        <param name="count">Maksymalna liczba znaków do odczytania. Jeśli osiągnięto koniec strumienia przed określoną liczbą znaków w buforze, metoda zwraca.</param>
        <summary>Odczytuje określoną maksymalną liczbę znaków z bieżącego strumienia asynchronicznie i zapisuje dane w buforze, rozpoczynając od określonego indeksu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <paramref name="TResult" /> parametru zawiera łączną liczbę znaków odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba żądanych znaków, jeśli liczba aktualnie dostępnych znaków jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie nie zostanie ukończone, dopóki nie zostanie odczytana liczba znaków określona `count` przez parametr lub osiągnięto koniec strumienia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="index" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wiersz znaków z bieżącego strumienia i zwraca dane jako ciąg.</summary>
        <returns>Następny wiersz ze strumienia wejściowego lub <see langword="null" /> Jeśli osiągnięto koniec strumienia wejściowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiersz jest definiowany jako sekwencja znaków, po którym następuje znak wysuwu wiersza ("\n"), znak powrotu karetki ("\r") lub znak powrotu karetki bezpośrednio po znaku wysuwu wiersza ("\r\n"). Zwrócony ciąg nie zawiera przerywanego powrotu karetki lub wysuwu wiersza. Zwracana wartość jest `null` , jeśli osiągnięto koniec strumienia wejściowego.  
  
 Ta metoda przesłania <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Jeśli bieżąca metoda zgłasza element <xref:System.OutOfMemoryException>, pozycja czytnika w obiekcie źródłowym <xref:System.IO.Stream> jest zaawansowana przez liczbę znaków, jaką może odczytać Metoda, ale znaki już odczytane w buforze wewnętrznym <xref:System.IO.StreamReader.ReadLine%2A> są odrzucane . W przypadku manipulowania pozycją źródłowego strumienia po odczytaniu danych do bufora pozycja strumienia podstawowego może nie odpowiadać pozycji buforu wewnętrznego. Aby zresetować bufor wewnętrzny, wywołaj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodę, jednak ta metoda spowalnia wydajność i powinna zostać wywołana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje wiersze z pliku do momentu osiągnięcia końca pliku.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wiersz znaków asynchronicznie z bieżącego strumienia i zwraca dane jako ciąg.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <paramref name="TResult" /> parametru zawiera następny wiersz ze strumienia lub to <see langword="null" /> , czy wszystkie znaki zostały odczytane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak odczytać pierwszy wiersz pliku przy użyciu <xref:System.IO.StreamReader.ReadLineAsync> metody.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków w następnym wierszu jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie znaki od bieżącego położenia do końca strumienia.</summary>
        <returns>Pozostała część strumienia jako ciąg, od bieżącego położenia do końca. Jeśli bieżące położenie znajduje się na końcu strumienia, zwraca pusty ciąg ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przesłania <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A>działa najlepiej, gdy trzeba odczytać wszystkie dane wejściowe z bieżącego położenia do końca strumienia. Jeśli wymagana jest większa kontrola nad liczbą znaków odczytywanych ze strumienia, należy użyć <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia metody, które zwykle daje lepszą wydajność.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A>zakłada, że strumień wie, kiedy osiągnął koniec. W przypadku protokołów interaktywnych, w których serwer wysyła dane tylko wtedy, gdy użytkownik poprosił o to, i nie <xref:System.IO.StreamReader.ReadToEnd%2A> zamyka połączenia, może blokować czas nieokreślony, ponieważ nie dociera do końca i należy unikać.  
  
 Należy pamiętać, że w <xref:System.IO.StreamReader.Read%2A> przypadku korzystania z metody, bardziej wydajne jest użycie bufora o takim samym rozmiarze jak wewnętrzny bufor strumienia. Jeśli rozmiar buforu nie został określony, gdy strumień został skonstruowany, jego domyślny rozmiar to 4 kilobajty (4096 bajtów).  
  
 Jeśli bieżąca metoda zgłasza element <xref:System.OutOfMemoryException>, pozycja czytnika w obiekcie źródłowym <xref:System.IO.Stream> jest zaawansowana przez liczbę znaków, jaką może odczytać Metoda, ale znaki już odczytane w buforze wewnętrznym <xref:System.IO.StreamReader.ReadLine%2A> są odrzucane . W przypadku manipulowania pozycją źródłowego strumienia po odczytaniu danych do bufora pozycja strumienia podstawowego może nie odpowiadać pozycji buforu wewnętrznego. Aby zresetować bufor wewnętrzny, wywołaj <xref:System.IO.StreamReader.DiscardBufferedData%2A> metodę, jednak ta metoda spowalnia wydajność i powinna zostać wywołana tylko wtedy, gdy jest to absolutnie konieczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu odczytuje cały sposób do końca pliku w jednej operacji.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci, aby przydzielić bufor dla zwracanego ciągu.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje wszystkie znaki od bieżącego położenia do końca strumienia asynchronicznie i zwraca je jako jeden ciąg.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <paramref name="TResult" /> parametru zawiera ciąg ze znakami od bieżącego położenia do końca strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak odczytać zawartość pliku przy użyciu <xref:System.IO.StreamReader.ReadToEndAsync> metody.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Liczba znaków jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Czytnik jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

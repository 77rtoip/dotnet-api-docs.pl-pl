<Type Name="StreamWriter" FullName="System.IO.StreamWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6f31bd789fd27cfb5dec1f299d1b5fc770e9fc32" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30455649" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamWriter : System.IO.TextWriter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamWriter extends System.IO.TextWriter" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamWriter&#xA;Inherits TextWriter" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamWriter : System::IO::TextWriter" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextWriter</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementuje <see cref="T:System.IO.TextWriter" /> dla wpisywanie znaków do strumienia przy użyciu określonego kodowania.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamWriter> jest przeznaczony dla danych wyjściowych znak, przy użyciu określonego kodowania klasy pochodzące z <xref:System.IO.Stream> są przeznaczone dla bajtu danych wejściowych i wyjściowych.  
  
> [!IMPORTANT]
>  Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 <xref:System.IO.StreamWriter> Wartość domyślna to za pomocą wystąpienia <xref:System.Text.UTF8Encoding> chyba że określono inaczej. To wystąpienie `UTF8Encoding` wykonane bez znacznika kolejności bajtów (BOM), więc jego <xref:System.Text.Encoding.GetPreamble%2A> metoda zwraca tablicę bajtów puste. UTF-8 domyślne kodowanie dla tego konstruktora zgłasza wyjątek na nieprawidłowe bajty. To zachowanie różni się od zachowania dostarczony przez obiekt kodowania w <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> właściwości. Aby określić BOM i ustalić, czy wyjątek jest zgłaszany na nieprawidłowe bajty, użyj Konstruktora akceptującego kodowania obiektu jako parametru, takich jak <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Text.Encoding%29> lub <xref:System.IO.StreamWriter.%23ctor%2A>.  
  
 Domyślnie <xref:System.IO.StreamWriter> nie jest wątku bezpieczne. Zobacz <xref:System.IO.TextWriter.Synchronized%2A?displayProperty=nameWithType> dla otoki obsługującej wielowątkowość.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.IO.StreamWriter> obiektu do zapisania pliku, który wyświetla listę katalogów na dysku C, a następnie używa <xref:System.IO.StreamReader> obiektu do odczytu i umieścić nazwę katalogu. Dobrym rozwiązaniem jest użycie tych obiektów w `using` instrukcji, aby zasoby niezarządzane poprawnie są usuwane. `using` Instrukcji automatycznie wywołuje <xref:System.IDisposable.Dispose%2A> obiektu po ukończeniu kod, który jest używany. Konstruktor używany w tym przykładzie nie jest obsługiwane do użycia w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji.  
  
 [!code-csharp[StreamReadWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/streamreadwrite/cs/program.cs#1)]
 [!code-vb[StreamReadWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/streamreadwrite/vb/module1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamReader" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do zapisu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego obiektu stream przy użyciu kodowania UTF-8 i domyślny rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.StreamWriter> z UTF-8 kodowanie bez kolejności bajtów znaku (BOM), więc jego <xref:System.Text.Encoding.GetPreamble%2A> metoda zwraca tablicę bajtów puste. UTF-8 domyślne kodowanie dla tego konstruktora zgłasza wyjątek na nieprawidłowe bajty. To zachowanie różni się od zachowania dostarczony przez obiekt kodowania w <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> właściwości. Aby określić, czy wyjątek jest zgłaszany na nieprawidłowe bajty, użyj Konstruktora akceptującego kodowania obiektu jako parametru, takich jak <xref:System.IO.StreamWriter.%23ctor%2A>. <xref:System.IO.StreamWriter.BaseStream%2A> Właściwość jest inicjowana przy użyciu `stream` parametru. Pozycji strumienia nie zostanie zresetowana.  
  
 <xref:System.IO.StreamWriter> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Gdy zbiór znaków zostanie skompilowany z określonym ustawieniem kultury, po czym pobrany z użyciem innego ustawienia kultury, znaki mogą nie nadawać się do interpretacji i powodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program1.cs#1)]
 [!code-vb[System.IO.StreamWriter.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie jest zapisywalny.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do zapisu. <c>ścieżka</c> może być nazwą pliku.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego pliku przy użyciu domyślnego kodowania i rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.StreamWriter> z UTF-8 kodowanie bez kolejności bajtów znaku (BOM), więc jego <xref:System.Text.Encoding.GetPreamble%2A> metoda zwraca tablicę bajtów puste. UTF-8 domyślne kodowanie dla tego konstruktora zgłasza wyjątek na nieprawidłowe bajty. To zachowanie różni się od zachowania dostarczony przez obiekt kodowania w <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> właściwości. Aby określić BOM i ustalić, czy wyjątek jest zgłaszany na nieprawidłowe bajty, użyj Konstruktora akceptującego kodowania obiektu jako parametru, takich jak <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Text.Encoding%29>.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC). Jeśli plik istnieje, zostanie zastąpiony; w przeciwnym razie jest tworzony nowy plik.  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Gdy zbiór znaków zostanie skompilowany z określonym ustawieniem kultury, po czym pobrany z użyciem innego ustawienia kultury, znaki mogą nie nadawać się do interpretacji i powodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program5.cs#5)]
 [!code-vb[System.IO.StreamWriter.ctor#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="path" /> zawiera nazwę urządzenia systemowe (com1, com2 itd.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki nie może przekraczać 248 znaków i nazwy pliku nie może przekraczać 260 znaków.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwa katalogu lub składnia etykiety woluminu.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do zapisu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego obiektu stream przy użyciu określonego kodowania i domyślny rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.IO.StreamWriter.Encoding%2A> właściwości za pomocą parametru kodowania i <xref:System.IO.StreamWriter.BaseStream%2A> właściwości przy użyciu parametru strumienia. Pozycji strumienia nie zostanie zresetowana. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.TextWriter.Encoding%2A>.  
  
 <xref:System.IO.StreamWriter> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program2.cs#2)]
 [!code-vb[System.IO.StreamWriter.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie jest zapisywalny.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path, bool append);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do zapisu.</param>
        <param name="append">
          <see langword="true" /> Aby dołączyć dane do pliku. <see langword="false" /> o zastąpieniu pliku. Jeśli określony plik nie istnieje, ten parametr nie ma wpływu i konstruktora tworzy nowy plik.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego pliku przy użyciu domyślnego kodowania i rozmiar buforu. Jeśli plik istnieje, można albo zastąpione lub dołączone do. Jeśli plik nie istnieje, ten konstruktor tworzy nowy plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy <xref:System.IO.StreamWriter> z UTF-8 kodowanie bez kolejności bajtów znaku (BOM), więc jego <xref:System.Text.Encoding.GetPreamble%2A> metoda zwraca tablicę bajtów puste. UTF-8 domyślne kodowanie dla tego konstruktora zgłasza wyjątek na nieprawidłowe bajty. To zachowanie różni się od zachowania dostarczony przez obiekt kodowania w <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> właściwości. Aby określić BOM i ustalić, czy wyjątek jest zgłaszany na nieprawidłowe bajty, użyj Konstruktora akceptującego kodowania obiektu jako parametru, takich jak <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Text.Encoding%29>.  
  
 `path` Parametr może być nazwa pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
 `path` Parametr nie jest wymagany jest przechowywany na dysku plikiem; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program6.cs#6)]
 [!code-vb[System.IO.StreamWriter.ctor#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pusty.  
  
 —lub—  
  
 <paramref name="path" /> zawiera nazwę urządzenia systemowe (com1, com2 itd.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwa katalogu lub składnia etykiety woluminu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki nie może przekraczać 248 znaków i nazwy pliku nie może przekraczać 260 znaków.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do zapisu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="bufferSize">Rozmiar buforu w bajtach.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego obiektu stream przy użyciu określonego kodowania i rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.IO.StreamWriter.Encoding%2A> za pomocą właściwości `encoding` parametru i <xref:System.IO.StreamWriter.BaseStream%2A> za pomocą właściwości `stream` parametru. Pozycji strumienia nie zostanie zresetowana. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.TextWriter.Encoding%2A>.  
  
 <xref:System.IO.StreamWriter> Obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program3.cs#3)]
 [!code-vb[System.IO.StreamWriter.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie jest zapisywalny.</exception>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path, bool append, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do zapisu.</param>
        <param name="append">
          <see langword="true" /> Aby dołączyć dane do pliku. <see langword="false" /> o zastąpieniu pliku. Jeśli określony plik nie istnieje, ten parametr nie ma wpływu i konstruktora tworzy nowy plik.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego pliku, używając określonego kodowania i domyślny rozmiar buforu. Jeśli plik istnieje, można albo zastąpione lub dołączone do. Jeśli plik nie istnieje, ten konstruktor tworzy nowy plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.IO.StreamWriter.Encoding%2A> właściwości przy użyciu parametru kodowania. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.TextWriter.Encoding%2A>.  
  
 `path` może być nazwą pliku, w tym plik w udziale Universal Naming Convention (UNC).  
  
 `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program7.cs#7)]
 [!code-vb[System.IO.StreamWriter.ctor#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pusty.  
  
 —lub—  
  
 <paramref name="path" /> zawiera nazwę urządzenia systemowe (com1, com2 itd.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwa katalogu lub składnia etykiety woluminu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki nie może przekraczać 248 znaków i nazwy pliku nie może przekraczać 260 znaków.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, int bufferSize, bool leaveOpen);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do zapisu.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="bufferSize">Rozmiar buforu w bajtach.</param>
        <param name="leaveOpen">
          <see langword="true" /> Aby pozostaw otwarte po strumienia <see cref="T:System.IO.StreamWriter" /> obiekt jest usunięty; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego obiektu stream przy użyciu określonego kodowania i rozmiaru buforu i opcjonalnie pozostawia Otwórz strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ustawisz `leaveOpen` parametr `true`, <xref:System.IO.StreamWriter> obiektu wywołania <xref:System.IO.Stream.Dispose> na udostępnionych <xref:System.IO.Stream> obiektu podczas <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> jest wywoływana.  
  
 Ten konstruktor inicjuje <xref:System.IO.StreamWriter.Encoding%2A> właściwości przy użyciu `encoding` parametr i inicjuje <xref:System.IO.StreamWriter.BaseStream%2A> właściwości przy użyciu `stream` parametru. Pozycji strumienia nie zostanie zresetowana. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.TextWriter.Encoding%2A> właściwości.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program4.cs#4)]
 [!code-vb[System.IO.StreamWriter.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> nie jest zapisywalny.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path, bool append, System.Text.Encoding encoding, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool append, class System.Text.Encoding encoding, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String,System.Boolean,System.Text.Encoding,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path, bool append, System::Text::Encoding ^ encoding, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do zapisu.</param>
        <param name="append">
          <see langword="true" /> Aby dołączyć dane do pliku. <see langword="false" /> o zastąpieniu pliku. Jeśli określony plik nie istnieje, ten parametr nie ma wpływu i konstruktora tworzy nowy plik.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <param name="bufferSize">Rozmiar buforu w bajtach.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.StreamWriter" /> klasy dla określonego pliku w określonej ścieżce, przy użyciu określonego kodowania i rozmiar buforu. Jeśli plik istnieje, można albo zastąpione lub dołączone do. Jeśli plik nie istnieje, ten konstruktor tworzy nowy plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje <xref:System.IO.StreamWriter.Encoding%2A> właściwości przy użyciu parametru kodowania. Aby uzyskać dodatkowe informacje, zobacz <xref:System.IO.TextWriter.Encoding%2A>.  
  
 `path` może być nazwą pliku, w tym plik w udziale Universal Naming Convention (UNC).  
  
 `path` nie jest wymagana jest plikiem przechowywane na dysku; może być dowolną część system, który obsługuje dostęp za pomocą strumieni.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tego konstruktora.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program8.cs#8)]
 [!code-vb[System.IO.StreamWriter.ctor#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> to ciąg pusty ("").  
  
 —lub—  
  
 <paramref name="path" /> zawiera nazwę urządzenia systemowe (com1, com2 itd.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> zawiera nieprawidłowe lub nieprawidłową składnię nazwy pliku, nazwa katalogu lub składnia etykiety woluminu.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Odmowa dostępu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki nie może przekraczać 248 znaków i nazwy pliku nie może przekraczać 260 znaków.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public virtual bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamWriter.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.IO.StreamWriter" /> spowoduje to opróżnienie buforu do źródłowego strumienia po każdym wywołaniu <see cref="M:System.IO.StreamWriter.Write(System.Char)" />.</summary>
        <value>
          <see langword="true" /> Aby wymusić <see cref="T:System.IO.StreamWriter" /> opróżnić buforu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opróżnianie strumienia nie opróżnić jego podstawowym kodera, chyba że jawnie wywołać <xref:System.IO.StreamWriter.Flush%2A> lub <xref:System.IO.StreamWriter.Close%2A>. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> do `true` oznacza, że dane zostaną opróżnione z buforu do strumienia po zakończeniu każdej operacji zapisu, ale nie zostaną opróżnione kodera stanu. Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko po otrzymaniu koder sąsiedniego znaku ani znaków.  
  
 Gdy `AutoFlush` ustawiono `false`, `StreamWriter` wykona ograniczonym buforowania, zarówno wewnętrznie i potencjalnie w koder kodowania przekazany w. Lepszą wydajność można uzyskać przez ustawienie `AutoFlush` do `false`, przy założeniu, że wywoływanie zawsze `Close` (lub co najmniej `Flush`) po zakończeniu pisania z `StreamWriter`.  
  
 Na przykład ustawić `AutoFlush` do `true` podczas pisania do urządzenia, na którym użytkownik oczekuje natychmiast uzyskuje opinie. `Console.Out` jest jednym z tych przypadkach: `StreamWriter` używana wewnętrznie do zapisywania `Console` opróżnia jego stanu wewnętrznego z wyjątkiem kodera stanu po każdym wywołaniu <xref:System.IO.StreamWriter.Write%2A?displayProperty=nameWithType>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono składnię przy użyciu `AutoFlush` właściwości.  
  
 [!code-cpp[System.IO.StreamWriter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#5)]
 [!code-csharp[System.IO.StreamWriter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#5)]
 [!code-vb[System.IO.StreamWriter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamWriter.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zasadniczy strumień, który interfejsy z magazynu zapasowego.</summary>
        <value>Strumień to <see langword="StreamWriter" /> zapisuje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżące <see langword="StreamWriter" /> obiekt i podstawowego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>.  
  
 Ta implementacja <xref:System.IO.StreamWriter.Close%2A> wywołania <xref:System.IO.StreamWriter.Dispose%2A> metody przekazywanie `true` wartość.  
  
 Należy wywołać <xref:System.IO.StreamWriter.Close%2A> aby upewnić się, że wszystkie dane jest prawidłowo zapisany do źródłowego strumienia. Po wywołaniu <xref:System.IO.StreamWriter.Close%2A>, jakichkolwiek działań na <xref:System.IO.StreamWriter> może zgłaszać wyjątków. Jeśli jest za mało miejsca na dysku, wywoływania <xref:System.IO.StreamWriter.Close%2A> zgłosi wyjątek.  
  
 Opróżnianie strumienia nie opróżnić jego podstawowym kodera, chyba że jawnie wywołać <xref:System.IO.StreamWriter.Flush%2A> lub <xref:System.IO.StreamWriter.Close%2A>. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> do `true` oznacza, że dane zostaną opróżnione z buforu w strumieniu, ale nie zostaną opróżnione kodera stanu. Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko po otrzymaniu koder sąsiedniego znaku ani znaków.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje `Close` metody.  
  
 [!code-cpp[System.IO.StreamWriter#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#17)]
 [!code-csharp[System.IO.StreamWriter#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#17)]
 [!code-vb[System.IO.StreamWriter#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">Bieżącego kodowania nie obsługuje wyświetlania połowy para zastępcza Unicode.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.StreamWriter" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.StreamWriter> odwołania. Ta metoda wywołuje `Dispose` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">Bieżącego kodowania nie obsługuje wyświetlania połowy para zastępcza Unicode.</exception>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />.  
  
 Ta metoda wywołuje metodę dispose klasy podstawowej, <see cref="M:System.IO.TextWriter.Dispose(System.Boolean)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public override System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamWriter.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Text.Encoding" /> w są zapisywane dane wyjściowe.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> Określonym w Konstruktorze dla bieżącego wystąpienia lub <see cref="T:System.Text.UTF8Encoding" /> , jeśli nie określono kodowania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest niezbędne w przypadku niektórych scenariuszy XML, gdy nagłówek musi być napisana zawierający kodowanie używane przez <xref:System.IO.StreamWriter>. Dzięki temu kod XML do pracy z dowolnego <xref:System.IO.StreamWriter> i wygeneruj nagłówek poprawne XML.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera kodowanie określonego <xref:System.IO.StreamWriter> wystąpienia.  
  
 [!code-cpp[System.IO.StreamWriter#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#11)]
 [!code-csharp[System.IO.StreamWriter#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#11)]
 [!code-vb[System.IO.StreamWriter#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie bufory dla bieżącego składnika zapisywania i powoduje, że wszystkie buforowane dane do zapisania do źródłowego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Flush%2A?displayProperty=nameWithType>.  
  
 Opróżnianie strumienia nie opróżnić jego podstawowym kodera, chyba że jawnie wywołać `Flush` lub <xref:System.IO.StreamWriter.Close%2A>. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> do `true` oznacza, że dane zostaną opróżnione z buforu do strumienia po zakończeniu każdej operacji zapisu, ale nie zostaną opróżnione kodera stanu. Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko po otrzymaniu koder sąsiedniego znaku ani znaków.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bieżący writer jest zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Bieżącego kodowania nie obsługuje wyświetlania połowy para zastępcza Unicode.</exception>
        <altmember cref="M:System.IO.Stream.Close" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie usuwa wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operację opróżniania.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamWriter Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamWriter Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamWriter.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamWriter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamWriter ^ Null;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Udostępnia <see langword="StreamWriter" /> z magazynem nie zapasowy, które mogą być zapisane, ale nie do odczytu z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Null` przekierować wyniki `StreamWriter` które nie będą korzystać z zasobów systemu operacyjnego.  
  
 Gdy `StreamWriter.Write` metody są wywoływane na `Null`, po prostu zwraca wywołanie i wszelkie magazynu zapasowego faktycznie są zapisywane żadne dane.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano korzystanie z `Null` pola.  
  
 [!code-cpp[System.IO.StreamWriter#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#6)]
 [!code-csharp[System.IO.StreamWriter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#6)]
 [!code-vb[System.IO.StreamWriter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane do strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak do zapisu do strumienia.</param>
        <summary>Zapisuje znak w strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Określony znak jest zapisywany do źródłowego strumienia, chyba że przedwcześnie osiągnięto koniec strumienia. Jeśli <xref:System.IO.StreamWriter.AutoFlush%2A> jest `true`, <xref:System.IO.StreamWriter.Flush%2A> jest wywoływana automatycznie.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> bufor jest pełna, a bieżąca writer jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> buforu jest pełny i nie można zapisać zawartości buforu do źródłowego strumienia o stałym rozmiarze, ponieważ <see cref="T:System.IO.StreamWriter" /> znajduje się na końcu strumienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, zawierający dane do zapisania. Jeśli <c>buforu</c> jest <see langword="null" />, nic nie zostanie zapisany.</param>
        <summary>Zapisuje tablicy znaków w strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Określonych znaków są zapisywane do źródłowego strumienia, chyba że przedwcześnie osiągnięto koniec strumienia. Jeśli <xref:System.IO.StreamWriter.AutoFlush%2A> jest `true`, <xref:System.IO.StreamWriter.Flush%2A> jest wywoływana automatycznie.  
  
 Ta metoda może być wydajniejsze niż `Write` (`char[],``int,``int`), ponieważ ma mniejszą liczbę argumentów do sprawdzenia.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> bufor jest pełna, a bieżąca writer jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> buforu jest pełny i nie można zapisać zawartości buforu do źródłowego strumienia o stałym rozmiarze, ponieważ <see cref="T:System.IO.StreamWriter" /> znajduje się na końcu strumienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do zapisu do strumienia. Jeśli <c>wartość</c> jest wartość null, nic nie zostanie zapisany.</param>
        <summary>Zapisuje ciąg w strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Określony <xref:System.String> są zapisywane do źródłowego strumienia, chyba że przedwcześnie osiągnięto koniec strumienia.  
  
 <xref:System.IO.StreamWriter.Flush%2A> jest wywoływana automatycznie, jeśli <xref:System.IO.StreamWriter.AutoFlush%2A> jest `true`. Jeśli `value` jest `null`, wpisy nie są zapisywane.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> bufor jest pełna, a bieżąca writer jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> buforu jest pełny i nie można zapisać zawartości buforu do źródłowego strumienia o stałym rozmiarze, ponieważ <see cref="T:System.IO.StreamWriter" /> znajduje się na końcu strumienia.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która zawiera dane do zapisania.</param>
        <param name="index">Pozycja znaku w buforze, od którego należy rozpocząć odczyt danych.</param>
        <param name="count">Maksymalna liczba znaków do zapisu.</param>
        <summary>Zapisuje subarray znaków w strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Znaki są odczytywane z `buffer` począwszy od `index` i kontynuowanie przy użyciu `index` + (`count` - 1). Wszystkie znaki są zapisywane do źródłowego strumienia, chyba że przedwcześnie osiągnięto koniec strumienia podstawowego. <xref:System.IO.StreamWriter.Flush%2A> jest wywoływana automatycznie, jeśli <xref:System.IO.StreamWriter.AutoFlush%2A> jest `true`.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W tym przykładzie zapisuje osiem znaków z tablicą 13 elementu do pliku, rozpoczynając od trzeciego elementu tablicy.  
  
 [!code-cpp[Classic StreamWriter.Write2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic StreamWriter.Write2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic StreamWriter.Write2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic StreamWriter.Write2 Example/CS/source.cs#1)]
 [!code-vb[Classic StreamWriter.Write2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic StreamWriter.Write2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość buforu pomniejszona o <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> bufor jest pełna, a bieżąca writer jest zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ma wartość true lub <see cref="T:System.IO.StreamWriter" /> buforu jest pełny i nie można zapisać zawartości buforu do źródłowego strumienia o stałym rozmiarze, ponieważ <see cref="T:System.IO.StreamWriter" /> znajduje się na końcu strumienia.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie zapisuje dane do strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (value As Char) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak do zapisu do strumienia.</param>
        <summary>Zapisuje asynchronicznie znak w strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania pojedynczego znaku (litery "") do pliku tekstowego za pomocą <xref:System.IO.StreamWriter.WriteAsync%28System.Char%29> metody.  
  
 [!code-csharp[System.IO.StreamWriter#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example20.cs#20)]
 [!code-vb[System.IO.StreamWriter#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example20.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (value As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do zapisu do strumienia. Jeśli <c>wartość</c> jest <see langword="null" />, nic nie zostanie zapisany.</param>
        <summary>Asynchronicznie zapisuje ciąg w strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania ciąg do pliku tekstowego za pomocą <xref:System.IO.StreamWriter.WriteAsync%28System.String%29> metody.  
  
 [!code-csharp[System.IO.StreamWriter#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example21.cs#21)]
 [!code-vb[System.IO.StreamWriter#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example21.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (ReadOnlyMemory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(valuetype System.ReadOnlyMemory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.ReadOnlyMemory{System.Char},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As Char(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków, która zawiera dane do zapisania.</param>
        <param name="index">Pozycja znaku w buforze, od którego ma zostać rozpoczęte odczytywanie danych.</param>
        <param name="count">Maksymalna liczba znaków do zapisu.</param>
        <summary>Zapisuje asynchronicznie subarray znaków w strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania wielu znaków do pliku tekstowego za pomocą <xref:System.IO.StreamWriter.WriteAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody.  
  
 [!code-csharp[System.IO.StreamWriter#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example24.cs#24)]
 [!code-vb[System.IO.StreamWriter#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example24.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> Plus <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(valuetype System.ReadOnlySpan`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLine(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (buffer As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje asynchronicznie następuje terminator wiersza w strumieniu danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie zapisuje terminator wiersza w strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza jest definiowana za pomocą <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync (value As Char) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Znak do zapisu do strumienia.</param>
        <summary>Zapisuje asynchronicznie następuje terminator wiersza w strumieniu znak.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza jest definiowana za pomocą <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania pojedynczego znaku (litery "") do wiersza w pliku tekstowym, a następnie inny wiersz, który zawiera pojedynczy znak (litery "b"), za pomocą <xref:System.IO.StreamWriter.WriteLineAsync%28System.Char%29> metody.  
  
 [!code-csharp[System.IO.StreamWriter#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example22.cs#22)]
 [!code-vb[System.IO.StreamWriter#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example22.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync (value As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do zapisu. Jeśli wartość jest <see langword="null" />, napisano terminator wiersza.</param>
        <summary>Zapisuje ciąg asynchronicznie następuje terminator wiersza w strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza jest definiowana za pomocą <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania dwa wiersze, które składają się z wartości ciągu do pliku tekstowego za pomocą <xref:System.IO.StreamWriter.WriteLineAsync%28System.String%29> metody.  
  
 [!code-csharp[System.IO.StreamWriter#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example23.cs#23)]
 [!code-vb[System.IO.StreamWriter#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example23.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (ReadOnlyMemory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(valuetype System.ReadOnlyMemory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.ReadOnlyMemory{System.Char},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync (buffer As Char(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica znaków do zapisywania danych z.</param>
        <param name="index">Pozycja znaku w buforze, od którego należy rozpocząć odczyt danych.</param>
        <param name="count">Maksymalna liczba znaków do zapisu.</param>
        <summary>Zapisuje subarray znaków asynchronicznie następuje terminator wiersza w strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza jest definiowana za pomocą <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania znaków na dwa oddzielne wiersze w pliku tekstowego za pomocą <xref:System.IO.StreamWriter.WriteLineAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody. Pierwszy wiersz zawiera najpierw 11 znaków z ciągu (litery "Pierwszego wiersza" następuje spacja). Drugi wiersz zawiera pozostałych znaków z ciągu (litery "i drugi wiersz").  
  
 [!code-csharp[System.IO.StreamWriter#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example25.cs#25)]
 [!code-vb[System.IO.StreamWriter#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example25.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> Plus <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">Moduł zapisujący strumień jest usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Moduł zapisujący strumień jest aktualnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
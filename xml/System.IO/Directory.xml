<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8c18e69be0dc557b1b08704b7f403f1c8201a977" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36484560" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody statyczne do tworzenia, przenoszenie i wyliczania katalogów i jego podkatalogach. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Directory> klasy dla typowych operacji, takich jak kopiowanie, przenoszenie, zmiana nazwy, tworzenie i usuwanie katalogów.  
  
-   Aby utworzyć katalog, użyj jednej z <xref:System.IO.Directory.CreateDirectory%2A> metody.  
  
-   Aby usunąć katalog, użyj jednej z <xref:System.IO.Directory.Delete%2A> metody.  
  
-   Aby pobrać lub ustawić bieżący katalog dla aplikacji, należy użyć <xref:System.IO.Directory.GetCurrentDirectory%2A> lub <xref:System.IO.Directory.SetCurrentDirectory%2A> metody.  
  
-   Do manipulowania <xref:System.DateTime> informacje dotyczące tworzenia, dostępu i pisanie katalogiem, użyj metod takich jak <xref:System.IO.Directory.SetLastAccessTime%2A> i <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Metod statycznych <xref:System.IO.Directory> klasy sprawdzania zabezpieczeń dla wszystkich metod. Jeśli zamierzasz użyć ponownie obiektu, należy wziąć pod uwagę przy użyciu odpowiednich metod wystąpień <xref:System.IO.DirectoryInfo> , ponieważ nie zawsze będą sprawdzanie zabezpieczeń należy.  
  
 Jeśli są wykonywane tylko jedno działanie związane z katalogu, może być bardziej wydajne, aby użyć statycznego <xref:System.IO.Directory> zamiast odpowiadającego <xref:System.IO.DirectoryInfo> metody wystąpienia. Większość <xref:System.IO.Directory> metody wymagają ścieżkę do katalogu, w którym są manipulowanie.  
  
> [!NOTE]
>  W elementach członkowskich, które przyjmują ciąg `path` parametr, że ścieżka musi być poprawnie sformułowany lub zgłoszony wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale rozpoczyna się od spacji ('c:\temp'), ciąg ścieżki nie jest usuwane, więc ścieżka jest nieprawidłowo sformułowany i zgłoszony wyjątek. Ponadto ścieżka lub kombinacji ścieżki nie może być w pełni kwalifikowana dwa razy. Na przykład "c:\temp c:\windows" również zgłasza wyjątek. Upewnij się, czy z ścieżki są poprawnie sformułowany, gdy przy użyciu metod, które przyjmują ciąg ścieżki. Aby uzyskać więcej informacji, zobacz <xref:System.IO.Path>.  
  
 W elementach członkowskich, które akceptują ścieżką ścieżka może odwoływać się do pliku lub katalogu. Pełna ścieżka, ścieżką względną lub ścieżką Universal Naming Convention (UNC) można użyć dla nazwy serwera i udziału. Na przykład następujące są dopuszczalne ścieżki:  
  
-   "c:\\\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.  
  
-   "MyDir\\\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" w języku C# lub "\\\MyServer\MyShare" w języku Visual Basic.  
  
 Domyślnie pełna odczytu/zapisu do nowych katalogów dostęp do wszystkich użytkowników. Jednak aplikacja musi mieć poprawnych zabezpieczeń do istniejących katalogach.  
  
 Żądanie uprawnień do katalogu i wszystkich jego podkatalogach, koniec ciągu ścieżki z znakiem separatora katalogu. (Na przykład "C:\Temp\\" udziela dostępu do C:\Temp\ i jego podkatalogach.) Żądanie uprawnień tylko do określonego katalogu, koniec ciągu ścieżki kropką. (Na przykład "C:\Temp\\." zezwala na dostęp tylko do C:\Temp\\, a nie do jego podkatalogach.)  
  
 W elementach członkowskich, które akceptują `searchPattern` parametr, ciąg wyszukiwania może być dowolną kombinację znaków literału i dwa znaki symboli wieloznacznych; \* i?. Ten parametr nie może rozpoznać wyrażenia regularne. Aby uzyskać więcej informacji, zobacz <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> metody lub innej metody, która używa `searchPattern` parametru.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> i <xref:System.IO.DirectoryInfo> nie są obsługiwane do użycia w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji. Aby uzyskać informacje dotyczące dostępu do plików i folderów w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji, zobacz [podczas uzyskiwania dostępu do danych i plików (aplikacje ze Sklepu Windows)](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać pliki tekstowe z katalogu i przenieś je do nowego katalogu. Po przeniesieniu plików, już nie istnieją w oryginalnej katalogu.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 W poniższym przykładzie pokazano sposób użycia <xref:System.IO.Directory.EnumerateFiles%2A> metody do pobierania kolekcję pliki tekstowe z katalogu, a następnie użyć tej kolekcji w zapytaniu, aby znaleźć wszystkie wiersze zawierające "Example".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 W poniższym przykładzie pokazano, jak przenieść katalogu i jego pliki do nowego katalogu. Oryginalny katalog nie istnieje już po została przeniesiona.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wszystkich katalogów w określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do utworzenia.</param>
        <summary>Tworzy wszystkich katalogów i podkatalogów w określonej ścieżce, chyba że, już istnieje.</summary>
        <returns>Obiekt, który reprezentuje katalog w określonej ścieżce. Ten obiekt jest zwracany niezależnie od tego, czy istnieje już katalog w określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w `path` są tworzone, chyba że istnieją już one lub część `path` jest nieprawidłowy. Jeśli katalog już istnieje, ta metoda nie tworzy nowy katalog, ale zwraca <xref:System.IO.DirectoryInfo> obiektu dla istniejącego katalogu.  
  
 `path` Parametr określa ścieżkę katalogu, a nie ścieżkę pliku.  
  
 Spacje są usuwane z koniec `path` parametru przed utworzeniem katalogu.  
  
 Na komputerze zdalnym, w udziale, który ma dostęp do zapisu, można utworzyć katalogu. Ścieżki UNC są obsługiwane; na przykład można określić następujący kod pod kątem `path`: `\\2009\Archives\December` w języku Visual Basic i `\\\\2009\\Archives\\December` w języku C#.  
  
 Tworzenie katalogu z tylko znakiem dwukropka (:) nie jest obsługiwane i spowoduje, że `NotSupportedException` zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy i usuwa określony katalog.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Można utworzyć katalogu C:\Users\User1\Public\Html, gdy bieżący katalog jest C:\Users\User1, używane następujące wywołania do zapewnienia właściwie interpretowany ukośniku odwrotnym.  
  
 W języku Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 W języku C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 W języku C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest plikiem.  - lub - nieznana nazwa sieci.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  - lub - <paramref name="path" /> jest prefiksem lub zawiera tylko znakiem dwukropka (:).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera znakiem dwukropka (:), który nie jest częścią Etykieta dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików lub katalogów. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do utworzenia.</param>
        <param name="directorySecurity">Kontrola dostępu do zastosowania do katalogu.</param>
        <summary>Tworzy w określonej ścieżce, wszystkie katalogi, chyba że istnieje, stosowania określonej zabezpieczeń systemu Windows.</summary>
        <returns>Obiekt, który reprezentuje katalog w określonej ścieżce. Ten obiekt jest zwracany niezależnie od tego, czy istnieje już katalog w określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody do tworzenia katalogu przy użyciu kontroli dostępu, więc nie ma bez możliwości, które można można uzyskać dostępu do katalogu, przed zastosowaniem zabezpieczeń.  
  
 Wszystkie katalogi określone w `path` parametru są tworzone, chyba że istnieją już one lub część `path` jest nieprawidłowy. `path` Parametr określa ścieżkę katalogu, a nie ścieżkę pliku. Jeśli katalog już istnieje, ta metoda nie tworzy nowy katalog, ale zwraca <xref:System.IO.DirectoryInfo> obiektu dla istniejącego katalogu.  
  
 Spacje są usuwane z koniec `path` parametru przed utworzeniem katalogu.  
  
 Na komputerze zdalnym, w udziale, który ma dostęp do zapisu, można utworzyć katalogu. Ścieżki UNC są obsługiwane; na przykład można określić następujący kod pod kątem `path`: `\\2009\Archives\December` w języku Visual Basic i `\\\\2009\\Archives\\December` w języku C#.  
  
 Tworzenie katalogu z tylko znakiem dwukropka (:) nie jest obsługiwane i powoduje, że `NotSupportedException` zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy katalog z reguł dostępu dla dwóch kont użytkowników.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest plikiem.  - lub - nieznana nazwa sieci.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  - lub - <paramref name="path" /> jest prefiksem lub zawiera tylko znakiem dwukropka (:).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> zawiera znakiem dwukropka (:), który nie jest częścią Etykieta dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Odczytywanie i zapisywanie plików i katalogów oraz dostęp do katalogu docelowego. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> akcji zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony katalog i opcjonalnie podkatalogów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pustego katalogu do usunięcia. Ten katalog musi być zapisywalny i jest pusta.</param>
        <summary>Usuwa pustego katalogu z określonej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zachowuje się tak samo <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> z `false` określony dla drugiego parametru.  
  
 `path` Parametr może określać ścieżkę względną lub bezwzględną informacji. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje są usuwane z koniec `path` parametru przed usunięciem katalogu.  
  
 Ta metoda zgłasza <xref:System.IO.IOException> Jeśli określono katalog `path` parametr zawiera pliki i podkatalogi.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 W niektórych przypadkach, jeśli określony katalog Otwórz w Eksploratorze plików <xref:System.IO.Directory.Delete%2A> metody nie można go usunąć.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowy katalog i podkatalogu, a następnie usunąć tylko podkatalogu.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik o tej samej nazwie i lokalizacji określonej przez <paramref name="path" /> istnieje.  - lub - katalog jest bieżący katalog roboczy aplikacji.  - lub - katalogu określonego przez <paramref name="path" /> nie jest pusty.  - lub - katalog jest przeznaczony tylko do odczytu lub zawiera tylko do odczytu pliku.  - lub - katalog jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> nie istnieje lub nie można odnaleźć.  - lub - określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa katalogu do usunięcia.</param>
        <param name="recursive">
          <see langword="true" /> Aby usunąć katalogów, podkatalogów i plików w <c>ścieżki</c>; w przeciwnym razie <see langword="false" />.</param>
        <summary>Usuwa określony katalog i, jeśli to wskazane, wszelkie podkatalogi i pliki w katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać ścieżkę względną lub bezwzględną informacji. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje są usuwane z koniec `path` parametru przed usunięciem katalogu.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Jeśli `recursive` parametr jest `true`, użytkownik musi mieć uprawnienie do zapisu dla bieżącego katalogu oraz jak w przypadku wszystkich podkatalogów.  
  
 Zachowanie ta metoda różni się nieco podczas usuwania katalogu zawierającego punkt ponownej analizy, takie jak łącza symbolicznego lub punkt instalacji. Jeśli punkt ponownej analizy to katalogu, takie jak punkt instalacji jest odinstalowane i usunięciu punktu instalacji. Ta metoda nie recurse za pośrednictwem punktu ponownej analizy. Jeśli punkt ponownej analizy to łącze symboliczne do pliku, punkt ponownej analizy zostanie usunięty, a nie element docelowy łącza symbolicznego.  
  
 W niektórych przypadkach, jeśli określony katalog Otwórz w Eksploratorze plików <xref:System.IO.Directory.Delete%2A> metody nie można go usunąć.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowy katalog, podkatalogu i plików w podkatalogu, a następnie rekursywnie Usuń nowych elementów.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik o tej samej nazwie i lokalizacji określonej przez <paramref name="path" /> istnieje.  - lub - katalogu określonego przez <paramref name="path" /> jest tylko do odczytu lub <paramref name="recursive" /> jest <see langword="false" /> i <paramref name="path" /> nie jest pusty katalog.  - lub - katalog jest bieżący katalog roboczy aplikacji.  - lub - katalog zawiera plik tylko do odczytu.  - lub - katalog jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> nie istnieje lub nie można odnaleźć.  - lub - określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogu, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogów, w określonej ścieżce.</summary>
        <returns>Wyliczalny kolekcji pełnych nazw (w tym ścieżki) dla katalogów w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić ścieżkę względną lub bezwzględną informacje w `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody. Nazwy katalogów zwracane są poprzedzane prefiksem wartość podana w `path` parametru. Na przykład podaj ścieżkę względną w `path` parametru nazwy katalogów zwrócony będzie zawierać ścieżkę względną.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateDirectories%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład wylicza najwyższego poziomu katalogów w określonej ścieżce.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy katalogów w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogu, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalny kolekcji pełnych nazw (w tym ścieżki) dla katalogów w katalogu określonym przez <paramref name="path" /> i który jest zgodny z wzorcem wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić ścieżkę względną lub bezwzględną informacje w `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody. Nazwy katalogów zwracane są poprzedzane prefiksem wartość podana w `path` parametru. Na przykład podaj ścieżkę względną w `path` parametru nazwy katalogów zwrócony będzie zawierać ścieżkę względną.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateDirectories%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład wylicza najwyższego poziomu katalogów w określonej ścieżce, zgodne ze wzorcem określonym wyszukiwania.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy katalogów w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać tylko bieżącego katalogu lub powinna zawierać wszystkie podkatalogi.  Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogu, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie wyszukuje podkatalogów.</summary>
        <returns>Wyliczalny kolekcji pełnych nazw (w tym ścieżki) dla katalogów w katalogu określonym przez <paramref name="path" /> i spełniających wzorzec wyszukiwania oraz opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Dokładnie jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić ścieżkę względną lub bezwzględną informacje w `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody. Nazwy katalogów zwracane są poprzedzane prefiksem wartość podana w `path` parametru. Na przykład podaj ścieżkę względną w `path` parametru nazwy katalogów zwrócony będzie zawierać ścieżkę względną.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateDirectories%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi w określonej ścieżce, które pasują do wzorca wyszukiwania określony. Używa `searchOption` parametr, aby określić, że wszystkie podkatalogi należy uwzględnić podczas wyszukiwania.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wyliczenia nazw plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalny kolekcji nazw plików w określonej ścieżce.</summary>
        <returns>Wyliczalny kolekcji pełnych nazw (w tym ścieżki) plików w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFiles%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobierania plików z katalogu i przenieś je do nowego katalogu. Po przeniesieniu plików, już nie istnieją w oryginalnej katalogu.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 Poniższy przykład wylicza pliki w określonym katalogu, odczytuje wiersz każdego pliku i wyświetla wiersz zawiera ciąg "Europy".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy plików w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczenia nazw plików, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalny kolekcji pełnych nazw (w tym ścieżki) plików w katalogu określonym przez <paramref name="path" /> i który jest zgodny z wzorcem wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFiles%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobierania plików tekstowych w katalogu i przenieś je do nowego katalogu. Po przeniesieniu plików, już nie istnieją w oryginalnej katalogu.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Poniższy przykład wylicza plików w określonym katalogu z rozszerzeniem txt, odczytuje wiersz każdego pliku i wyświetla wiersz zawiera ciąg "Europy".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy plików w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać tylko bieżącego katalogu lub powinna zawierać wszystkie podkatalogi.  Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczenia nazw plików, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie wyszukuje podkatalogów.</summary>
        <returns>Wyliczalny kolekcji pełnych nazw (w tym ścieżki) plików w katalogu określonym przez <paramref name="path" /> i spełniających wzorzec wyszukiwania oraz opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFiles%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobierania plików tekstowych w katalogu i jego podkatalogach i przenieś je do nowego katalogu. Po przeniesieniu plików, już nie istnieją w oryginalnej katalogach.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Następujący przykład rekursywnie wylicza wszystkie pliki z rozszerzeniem txt, odczytuje każdego wiersza w pliku i wyświetla wiersz zawiera ciąg "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wyliczalny wpisów systemu plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalny kolekcję nazw plików i katalog w określonej ścieżce.</summary>
        <returns>Wyliczalny zbiór wpisów systemu plików w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, rozpoczęciem wyliczania kolekcji wpisów przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, musisz poczekać, aż całą tablicę wpisów zwrócone, zanim dostęp do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy wpisów systemu plików w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczenia nazw plików i nazwy katalogu, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalny zbiór wpisów systemu plików w katalogu określonym przez <paramref name="path" /> i który jest zgodny z wzorcem wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`...  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, rozpoczęciem wyliczania kolekcji wpisów przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, musisz poczekać, aż całą tablicę wpisów zwrócone, zanim dostęp do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania, aby dopasować wpisów systemu plików w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać tylko bieżącego katalogu lub powinna zawierać wszystkie podkatalogi.  Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczenia nazw plików i nazwy katalogu, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie wyszukuje podkatalogów.</summary>
        <returns>Wyliczalny zbiór wpisów systemu plików w katalogu określonym przez <paramref name="path" /> i spełniających wzorzec wyszukiwania oraz opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, rozpoczęciem wyliczania kolekcji wpisów przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, musisz poczekać, aż całą tablicę wpisów zwrócone, zanim dostęp do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Zwracana Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do testowania.</param>
        <summary>Określa, czy podana ścieżka odwołuje się do istniejącego katalogu na dysku.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="path" /> odwołuje się do istniejącego katalogu; <see langword="false" /> Jeśli katalog nie istnieje lub występuje błąd podczas próby określenia, czy istnieje określony katalog.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego.  
  
 Spacje są usuwane z koniec `path` parametru przed sprawdzeniem, czy katalog istnieje.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Jeśli nie masz w minimalne uprawnienia tylko do odczytu do katalogu, <xref:System.IO.Directory.Exists%2A> metoda zwróci `false`.  
  
 <xref:System.IO.Directory.Exists%2A> Metoda zwraca `false` przypadku wystąpieniu błędu podczas próby określenia, czy istnieje określony plik. Taka sytuacja może wystąpić w sytuacji, które powodują wystąpienie wyjątków, takich jak przekazanie nazwę pliku z nieprawidłowe znaki lub zbyt wiele znaków, wystąpił błąd lub Brak dysku, lub jeśli element wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę nazwy pliku lub katalogu, w wierszu polecenia, określa, jakiego rodzaju nazwy jest i odpowiednio je przetwarza.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca Windows listy kontroli dostępu (ACL) dla katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do katalogu zawierającego <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu, który opisuje informacji listę kontroli dostępu (ACL) kontroli dostępu do pliku.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla określonego katalogu.</summary>
        <returns>Obiekt hermetyzujący kontroli dostępu reguł dla plików opisanego przez <paramref name="path" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Directory.GetAccessControl%2A> metodę, aby pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu dla katalogu.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 W środowiskach NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przypisywane do użytkownika, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia folderu nadrzędnego. Odrzucanie <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w nadrzędnym katalogu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetAccessControl%2A> i <xref:System.IO.Directory.SetAccessControl%2A> metody dodawania dostępu kontrolować wpis listę kontroli dostępu (ACL), a następnie usuń wpis listy ACL z katalogu.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest system Windows 2000 lub nowszy.</exception>
        <exception cref="T:System.SystemException">Wystąpił błąd na poziomie systemu, takie jak nie można odnaleźć katalogu. Określony wyjątek może być podklasą klasy <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony katalog, który jest tylko do odczytu.  - lub - tej operacji nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> akcji zabezpieczeń: żądanie.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do katalogu zawierającego <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu, który opisuje informacji listę kontroli dostępu (ACL) kontroli dostępu do pliku.</param>
        <param name="includeSections">Jeden z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, które określają typ dostępu kontrolować listę kontroli dostępu (ACL) informacje do odbierania.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt hermetyzujący określonego typu z kontroli dostępu listę kontroli dostępu (ACL) dla określonego katalogu.</summary>
        <returns>Obiekt hermetyzujący kontroli dostępu reguł dla plików opisanego przez <paramref name="path" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Directory.GetAccessControl%2A> metodę, aby pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu dla katalogu.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 W środowiskach NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przypisywane do użytkownika, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia folderu nadrzędnego. Odrzucanie <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w nadrzędnym katalogu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest system Windows 2000 lub nowszy.</exception>
        <exception cref="T:System.SystemException">Wystąpił błąd na poziomie systemu, takie jak nie można odnaleźć katalogu. Określony wyjątek może być podklasą klasy <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony katalog, który jest tylko do odczytu.  - lub - tej operacji nie jest obsługiwane na bieżącej platformie.  - lub - obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> akcji zabezpieczeń: żądanie.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <summary>Pobiera Data i godzina utworzenia katalogu.</summary>
        <returns>Struktura, która ma ustawioną wartość daty i godziny dla określonego katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Ta metoda jest odpowiednikiem <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera godzinę utworzenia określonego katalogu.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <summary>Pobiera datę i godzinę utworzenia, w formacie uniwersalnego czasu koordynowanego (UTC), w katalogu.</summary>
        <returns>Struktura, która ma ustawioną wartość daty i godziny dla określonego katalogu. Ta wartość jest wyrażone według czasu UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Użyj tej metody można pobrać czasu utworzenia katalogu oparte na uniwersalny czas koordynowany (UTC).  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych w formacie uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący katalog roboczy aplikacji.</summary>
        <returns>Ciąg, który zawiera ścieżkę bieżącego katalogu roboczego i nie kończy się ukośnikiem (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący katalog różni się od oryginalnej katalog, który jest ten, z którego został uruchomiony proces.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `GetCurrentDirectory` metody.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny jest Windows CE, które nie ma bieżącego katalogu funkcji.  Ta metoda jest dostępna w programie .NET Compact Framework, ale nie jest obecnie obsługiwany.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy podkatalogów, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy podkatalogi (łącznie z ich ścieżek) w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) podkatalogów w określonej ścieżce lub pusta tablica, jeśli żadne katalogi nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taki sam jak <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> z gwiazdką (\*) określony wzorzec wyszukiwania, więc zwraca wszystkie podkatalogi. Aby wyszukać podkatalogów, należy użyć <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> metodę, która umożliwia określenie wyszukiwania podkatalogów z `searchOption` parametru.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateDirectories%2A> może być skuteczniejsza.  
  
 `path` Parametr można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nazwy zwracane przez tę metodę są poprzedzane prefiksem katalogu informacji dostępnych w `path`.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę nazwy pliku lub katalogu, w wierszu polecenia, określa, jakiego rodzaju nazwy jest i odpowiednio je przetwarza.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy podkatalogów w <c>ścieżki</c>. Ten parametr może zawierać kombinację prawidłowym literałem i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca nazwy podkatalogi (łącznie z ich ścieżek), pasujących do wzorca wyszukiwania w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) podkatalogów, które jest zgodny z wzorcem wyszukiwania w określonym katalogu lub pusta tablica, jeśli żadne katalogi nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wszystkie podkatalogi bezpośrednio w określonym katalogu pasujących do wzorca wyszukiwania. Jeśli określony katalog nie ma żadnych podkatalogów, albo znaleźć dopasowanie do żadnych podkatalogów `searchPattern` parametr, metoda zwraca pustą tablicę. Katalog główny będzie przeszukiwana. Jeśli chcesz wyszukać także podkatalogów, użyj <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> — metoda i określ <xref:System.IO.SearchOption.AllDirectories> w `searchOption` parametru.  
  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 `path` Można określić ścieżkę względną lub bezwzględną informacje, a nie jest rozróżniana wielkość liter.  Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateDirectories%2A> może być skuteczniejsza.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza katalogi w ścieżce, które zaczynają się od określonej litery.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" />.  - lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy podkatalogów w <c>ścieżki</c>. Ten parametr może zawierać kombinację prawidłowym literałem i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinny zawierać wszystkie podkatalogi lub bieżącego katalogu.</param>
        <summary>Zwraca nazwy podkatalogi (łącznie z ich ścieżek), pasujących do wzorca wyszukiwania w określonym katalogu i opcjonalnie wyszukuje podkatalogów.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) podkatalogów, spełniających określone kryteria, lub pusta tablica, jeśli żadne katalogi nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Można określić ścieżkę względną lub bezwzględną informacje, a nie jest rozróżniana wielkość liter. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateDirectories%2A> może być skuteczniejsza.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza katalogi, które zaczynają się od litery określonego w ścieżce. Przeszukiwane będą tylko w katalogu najwyższego poziomu.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  - lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub katalogu.</param>
        <summary>Zwraca informacji o woluminie i/lub głównego informacje dla określonej ścieżki.</summary>
        <returns>Ciąg, który zawiera informacji o woluminie i/lub głównego informacje dla określonej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera w pełni kwalifikowana nazwa `path`, jak zwracany przez <xref:System.IO.Path.GetFullPath%2A>, i zwraca główny informacji katalogowych. Określona ścieżka nie jest wymagana do istnieje.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawić bieżącego katalogu i wyświetlić katalog główny.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżek) w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) plików w określonym katalogu lub pusta tablica, jeśli nie są można odnaleźć plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFiles%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Nazwy plików zwracane są dołączane do podane `path` parametru.  
  
 Ta metoda jest taki sam jak <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> z gwiazdką (\*) określony jako wzorzec wyszukiwania.  
  
 `path` Parametr można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Kolejność nazw zwróconego pliku nie jest gwarantowana; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.IO.Directory.GetFiles%2A> metody do zwracania nazwy pliku z lokalizacji określonej przez użytkownika. Przykład skonfigurowano catch wszystkie błędy wspólne dla tej metody.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.  - lub - wystąpił błąd sieciowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka nie zostanie znaleziony lub jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy plików w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżek) pasujących do wzorca wyszukiwania w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) plików w określonym katalogu spełniających wzorzec wyszukiwania lub pusta tablica, jeśli nie są można odnaleźć plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy plików zwracane są dołączane do podane `path` parametr i kolejność nazw zwróconego pliku nie jest gwarantowana; użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza przed zarówno format nazwy pliku w formacie 8.3 i format nazwy długie nazwy plików, wyszukiwanie wzorca podobne do "\*1\*.txt" może zwrócić nieoczekiwane nazwach. Na przykład za pomocą wzorzec wyszukiwania "\*1\*.txt" zwraca "długa_nazwa_pliku.txt", ponieważ "LONGFI~1.TXT" jest równoważna format nazwy pliku w formacie 8.3.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFiles%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 `path` Parametr można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza liczbę plików, które zaczynają się od określonej litery.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.  - lub - wystąpił błąd sieciowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" />.  - lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka nie zostanie znaleziony lub jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy plików w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinny zawierać wszystkie podkatalogi lub bieżącego katalogu.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżek) pasujących do wzorca wyszukiwania w określonym katalogu, aby określić, czy podkatalogi wyszukiwania przy użyciu wartości.</summary>
        <returns>Znaleziono tablicę pełnych nazw (w tym ścieżki) zgodnych ze wzorcem określonym wyszukiwania i opcji pliki w określonym katalogu lub pusta tablica, jeśli żadne pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy plików zwracane są dołączane do dostarczony parametr `path` i nie jest gwarantowana w kolejności nazw plików zwrócony; użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania"file*.txt"zwraca oba pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza przed zarówno format nazwy pliku w formacie 8.3 i format nazwy długie nazwy plików, wyszukiwanie wzorca podobne do "\*1\*.txt" może zwrócić nieoczekiwane nazwach. Na przykład za pomocą wzorzec wyszukiwania "\*1\*.txt" zwraca "długa_nazwa_pliku.txt", ponieważ "LONGFI~1.TXT" jest równoważna format nazwy pliku w formacie 8.3.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFiles%2A>, można uruchomić wyliczania Kolekcja nazw przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, musisz poczekać, aż całą tablicę nazw, które można zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Nazwy plików zawierać pełną ścieżkę.  
  
 `path` Parametr można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  - lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="searchpattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka nie zostanie znaleziony lub jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.  - lub - wystąpił błąd sieciowy.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy wszystkie pliki i podkatalogi, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy wszystkich plików i podkatalogów w określonej ścieżce.</summary>
        <returns>Tablica nazw plików i podkatalogów w określonym katalogu lub pusta tablica, jeśli zostaną znalezione żadne pliki lub podkatalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwracanych pliku i nazwy katalogów nie jest gwarantowana; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, rozpoczęciem wyliczania kolekcji wpisów przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, musisz poczekać, aż całą tablicę wpisów zwrócone, zanim dostęp do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Ta metoda jest taki sam jak <xref:System.IO.Directory.GetFileSystemEntries%2A> z gwiazdką (\*) określony jako wzorzec wyszukiwania.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetFileSystemEntries%2A> metody, aby wypełnić tablica ciągów nazw wszystkie pliki i podkatalogi w lokalizacji określonej przez użytkownika i odbitek każdego ciągu w tablicy do konsoli. Przykład skonfigurowano catch wszystkie błędy wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy plików i katalogów w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca tablicę nazw plików, a nazwy katalogu, które zgodne wyszukiwanie wzorca w określonej ścieżce.</summary>
        <returns>Tablica nazw plików i nazwy katalogu, spełniających określone kryteria wyszukiwania lub pusta tablica, jeśli zostaną znalezione nie pliki lub katalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwracanych pliku i nazwy katalogów nie jest gwarantowana; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetFileSystemEntries%2A> metodę, aby wypełnić tablica ciągów nazw wszystkich pliki zgodne filtru określonego przez użytkownika w określonej lokalizacji i wyświetla każdy ciąg w tablicy do konsoli. Przykład skonfigurowano catch wszystkie błędy wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  - lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do wyszukiwania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazwy plików i katalogów w <c>ścieżki</c>.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaków, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać tylko bieżącego katalogu lub powinna zawierać wszystkie podkatalogi.  Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca tablicę nazw plików i nazwy katalogu, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie wyszukuje podkatalogów.</summary>
        <returns>Tablica plików, nazwy pliku i nazwy katalogu, spełniających określone kryteria wyszukiwania lub pusta tablica, jeśli nie pliki lub katalogi zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwracanych pliku i nazwy katalogów nie jest gwarantowana; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literał i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdkę)|Zero lub więcej znaków na tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tej lokalizacji.|  
  
 Znaki inne niż symbol wieloznaczny są znaki. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` zaczyna się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, nie może zawierać nieprawidłowych znaków. Nieprawidłowe znaki można wyszukać przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określone rozszerzenie ma wpływ na wyszukiwanie w następujący sposób:  
>   
>  -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które rozpoczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca zarówno "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki dokładnie zgodne z określonym rozszerzeniem. Na przykład "\*.ai" zwraca "file.ai", ale nie "file.aif".  
>   
>  Użycie symboli wieloznacznych znak zapytania, ta metoda zwraca tylko te pliki, które pasują do podanego rozszerzenia pliku. Na przykład, podany w katalogu, wzorzec wyszukiwania dwóch plików, "więc Plik1.txt" i "file1.txtother", "pliku?. txt"zwraca tylko pierwszy plik, podczas gdy wzorzec wyszukiwania" pliku\*.txt "zwraca oba pliki.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, rozpoczęciem wyliczania kolekcji wpisów przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, musisz poczekać, aż całą tablicę wpisów zwrócone, zanim dostęp do tablicy. W związku z tym podczas pracy z wielu plików i katalogów, <xref:System.IO.Directory.EnumerateFiles%2A> może być skuteczniejsza.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej jest interpretowany jako względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki. Nieprawidłowe znaki można wyszukać przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  \- lub - <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.  - lub - <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy, takie jak odwołujących się do mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> jest to nazwa pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku, nazwa lub połączone przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, do którego będzie można uzyskać dostępu do informacji daty i godziny.</param>
        <summary>Zwraca określony datę i godzinę ostatniego udostępnienia pliku lub katalogu.</summary>
        <returns>Ostatniego dostępu do struktury, która ma ustawioną wartość daty i godziny określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Ta metoda jest taki sam jak <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> Parametr jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, do którego będzie można uzyskać dostępu do informacji daty i godziny.</param>
        <summary>Zwraca datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), na ostatniego udostępnienia określonego pliku lub katalogu.</summary>
        <returns>Ostatniego dostępu do struktury, która ma ustawioną wartość daty i godziny określonego pliku lub katalogu. Ta wartość jest wyrażone według czasu UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych w formacie uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> Parametr jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji o Data i godzina modyfikacji.</param>
        <summary>Zwraca datę i godzinę określonego pliku lub katalogu zostały ostatnio zapisane.</summary>
        <returns>Struktura, która ma ustawioną wartość daty i godziny określonego pliku lub katalogu ostatnio zostało zapisane. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji o Data i godzina modyfikacji.</param>
        <summary>Zwraca datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), który określonego pliku lub katalogu zostały ostatnio zapisane.</summary>
        <returns>Struktura, która ma ustawioną wartość daty i godziny określonego pliku lub katalogu ostatnio zostało zapisane. Ta wartość jest wyrażone według czasu UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych w formacie uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwy dysków logicznych na tym komputerze w postaci "&lt;literę dysku&gt;:\\".</summary>
        <returns>Dyski logiczne na tym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives zwraca wszystkie dostępne dyski na komputerze tym stacja dyskietek i wszelkie optyczne dyski.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetLogicalDrives%2A> metody można przypisać nazwy każdego dysku, na komputerze wywoływania na tablicę ciągów. Każdy członek tej tablicy ciągów jest następnie wydrukowany do konsoli. Przykład skonfigurowano catch wszystkie błędy wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy (na przykład awaria dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływania kodu niezarządzanego, taką jak wywołanie kodu natywnego za pomocą funkcji PInvoke lub COM interop. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, dla którego można pobrać katalogu nadrzędnego.</param>
        <summary>Pobiera katalogu nadrzędnego określonej ścieżki, w tym ścieżki względne i bezwzględne.</summary>
        <returns>Katalogu nadrzędnego lub <see langword="null" /> Jeśli <paramref name="path" /> to katalog główny, w tym folderze głównym nazwy serwera lub udziału UNC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje są usuwane z koniec `path` parametru przed pobraniem katalogu.  
  
 Długość ciągu zwróconego przez tę metodę składa się z wszystkie znaki w ścieżce do, ale nie w tym, ostatniego <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>. Na przykład, przekazywanie do ścieżki "C:\Directory\SubDirectory\test.txt" <xref:System.IO.Directory.GetParent%2A> zwraca "C:\Directory\SubDirectory". Przekazywanie "C:\Directory\SubDirectory" zwraca "C:\Directory". Jednak przekazywanie "C:\Directory\SubDirectory\\" zwraca "C:\Directory\SubDirectory", ponieważ końcowy separatora katalogu jest poprzedzone "Podkatalogu".  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.IO.Directory.GetParent%2A> metoda pobierania katalogu nadrzędnego w lokalizacji określonej przez użytkownika "path". Wartość zwrócona przez <xref:System.IO.Directory.GetParent%2A> metody jest następnie drukować na konsoli. Przykład skonfigurowano catch wszystkie błędy wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest tylko do odczytu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Aby uzyskać więcej informacji, zobacz <see cref="T:System.IO.PathTooLongException" /> tematu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">.NET framework: obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z usługi plików i katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Ścieżka do pliku lub katalogu, aby przenieść.</param>
        <param name="destDirName">Ścieżka do nowej lokalizacji dla <c>sourceDirName</c>. Jeśli <c>sourceDirName</c> jest plikiem, następnie <c>destDirName</c> również musi być nazwą pliku.</param>
        <summary>Przenosi plik lub katalog i jego zawartość do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy katalog o nazwie określonej przez `destDirName` i przenosi zawartość `sourceDirName` do katalogu docelowego nowo utworzony. Jeśli spróbujesz przenieść katalogu do katalogu, który już istnieje, <xref:System.IO.IOException> zostanie przeprowadzona. Na przykład wyjątek wystąpi, jeśli będą spróbuj przenieść c:\mydir c:\public i c:\public już istnieje. Alternatywnie można określić "c:\\\public\\\mydir" jako `destDirName` parametru, pod warunkiem że "mydir" nie istnieje w obszarze "c:\\\public", lub określ nową nazwę katalogu, takie jak "c:\\\newdir".  
  
 `sourceDirName` i `destDirName` argumenty są dozwolone pozwala określić informacje o ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje są usuwane z koniec parametry ścieżki przed przeniesieniem katalogu.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak przenieść katalogu i jego pliki do nowego katalogu. Oryginalny katalog nie istnieje już po została przeniesiona.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Próbowano przenieść katalogu do innego woluminu.  - lub - <paramref name="destDirName" /> już istnieje.  - lub - <paramref name="sourceDirName" /> i <paramref name="destDirName" /> parametry odnoszą się do tego samego pliku lub katalogu.  - lub - katalog lub plik jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceDirName" /> lub <paramref name="destDirName" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirName" /> lub <paramref name="destDirName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona przez <paramref name="sourceDirName" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z <paramref name="sourceDirName" /> i zapisywanie do <paramref name="sourceDirName" /> i <paramref name="destDirName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Aby dodać lub usunąć wpisy listę kontroli dostępu (ACL) kontroli dostępu z katalogu.</param>
        <param name="directorySecurity">A <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu, który opisuje wpisu na liście ACL, aby zastosować do katalogu opisanego przez <c>ścieżki</c> parametru.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu do określonego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.SetAccessControl%2A> Metoda stosowana wpisów listę kontroli dostępu (ACL) kontroli dostępu do pliku, który reprezentuje noninherited listy ACL.  
  
> [!CAUTION]
>  Określona lista ACL dla `directorySecurity` parametru zastępuje istniejące listy ACL dla katalogu. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.Directory.GetAccessControl%2A> metodę, aby uzyskać istniejące listy ACL, a następnie zmodyfikować go.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 <xref:System.IO.Directory.SetAccessControl%2A> Metody tylko będzie się powtarzał <xref:System.Security.AccessControl.DirectorySecurity> obiektów, które zostały zmodyfikowane po utworzeniu obiektu.  Jeśli <xref:System.Security.AccessControl.DirectorySecurity> obiektu nie został zmodyfikowany, nie będzie można utrwalone w pliku.  W związku z tym nie jest możliwe do pobrania <xref:System.Security.AccessControl.DirectorySecurity> obiektu z jednego pliku i ponownie zastosuj ten sam obiekt do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do innego:  
  
1.  Użyj <xref:System.IO.Directory.GetAccessControl%2A> metoda pobierania <xref:System.Security.AccessControl.DirectorySecurity> obiektów z pliku źródłowego.  
  
2.  Utwórz nową <xref:System.Security.AccessControl.DirectorySecurity> obiektu dla pliku docelowego.  
  
3.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metody źródła <xref:System.Security.AccessControl.DirectorySecurity> obiekt, aby pobrać listę kontroli dostępu.  
  
4.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodę, aby skopiować dane pobierane w kroku 3 do miejsca docelowego <xref:System.Security.AccessControl.DirectorySecurity> obiektu.  
  
5.  Skonfiguruj docelowego <xref:System.Security.AccessControl.DirectorySecurity> obiektu przy użyciu pliku docelowego <xref:System.IO.Directory.SetAccessControl%2A> metody.  
  
 W środowiskach NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przypisywane do użytkownika, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia folderu nadrzędnego. Odrzucanie <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w nadrzędnym katalogu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetAccessControl%2A> i <xref:System.IO.Directory.SetAccessControl%2A> metody dodawania dostępu kontrolować wpis listę kontroli dostępu (ACL), a następnie usuń wpis listy ACL z katalogu.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directorySecurity" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można odnaleźć katalogu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Był nieprawidłowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do katalogu określonego przez <paramref name="path" />.  - lub - bieżący proces nie ma wystarczającego uprawnienia, aby ustawić wpisu na liście ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest system Windows 2000 lub nowszy.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> akcji zabezpieczeń: żądanie.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, do których chcesz ustawić informacji o datę i godzinę utworzenia.</param>
        <param name="creationTime">Data i czas pliku lub katalogu ostatnio zostało zapisane. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia daty i godziny dla określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych w formacie uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, do których chcesz ustawić informacji o datę i godzinę utworzenia.</param>
        <param name="creationTimeUtc">Data i czas katalog lub plik został utworzony. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę utworzenia, w formacie uniwersalnego czasu koordynowanego (UTC), dla określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, do którego ustawiono bieżący katalog roboczy.</param>
        <summary>Ustawia bieżący katalog roboczy aplikacji do określonego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu działania aplikacji, katalogu roboczego został przywrócony do jej oryginalnej lokalizacji (katalog, w którym został uruchomiony proces).  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje są usuwane z koniec `path` parametru przed ustawieniem katalogu.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Jeśli konfigurujesz katalogu na dysku z nośnika wymiennego na przykład, aby ("A:" dla stacji dyskietek) lub "E:" dla dysku CD, można określić, czy stacja jest gotowa, za pomocą <xref:System.IO.DriveInfo.IsReady%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób ustawić bieżącego katalogu i wyświetlić katalog główny.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień, dostęp do kodu niezarządzanego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określony katalog nie został znaleziony.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">dla zapisu do plików lub katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ustawienia dostępu do informacji daty i godziny.</param>
        <param name="lastAccessTime">Obiekt, który zawiera wartość do ustawienia dla dostępu Data i godzina <c>ścieżki</c>. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia określony datę i godzinę ostatniego udostępnienia pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ustawienia dostępu do informacji daty i godziny.</param>
        <param name="lastAccessTimeUtc">Obiekt, który zawiera wartość do ustawienia dla dostępu Data i godzina <c>ścieżki</c>. Ta wartość jest wyrażone według czasu UTC.</param>
        <summary>Ustawia datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), na ostatniego udostępnienia określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych w formacie uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <param name="lastWriteTime">Data i godzina ostatniego zapisania katalogu do. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego zostało zapisane katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <param name="lastWriteTimeUtc">Data i godzina ostatniego zapisania katalogu do. Ta wartość jest wyrażone według czasu UTC.</param>
        <summary>Ustawia datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), który ostatnio zapisano katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych w formacie uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków. Można zbadać nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku zapisywania do określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
  </Members>
</Type>
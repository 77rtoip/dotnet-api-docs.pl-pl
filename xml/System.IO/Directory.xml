<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b2dfc84f48aa62b20974348afaefe56611626b9" /><Meta Name="ms.sourcegitcommit" Value="f9e71795ba0f9c2dfaa74bec233343ed0f3ffd99" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/14/2019" /><Meta Name="ms.locfileid" Value="57915831" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody statyczne do tworzenia, przenoszenia i wyliczania katalogów i podkatalogów. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Directory> klasy dla typowych operacji, takich jak kopiowanie, przenoszenie, zmiana nazwy, tworzenie i usuwanie katalogów.  
  
-   Aby utworzyć katalog, użyj jednej z <xref:System.IO.Directory.CreateDirectory%2A> metody.  
  
-   Aby usunąć katalog, użyj jednej z <xref:System.IO.Directory.Delete%2A> metody.  
  
-   Aby pobrać lub ustawić bieżący katalog dla aplikacji, należy użyć <xref:System.IO.Directory.GetCurrentDirectory%2A> lub <xref:System.IO.Directory.SetCurrentDirectory%2A> metody.  
  
-   Do manipulowania <xref:System.DateTime> informacje dotyczące tworzenia, dostępu i zapis w katalogu, używać metod takich jak <xref:System.IO.Directory.SetLastAccessTime%2A> i <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Metody statyczne <xref:System.IO.Directory> klasy sprawdzania zabezpieczeń dla wszystkich metod. Jeśli chcesz ponownie użyć obiektu, należy wziąć pod uwagę przy użyciu odpowiedniej metody wystąpienia <xref:System.IO.DirectoryInfo> zamiast tego należy być konieczne, ponieważ nie zawsze będą sprawdzanie zabezpieczeń.  
  
 Jeśli wykonujesz tylko jedną akcje związane z katalogu, może być bardziej efektywne, aby użyć statycznego <xref:System.IO.Directory> metody zamiast odpowiednią <xref:System.IO.DirectoryInfo> metodę wystąpienia. Większość <xref:System.IO.Directory> metody wymagają ścieżki do katalogu, który modyfikujesz.  
  
> [!NOTE]
>  Elementów członkowskich, które akceptują ciąg `path` parametr, ta ścieżka musi być poprawnie sformułowany lub zgłaszany jest wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowany, ale zaczyna się od spacji ("c:\temp"), ciąg ścieżki nie jest przycięty, aby ścieżka jest uznawany za nieprawidłowo sformułowany i zgłaszany jest wyjątek. Ponadto ścieżka lub kombinacji ścieżki nie może być w pełni kwalifikowana dwa razy. Na przykład "c:\temp c:\windows" także zgłasza wyjątek. Upewnij się, Twoje ścieżki są poprawnie sformułowane, korzystając z metod, które akceptują ciąg ścieżki. Aby uzyskać więcej informacji, zobacz <xref:System.IO.Path>.  
  
 W przypadku elementów członkowskich, które akceptują ścieżką ścieżka może odwoływać się do pliku lub katalogu. Nazwy udziałów i serwera, można użyć pełnej ścieżki, ścieżką względną lub ścieżką Universal Naming Convention (UNC). Na przykład następujące warunki są dopuszczalne ścieżki:  
  
-   "c:\\\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.  
  
-   "MyDir\\\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" w języku C# lub "\\\MyServer\MyShare" w języku Visual Basic.  
  
 Domyślnie Pełny odczyt/zapis dostęp do nowych katalogów otrzymuje dla wszystkich użytkowników. Jednak aplikacja musi mieć poprawny zabezpieczeń na dostęp do istniejących katalogach.  
  
 Żądanie uprawnień do katalogu i wszystkie podkatalogi, koniec ciągu ścieżki ze znakiem separatora katalogu. (Na przykład "C:\Temp\\" udziela dostępu do C:\Temp\ i jego podkatalogach.) Żądanie uprawnień tylko do określonego katalogu zakończenia ciąg ścieżki kropką. (Na przykład "C:\Temp\\." zezwolenie na dostęp tylko C:\Temp\\, a nie do jego podkatalogi.)  
  
 Elementów członkowskich, które akceptują `searchPattern` parametr ciągu wyszukiwania może być dowolną kombinacją znaków literału i dwa znaki symboli wieloznacznych; \* i?. Ten parametr nie może rozpoznać wyrażenia regularne. Aby uzyskać więcej informacji, zobacz <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> metody lub metody, która używa `searchPattern` parametru.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> i <xref:System.IO.DirectoryInfo> nie są obsługiwane do użytku w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji. Aby uzyskać informacje dotyczące dostępu do plików i folderów w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacji, zobacz [uzyskiwania dostępu do danych i plików (aplikacje Windows Store)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wszystkie pliki tekstowe z katalogu i przenieść je do nowego katalogu. Po przeniesieniu plików już nie istnieją one w oryginalnym katalogu.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Poniższy przykład pokazuje sposób użycia <xref:System.IO.Directory.EnumerateFiles%2A> metody pobieranie kolekcji plików tekstowych z katalogu, a następnie użyć tej kolekcji w zapytaniu, aby znaleźć wszystkie wiersze, które zawierają "Przykład".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 Poniższy przykład pokazuje, jak można przenieść katalogu i wszystkich jego plików do nowego katalogu. Oryginalny katalog już nie istnieje, po jego przeniesieniu.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis w nowo utworzonym pliku danych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wszystkich katalogów w określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do utworzenia.</param>
        <summary>Tworzy wszystkich katalogów i podkatalogów w określonej ścieżce, chyba że już istnieje.</summary>
        <returns>Obiekt, który reprezentuje katalog w określonej ścieżce. Ten obiekt jest zwracany niezależnie od tego, czy istnieje już katalog w określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w `path` są tworzone, chyba że już istnieje lub jakaś część `path` jest nieprawidłowy. Jeśli katalog już istnieje, ta metoda nie powoduje utworzenia nowego katalogu, ale zwraca <xref:System.IO.DirectoryInfo> obiekt do istniejącego katalogu.  
  
 `path` Parametr określa ścieżkę do katalogu, nie ścieżka do pliku.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed utworzeniem katalogu.  
  
 Można utworzyć katalogu na komputerze zdalnym w udziale, który ma dostęp do zapisu. Ścieżki UNC są obsługiwane; na przykład można określić następujące `path`: `\\2009\Archives\December` w języku Visual Basic i `\\\\2009\\Archives\\December` w języku C#.  
  
 Tworzenie katalogu przy użyciu tylko znak dwukropka (:) nie jest obsługiwane i spowoduje, że `NotSupportedException` zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy i usuwa określonego katalogu.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Można utworzyć katalogu C:\Users\User1\Public\Html, gdy bieżący katalog to C:\Users\User1, należy użyć innych następujące wywołania aby upewnić się, że ukośnik odwrotny będzie interpretowany prawidłowo.  
  
 W języku Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 W języku C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 In C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest plikiem.  
  
—lub— 
Nazwa sieci nie jest znany.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="path" /> jest poprzedzony znakiem lub zawiera tylko znak dwukropka (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> zawiera znak dwukropka (:), który nie jest częścią Etykieta dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików lub katalogów. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do utworzenia.</param>
        <param name="directorySecurity">Kontrola dostępu do zastosowania do katalogu.</param>
        <summary>Tworzy wszystkich katalogów w określonej ścieżce, chyba że istnieje, stosując określoną zabezpieczeń Windows.</summary>
        <returns>Obiekt, który reprezentuje katalog w określonej ścieżce. Ten obiekt jest zwracany niezależnie od tego, czy istnieje już katalog w określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do tworzenia katalogu przy użyciu kontroli dostępu, więc nie ma żadnych szansy katalogu są dostępne przed zastosowaniem zabezpieczeń.  
  
 Wszystkie katalogi określone w `path` parametru są tworzone, chyba że już istnieje lub jakaś część `path` jest nieprawidłowy. `path` Parametr określa ścieżkę do katalogu, nie ścieżka do pliku. Jeśli katalog już istnieje, ta metoda nie powoduje utworzenia nowego katalogu, ale zwraca <xref:System.IO.DirectoryInfo> obiekt do istniejącego katalogu.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed utworzeniem katalogu.  
  
 Można utworzyć katalogu na komputerze zdalnym w udziale, który ma dostęp do zapisu. Ścieżki UNC są obsługiwane; na przykład można określić następujące `path`: `\\2009\Archives\December` w języku Visual Basic i `\\\\2009\\Archives\\December` w języku C#.  
  
 Tworzenie katalogu przy użyciu tylko znak dwukropka (:) nie jest obsługiwane i powoduje, że `NotSupportedException` zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy katalog z reguł dostępu dla dwóch kont użytkowników.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest plikiem.  
  
—lub— 
Nazwa sieci nie jest znany.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="path" /> jest poprzedzony znakiem lub zawiera tylko znak dwukropka (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> zawiera znak dwukropka (:), który nie jest częścią Etykieta dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików i katalogów oraz dostęp do katalogu docelowego. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony katalog i opcjonalnie wszystkich podkatalogach.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pustego katalogu do usunięcia. Ten katalog musi być zapisywalny i jest pusty.</param>
        <summary>Usuwa pusty katalog z określonej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta działa identycznie do <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> z `false` określony dla drugiego parametru.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed usunięciem katalogu.  
  
 Ta metoda wyrzuca <xref:System.IO.IOException> Jeśli katalogu określonego w `path` parametr zawiera plików i podkatalogów.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 W niektórych przypadkach, jeśli określony katalog, Otwórz w Eksploratorze plików <xref:System.IO.Directory.Delete%2A> metody nie można go usunąć.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia nowego katalogu i podkatalogów, a następnie usuń tylko podkatalogu.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik o tej samej nazwie i lokalizacji określonej przez <paramref name="path" /> istnieje.  
  
—lub— 
Katalog znajduje się bieżący katalog roboczy aplikacji.  
  
—lub— 
Katalog określony przez <paramref name="path" /> nie jest pusty.  
  
—lub— 
Katalog jest tylko do odczytu lub plikiem tylko do odczytu.  
  
—lub— 
Katalog jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> nie istnieje lub nie został odnaleziony.  
  
—lub— 
Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pisania w określonym katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa katalogu do usunięcia.</param>
        <param name="recursive"><see langword="true" /> Aby usunąć katalogów, podkatalogów i plików w <paramref name="path" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Usuwa określony katalog i, jeśli wskazano, wszelkie podkatalogi i pliki w katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed usunięciem katalogu.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Jeśli `recursive` parametr jest `true`, użytkownik musi mieć uprawnienia do zapisu dla bieżącego katalogu oraz jak w przypadku wszystkich podkatalogach.  
  
 Zachowanie tej metody różni się podczas usuwania katalogu, zawierającego punkt ponownej analizy, takie jak łącza symbolicznego ani punktu instalacji. Jeśli punkt ponownej analizy to katalog, takie jak punkt instalacji jest odinstalowane, a punkt instalacji zostanie usunięty. Ta metoda nie recurse za pośrednictwem punktu ponownej analizy. Jeśli punkt ponownej analizy to łącze symboliczne do pliku, zostanie usunięty punkt ponownej analizy i nie element docelowy łącza symbolicznego.  
  
 W niektórych przypadkach, jeśli określony katalog, Otwórz w Eksploratorze plików <xref:System.IO.Directory.Delete%2A> metody nie można go usunąć.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowy katalog, podkatalogów i plików w podkatalogu, a następnie rekursywnie Usuń wszystkie nowe elementy.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik o tej samej nazwie i lokalizacji określonej przez <paramref name="path" /> istnieje.  
  
—lub— 
Katalog określony przez <paramref name="path" /> jest tylko do odczytu lub <paramref name="recursive" /> jest <see langword="false" /> i <paramref name="path" /> nie jest pusty katalog.  
  
—lub— 
Katalog znajduje się bieżący katalog roboczy aplikacji.  
  
—lub— 
Katalog zawiera plik tylko do odczytu.  
  
—lub— 
Katalog jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> nie istnieje lub nie został odnaleziony.  
  
—lub— 
Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pisania w określonym katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogów, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalny zbiór nazwy katalogów w określonej ścieżce.</summary>
        <returns>Wyliczalne zbiór pełnych nazw (w tym ścieżki) w przypadku katalogów w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić informacje o ścieżce względnej lub bezwzględnej `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody. Nazwy katalogów zwracane są poprzedzone przy użyciu wartości podanych w `path` parametru. Na przykład, jeśli podano ścieżkę względną w `path` parametru nazwy katalogów zwracany będzie zawierać ścieżkę względną.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi najwyższego poziomu w określonej ścieżce.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalne zbiór pełnych nazw (w tym ścieżki) w przypadku katalogów w katalogu określonym przez <paramref name="path" /> i który pasuje do wzorca wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej lub bezwzględnej `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody. Nazwy katalogów zwracane są poprzedzone przy użyciu wartości podanych w `path` parametru. Na przykład, jeśli podano ścieżkę względną w `path` parametru nazwy katalogów zwracany będzie zawierać ścieżkę względną.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi najwyższego poziomu w określonej ścieżce, które pasują do wzorca wyszukiwania.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać bieżący katalog powinien zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny nazwy katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie przeszukuje podkatalogów.</summary>
        <returns>Wyliczalne zbiór pełnych nazw (w tym ścieżki) w przypadku katalogów w katalogu określonym przez <paramref name="path" /> i który pasuje do określonego wzorca wyszukiwania i opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Dokładnie jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej lub bezwzględnej `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody. Nazwy katalogów zwracane są poprzedzone przy użyciu wartości podanych w `path` parametru. Na przykład, jeśli podano ścieżkę względną w `path` parametru nazwy katalogów zwracany będzie zawierać ścieżkę względną.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi w określonej ścieżce, które pasują do wzorca wyszukiwania. Używa ona `searchOption` parametru, aby określić, że wszystkie podkatalogi, należy uwzględnić w wyszukiwaniu.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wyliczalny nazw plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalny zbiór nazwy plików w określonej ścieżce.</summary>
        <returns>Wyliczalne zbiór pełnych nazw (w tym ścieżki) dla plików w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFiles%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wszystkie pliki w katalogu i przenieść je do nowego katalogu. Po przeniesieniu plików już nie istnieją one w oryginalnym katalogu.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 Poniższy przykład wylicza pliki w określonym katalogu odczytuje każdego wiersza w pliku i wyświetla wiersz zawiera ciąg "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowania z nazwami plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny nazw plików, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalne zbiór pełnych nazw (w tym ścieżki) dla plików w katalogu określonym przez <paramref name="path" /> i który pasuje do wzorca wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFiles%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobierania plików tekstowych w katalogu i przenieść je do nowego katalogu. Po przeniesieniu plików już nie istnieją one w oryginalnym katalogu.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Poniższy przykład wylicza pliki w określonym katalogu, z rozszerzeniem txt, odczytuje każdego wiersza w pliku i wyświetla wiersz zawiera ciąg "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowania z nazwami plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać bieżący katalog powinien zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny nazw plików, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie przeszukuje podkatalogów.</summary>
        <returns>Wyliczalne zbiór pełnych nazw (w tym ścieżki) dla plików w katalogu określonym przez <paramref name="path" /> i który pasuje do określonego wzorca wyszukiwania i opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFiles%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób pobierania plików tekstowych w katalogu i jego podkatalogach i przenieść je do nowego katalogu. Po przeniesieniu plików już nie istnieją w oryginalnej katalogach.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Rekursywnie poniższy przykład wylicza wszystkie pliki z rozszerzeniem txt odczytuje każdego wiersza w pliku i wyświetla wiersz zawiera ciąg "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję wyliczalny wpisy systemu plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalny kolekcję nazw plików i katalog, w określonej ścieżce.</summary>
        <returns>Wyliczalne zbiór wpisów systemu plików w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, możesz rozpocząć wyliczanie zbiór wpisów, zanim zostanie zwrócony całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, należy poczekać całą gamę wpisów, aby otrzymać dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw systemu plików wpisów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny nazw plików i nazwy katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalne zbiór wpisów systemu plików w katalogu określonym przez <paramref name="path" /> i który pasuje do wzorca wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`. 
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, możesz rozpocząć wyliczanie zbiór wpisów, zanim zostanie zwrócony całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, należy poczekać całą gamę wpisów, aby otrzymać dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania wpisy systemu plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać bieżący katalog powinien zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny nazw plików i nazwy katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie przeszukuje podkatalogów.</summary>
        <returns>Wyliczalne zbiór wpisów systemu plików w katalogu określonym przez <paramref name="path" /> i który pasuje do określonego wzorca wyszukiwania i opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, możesz rozpocząć wyliczanie zbiór wpisów, zanim zostanie zwrócony całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, należy poczekać całą gamę wpisów, aby otrzymać dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> kolekcji rozpocznie się nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do testowania.</param>
        <summary>Określa, czy dany ścieżka odwołuje się do istniejącego katalogu na dysku.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="path" /> odwołuje się do istniejącego katalogu; <see langword="false" /> katalog nie istnieje. czy występuje błąd podczas próby określenia, czy istnieje określony katalog.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed sprawdzeniem, czy katalog istnieje.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Jeśli nie ma pod minimalne uprawnienia tylko do odczytu do katalogu, <xref:System.IO.Directory.Exists%2A> metoda zwróci `false`.  
  
 <xref:System.IO.Directory.Exists%2A> Metoda zwraca `false` sytuacji wszelkie błędy podczas próby określenia, czy istnieje określony plik. Taka sytuacja może wystąpić w sytuacji, które zgłaszają wyjątki, takich jak przekazanie nazwy pliku zawierającej nieprawidłowe znaki lub zbyt wiele znaków, ile niepowodzeniem lub brakuje dysku, czy obiekt wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę nazwy pliku lub katalogu, w wierszu polecenia, określa, jakiego rodzaju nazwy jest i odpowiednio je przetwarza.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca Windows listy kontroli dostępu (ACL) dla katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do katalogu zawierającego <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który opisuje informacje listę kontroli dostępu (ACL) kontroli dostępu do tego pliku.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który hermetyzuje wpisów listę kontroli dostępu (ACL) kontroli dostępu dla określonego katalogu.</summary>
        <returns>Obiekt hermetyzujący kontroli dostępu reguły dla pliku opisanego przez <paramref name="path" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Directory.GetAccessControl%2A> metody do pobierania wpisów listę kontroli dostępu (ACL) kontroli dostępu dla katalogu.  
  
 Listy ACL w tym artykule opisano użytkowników indywidualnych i/lub grupy, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 W środowiskach systemu plików NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> przyznane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> praw w folderze nadrzędnym. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w katalogu nadrzędnym.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetAccessControl%2A> i <xref:System.IO.Directory.SetAccessControl%2A> metody, aby dodać dostęp kontrolować wpis na liście (ACL), a następnie usuń wpis listy ACL, z katalogu.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Windows 2000 lub nowszym.</exception>
        <exception cref="T:System.SystemException">Wystąpił błąd poziomie systemu, np. nie można odnaleźć katalogu. Określony wyjątek, może być podklasą klasy <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określony katalog, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Akcja zabezpieczeń: Żądanie.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do katalogu zawierającego <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który opisuje informacje listę kontroli dostępu (ACL) kontroli dostępu do tego pliku.</param>
        <param name="includeSections">Jedną z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, które określa typ dostępu kontrolować listę kontroli dostępu (ACL) informacji do odbierania.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który hermetyzuje określony typ pozycji listy (ACL) kontroli dostępu dla określonego katalogu.</summary>
        <returns>Obiekt hermetyzujący kontroli dostępu reguły dla pliku opisanego przez <paramref name="path" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Directory.GetAccessControl%2A> metody do pobierania wpisów listę kontroli dostępu (ACL) kontroli dostępu dla katalogu.  
  
 Listy ACL w tym artykule opisano użytkowników indywidualnych i/lub grupy, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 W środowiskach systemu plików NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> przyznane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> praw w folderze nadrzędnym. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w katalogu nadrzędnym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Windows 2000 lub nowszym.</exception>
        <exception cref="T:System.SystemException">Wystąpił błąd poziomie systemu, np. nie można odnaleźć katalogu. Określony wyjątek, może być podklasą klasy <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określony katalog, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Akcja zabezpieczeń: Żądanie.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <summary>Pobiera datę i godzinę utworzenia katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę utworzenia określonego katalogu. Ta wartość jest wyrażone według czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa ona funkcji natywnych, których wartości może nie być stale aktualizowana przez system operacyjny.  
  
 Ta metoda jest odpowiednikiem <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera czasu utworzenia określonego katalogu.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <summary>Pobiera datę i godzinę utworzenia, w formacie uniwersalnego czasu koordynowanego (UTC), w katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę utworzenia określonego katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa ona funkcji natywnych, których wartości może nie być stale aktualizowana przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Użyj tej metody można pobrać czasu utworzenia katalogu, na podstawie na uniwersalny czas koordynowany (UTC).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący katalog roboczy aplikacji.</summary>
        <returns>Ciąg, który zawiera ścieżkę bezwzględną do bieżącego katalogu roboczego, a nie kończy się znakiem kreski ułamkowej odwróconej (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący katalog różni się od oryginalnego katalogu, który jest jeden, z którego proces został uruchomiony.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `GetCurrentDirectory` metody.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny jest Windows CE, które nie ma bieżącej funkcji katalogu.  
  
Ta metoda jest dostępna w programie .NET Compact Framework, ale nie jest obecnie obsługiwane.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy podkatalogów, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy podkatalogi (łącznie z ich ścieżek) w określonym katalogu.</summary>
        <returns>Tablica pełne nazwy podkatalogi w określonej ścieżce lub pusta tablica, jeśli zostaną znalezione żadne katalogi (w tym ścieżki).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest taka sama jak <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> z gwiazdką (\*) określony jako wzorzec wyszukiwania, dlatego zwraca wszystkich podkatalogach. Jeśli zachodzi potrzeba przeszukuje podkatalogów, użyj <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> metody, która pozwala na określenie wyszukiwanie podkatalogów z `searchOption` parametru.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 `path` Parametru można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nazwy, zwracany przez tę metodę mają prefiks katalogu informacjami w `path`.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę nazwy pliku lub katalogu, w wierszu polecenia, określa, jakiego rodzaju nazwy jest i odpowiednio je przetwarza.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw podkatalogów w <paramref name="path" />. Ten parametr może zawierać kombinację prawidłowym literałem i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca nazwy podkatalogi (łącznie z ich ścieżek), pasujących do wzorca wyszukiwania w określonym katalogu.</summary>
        <returns>Tablica nazw (w tym ścieżki) podkatalogów, które pasuje do wzorca wyszukiwania w określonym katalogu lub pusta tablica, jeśli zostaną znalezione żadne katalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wszystkie podkatalogi bezpośrednio w określonym katalogu, pasujących do wzorca wyszukiwania. Określony katalog nie ma żadnych podkatalogów, czy dopasować żadnych podkatalogów `searchPattern` parametru, ta metoda zwraca pustą tablicę. Katalog główny jest przeszukiwany. Aby przeszukuje podkatalogów, a także użyć <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> metodę i określić <xref:System.IO.SearchOption.AllDirectories> w `searchOption` parametru.  
  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 `path` Parametr można określić informacje o ścieżce względnej lub bezwzględnej i nie jest rozróżniana wielkość liter.  Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza katalogi w ścieżce, które zaczynają się od określonej litery.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw podkatalogów w <paramref name="path" />. Ten parametr może zawierać kombinację prawidłowym literałem i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać wszystkie podkatalogi lub bieżącym katalogu.</param>
        <summary>Zwraca nazwy podkatalogi (łącznie z ich ścieżek), pasujących do wzorca wyszukiwania w określonym katalogu i opcjonalnie przeszukuje podkatalogów.</summary>
        <returns>Tablica pełne nazwy podkatalogów, spełniających określone kryteria (w tym ścieżki) lub pusta tablica, jeśli zostaną znalezione żadne katalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr można określić informacje o ścieżce względnej lub bezwzględnej i nie jest rozróżniana wielkość liter. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
 <xref:System.IO.Directory.EnumerateDirectories%2A> i <xref:System.IO.Directory.GetDirectories%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetDirectories%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza katalogi, które zaczynają się od określonej litery w ścieżce. Przeszukiwany jest tylko katalog najwyższego poziomu.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub katalogu.</param>
        <summary>Zwraca informacje o woluminie i/lub informacje o głównym dla określonej ścieżki.</summary>
        <returns>Ciąg, który zawiera informacje o woluminie i/lub informacje o głównym dla określonej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pobiera w pełni kwalifikowana nazwa `path`, jak zwracany przez <xref:System.IO.Path.GetFullPath%2A>, i zwraca główne informacje o katalogu. Określona ścieżka nie musi istnieć.  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje jak ustawienie bieżącego katalogu i wyświetlić katalog główny.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżek) w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) dla plików w określonym katalogu lub pusta tablica, jeśli zostaną znalezione żadne pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFiles%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Nazwy plików zwracane są dołączane do podane `path` parametru.  
  
 Ta metoda jest taka sama jak <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> z gwiazdką (\*) określony jako wzorzec wyszukiwania.  
  
 `path` Parametru można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nie jest gwarantowana kolejność nazw plików zwrócone; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.IO.Directory.GetFiles%2A> metodę, aby zwrócić nazwy plików z lokalizacji określonej przez użytkownika. Przykład został skonfigurowany do błędów catch, wszystkie wspólne dla tej metody.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.  
  
—lub— 
Wystąpił błąd sieci.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka nie zostanie znaleziony lub jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowania z nazwami plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżek), pasujących do wzorca wyszukiwania w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) dla plików w określonym katalogu zgodnych określonego wzorca wyszukiwania lub pusta tablica, jeśli nie zostaną znalezione żadne pliki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy plików zwracane są dołączane do podane `path` parametru i kolejność nazw plików zwrócone nie ma żadnej gwarancji; użyj <xref:System.Array.Sort%2A> metody, jeśli wymagana jest porządek sortowania określonych.  
  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza względem format nazwy pliku w formacie 8.3 i format nazwy pliku długie nazwy plików, wyszukiwanie wzorca podobny do "\*1\*.txt" może zwracać nieoczekiwane nazwy. Na przykład za pomocą wzorca wyszukiwania "\*1\*.txt" zwraca "długa_nazwa_pliku.txt", ponieważ równoważne 8.3 format nazwy pliku jest "LONGFI~1.TXT".  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFiles%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 `path` Parametru można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza liczbę plików, które zaczynają się od określonej litery.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.  
  
—lub— 
Wystąpił błąd sieci.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka nie zostanie znaleziony lub jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowania z nazwami plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać wszystkie podkatalogi lub bieżącym katalogu.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżek), pasujących do wzorca wyszukiwania w określonym katalogu, przy użyciu wartości w celu ustalenia, czy podkatalogi wyszukiwania.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) dla plików w określonym katalogu, które pasują do określonego wzorca wyszukiwania i opcji lub pusta tablica, jeśli żadne pliki nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy plików zwracane są dołączane do podany parametr `path` i nie jest gwarantowana kolejność nazw plików zwrócone; użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania"file*.txt"zwraca zarówno pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza względem format nazwy pliku w formacie 8.3 i format nazwy pliku długie nazwy plików, wyszukiwanie wzorca podobny do "\*1\*.txt" może zwracać nieoczekiwane nazwy. Na przykład za pomocą wzorca wyszukiwania "\*1\*.txt" zwraca "długa_nazwa_pliku.txt", ponieważ równoważne 8.3 format nazwy pliku jest "LONGFI~1.TXT".  
  
 <xref:System.IO.Directory.EnumerateFiles%2A> i <xref:System.IO.Directory.GetFiles%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFiles%2A>, możesz rozpocząć wyliczanie Kolekcja nazw przed zwróceniem całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFiles%2A>, należy poczekać cała tablica nazw ma zostać zwrócony mają dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Nazwy plików zawierają pełną ścieżkę.  
  
 `path` Parametru można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> lub <paramref name="searchpattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka nie zostanie znaleziony lub jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.  
  
—lub— 
Wystąpił błąd sieci.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy wszystkich plików i podkatalogów, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy wszystkich plików i podkatalogów w określonej ścieżce.</summary>
        <returns>Tablica nazw plików i podkatalogów w określonym katalogu lub pusta tablica, jeśli zostaną znalezione żadne pliki lub podkatalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwróconego pliku i nazwy katalogów nie ma żadnej gwarancji; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, możesz rozpocząć wyliczanie zbiór wpisów, zanim zostanie zwrócony całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, należy poczekać całą gamę wpisów, aby otrzymać dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Ta metoda jest taka sama jak <xref:System.IO.Directory.GetFileSystemEntries%2A> z gwiazdką (\*) określony jako wzorzec wyszukiwania.  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetFileSystemEntries%2A> metodę, aby wypełnić tablica ciągów nazw wszystkich plików i podkatalogów w lokalizacji określonej przez użytkownika i drukuje każdego ciągu w tablicy do konsoli. Przykład został skonfigurowany do błędów catch, wszystkie wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw plików i katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca tablicę nazw plików i nazwy katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Tablica nazw plików i katalog, które odpowiadają określonym kryteriom wyszukiwania lub pusta tablica, jeśli zostaną znalezione nie pliki lub katalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwróconego pliku i nazwy katalogów nie ma żadnej gwarancji; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetFileSystemEntries%2A> metody do wypełnienia tablicy ciągów przy użyciu nazwy wszystkich plików zgodnych z filtrem określonych przez użytkownika w określonej lokalizacji i drukuje każdego ciągu w tablicy do konsoli. Przykład został skonfigurowany do błędów catch, wszystkie wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do informacji o ścieżce dla bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Względna lub bezwzględna ścieżka do katalogu, do wyszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Wyszukiwany ciąg do dopasowywania nazw plików i katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinna zawierać bieżący katalog powinien zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca tablicę nazw plików i nazwy katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce, a opcjonalnie przeszukuje podkatalogów.</summary>
        <returns>Tablica pliku, które znajdują się nazwy pliku i nazwy katalogów, spełniających określone kryteria wyszukiwania lub pusta tablica, jeśli nie pliki lub katalogi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwróconego pliku i nazwy katalogów nie ma żadnej gwarancji; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|\* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład `searchPattern` ciąg "\*t" wyszukuje wszystkie nazwy `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 `searchPattern` nie może kończyć się dwie kropki ("..") lub zawiera dwie kropki ("..") następuje <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, ani nie może zawierać nieprawidłowych znaków. Można wyszukiwać nieprawidłowych znaków, przy użyciu <xref:System.IO.Path.GetInvalidPathChars%2A> metody.  
  
> [!NOTE]
>  Kiedy używać gwiazdki jako symbolu wieloznacznego w `searchPattern` takich jak "\*.txt", liczba znaków w określonego rozszerzenia ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie jest dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się z określonym rozszerzeniem. Na przykład "\*xls" zwraca "book.xls" i "book.xlsx".  
> -   We wszystkich innych przypadkach metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*AI" zwraca "file.ai", ale nie "file.aif".  
>   
>  Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki, "więc Plik1.txt" i "file1.txtother" w katalogu, wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik, natomiast do wzorca wyszukiwania z" pliku\*.txt "zwraca zarówno pliki.  
  
 <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i <xref:System.IO.Directory.GetFileSystemEntries%2A> metody różnią się w następujący sposób: Kiedy używasz <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, możesz rozpocząć wyliczanie zbiór wpisów, zanim zostanie zwrócony całej kolekcji; Jeśli używasz <xref:System.IO.Directory.GetFileSystemEntries%2A>, należy poczekać całą gamę wpisów, aby otrzymać dostęp do tablicy. W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.Directory.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Można określić informacje o ścieżce względnej z `path` parametru. Informacje o ścieżce względnej są interpretowane względem bieżącego katalogu roboczego, który można określić za pomocą <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Można wyszukiwać nieprawidłowych znaków, przy użyciu <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.  
  
—lub— 
 <paramref name="searchPattern" /> nie zawiera prawidłowy wzorzec.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> jest nieprawidłowa, takich jak odnoszące się do niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka pliku nazwa lub połączone przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać dostęp do informacji daty i godziny.</param>
        <summary>Zwraca datę i godzinę, określonego pliku lub katalogu nastąpił ostatni dostęp do.</summary>
        <returns>Ostatniego dostępu do struktury, która jest ustawiona na datę i godzinę określonego pliku lub katalogu. Ta wartość jest wyrażone według czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa ona funkcji natywnych, których wartości może nie być stale aktualizowana przez system operacyjny.  
  
 Ta metoda jest taka sama jak <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> Parametr jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać dostęp do informacji daty i godziny.</param>
        <summary>Zwraca wartość daty i godziny, w formacie uniwersalnego czasu koordynowanego (UTC) ostatniej dostępne określonego pliku lub katalogu.</summary>
        <returns>Ostatniego dostępu do struktury, która jest ustawiona na datę i godzinę określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa ona funkcji natywnych, których wartości może nie być stale aktualizowana przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> Parametr jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji daty i godziny modyfikacji.</param>
        <summary>Zwraca datę i godzinę określony plik lub katalog został ostatnio zapisany.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę określonego pliku lub katalogu ostatniej zostały zapisane. Ta wartość jest wyrażone według czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa ona funkcji natywnych, których wartości może nie być stale aktualizowana przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji daty i godziny modyfikacji.</param>
        <summary>Zwraca datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), który określony plik lub katalog został ostatnio zapisany.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę określonego pliku lub katalogu ostatniej zostały zapisane. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa ona funkcji natywnych, których wartości może nie być stale aktualizowana przez system operacyjny.  
  
 Jeśli katalog opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwy dysków logicznych na tym komputerze w formie "&lt;literę&gt;:\\".</summary>
        <returns>Dyski logiczne na tym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives zwraca wszystkie dostępne dyski na danym komputerze, w tym stacji dyskietek i wszystkie stacje dysków optycznych.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetLogicalDrives%2A> metodę, aby przypisać nazwę każdego dysku, na komputerze wywoływania na tablicę ciągów. Każdy członek tej tablicy ciągów jest następnie drukowane w konsoli. Przykład został skonfigurowany do błędów catch, wszystkie wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy (na przykład awaria dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">wywoływanie niezarządzanego kodu, takich jak wywoływanie kodu natywnego za pomocą funkcji PInvoke lub COM interop. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, dla którego można pobrać katalogu nadrzędnego.</param>
        <summary>Pobiera katalog nadrzędny określona ścieżka, w tym ścieżki względne i bezwzględne.</summary>
        <returns>Katalogu nadrzędnego lub <see langword="null" /> Jeśli <paramref name="path" /> to katalog główny, w tym katalogu głównego nazwę serwera lub udziału UNC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametru można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed przejściem do katalogu.  
  
 Ciąg zwracany przez tę metodę zawiera wszystkie znaki w ścieżce aż do, ale nie w tym, ostatni <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>. Na przykład, przekazując ścieżkę "C:\Directory\SubDirectory\test.txt" do <xref:System.IO.Directory.GetParent%2A> zwraca "C:\Directory\SubDirectory". Przekazywanie "C:\Directory\SubDirectory" zwraca "C:\Directory". Jednakże, przekazując "C:\Directory\SubDirectory\\" zwraca wartość "C:\Directory\SubDirectory", ponieważ końcowy separator katalogu jest po "Podkatalogu".  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.IO.Directory.GetParent%2A> metoda pobierania katalogu nadrzędnego w lokalizacji określonej przez użytkownika "path". Wartość zwrócona przez obiekt <xref:System.IO.Directory.GetParent%2A> metoda następnie drukowane w konsoli. Przykład został skonfigurowany do błędów catch, wszystkie wspólne dla tej metody.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest tylko do odczytu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Aby uzyskać więcej informacji, zobacz <see cref="T:System.IO.PathTooLongException" /> tematu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można odnaleźć określonej ścieżki.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Tylko platforma .NET framework: Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">podczas odczytu z plików lub katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Ścieżka pliku lub katalogu, aby przenieść.</param>
        <param name="destDirName">Ścieżka do nowej lokalizacji dla <paramref name="sourceDirName" />. Jeśli <paramref name="sourceDirName" /> jest plikiem, następnie <paramref name="destDirName" /> również musi być nazwą pliku.</param>
        <summary>Przenosi plik lub katalog i jego zawartość do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy katalog o nazwie określonej przez `destDirName` i przenosi zawartość `sourceDirName` do katalogu docelowego nowo utworzony. Jeśli zostanie podjęta próba przeniesienia katalogu do katalogu, który już istnieje, <xref:System.IO.IOException> zostanie przeprowadzona. Na przykład wyjątek wystąpi, Jeśli spróbujesz przenieść c:\mydir c:\public i c:\public już istnieje. Alternatywnie, można określić "c:\\\public\\\mydir" jako `destDirName` parametru, pod warunkiem, że "mydir" nie istnieje w obszarze "c:\\\public", lub określ nową nazwę katalogu, takie jak "c:\\\newdir".  
  
 `sourceDirName` i `destDirName` argumenty są dozwolone, aby określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końca parametry ścieżki przed skierowaniem ich do katalogu.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można przenieść katalogu i wszystkich jego plików do nowego katalogu. Oryginalny katalog już nie istnieje, po jego przeniesieniu.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nastąpiła próba można przenieść katalogu do innego woluminu.  
  
—lub— 
 <paramref name="destDirName" /> już istnieje.  
  
—lub— 
<paramref name="sourceDirName" /> i <paramref name="destDirName" /> parametry odnoszą się do tego samego pliku lub katalogu.  
  
—lub— 
Katalog lub plik jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> lub <paramref name="destDirName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirName" /> lub <paramref name="destDirName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona przez plik <paramref name="sourceDirName" /> jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">podczas odczytu z <paramref name="sourceDirName" /> i zapisywanie <paramref name="sourceDirName" /> i <paramref name="destDirName" />. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Dodawanie lub usuwanie pozycji listy (ACL) kontroli dostępu z katalogu.</param>
        <param name="directorySecurity">A <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który opisuje wpisu listy ACL dotyczą katalog opisanego przez <paramref name="path" /> parametru.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu w określonym katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.SetAccessControl%2A> Metodę stosuje się wpisy listę kontroli dostępu (ACL) kontroli dostępu do pliku, który reprezentuje noninherited listy ACL.  
  
> [!CAUTION]
>  Listy ACL określonych dla `directorySecurity` parametr zastępuje istniejące listy ACL dla katalogu. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.Directory.GetAccessControl%2A> metodę, aby uzyskać istniejącej listy ACL i zmodyfikuj go.  
  
 Listy ACL w tym artykule opisano użytkowników indywidualnych i/lub grupy, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 <xref:System.IO.Directory.SetAccessControl%2A> Metody tylko będzie się powtarzał <xref:System.Security.AccessControl.DirectorySecurity> obiekty, które zostały zmodyfikowane po utworzeniu obiektu.  Jeśli <xref:System.Security.AccessControl.DirectorySecurity> obiekt nie został zmodyfikowany, go nie zostaną utrwalone w pliku.  W związku z tym, nie jest możliwe do pobrania <xref:System.Security.AccessControl.DirectorySecurity> obiektu z jednego pliku i ponowne zastosowanie tego samego obiektu do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do drugiego:  
  
1.  Użyj <xref:System.IO.Directory.GetAccessControl%2A> metodę, która pobierze <xref:System.Security.AccessControl.DirectorySecurity> obiektu z pliku źródłowego.  
  
2.  Utwórz nową <xref:System.Security.AccessControl.DirectorySecurity> obiektu dla pliku docelowego.  
  
3.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metoda źródła <xref:System.Security.AccessControl.DirectorySecurity> obiektu można pobrać informacji o listy ACL.  
  
4.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodę, aby skopiować informacje o pobranego w kroku 3 do miejsca docelowego <xref:System.Security.AccessControl.DirectorySecurity> obiektu.  
  
5.  Skonfiguruj docelowego <xref:System.Security.AccessControl.DirectorySecurity> obiektu za pomocą pliku docelowego <xref:System.IO.Directory.SetAccessControl%2A> metody.  
  
 W środowiskach systemu plików NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> przyznane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> praw w folderze nadrzędnym. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w katalogu nadrzędnym.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.Directory.GetAccessControl%2A> i <xref:System.IO.Directory.SetAccessControl%2A> metody, aby dodać dostęp kontrolować wpis na liście (ACL), a następnie usuń wpis listy ACL, z katalogu.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="directorySecurity" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można odnaleźć katalogu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Był nieprawidłowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do katalogu określonego przez <paramref name="path" />.  
  
—lub— 
Bieżący proces nie ma wystarczających uprawnień, aby ustawić wpisu na liście ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Akcja zabezpieczeń: Żądanie.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można ustawić informacji daty i godziny tworzenia.</param>
        <param name="creationTime">Data i czas pliku lub katalogu ostatniej zostały zapisane. Ta wartość jest wyrażone według czasu lokalnego.</param>
        <summary>Ustawia datę i godzinę utworzenia określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można ustawić informacji daty i godziny tworzenia.</param>
        <param name="creationTimeUtc">Data i godzina katalog lub plik został utworzony. Ta wartość jest wyrażone według czasu lokalnego.</param>
        <summary>Ustawia datę i godzinę utworzenia, w formacie uniwersalnego czasu koordynowanego (UTC), dla określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Windows NT lub nowszego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, do którego bieżący katalog roboczy jest ustawiony.</param>
        <summary>Ustawia bieżący katalog roboczy aplikacji w określonym katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu działania aplikacji, katalog roboczy zostanie przywrócony do jego oryginalnej lokalizacji (katalog, w którym proces został uruchomiony).  
  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końcem `path` parametru przed ustawieniem katalogu.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Po ustawieniu katalogu na dysku nośnika wymiennego (na przykład "E:" jak dysk flash USB), który można określić, czy stacja jest gotowa, za pomocą <xref:System.IO.DriveInfo.IsReady%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład ilustruje jak ustawienie bieżącego katalogu i wyświetlić katalog główny.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień do dostępu do kodu niezarządzanego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonej ścieżki.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie znaleziono określonego katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania plików lub katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ustawienia dostępu do informacji daty i godziny.</param>
        <param name="lastAccessTime">Obiekt zawierający wartości do ustawienia dostępu Data i godzina <paramref name="path" />. Ta wartość jest wyrażone według czasu lokalnego.</param>
        <summary>Ustawia datę i godzinę, określonego pliku lub katalogu nastąpił ostatni dostęp do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ustawienia dostępu do informacji daty i godziny.</param>
        <param name="lastAccessTimeUtc">Obiekt zawierający wartości do ustawienia dostępu Data i godzina <paramref name="path" />. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), na ostatnio używane określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <param name="lastWriteTime">Data i godzina ostatniego zapisania katalogu do. Ta wartość jest wyrażone według czasu lokalnego.</param>
        <summary>Ustawia datę i godzinę ostatniego zapisania do katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> Nie znaleziono (na przykład katalog nie istnieje lub znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> Nie znaleziono (na przykład katalog nie istnieje lub znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <param name="lastWriteTimeUtc">Data i godzina ostatniego zapisania katalogu do. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę, w formacie uniwersalnego czasu koordynowanego (UTC), który ostatnio zapisano katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr ma uprawnienie do określania informacji o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych w przypadku korzystania z danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> Nie znaleziono (na przykład katalog nie istnieje lub znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> Nie znaleziono (na przykład katalog nie istnieje lub znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można tworzyć zapytania nieprawidłowych znaków z <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Windows NT lub nowszego.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania określonego pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>
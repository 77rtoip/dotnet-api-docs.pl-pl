<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="42da812b1eb64e6c51edd7e20c24e194720a123a" /><Meta Name="ms.sourcegitcommit" Value="a6bdadf68af7570526dd3786974e45698b0d8a49" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/14/2019" /><Meta Name="ms.locfileid" Value="69013138" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia statyczne metody tworzenia, przechodzenia i wyliczania katalogów i podkatalogów. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory> Użyj klasy dla typowych operacji, takich jak kopiowanie, przesuwanie, zmiana nazwy, tworzenie i Usuwanie katalogów.  
  
-   Aby utworzyć katalog, użyj jednej z <xref:System.IO.Directory.CreateDirectory%2A> metod.  
  
-   Aby usunąć katalog, użyj jednej z <xref:System.IO.Directory.Delete%2A> metod.  
  
-   Aby pobrać lub ustawić bieżący katalog dla aplikacji, użyj <xref:System.IO.Directory.GetCurrentDirectory%2A> metody lub. <xref:System.IO.Directory.SetCurrentDirectory%2A>  
  
-   Aby manipulować <xref:System.DateTime> informacjami związanymi z tworzeniem, dostępem i zapisywaniem katalogu, użyj metod, takich jak <xref:System.IO.Directory.SetLastAccessTime%2A> i <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Statyczne metody <xref:System.IO.Directory> klasy sprawdzają zabezpieczenia wszystkich metod. Jeśli chcesz ponownie użyć obiektu kilka razy, rozważ użycie odpowiedniej metody <xref:System.IO.DirectoryInfo> wystąpienia zamiast tego, ponieważ sprawdzanie zabezpieczeń nie zawsze jest konieczne.  
  
 Jeśli wykonujesz tylko jedną akcję powiązaną z katalogiem, może być bardziej wydajne użycie metody statycznej <xref:System.IO.Directory> zamiast odpowiedniej <xref:System.IO.DirectoryInfo> metody wystąpienia. Większość <xref:System.IO.Directory> metod wymaga ścieżki do katalogu, który jest manipulowany.  
  
> [!NOTE]
>  W elementach członkowskich, które `path` akceptują parametr ciągu, ta ścieżka musi być poprawnie sformułowana lub występuje wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale zaczyna się spacją ("c:\Temp"), ciąg ścieżki nie jest przycięty, dlatego ścieżka jest uznawana za wadliwą i występuje wyjątek. Ponadto ścieżka lub kombinacja ścieżek nie mogą być w pełni kwalifikowane dwukrotnie. Na przykład "c:\Temp c:\Windows" wywołuje również wyjątek. Upewnij się, że ścieżki są poprawnie sformułowane podczas korzystania z metod, które akceptują ciąg ścieżki. Aby uzyskać więcej informacji <xref:System.IO.Path>, zobacz.  
  
 W elementach członkowskich, które akceptują ścieżkę, ścieżka może odwoływać się do pliku lub katalogu. Dla nazwy serwera i udziału można użyć pełnej ścieżki, ścieżki względnej lub ścieżki Universal Naming Convention (UNC). Na przykład wszystkie następujące są dopuszczalne ścieżki:  
  
-   "c:\\\mydir" in C#lub "c:\mydir" w Visual Basic.  
  
-   "Mydir\\\MySubdir" in C#lub "MyDir\MySubDir" w Visual Basic.  
  
-   "\\\\ C#\MyServer \MyShare" in lub"\\\MyServer\MyShare" w Visual Basic.\\\\  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych katalogów jest udzielany wszystkim użytkownikom. Jednak aplikacja musi mieć odpowiednie zabezpieczenia, aby uzyskać dostęp do istniejących katalogów.  
  
 Aby na żądanie uzyskać uprawnienia do katalogu i wszystkich jego podkatalogów, należy zakończyć ciąg ścieżki znakiem separatora katalogu. (Na przykład "C:\Temp\\" udziela dostępu do lokalizacji c:\Temp\ i wszystkich jego podkatalogów). Aby zażądać uprawnień tylko do określonego katalogu, Zakończ ciąg ścieżki kropką. (Na przykład "C:\Temp\\". przyznaje dostęp tylko do\\C:\Temp, nie do jego podkatalogów.  
  
 W elementach członkowskich, `searchPattern` które akceptują parametr, ciąg wyszukiwania może być dowolną kombinacją znaków literału i dwóch symboli wieloznacznych; \* i?. Ten parametr nie rozpoznaje wyrażeń regularnych. Aby uzyskać więcej informacji, zobacz <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> metodę lub inną metodę `searchPattern` korzystającą z parametru.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory>i <xref:System.IO.DirectoryInfo> nie są obsługiwane w [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplikacjach. Aby uzyskać informacje na temat uzyskiwania dostępu do plików i [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] folderów w aplikacjach, zobacz [dostęp do danych i plików (aplikacje ze sklepu Windows)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wszystkie pliki tekstowe z katalogu i przenieść je do nowego katalogu. Po przeniesieniu plików nie znajdują się one już w oryginalnym katalogu.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 W poniższym przykładzie pokazano, jak użyć <xref:System.IO.Directory.EnumerateFiles%2A> metody do pobrania kolekcji plików tekstowych z katalogu, a następnie użyć tej kolekcji w zapytaniu, aby znaleźć wszystkie wiersze, które zawierają "przykład".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 W poniższym przykładzie pokazano, jak przenieść katalog i wszystkie jego pliki do nowego katalogu. Po przeniesieniu oryginalny katalog już nie istnieje.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy wszystkie katalogi w określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog, który ma zostać utworzony.</param>
        <summary>Tworzy wszystkie katalogi i podkatalogi w określonej ścieżce, chyba że już istnieją.</summary>
        <returns>Obiekt, który reprezentuje katalog w określonej ścieżce. Ten obiekt jest zwracany bez względu na to, czy katalog w określonej ścieżce już istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w programie `path` są tworzone, chyba że już istnieją lub część z `path` nich nie jest nieprawidłowa. Jeśli katalog już istnieje, ta metoda nie tworzy nowego katalogu, ale zwraca <xref:System.IO.DirectoryInfo> obiekt dla istniejącego katalogu.  
  
 `path` Parametr określa ścieżkę katalogu, a nie ścieżkę pliku.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed utworzeniem katalogu.  
  
 Katalog na komputerze zdalnym można utworzyć na udziale, do którego masz uprawnienia do zapisu. Obsługiwane są ścieżki UNC; na przykład można określić następujące elementy `path`dla: `\\2009\Archives\December` w Visual Basic i `\\\\2009\\Archives\\December` w. C#  
  
 Tworzenie katalogu tylko z dwukropkiem (:) nie jest obsługiwana i spowoduje, że `NotSupportedException` zostanie zgłoszony.  
  
   
  
## Examples  
 Poniższy przykład tworzy i usuwa określony katalog.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Aby utworzyć katalog C:\Users\User1\Public\Html, gdy bieżący katalog jest C:\Users\User1, użyj dowolnego z następujących wywołań, aby upewnić się, że ukośnik odwrotny jest poprawnie interpretowany.  
  
 W Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 W języku C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 W C++programie:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> to plik.  
  
—lub— 
Nazwa sieci jest nieznana.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />jest poprzedzony znakiem lub zawierającym tylko dwukropek (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera dwukropek (:) to nie jest część etykiety dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu i zapisu plików lub katalogów. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Katalog, który ma zostać utworzony.</param>
        <param name="directorySecurity">Kontrola dostępu, która ma zostać zastosowana do katalogu.</param>
        <summary>Tworzy wszystkie katalogi w określonej ścieżce, chyba że już istnieją, stosując określone zabezpieczenia systemu Windows.</summary>
        <returns>Obiekt, który reprezentuje katalog w określonej ścieżce. Ten obiekt jest zwracany bez względu na to, czy katalog w określonej ścieżce już istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody, aby utworzyć katalog z kontrolą dostępu, więc nie ma możliwości dostępu do katalogu przed zastosowaniem zabezpieczeń.  
  
 Wszystkie katalogi określone w `path` parametrze są tworzone, chyba że już istnieją lub część z `path` nich nie jest nieprawidłowa. `path` Parametr określa ścieżkę katalogu, a nie ścieżkę pliku. Jeśli katalog już istnieje, ta metoda nie tworzy nowego katalogu, ale zwraca <xref:System.IO.DirectoryInfo> obiekt dla istniejącego katalogu.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed utworzeniem katalogu.  
  
 Katalog na komputerze zdalnym można utworzyć na udziale, do którego masz uprawnienia do zapisu. Obsługiwane są ścieżki UNC; na przykład można określić następujące elementy `path`dla: `\\2009\Archives\December` w Visual Basic i `\\\\2009\\Archives\\December` w. C#  
  
 Tworzenie katalogu tylko z dwukropkiem (:) nie jest obsługiwana i powoduje, `NotSupportedException` że jest zgłaszany.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy katalog z regułami dostępu dla dwóch kont użytkowników.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> to plik.  
  
—lub— 
Nazwa sieci jest nieznana.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="path" />jest poprzedzony znakiem lub zawierającym tylko dwukropek (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera dwukropek (:) to nie jest część etykiety dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików i katalogów oraz do uzyskiwania dostępu do katalogu docelowego. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> Akcja zabezpieczeń:<see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony katalog i opcjonalnie wszystkie podkatalogi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pustego katalogu do usunięcia. Ten katalog musi być zapisywalny i pusty.</param>
        <summary>Usuwa pusty katalog z określonej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zachowuje się identycznie <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> z `false` określoną dla drugiego parametru.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed usunięciem katalogu.  
  
 Ta metoda zgłasza <xref:System.IO.IOException> , jeśli katalog określony `path` w parametrze zawiera pliki lub podkatalogi.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 W niektórych przypadkach, jeśli w Eksploratorze plików jest otwarty określony katalog, <xref:System.IO.Directory.Delete%2A> Metoda może nie być w stanie jej usunąć.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowy katalog i podkatalog, a następnie usunąć tylko podkatalog.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik o tej samej nazwie i lokalizacji określony przez <paramref name="path" /> istnieje.  
  
—lub— 
Katalog jest bieżącym katalogiem roboczym aplikacji.  
  
—lub— 
Katalog określony przez <paramref name="path" /> nie jest pusty.  
  
—lub— 
Katalog jest tylko do odczytu lub zawiera plik tylko do odczytu.  
  
—lub— 
Katalog jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />nie istnieje lub nie można go znaleźć.  
  
—lub— 
Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa katalogu do usunięcia.</param>
        <param name="recursive"><see langword="true" />do usuwania katalogów, podkatalogów i plików w <paramref name="path" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Usuwa określony katalog i, jeśli to wskazane, wszystkie podkatalogi i pliki w katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed usunięciem katalogu.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Jeśli parametr ma `true`wartość, użytkownik musi mieć uprawnienia do zapisu w bieżącym katalogu, a także dla wszystkich podkatalogów. `recursive`  
  
 Zachowanie tej metody różni się nieco w przypadku usuwania katalogu, który zawiera punkt ponownej analizy, takiego jak link symboliczny lub punkt instalacji. Jeśli punkt ponownej analizy jest katalogiem, takim jak punkt instalacji, jest odinstalowywany, a punkt instalacji zostaje usunięty. Ta metoda nie powtarza się za pomocą punktu ponownej analizy. Jeśli punkt ponownej analizy jest linkiem symbolicznym do pliku, punkt ponownej analizy jest usuwany, a nie obiektem docelowym linku symbolicznego.  
  
 W niektórych przypadkach, jeśli w Eksploratorze plików jest otwarty określony katalog, <xref:System.IO.Directory.Delete%2A> Metoda może nie być w stanie jej usunąć.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowy katalog, podkatalog i plik w podkatalogu, a następnie rekursywnie usunąć wszystkie nowe elementy.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik o tej samej nazwie i lokalizacji określony przez <paramref name="path" /> istnieje.  
  
—lub— 
Katalog określony przez <paramref name="path" /> jest tylko do odczytu lub <paramref name="recursive" /> jest <see langword="false" /> i <paramref name="path" /> nie jest pustym katalogiem.  
  
—lub— 
Katalog jest bieżącym katalogiem roboczym aplikacji.  
  
—lub— 
Katalog zawiera plik tylko do odczytu.  
  
—lub— 
Katalog jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />nie istnieje lub nie można go znaleźć.  
  
—lub— 
Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalną kolekcję nazw katalogów spełniających określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalną kolekcję nazw katalogów w określonej ścieżce.</summary>
        <returns>Wyliczalna kolekcja pełnych nazw (w tym ścieżki) dla katalogów w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W `path` parametrze można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody. Zwrócone nazwy katalogów są poprzedzone wartością podaną w `path` parametrze. Na przykład w przypadku podania ścieżki względnej w `path` parametrze zwrócone nazwy katalogów będą zawierać ścieżkę względną.  
  
 Metody <xref:System.IO.Directory.EnumerateDirectories%2A> i<xref:System.IO.Directory.GetDirectories%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetDirectories%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateDirectories%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi najwyższego poziomu w określonej ścieżce.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca wyliczalną kolekcję nazw katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalna kolekcja pełnych nazw (w tym ścieżki) dla katalogów w katalogu określonym przez <paramref name="path" /> i, które pasują do określonego wzorca wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 W `path` parametrze można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody. Zwrócone nazwy katalogów są poprzedzone wartością podaną w `path` parametrze. Na przykład w przypadku podania ścieżki względnej w `path` parametrze zwrócone nazwy katalogów będą zawierać ścieżkę względną.  
  
 Metody <xref:System.IO.Directory.EnumerateDirectories%2A> i<xref:System.IO.Directory.GetDirectories%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetDirectories%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateDirectories%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi najwyższego poziomu w określonej ścieżce, które pasują do określonego wzorca wyszukiwania.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna zawierać tylko bieżący katalog, czy też powinna zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca wyliczalną kolekcję nazw katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce i opcjonalnie przeszukują podkatalogi.</summary>
        <returns>Wyliczalna kolekcja pełnych nazw (w tym ścieżki) dla katalogów w katalogu określonym przez <paramref name="path" /> i, które pasują do określonego wzorca wyszukiwania i opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Dokładnie jeden znak w tej pozycji.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 W `path` parametrze można określić informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody. Zwrócone nazwy katalogów są poprzedzone wartością podaną w `path` parametrze. Na przykład w przypadku podania ścieżki względnej w `path` parametrze zwrócone nazwy katalogów będą zawierać ścieżkę względną.  
  
 Metody <xref:System.IO.Directory.EnumerateDirectories%2A> i<xref:System.IO.Directory.GetDirectories%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetDirectories%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateDirectories%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza katalogi w określonej ścieżce, które pasują do określonego wzorca wyszukiwania. Używa `searchOption` parametru, aby określić, że wszystkie podkatalogi powinny być uwzględnione w wyszukiwaniu.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalną kolekcję nazw plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalną kolekcję nazw plików w określonej ścieżce.</summary>
        <returns>Wyliczalna kolekcja pełnych nazw (w tym ścieżki) dla plików w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 Metody <xref:System.IO.Directory.EnumerateFiles%2A> i<xref:System.IO.Directory.GetFiles%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFiles%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFiles%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wszystkie pliki w katalogu i przenieść je do nowego katalogu. Po przeniesieniu plików nie znajdują się one już w oryginalnym katalogu.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 Poniższy przykład wylicza pliki w określonym katalogu, odczytuje każdy wiersz pliku i wyświetla wiersz, jeśli zawiera ciąg "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca wyliczalną kolekcję nazw plików, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalna kolekcja pełnych nazw (w tym ścieżki) dla plików w katalogu określonym przez <paramref name="path" /> i, które pasują do określonego wzorca wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 Metody <xref:System.IO.Directory.EnumerateFiles%2A> i<xref:System.IO.Directory.GetFiles%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFiles%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFiles%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wszystkie pliki tekstowe w katalogu i przenieść je do nowego katalogu. Po przeniesieniu plików nie znajdują się one już w oryginalnym katalogu.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Poniższy przykład wylicza pliki w określonym katalogu, który ma rozszerzenie. txt, odczytuje każdy wiersz pliku i wyświetla wiersz, jeśli zawiera ciąg "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna zawierać tylko bieżący katalog, czy też powinna zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca wyliczalną kolekcję nazw plików, które pasują do wzorca wyszukiwania w określonej ścieżce i opcjonalnie przeszukują podkatalogi.</summary>
        <returns>Wyliczalna kolekcja pełnych nazw (w tym ścieżki) dla plików w katalogu określonym przez <paramref name="path" /> i, które pasują do określonego wzorca wyszukiwania i opcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 Metody <xref:System.IO.Directory.EnumerateFiles%2A> i<xref:System.IO.Directory.GetFiles%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFiles%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFiles%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać wszystkie pliki tekstowe w katalogu i jego podkatalogach i przenieść je do nowego katalogu. Po przeniesieniu plików nie znajdują się one już w oryginalnych katalogach.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Poniższy przykład rekursywnie wylicza wszystkie pliki z rozszerzeniem. txt, odczytuje każdy wiersz pliku i wyświetla wiersz, jeśli zawiera ciąg "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalną kolekcję wpisów systemu plików, które spełniają określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca wyliczalną kolekcję nazw plików i nazw katalogów w określonej ścieżce.</summary>
        <returns>Wyliczalna kolekcja wpisów systemu plików w katalogu określonym przez <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 Metody <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i<xref:System.IO.Directory.GetFileSystemEntries%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFileSystemEntries%2A>programu ,możnarozpocząćwyliczaniekolekcjiwpisówprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałatablicawpisówzostaniezwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw wpisów systemu plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca wyliczalną kolekcję nazw plików i nazw katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Wyliczalna kolekcja wpisów systemu plików w katalogu określonym przez <paramref name="path" /> i zgodna z określonym wzorcem wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`. 
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 Metody <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i<xref:System.IO.Directory.GetFileSystemEntries%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFileSystemEntries%2A>programu ,możnarozpocząćwyliczaniekolekcjiwpisówprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałatablicawpisówzostaniezwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania względem wpisów systemu plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna zawierać tylko bieżący katalog, czy też powinna zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca wyliczalną kolekcję nazw plików i nazw katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce i opcjonalnie przeszukują podkatalogi.</summary>
        <returns>Wyliczalna kolekcja wpisów systemu plików w katalogu określonym przez <paramref name="path" /> i zgodna z określonym wzorcem wyszukiwania i opcją.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 Metody <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i<xref:System.IO.Directory.GetFileSystemEntries%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFileSystemEntries%2A>programu ,możnarozpocząćwyliczaniekolekcjiwpisówprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałatablicawpisówzostaniezwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> w kolekcji zacznie nowe Wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do przetestowania.</param>
        <summary>Określa, czy dana ścieżka odwołuje się do istniejącego katalogu na dysku.</summary>
        <returns><see langword="true" />Jeśli <paramref name="path" /> odwołuje się do istniejącego katalogu; <see langword="false" /> Jeśli katalog nie istnieje lub wystąpi błąd podczas próby ustalenia, czy określony katalog istnieje.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed sprawdzeniem, czy katalog istnieje.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Jeśli nie masz co najmniej uprawnienia tylko do odczytu do katalogu, Metoda <xref:System.IO.Directory.Exists%2A> `false`zwróci wartość.  
  
 <xref:System.IO.Directory.Exists%2A> Metoda zwraca`false` Jeśli wystąpi błąd podczas próby ustalenia, czy określony plik istnieje. Może się to zdarzyć w sytuacjach, w których są wywoływane wyjątki, takie jak przekazywanie nazwy pliku z nieprawidłowymi znakami lub zbyt wiele znaków, Niepowodzenie lub brak dysku lub jeśli obiekt wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę nazw plików lub katalogów w wierszu polecenia, określa rodzaj nazwy, a także przetwarza odpowiednie.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca listę kontroli dostępu (ACL) systemu Windows dla katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do katalogu zawierającego <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt opisujący informacje na temat listy kontroli dostępu (ACL) pliku.</param>
        <summary><see cref="T:System.Security.AccessControl.DirectorySecurity" /> Pobiera obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla określonego katalogu.</summary>
        <returns>Obiekt, który hermetyzuje reguły kontroli dostępu dla pliku opisanego przez <paramref name="path" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy kontroli dostępu (ACL) dla katalogu.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych akcji dotyczących danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 W środowiskach NTFS i <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przyznawane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia do folderu nadrzędnego. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>odmówić w katalogu nadrzędnym.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.Directory.GetAccessControl%2A> metody i <xref:System.IO.Directory.SetAccessControl%2A> , aby dodać wpis listy kontroli dostępu (ACL), a następnie usunąć wpis listy ACL z katalogu.  Aby uruchomić ten przykład, należy podać prawidłowe konto użytkownika lub grupy.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows 2000 lub nowszym.</exception>
        <exception cref="T:System.SystemException">Wystąpił błąd na poziomie systemu, na przykład nie można znaleźć katalogu. Konkretny wyjątek może być podklasą klasy <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa katalog, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do wyliczania listy kontroli dostępu (ACL) dla katalogu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Akcja zabezpieczeń: Podaż.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do katalogu zawierającego <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt opisujący informacje na temat listy kontroli dostępu (ACL) pliku.</param>
        <param name="includeSections">Jedna z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, która określa typ informacji listy kontroli dostępu (ACL) do odbierania.</param>
        <summary><see cref="T:System.Security.AccessControl.DirectorySecurity" /> Pobiera obiekt, który hermetyzuje określony typ wpisów listy kontroli dostępu (ACL) dla określonego katalogu.</summary>
        <returns>Obiekt, który hermetyzuje reguły kontroli dostępu dla pliku opisanego przez <paramref name="path" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy kontroli dostępu (ACL) dla katalogu.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych akcji dotyczących danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 W środowiskach NTFS i <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przyznawane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia do folderu nadrzędnego. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>odmówić w katalogu nadrzędnym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows 2000 lub nowszym.</exception>
        <exception cref="T:System.SystemException">Wystąpił błąd na poziomie systemu, na przykład nie można znaleźć katalogu. Konkretny wyjątek może być podklasą klasy <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa katalog, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do wyliczania listy kontroli dostępu (ACL) dla katalogu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Akcja zabezpieczeń: Podaż.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <summary>Pobiera datę i godzinę utworzenia katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę utworzenia określonego katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Ta metoda jest równoważna <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>z.  
  
 Jeśli katalog opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowany do czasu lokalnego.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera czas utworzenia określonego katalogu.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <summary>Pobiera datę i godzinę utworzenia w formacie uniwersalnego czasu koordynowanego (UTC) katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę utworzenia określonego katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli katalog opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Użyj tej metody, aby uzyskać czas tworzenia dla katalogu na podstawie uniwersalnego czasu koordynowanego (UTC).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych przy użyciu danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera bieżący katalog roboczy aplikacji.</summary>
        <returns>Ciąg, który zawiera ścieżkę bezwzględną bieżącego katalogu roboczego i nie kończy się ukośnikiem odwrotnym (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący katalog jest odrębny od oryginalnego katalogu, który jest tym, z którego proces został uruchomiony.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania `GetCurrentDirectory` metody.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">System operacyjny jest Windows CE, który nie ma bieżącej funkcjonalności katalogu.  
  
 Ta metoda jest dostępna w .NET Compact Framework, ale nie jest obecnie obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy podkatalogów spełniających określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy podkatalogów (łącznie z ich ścieżkami) w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) podkatalogów w określonej ścieżce lub pustej tablicy, jeśli nie odnaleziono katalogów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest identyczna <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> z gwiazdką (\*) określoną jako wzorzec wyszukiwania, dlatego zwraca wszystkie podkatalogi. Jeśli konieczne jest przeszukanie podkatalogów, użyj <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> metody, która umożliwia określenie przeszukiwania podkatalogów `searchOption` z parametrem.  
  
 Metody <xref:System.IO.Directory.EnumerateDirectories%2A> i<xref:System.IO.Directory.GetDirectories%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetDirectories%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateDirectories%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nazwy zwracane przez tę metodę są poprzedzone informacjami katalogowymi podanymi w `path`temacie.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pobiera tablicę nazw plików lub katalogów w wierszu polecenia, określa rodzaj nazwy, a także przetwarza odpowiednie.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do uzyskiwania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw podkatalogów w <paramref name="path" />. Ten parametr może zawierać kombinację prawidłowych znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca nazwy podkatalogów (w tym ich ścieżki), które pasują do określonego wzorca wyszukiwania w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (łącznie z ścieżkami) podkatalogów, które pasują do wzorca wyszukiwania w określonym katalogu, lub pustą tablicę, jeśli nie odnaleziono katalogów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca wszystkie podkatalogi bezpośrednio w określonym katalogu, które pasują do określonego wzorca wyszukiwania. Jeśli określony katalog nie zawiera podkatalogów lub żadne podkatalogi nie odpowiadają `searchPattern` parametrowi, ta metoda zwraca pustą tablicę. Przeszukiwany jest tylko górny katalog. Jeśli chcesz wyszukać również podkatalogi, użyj <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> metody i określ <xref:System.IO.SearchOption.AllDirectories> `searchOption` parametr.  
  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej i nie uwzględnia wielkości liter.  Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Metody <xref:System.IO.Directory.EnumerateDirectories%2A> i<xref:System.IO.Directory.GetDirectories%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetDirectories%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateDirectories%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie liczba katalogów w ścieżce rozpoczyna się od określonej litery.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą polecenia <see cref="M:System.IO.Path.GetInvalidPathChars" />można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw podkatalogów w <paramref name="path" />. Ten parametr może zawierać kombinację prawidłowych znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować wszystkie podkatalogi, czy tylko bieżący katalog.</param>
        <summary>Zwraca nazwy podkatalogów (w tym ich ścieżki), które pasują do określonego wzorca wyszukiwania w określonym katalogu, i opcjonalnie przeszukuje podkatalogi.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) podkatalogów spełniających określone kryteria lub pusta tablica, jeśli nie odnaleziono katalogów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej i nie uwzględnia wielkości liter. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
 Metody <xref:System.IO.Directory.EnumerateDirectories%2A> i<xref:System.IO.Directory.GetDirectories%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetDirectories%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateDirectories%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie liczba katalogów, które zaczynają się od określonej litery w ścieżce. Przeszukiwany jest tylko katalog najwyższego poziomu.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub katalogu.</param>
        <summary>Zwraca informacje o woluminie, informacje główne lub oba dla określonej ścieżki.</summary>
        <returns>Ciąg zawierający informacje o woluminie, informacje główne lub oba dla określonej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda uzyskuje w pełni kwalifikowaną nazwę `path`ścieżki, w postaci zwróconej przez <xref:System.IO.Path.GetFullPath%2A>, i zwraca informacje o katalogu głównym. Określona ścieżka nie musi istnieć.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób ustawiania bieżącego katalogu i wyświetlania katalogu głównego katalogu.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wykonać zapytanie o nieprawidłowe znaki w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy plików spełniających określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżki) w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) dla plików w określonym katalogu lub pustej tablicy, jeśli nie znaleziono plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.Directory.EnumerateFiles%2A> i<xref:System.IO.Directory.GetFiles%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFiles%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFiles%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Zwrócone nazwy plików są dołączane do podanego `path` parametru.  
  
 Ta metoda jest identyczna <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> z gwiazdką (\*) określoną jako wzorzec wyszukiwania.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Kolejność zwróconych nazw plików nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.IO.Directory.GetFiles%2A> metody do zwracania nazw plików z lokalizacji określonej przez użytkownika. Przykład jest skonfigurowany do przechwytywania wszystkich błędów wspólnych dla tej metody.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.  
  
—lub— 
Wystąpił błąd sieciowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie odnaleziono określonej ścieżki lub jest ona nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżki), które pasują do określonego wzorca wyszukiwania w określonym katalogu.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) dla plików w określonym katalogu, które pasują do określonego wzorca wyszukiwania lub pustej tablicy, jeśli nie znaleziono plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone nazwy plików są dołączane do podanego `path` parametru, a kolejność zwróconych nazw plików nie jest gwarantowana; Użyj metody, <xref:System.Array.Sort%2A> Jeśli wymagana jest określona kolejność sortowania.  
  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza nazwy plików w formacie nazwy pliku 8,3 i formacie długiej nazwy pliku, wzór wyszukiwania podobny do "\*1\*. txt" może zwracać nieoczekiwane nazwy plików. Na przykład użycie wzorca wyszukiwania "\*1\*. txt" zwraca wartość "LongFileName. txt", ponieważ odpowiednik formatu nazwy pliku 8,3 to "LongFi ~ 1. txt".  
  
 Metody <xref:System.IO.Directory.EnumerateFiles%2A> i<xref:System.IO.Directory.GetFiles%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFiles%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFiles%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie liczba plików rozpoczyna się od określonej litery.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.  
  
—lub— 
Wystąpił błąd sieciowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą polecenia <see cref="M:System.IO.Path.GetInvalidPathChars" />można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie odnaleziono określonej ścieżki lub jest ona nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować wszystkie podkatalogi, czy tylko bieżący katalog.</param>
        <summary>Zwraca nazwy plików (w tym ich ścieżki), które pasują do określonego wzorca wyszukiwania w określonym katalogu, przy użyciu wartości, aby określić, czy przeszukiwać podkatalogi.</summary>
        <returns>Tablica pełnych nazw (w tym ścieżki) dla plików w określonym katalogu, które pasują do określonego wzorca wyszukiwania i opcji, lub pustej tablicy, jeśli nie znaleziono plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone nazwy plików są dołączane do podanego `path` parametru, a kolejność zwróconych nazw plików nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" File*. txt "zwraca oba pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza nazwy plików w formacie nazwy pliku 8,3 i formacie długiej nazwy pliku, wzór wyszukiwania podobny do "\*1\*. txt" może zwracać nieoczekiwane nazwy plików. Na przykład użycie wzorca wyszukiwania "\*1\*. txt" zwraca wartość "LongFileName. txt", ponieważ odpowiednik formatu nazwy pliku 8,3 to "LongFi ~ 1. txt".  
  
 Metody <xref:System.IO.Directory.EnumerateFiles%2A> i<xref:System.IO.Directory.GetFiles%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFiles%2A>programu ,możnarozpocząćwyliczaniekolekcjinazwprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałaTablicanazwmazostaćzwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFiles%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Nazwy plików zawierają pełną ścieżkę.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="searchpattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie odnaleziono określonej ścieżki lub jest ona nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.  
  
—lub— 
Wystąpił błąd sieciowy.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca nazwy wszystkich plików i podkatalogów spełniających określone kryteria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <summary>Zwraca nazwy wszystkich plików i podkatalogów w określonej ścieżce.</summary>
        <returns>Tablica nazw plików i podkatalogów w określonym katalogu lub pusta tablica, jeśli nie znaleziono plików lub podkatalogów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwróconych nazw plików i katalogów nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 Metody <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i<xref:System.IO.Directory.GetFileSystemEntries%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFileSystemEntries%2A>programu ,możnarozpocząćwyliczaniekolekcjiwpisówprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałatablicawpisówzostaniezwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda jest identyczna <xref:System.IO.Directory.GetFileSystemEntries%2A> z gwiazdką (\*) określoną jako wzorzec wyszukiwania.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.Directory.GetFileSystemEntries%2A> metodę, aby wypełnić tablicę ciągów nazwami wszystkich plików i podkatalogów w lokalizacji określonej przez użytkownika i wydrukować każdy ciąg w tablicy do konsoli programu. Przykład jest skonfigurowany do przechwytywania wszystkich błędów wspólnych dla tej metody.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Można wykonać zapytanie o nieprawidłowe znaki w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików i katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca tablicę nazw plików i nazw katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce.</summary>
        <returns>Tablica nazw plików i nazw katalogów, które pasują do określonych kryteriów wyszukiwania lub pustej tablicy, jeśli nie znaleziono plików lub katalogów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwróconych nazw plików i katalogów nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład używa metody, <xref:System.IO.Directory.GetFileSystemEntries%2A> aby wypełnić tablicę ciągów nazwami wszystkich plików zgodnych z filtrem określonym przez użytkownika w określonej lokalizacji i drukuje każdy ciąg w tablicy do konsoli programu. Przykład jest skonfigurowany do przechwytywania wszystkich błędów wspólnych dla tej metody.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do informacji o ścieżce dla bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna lub bezwzględna do katalogu do przeszukania. W tym ciągu nie jest rozróżniana wielkość liter.</param>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików i katalogów w <paramref name="path" />.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna zawierać tylko bieżący katalog, czy też powinna zawierać wszystkie podkatalogi.  
  
Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca tablicę wszystkich nazw plików i katalogów, które pasują do wzorca wyszukiwania w określonej ścieżce i opcjonalnie przeszukują podkatalogi.</summary>
        <returns>Tablica plików nazw plików i katalogów, które pasują do określonych kryteriów wyszukiwania lub pustej tablicy, jeśli nie znaleziono plików lub katalogów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność zwróconych nazw plików i katalogów nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|\*znaku|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład `searchPattern` ciąg "\*t" `path` wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 `searchPattern`nie może kończyć się w dwóch okresach ("..") ani zawierać dwóch kropek (".." <xref:System.IO.Path.DirectorySeparatorChar> ) <xref:System.IO.Path.AltDirectorySeparatorChar>, po których następuje znak lub, ani nie może zawierać żadnych nieprawidłowych znaków. Za pomocą <xref:System.IO.Path.GetInvalidPathChars%2A> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
> [!NOTE]
>  Gdy używasz symbolu wieloznacznego gwiazdki w `searchPattern` taki sposób jak "\*. txt", liczba znaków w określonym rozszerzeniu ma wpływ na wyszukiwanie w następujący sposób:  
>   
> -   Jeśli określone rozszerzenie ma dokładnie trzy znaki, metoda zwraca pliki z rozszerzeniami, które zaczynają się od określonego rozszerzenia. Na przykład "\*xls" zwraca zarówno "Book. xls", jak i "Book. xlsx".  
> -   We wszystkich innych przypadkach Metoda zwraca pliki, które dokładnie pasują do określonego rozszerzenia. Na przykład "\*. AI" zwraca wartość "File.AI", ale nie "File. AIF".  
>   
>  Gdy używasz znaku wieloznacznego znaku zapytania, Metoda ta zwraca tylko pliki zgodne z określonym rozszerzeniem pliku. Na przykład, podaną dwa pliki, "plik1. txt" i "plik1. txtother", w katalogu, wzorzec wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 Metody <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> i<xref:System.IO.Directory.GetFileSystemEntries%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.Directory.GetFileSystemEntries%2A>programu ,możnarozpocząćwyliczaniekolekcjiwpisówprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałatablicawpisówzostaniezwrócona,zanimbędziemożnauzyskać<xref:System.IO.Directory.EnumerateFileSystemEntries%2A>dostęp do tablicy. W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.Directory.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Do `path` parametru można określić informacje o ścieżce względnej. Informacje o ścieżce względnej są interpretowane jako odnoszące się do bieżącego katalogu roboczego, który można <xref:System.IO.Directory.GetCurrentDirectory%2A> określić za pomocą metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.  
  
—lub— 
 <paramref name="searchPattern" />nie zawiera prawidłowego wzorca.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy, na przykład odwołujący się do niemapowanego dysku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" />jest nazwą pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Określona ścieżka, nazwa pliku lub łącznie przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać uzyskany dostęp do informacji o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę ostatniego dostępu do określonego pliku lub katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę ostatniego dostępu do określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Ta metoda jest taka sama <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>jak.  
  
 Jeśli katalog opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowany do czasu lokalnego.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia `GetLastAccessTime`programu.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> Parametr ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać uzyskany dostęp do informacji o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę w formacie uniwersalnego czasu koordynowanego (UTC), do ostatniego dostępu do określonego pliku lub katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę ostatniego dostępu do określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli katalog opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych przy użyciu danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> Parametr ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego mają zostać uzyskane modyfikacje informacje o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę ostatniego zapisu określonego pliku lub katalogu.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę ostatniego zapisu określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli katalog opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowany do czasu lokalnego.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia `GetLastWriteTime`programu.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego mają zostać uzyskane modyfikacje informacje o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę w formacie uniwersalnego czasu koordynowanego (UTC), że określony plik lub katalog został ostatnio zapisany.</summary>
        <returns>Struktura, która jest ustawiona na datę i godzinę ostatniego zapisu określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli katalog opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych przy użyciu danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania określonego pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera nazwy dysków logicznych na tym komputerze w postaci "&lt;litera&gt;dysku:\\".</summary>
        <returns>Dyski logiczne na tym komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives zwraca wszystkie dostępne dyski na konkretnym komputerze, w tym stację dyskietek i wszystkie napędy optyczne.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.Directory.GetLogicalDrives%2A> metodę, aby przypisać nazwę każdego dysku na komputerze wywołującym do tablicy ciągów. Każdy element członkowski tej tablicy ciągów jest następnie drukowany w konsoli programu. Przykład jest skonfigurowany do przechwytywania wszystkich błędów wspólnych dla tej metody.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy (na przykład błąd dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie kodu niezarządzanego, na przykład Wywoływanie kodu natywnego za pomocą funkcji PInvoke lub COM Interop. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, dla której ma zostać pobrany katalog nadrzędny.</param>
        <summary>Pobiera katalog nadrzędny określonej ścieżki, w tym ścieżki absolutne i względne.</summary>
        <returns>Katalog nadrzędny lub <see langword="null" /> , jeśli <paramref name="path" /> jest katalogiem głównym, włącznie z katalogiem głównym serwera lub nazwy udziału.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed pobraniem katalogu.  
  
 Ciąg zwracany przez tę metodę składa się ze wszystkich znaków w ścieżce do, ale nie do, do ostatniego <xref:System.IO.Path.DirectorySeparatorChar> lub. <xref:System.IO.Path.AltDirectorySeparatorChar> Na przykład przekazanie ścieżki "C:\Directory\SubDirectory\test.txt" <xref:System.IO.Directory.GetParent%2A> zwraca wartość "C:\Directory\SubDirectory". Przekazywanie "C:\Directory\SubDirectory" zwraca wartość "C:\Directory". Jednak przekazanie "C:\Directory\SubDirectory\\" zwraca wartość "C:\Directory\SubDirectory", ponieważ końcowym separatorem katalogów jest po "subdirectory".  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak za pomocą <xref:System.IO.Directory.GetParent%2A> metody pobrać katalog nadrzędny lokalizacji określonej przez użytkownika, "Path". Wartość zwracana przez <xref:System.IO.Directory.GetParent%2A> metodę jest następnie drukowana w konsoli programu. Przykład jest skonfigurowany do przechwytywania wszystkich błędów wspólnych dla tej metody.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest tylko do odczytu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Aby uzyskać więcej informacji, zobacz <see cref="T:System.IO.PathTooLongException" /> temat.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Tylko .NET Framework: Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików lub katalogów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Ścieżka pliku lub katalogu, który ma zostać przeniesiony.</param>
        <param name="destDirName">Ścieżka do nowej lokalizacji <paramref name="sourceDirName" />. Jeśli <paramref name="sourceDirName" /> jest plikiem <paramref name="destDirName" /> , należy również być nazwą pliku.</param>
        <summary>Przenosi plik lub katalog wraz z jego zawartością do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowy katalog o nazwie określonej przez `destDirName` i przenosi `sourceDirName` zawartość do nowo utworzonego katalogu docelowego. Jeśli spróbujesz przenieść katalog do katalogu, który już istnieje, <xref:System.IO.IOException> wystąpi błąd. Na przykład wyjątek wystąpi, jeśli próbujesz przenieść c:\mydir do c:\public, a c:\public już istnieje. Alternatywnie można określić wartość "c:\\\public\\\mydir" jako `destDirName` parametr, pod warunkiem, że "Mydir" nie istnieje w obszarze "c\\: \public" lub określić nową nazwę katalogu, taką jak "c:\\\newdir".  
  
 Argumenty `sourceDirName` i`destDirName` mogą określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końca parametrów ścieżki przed przeniesieniem katalogu.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  


> [!NOTE]
>  Począwszy od platformy .NET Core 3,0, `Move` Metoda <xref:System.IO.IOException> zgłasza `destDirName` na wszystkich platformach, gdy już istnieje. W programie .NET Core 2,2 i poprzednich wersjach wyjątek został wygenerowany tylko w systemie Windows, a inne platformy mogą się nie powieść `destDirName`lub zastąpić. Zobacz [ C++ zmiana nazwy](https://linux.die.net/man/2/rename).
   
  
## Examples  
 W poniższym przykładzie pokazano, jak przenieść katalog i wszystkie jego pliki do nowego katalogu. Po przeniesieniu oryginalny katalog już nie istnieje.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podjęto próbę przeniesienia katalogu do innego woluminu.
  
—lub— 
 <paramref name="destDirName" />już istnieje. Zapoznaj się z uwagą w sekcji uwagi.
  
—lub— 
Parametry <paramref name="sourceDirName" /> i<paramref name="destDirName" /> odwołują się do tego samego pliku lub katalogu.  
  
—lub— 
Katalog lub znajdujący się w nim plik jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" />lub <paramref name="destDirName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirName" />lub <paramref name="destDirName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona przez <paramref name="sourceDirName" /> jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu <paramref name="sourceDirName" /> i zapisu do <paramref name="sourceDirName" /> i <paramref name="destDirName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Katalog służący do dodawania lub usuwania wpisów listy kontroli dostępu (ACL).</param>
        <param name="directorySecurity">Obiekt opisujący wpis listy kontroli dostępu, który ma zostać zastosowany do katalogu <paramref name="path" /> opisanego przez parametr. <see cref="T:System.Security.AccessControl.DirectorySecurity" /></param>
        <summary>Stosuje wpisy listy kontroli dostępu (ACL) opisane przez <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt do określonego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Directory.SetAccessControl%2A> Metoda stosuje wpisy listy kontroli dostępu (ACL) do pliku, który reprezentuje niedziedziczoną listę ACL.  
  
> [!CAUTION]
>  Lista ACL określona dla `directorySecurity` parametru zastępuje istniejącą listę ACL dla katalogu. Aby dodać uprawnienia dla nowego użytkownika, użyj <xref:System.IO.Directory.GetAccessControl%2A> metody w celu uzyskania istniejącej listy ACL i zmodyfikuj ją.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych akcji dotyczących danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 Metoda utrzymuje tylko <xref:System.Security.AccessControl.DirectorySecurity> te obiekty, które zostały zmodyfikowane po utworzeniu obiektu. <xref:System.IO.Directory.SetAccessControl%2A>  <xref:System.Security.AccessControl.DirectorySecurity> Jeśli obiekt nie został zmodyfikowany, nie zostanie utrwalony w pliku.  W związku z tym nie można pobrać <xref:System.Security.AccessControl.DirectorySecurity> obiektu z jednego pliku i ponownie zastosować tego samego obiektu do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do innego:  
  
1.  Użyj metody, aby pobrać obiekt z pliku źródłowego. <xref:System.Security.AccessControl.DirectorySecurity> <xref:System.IO.Directory.GetAccessControl%2A>  
  
2.  Utwórz nowy <xref:System.Security.AccessControl.DirectorySecurity> obiekt dla pliku docelowego.  
  
3.  Użyj metody <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> <xref:System.Security.AccessControl.DirectorySecurity> lub obiektu źródłowego, aby pobrać informacje listy ACL. <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>  
  
4.  Użyj metody <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> <xref:System.Security.AccessControl.DirectorySecurity> lub, aby skopiować informacje pobrane w kroku 3 do obiektu docelowego. <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>  
  
5.  Ustaw obiekt docelowy <xref:System.Security.AccessControl.DirectorySecurity> w pliku docelowym <xref:System.IO.Directory.SetAccessControl%2A> przy użyciu metody.  
  
 W środowiskach NTFS i <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przyznawane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia do folderu nadrzędnego. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>odmówić w katalogu nadrzędnym.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.Directory.GetAccessControl%2A> metody i <xref:System.IO.Directory.SetAccessControl%2A> , aby dodać wpis listy kontroli dostępu (ACL), a następnie usunąć wpis listy ACL z katalogu.  Aby uruchomić ten przykład, należy podać prawidłowe konto użytkownika lub grupy.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="directorySecurity" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można znaleźć katalogu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Nieprawidłowy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do katalogu określonego przez <paramref name="path" />.  
  
—lub— 
Bieżący proces nie ma wystarczających uprawnień do ustawienia wpisu listy ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do wyliczania listy kontroli dostępu (ACL) dla katalogu. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Akcja zabezpieczeń: Podaż.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać ustawione informacje o dacie i godzinie utworzenia.</param>
        <param name="creationTime">Data i godzina ostatniego zapisu pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę utworzenia określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych przy użyciu danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać ustawione informacje o dacie i godzinie utworzenia.</param>
        <param name="creationTimeUtc">Data i godzina utworzenia katalogu lub pliku. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę utworzenia w formacie uniwersalnego czasu koordynowanego (UTC) dla określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, do której jest ustawiony bieżący katalog roboczy.</param>
        <summary>Ustawia bieżący katalog roboczy aplikacji do określonego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zakończeniu działania aplikacji katalog roboczy jest przywracany do oryginalnej lokalizacji (katalog, w którym proces został uruchomiony).  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Spacje końcowe są usuwane z końca `path` parametru przed ustawieniem katalogu.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Jeśli konfigurujesz katalog na dysk z nośnikiem wymiennym (na przykład "E:" dla dysku flash USB), możesz określić, czy dysk jest gotowy przy użyciu <xref:System.IO.DriveInfo.IsReady%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób ustawiania bieżącego katalogu i wyświetlania katalogu głównego katalogu.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganego uprawnienia dostępu do kodu niezarządzanego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie znaleziono określonego katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w plikach lub katalogach. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać ustawiony informacje o dacie i godzinie dostępu.</param>
        <param name="lastAccessTime">Obiekt, który zawiera wartość, która ma zostać ustawiona dla daty i godziny <paramref name="path" />dostępu. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego dostępu do określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia `SetLastAccessTime`programu.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać ustawiony informacje o dacie i godzinie dostępu.</param>
        <param name="lastAccessTimeUtc">Obiekt, który zawiera wartość, która ma zostać ustawiona dla daty i godziny <paramref name="path" />dostępu. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę w formacie uniwersalnego czasu koordynowanego (UTC), do ostatniego dostępu do określonego pliku lub katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych przy użyciu danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <param name="lastWriteTime">Data i godzina ostatniego zapisu w katalogu. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego zapisu katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia `SetLastWriteTime`programu.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" />nie znaleziono (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />nie znaleziono (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka katalogu.</param>
        <param name="lastWriteTimeUtc">Data i godzina ostatniego zapisu w katalogu. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę w formacie uniwersalnego czasu koordynowanego (UTC), w którym katalog został ostatnio zapisany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje różnice w danych wyjściowych przy użyciu danych wyjściowych uniwersalnego czasu koordynowanego (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" />nie znaleziono (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />nie znaleziono (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków. Za pomocą <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody można wykonywać zapytania dotyczące nieprawidłowych znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>

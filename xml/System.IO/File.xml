<Type Name="File" FullName="System.IO.File">
  <Metadata><Meta Name="ms.openlocfilehash" Value="421540d5f38818f6a7aafacd0fd342afb3db014f" /><Meta Name="ms.sourcegitcommit" Value="24f564114ee2fa9c63dbac1b25b82826cc4e320f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/25/2019" /><Meta Name="ms.locfileid" Value="68487925" /></Metadata><TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <TypeSignature Language="F#" Value="type File = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia statyczne metody tworzenia, kopiowania, usuwania, przechodzenia i otwierania pojedynczego pliku oraz ułatwia tworzenie <see cref="T:System.IO.FileStream" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File> Użyj klasy dla typowych operacji, takich jak kopiowanie, przesuwanie, zmiana nazwy, tworzenie, otwieranie, usuwanie i dołączanie do pojedynczego pliku w danym momencie. Można również użyć klasy, <xref:System.IO.File> aby pobrać i ustawić atrybuty plików lub <xref:System.DateTime> informacje związane z tworzeniem, dostępem i zapisywaniem pliku. Jeśli chcesz wykonać operacje na wielu plikach, zobacz <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> lub. <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>  
  
 <xref:System.IO.File> Wiele metod zwraca inne typy we/wy podczas tworzenia lub otwierania plików. Możesz użyć tych innych typów do dalszej manipulacji plikiem. Aby uzyskać więcej informacji, zobacz <xref:System.IO.File> określone elementy członkowskie <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>takie jak <xref:System.IO.File.Create%2A>, lub.  
  
 Ponieważ wszystkie <xref:System.IO.File> metody są statyczne, <xref:System.IO.File> użycie metody zamiast odpowiedniej <xref:System.IO.FileInfo> metody wystąpienia może być bardziej wydajne, jeśli chcesz wykonać tylko jedną akcję. Wszystkie <xref:System.IO.File> metody wymagają ścieżki do pliku, który jest manipulowany.  
  
 Statyczne metody <xref:System.IO.File> klasy sprawdzają zabezpieczenia wszystkich metod. Jeśli chcesz ponownie użyć obiektu kilka razy, rozważ użycie odpowiedniej metody <xref:System.IO.FileInfo> wystąpienia zamiast tego, ponieważ sprawdzanie zabezpieczeń nie zawsze jest konieczne.  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych plików jest udzielany wszystkim użytkownikom.  
  
 W poniższej tabeli opisano wyliczenia, które są używane do dostosowywania zachowania różnych <xref:System.IO.File> metod.  
  
|Wyliczenie|Opis|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Określa dostęp do odczytu i zapisu do pliku.|  
|<xref:System.IO.FileShare>|Określa poziom dostępu dozwolony dla pliku, który jest już używany.|  
|<xref:System.IO.FileMode>|Określa, czy zawartość istniejącego pliku jest zachowywana, zastępowana, oraz czy żądania utworzenia istniejącego pliku powodują wystąpienie wyjątku.|  
  
> [!NOTE]
>  W elementach członkowskich, które akceptują ścieżkę jako ciąg wejściowy, ta ścieżka musi być poprawnie sformułowana lub występuje wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale zaczyna się od spacji, ścieżka nie jest przycięta w metodach klasy. W związku z tym ścieżka jest źle sformułowana i zgłaszany jest wyjątek. Podobnie ścieżka lub kombinacja ścieżek nie mogą być w pełni kwalifikowane dwukrotnie. Na przykład "c:\Temp c:\Windows" wywołuje również wyjątek w większości przypadków. Upewnij się, że ścieżki są poprawnie sformułowane podczas korzystania z metod, które akceptują ciąg ścieżki.  
  
 W elementach członkowskich, które akceptują ścieżkę, ścieżka może odwoływać się do pliku lub tylko katalogu. Określona ścieżka może również odwoływać się do ścieżki względnej lub ścieżki Universal Naming Convention (UNC) dla serwera i nazwy udziału. Na przykład wszystkie następujące są dopuszczalne ścieżki:  
  
-   `"c:\\\MyDir\\\MyFile.txt"`w C#programie lub `"c:\MyDir\MyFile.txt"` w Visual Basic.  
  
-   `"c:\\\MyDir"`w C#programie lub `"c:\MyDir"` w Visual Basic.
  
-   `"MyDir\\\MySubdir"`w C#programie lub `"MyDir\MySubDir"` w Visual Basic.
  
-   `"\\\\\\\MyServer\\\MyShare"`w C#programie lub `"\\\MyServer\MyShare"` w Visual Basic.
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak użyć <xref:System.IO.File> klasy do sprawdzenia, czy plik istnieje, a w zależności od wyniku Utwórz nowy plik i zapisać go, albo Otwórz istniejący plik i odczytaj go. Przed uruchomieniem kodu Utwórz `c:\temp` folder.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza wiersze do pliku, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego mają zostać dołączone wiersze. Plik zostanie utworzony, jeśli jeszcze nie istnieje.</param>
        <param name="contents">Wiersze do dołączenia do pliku.</param>
        <summary>Dołącza wiersze do pliku, a następnie zamyka plik. Jeśli określony plik nie istnieje, ta metoda tworzy plik, zapisuje określone wiersze do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowych katalogów. W związku z tym wartość `path` parametru musi zawierać istniejące katalogi.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wybrane wiersze z przykładowego pliku danych do pliku, a następnie dołącza więcej wierszy. Do pomyślnego ukończenia przykładu należy mieć katalog o nazwie `temp` na dysku C.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden więcej nieprawidłowych znaków zdefiniowanych <see cref="M:System.IO.Path.GetInvalidPathChars" /> przez metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Lub<paramref name="contents" /> jest .<see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> przez.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień do zapisu w pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />Określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />jest katalogiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego mają zostać dołączone wiersze. Plik zostanie utworzony, jeśli jeszcze nie istnieje.</param>
        <param name="contents">Wiersze do dołączenia do pliku.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <summary>Dołącza wiersze do pliku przy użyciu określonego kodowania, a następnie zamyka plik. Jeśli określony plik nie istnieje, ta metoda tworzy plik, zapisuje określone wiersze do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowych katalogów. W związku z tym wartość `path` parametru musi zawierać istniejące katalogi.  
  
 Za pomocą tej metody można utworzyć plik, który zawiera następujące elementy:  
  
-   Wyniki zapytania [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) na wierszach pliku uzyskanych przy użyciu <xref:System.IO.File.ReadLines%2A> metody.  
  
-   Zawartość kolekcji implementującej <xref:System.Collections.Generic.IEnumerable%601> ciągi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden więcej nieprawidłowych znaków zdefiniowanych <see cref="M:System.IO.Path.GetInvalidPathChars" /> przez metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />, ,<paramref name="contents" />Lub jest<paramref name="encoding" /> . <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowy (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> przez.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />Określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />jest katalogiem.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego mają zostać dołączone wiersze. Plik zostanie utworzony, jeśli jeszcze nie istnieje.</param>
        <param name="contents">Wiersze do dołączenia do pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie dołącza wiersze do pliku, a następnie zamyka plik. Jeśli określony plik nie istnieje, ta metoda tworzy plik, zapisuje określone wiersze do pliku, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczne operacje dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego mają zostać dołączone wiersze. Plik zostanie utworzony, jeśli jeszcze nie istnieje.</param>
        <param name="contents">Wiersze do dołączenia do pliku.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie dołącza wiersze do pliku przy użyciu określonego kodowania, a następnie zamyka plik. Jeśli określony plik nie istnieje, ta metoda tworzy plik, zapisuje określone wiersze do pliku, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczne operacje dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza określony ciąg do pliku, tworząc plik, jeśli jeszcze nie istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego ma zostać dołączony określony ciąg.</param>
        <param name="contents">Ciąg do dołączenia do pliku.</param>
        <summary>Otwiera plik, dołącza określony ciąg do pliku, a następnie zamyka plik. Jeśli plik nie istnieje, ta metoda tworzy plik, zapisuje określony ciąg do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podano ciąg i ścieżkę do pliku, ta metoda otwiera określony plik, dołącza ciąg na końcu pliku, a następnie zamyka plik. Dojście do pliku ma być zamknięte przez tę metodę, nawet jeśli zostały zgłoszone wyjątki.  
  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowych katalogów. W związku z tym wartość `path` parametru musi zawierać istniejące katalogi.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.AppendAllText%2A> metody w celu dodania dodatkowego tekstu na końcu pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst. Jednak katalog o nazwie `temp` na dysku C musi istnieć, aby przykład mógł zostać pomyślnie ukończony.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member AppendAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.AppendAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego ma zostać dołączony określony ciąg.</param>
        <param name="contents">Ciąg do dołączenia do pliku.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <summary>Dołącza określony ciąg do pliku przy użyciu określonego kodowania, tworząc plik, jeśli jeszcze nie istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podano ciąg i ścieżkę do pliku, ta metoda otwiera określony plik, dołącza ciąg do końca pliku przy użyciu określonego kodowania, a następnie zamyka plik. Dojście do pliku ma być zamknięte przez tę metodę, nawet jeśli zostały zgłoszone wyjątki.  
  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowych katalogów. W związku z tym wartość `path` parametru musi zawierać istniejące katalogi.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.AppendAllText%2A> metody w celu dodania dodatkowego tekstu na końcu pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst. Jednak katalog o nazwie `temp` na dysku C musi istnieć, aby przykład mógł zostać pomyślnie ukończony.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego ma zostać dołączony określony ciąg.</param>
        <param name="contents">Ciąg do dołączenia do pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik lub tworzy plik, jeśli jeszcze nie istnieje, dołącza określony ciąg do pliku, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczne operacje dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member AppendAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.AppendAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik, do którego ma zostać dołączony określony ciąg.</param>
        <param name="contents">Ciąg do dołączenia do pliku.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik lub tworzy plik, jeśli jeszcze nie istnieje, dołącza określony ciąg do pliku przy użyciu określonego kodowania, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczne operacje dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member AppendText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.AppendText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku do dołączenia.</param>
        <summary>Tworzy obiekt <see cref="T:System.IO.StreamWriter" /> , który dołącza tekst zakodowany w formacie UTF-8 do istniejącego pliku lub do nowego pliku, jeśli określony plik nie istnieje.</summary>
        <returns>Składnik zapisywania strumienia, który dołącza tekst zakodowany w formacie UTF-8 do określonego pliku lub do nowego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna z <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> przeciążeniem konstruktora. Jeśli plik określony przez `path` nie istnieje, zostanie utworzony. Jeśli plik istnieje, operacje zapisu w polu <xref:System.IO.StreamWriter> Dołącz tekst do pliku. Dodatkowe wątki mogą odczytywać plik, gdy jest otwarty.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` parametrze nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład dołącza tekst do pliku. Metoda tworzy nowy plik, jeśli plik nie istnieje. Jednak katalog o nazwie `temp` na dysku C musi istnieć, aby przykład mógł zostać pomyślnie ukończony.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład katalog nie istnieje lub znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do dołączania do określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje istniejący plik do nowego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destFileName">Nazwa pliku docelowego. Nie może to być katalog ani istniejący plik.</param>
        <summary>Kopiuje istniejący plik do nowego pliku. Zastąpienie pliku o tej samej nazwie jest niedozwolone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> z przeciążeniem metody `overwrite` z parametrem ustawionym na `false`.  
  
 Parametry `sourceFileName` i`destFileName` mogą określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> metodę. Ta metoda nie obsługuje symboli wieloznacznych w parametrach.  
  
 Atrybuty oryginalnego pliku są zachowywane w kopiowanym pliku.  
  
   
  
## Examples  
 Poniższy przykład kopiuje pliki do folderu kopii zapasowej C:\archives\2008. Używa dwóch przeciążeń <xref:System.IO.File.Copy%2A> metody w następujący sposób:  
  
-   Najpierw używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> przeciążenia metody do kopiowania plików tekstowych (. txt). Kod pokazuje, że to Przeciążenie nie zezwala na zastępowanie plików, które zostały już skopiowane.  
  
-   Następnie używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia metody do kopiowania obrazów (plików jpg). Kod pokazuje, że to Przeciążenie zezwala na zastępowanie plików, które zostały już skopiowane.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.  
  
—lub— 
 <paramref name="sourceFileName" />lub <paramref name="destFileName" /> określa katalog.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" />nie znaleziono.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destFileName" />istniejący.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu <paramref name="sourceFileName" /> i zapisu do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member Copy : string * string * bool -&gt; unit" Usage="System.IO.File.Copy (sourceFileName, destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destFileName">Nazwa pliku docelowego. Nie może to być katalog.</param>
        <param name="overwrite"><see langword="true" />Jeśli plik docelowy może zostać nadpisany; w przeciwnym razie. <see langword="false" /></param>
        <summary>Kopiuje istniejący plik do nowego pliku. Zastępowanie pliku o tej samej nazwie jest dozwolone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `sourceFileName` i`destFileName` mogą określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Ta metoda nie obsługuje symboli wieloznacznych w parametrach.  
  
 Atrybuty oryginalnego pliku są zachowywane w kopiowanym pliku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kopiuje pliki do folderu kopii zapasowej C:\archives\2008. Używa dwóch przeciążeń <xref:System.IO.File.Copy%2A> metody w następujący sposób:  
  
-   Najpierw używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> przeciążenia metody do kopiowania plików tekstowych (. txt). Kod pokazuje, że to Przeciążenie nie zezwala na zastępowanie plików, które zostały już skopiowane.  
  
 Następnie używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia metody do kopiowania obrazów (plików jpg). Kod pokazuje, że to Przeciążenie zezwala na zastępowanie plików, które zostały już skopiowane.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="destFileName" />jest tylko do odczytu.
        
—lub— 
<paramref name="overwrite" />jest <see langword="true" /> <paramref name="sourceFileName" /> , <paramref name="destFileName" /> istnieje i jest ukryty, ale nie jest ukryty.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.  
  
—lub— 
 <paramref name="sourceFileName" />lub <paramref name="destFileName" /> określa katalog.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" />nie znaleziono.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destFileName" />istnieje i <paramref name="overwrite" /> ma <see langword="false" />.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu <paramref name="sourceFileName" /> i zapisu do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik w określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.IO.FileStream" Usage="System.IO.File.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku do utworzenia.</param>
        <summary>Tworzy lub zastępuje plik w określonej ścieżce.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> , który zapewnia dostęp do odczytu i zapisu do pliku określonego <paramref name="path" />w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt utworzony przez tę metodę ma wartość <xref:System.IO.FileShare.None>domyślną <xref:System.IO.FileShare> ; żaden inny proces lub kod nie może uzyskać dostępu do utworzonego pliku do momentu zamknięcia oryginalnego dojścia do pliku. <xref:System.IO.FileStream>  
  
 Ta metoda jest równoważna <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> z przeciążeniem metody przy użyciu domyślnego rozmiaru buforu wynoszącego 4 096 bajtów.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli określony plik nie istnieje, zostanie utworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość jest zastępowana.  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych plików jest udzielany wszystkim użytkownikom. Plik jest otwierany z dostępem do odczytu/zapisu i musi być zamknięty, aby mógł zostać otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy plik w określonej ścieżce, zapisuje niektóre informacje do pliku i odczytuje z pliku.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu w pliku opisanym przez <paramref name="path" /> parametr. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberSignature Language="F#" Value="static member Create : string * int -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku.</param>
        <param name="bufferSize">Liczba bajtów buforowanych w celu odczytu i zapisu w pliku.</param>
        <summary>Tworzy lub zastępuje określony plik.</summary>
        <returns>O określonym rozmiarze buforu, który zapewnia dostęp do odczytu i zapisu do pliku określonego w <paramref name="path" />. <see cref="T:System.IO.FileStream" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt utworzony przez tę metodę ma wartość <xref:System.IO.FileShare.None>domyślną <xref:System.IO.FileShare> ; żaden inny proces lub kod nie może uzyskać dostępu do utworzonego pliku do momentu zamknięcia oryginalnego dojścia do pliku. <xref:System.IO.FileStream>  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ta metoda jest równoważna z <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> przeciążeniem konstruktora. Jeśli określony plik nie istnieje, zostanie utworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość jest zastępowana.  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych plików jest udzielany wszystkim użytkownikom. Plik jest otwierany z dostępem do odczytu/zapisu i musi być zamknięty, aby mógł zostać otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy plik o określonym rozmiarze buforu.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu w pliku opisanym przez <paramref name="path" /> parametr. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku.</param>
        <param name="bufferSize">Liczba bajtów buforowanych w celu odczytu i zapisu w pliku.</param>
        <param name="options">Jedna z <see cref="T:System.IO.FileOptions" /> wartości opisujących sposób tworzenia lub zastępowania pliku.</param>
        <summary>Tworzy lub zastępuje określony plik, określając rozmiar buforu i <see cref="T:System.IO.FileOptions" /> wartość opisującą sposób tworzenia lub zastępowania pliku.</summary>
        <returns>Nowy plik o określonym rozmiarze buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ta metoda jest równoważna z <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> przeciążeniem konstruktora. Jeśli określony plik nie istnieje, zostanie utworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość jest zastępowana.  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych plików jest udzielany wszystkim użytkownikom. Plik jest otwierany z dostępem do odczytu/zapisu i musi być zamknięty, aby mógł zostać otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu w pliku opisanym przez <paramref name="path" /> parametr. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member Create : string * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="System.IO.File.Create (path, bufferSize, options, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku.</param>
        <param name="bufferSize">Liczba bajtów buforowanych w celu odczytu i zapisu w pliku.</param>
        <param name="options">Jedna z <see cref="T:System.IO.FileOptions" /> wartości opisujących sposób tworzenia lub zastępowania pliku.</param>
        <param name="fileSecurity">Jedna z <see cref="T:System.Security.AccessControl.FileSecurity" /> wartości, która określa kontrolę dostępu i zabezpieczenia inspekcji dla pliku.</param>
        <summary>Tworzy lub zastępuje określony plik określonym rozmiarem buforu, opcjami plików i zabezpieczeniami plików.</summary>
        <returns>Nowy plik o określonym rozmiarze bufora, opcjach plików i zabezpieczeniach plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ta metoda jest równoważna z <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> przeciążeniem konstruktora. Jeśli określony plik nie istnieje, zostanie utworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość jest zastępowana.  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych plików jest udzielany wszystkim użytkownikom. Plik jest otwierany z dostępem do odczytu/zapisu i musi być zamknięty, aby mógł zostać otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu w pliku opisanym przez <paramref name="path" /> parametr. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateText : string -&gt; System.IO.StreamWriter" Usage="System.IO.File.CreateText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do zapisu.</param>
        <summary>Tworzy lub otwiera plik do pisania tekstu zakodowanego w formacie UTF-8. Jeśli plik już istnieje, jego zawartość jest zastępowana.</summary>
        <returns><see cref="T:System.IO.StreamWriter" /> Zapisuje w określonym pliku przy użyciu kodowania UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> z przeciążeniem konstruktora `append` z parametrem ustawionym na `false`. Jeśli plik określony przez `path` nie istnieje, zostanie utworzony. Jeśli plik istnieje, jego zawartość jest zastępowana. Dodatkowe wątki mogą odczytywać plik, gdy jest otwarty.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy plik do pisania i odczytywania tekstu.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Decrypt : string -&gt; unit" Usage="System.IO.File.Decrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka opisująca plik do odszyfrowania.</param>
        <summary>Odszyfrowuje plik, który został zaszyfrowany przez bieżące konto przy użyciu <see cref="M:System.IO.File.Encrypt(System.String)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia odszyfrowanie pliku, który został zaszyfrowany <xref:System.IO.File.Encrypt%2A> przy użyciu metody. <xref:System.IO.File.Decrypt%2A>  <xref:System.IO.File.Decrypt%2A> Metoda może odszyfrować tylko pliki, które zostały zaszyfrowane przy użyciu bieżącego konta użytkownika.  

 > [!IMPORTANT]
 > Ten interfejs API jest obsługiwany tylko na platformach z systemem Windows, które mogą korzystać z systemu plików NTFS system szyfrowania plików (EFS). Każda próba użycia tej opcji w systemach innych niż Windows, systemach Windows Home Edition lub dyskach innych niż NTFS powoduje <xref:System.PlatformNotSupportedException> lub <xref:System.NotSupportedException>w zależności od sytuacji.
 > 
 > Nie zaleca się używania tego interfejsu API w programie .NET Core; jest on dostępny, aby umożliwić przenośność aplikacji, które są przenoszone do platformy .NET Core, ale nadal jawnie w systemie Windows.

 <xref:System.IO.File.Decrypt%2A> Metoda wymaga wyłącznego dostępu do pliku, który jest odszyfrowywany, i zgłasza wyjątek, jeśli inny proces korzysta z pliku. Jeśli plik nie jest zaszyfrowany, <xref:System.IO.File.Decrypt%2A> zwróci wartość różną od zera, która wskazuje na powodzenie.  
  
 <xref:System.IO.File.Encrypt%2A> Obie metody<xref:System.IO.File.Decrypt%2A> i metody używają dostawcy usług kryptograficznych (CSP) zainstalowanego na komputerze oraz kluczy szyfrowania plików procesu wywołującego metodę.  
  
 Bieżący system plików musi być sformatowany w systemie plików NTFS, a bieżący system operacyjny musi mieć system Windows NT lub nowszy.  
   
## Examples  
 Poniższy przykład kodu używa <xref:System.IO.File.Encrypt%2A> metody <xref:System.IO.File.Decrypt%2A> i metody do szyfrowania, a następnie odszyfrowywania pliku. Aby przykład mógł zostać zadziałały, musi istnieć plik.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych przez <see cref="F:System.IO.Path.InvalidPathChars" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku opisanego <paramref name="path" /> przez parametr.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy. Na przykład zaszyfrowany plik jest już otwarty.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwana na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.NotSupportedException">System plików nie jest systemem plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
<paramref name="path" /> Parametr określił katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu w pliku opisanym przez <paramref name="path" /> parametr. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.File.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku, który ma zostać usunięty. Symbole wieloznaczne nie są obsługiwane.</param>
        <summary>Usuwa określony plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ nazwę pliku z informacjami o ścieżce względnej lub bezwzględnym `path` dla parametru. Nie można dołączać symboli wieloznacznych. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli plik, który ma zostać usunięty, nie istnieje, nie jest zgłaszany żaden wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kopiuje grupy plików do folderu kopii zapasowej C:\archives\2008, a następnie usuwa je z folderu źródłowego.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Określony plik jest w użyciu.  
  
—lub— 
Istnieje otwarte dojście do pliku, a system operacyjny to Windows XP lub wcześniejsza wersja. To otwarte dojście może wynikać z wyliczania katalogów i plików. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i](~/docs/standard/io/how-to-enumerate-directories-and-files.md)plików.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
Plik jest plikiem wykonywalnym, który jest używany.  
  
—lub— 
 <paramref name="path" />jest katalogiem.  
  
—lub— 
 <paramref name="path" />określono plik tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do usunięcia określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Encrypt : string -&gt; unit" Usage="System.IO.File.Encrypt path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka opisująca plik do zaszyfrowania.</param>
        <summary>Szyfruje plik, tak aby tylko konto użyte do zaszyfrowania pliku może je odszyfrować.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks  
 <xref:System.IO.File.Encrypt%2A> Metoda umożliwia Zaszyfrowanie pliku, tak aby tylko konto użyte do wywołania tej metody można je odszyfrować. Użyj metody <xref:System.IO.File.Decrypt%2A> , aby odszyfrować plik zaszyfrowany <xref:System.IO.File.Encrypt%2A> przez metodę.  

 > [!IMPORTANT]
 > Ten interfejs API jest obsługiwany tylko na platformach z systemem Windows, które mogą korzystać z systemu plików NTFS system szyfrowania plików (EFS). Każda próba użycia tej opcji w systemach innych niż Windows, systemach Windows Home Edition lub dyskach innych niż NTFS powoduje <xref:System.PlatformNotSupportedException> lub <xref:System.NotSupportedException>w zależności od sytuacji.
 > 
 > Nie zaleca się używania tego interfejsu API w programie .NET Core; jest on dostępny, aby umożliwić przenośność aplikacji, które są przenoszone do platformy .NET Core, ale nadal jawnie w systemie Windows.

 <xref:System.IO.File.Encrypt%2A> Metoda wymaga wyłącznego dostępu do zaszyfrowanego pliku i zakończy się niepowodzeniem, jeśli inny proces korzysta z pliku.  
  
 <xref:System.IO.File.Encrypt%2A> Obie metody<xref:System.IO.File.Decrypt%2A> i metody używają dostawcy usług kryptograficznych (CSP) zainstalowanego na komputerze oraz kluczy szyfrowania plików procesu wywołującego metodę.  
  
 Ta metoda nie jest dostępna we wszystkich wersjach systemu Windows. Na przykład nie jest dostępna w wersjach Home.  
  
 Bieżący system plików musi być sformatowany w systemie plików NTFS.  
  
## Examples  
 Poniższy przykład kodu używa <xref:System.IO.File.Encrypt%2A> metody <xref:System.IO.File.Decrypt%2A> i metody do szyfrowania, a następnie odszyfrowywania pliku. Aby przykład mógł zostać zadziałały, musi istnieć plik.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych przez <see cref="F:System.IO.Path.InvalidPathChars" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku opisanego <paramref name="path" /> przez parametr.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwana na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Windows NT lub nowszym.</exception>
        <exception cref="T:System.NotSupportedException">System plików nie jest systemem plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
<paramref name="path" /> Parametr określił katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu w pliku opisanym przez <paramref name="path" /> parametr. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.File.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik do sprawdzenia.</param>
        <summary>Określa, czy określony plik istnieje.</summary>
        <returns><see langword="true" />Jeśli obiekt wywołujący ma wymagane uprawnienia i <paramref name="path" /> zawiera nazwę istniejącego pliku; <see langword="false" />w przeciwnym razie. Ta metoda zwraca również <see langword="false" /> wartość <paramref name="path" /> , <see langword="null" />jeśli jest, nieprawidłowa ścieżka lub ciąg o zerowej długości. Jeśli obiekt wywołujący nie ma wystarczających uprawnień do odczytu określonego pliku, żaden wyjątek nie jest zgłaszany, a <see langword="false" /> Metoda zwraca, niezależnie od <paramref name="path" />istnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda nie powinna być używana do walidacji ścieżki, dlatego ta metoda sprawdza tylko, czy plik określony `path` w istnieje. <xref:System.IO.File.Exists%2A> Przekazywanie nieprawidłowej ścieżki <xref:System.IO.File.Exists%2A> w `false`celu pominięcia. Aby sprawdzić, czy ścieżka zawiera nieprawidłowe znaki, można wywołać <xref:System.IO.Path.GetInvalidPathChars%2A> metodę w celu pobrania znaków, które są nieprawidłowe dla systemu plików. Możesz również utworzyć wyrażenie regularne, aby sprawdzić, czy ścieżka jest prawidłowa dla danego środowiska. Przykłady akceptowalnych ścieżek można znaleźć w <xref:System.IO.File>temacie.  
  
 Aby sprawdzić, czy katalog istnieje, zobacz <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Należy pamiętać, że inny proces może wykonać coś z plikiem w czasie wywołania <xref:System.IO.File.Exists%2A> metody i wykonać inną operację na pliku, na przykład. <xref:System.IO.File.Delete%2A>  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 W `path` przypadku opisywania katalogu ta metoda zwraca `false`wartość. Spacje końcowe są usuwane z `path` parametru przed ustaleniem, czy plik istnieje.  
  
 <xref:System.IO.File.Exists%2A> Metoda zwraca`false` Jeśli wystąpi błąd podczas próby ustalenia, czy określony plik istnieje. Może się to zdarzyć w sytuacjach, w których są wywoływane wyjątki, takie jak przekazywanie nazwy pliku z nieprawidłowymi znakami lub zbyt wiele znaków, Niepowodzenie lub brak dysku lub jeśli obiekt wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład określa, czy plik istnieje.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Security.AccessControl.FileSecurity" /> Pobiera obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileInfo.GetAccessControl%2A> Użyj metod, aby pobrać wpisy listy kontroli dostępu (ACL) dla określonego pliku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku zawierającego <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt opisujący informacje na temat listy kontroli dostępu (ACL) pliku.</param>
        <summary><see cref="T:System.Security.AccessControl.FileSecurity" /> Pobiera obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla określonego pliku.</summary>
        <returns>Obiekt, który hermetyzuje reguły kontroli dostępu dla pliku opisanego <paramref name="path" /> przez parametr. <see cref="T:System.Security.AccessControl.FileSecurity" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy kontroli dostępu (ACL) dla pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych działań w danym pliku. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 W środowiskach NTFS i <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przyznawane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia do folderu nadrzędnego. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>odmówić w katalogu nadrzędnym.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.IO.File.GetAccessControl%2A> <xref:System.IO.File.SetAccessControl%2A> metod i do dodawania i usuwania wpisu listy kontroli dostępu (ACL) z pliku.  Aby uruchomić ten przykład, należy podać prawidłowe konto użytkownika lub grupy.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
<paramref name="path" /> Parametr określił katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu listy kontroli dostępu. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />,<see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="System.IO.File.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku zawierającego <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt opisujący informacje na temat listy kontroli dostępu (ACL) pliku.</param>
        <param name="includeSections">Jedna z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, która określa typ informacji listy kontroli dostępu (ACL) do odbierania.</param>
        <summary><see cref="T:System.Security.AccessControl.FileSecurity" /> Pobiera obiekt, który hermetyzuje określony typ wpisów listy kontroli dostępu (ACL) dla określonego pliku.</summary>
        <returns>Obiekt, który hermetyzuje reguły kontroli dostępu dla pliku opisanego <paramref name="path" /> przez parametr. <see cref="T:System.Security.AccessControl.FileSecurity" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy kontroli dostępu (ACL) dla pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych działań w danym pliku. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 W środowiskach NTFS i <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przyznawane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia do folderu nadrzędnego. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>odmówić w katalogu nadrzędnym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
<paramref name="path" /> Parametr określił katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu listy kontroli dostępu. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />,<see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAttributes : string -&gt; System.IO.FileAttributes" Usage="System.IO.File.GetAttributes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku.</param>
        <summary><see cref="T:System.IO.FileAttributes" /> Pobiera plik na ścieżce.</summary>
        <returns><see cref="T:System.IO.FileAttributes" /> Plik na ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje `GetAttributes` metody i `SetAttributes` , stosując `Archive` atrybuty i `Hidden` do pliku.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pusty, zawiera tylko spacje lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" />reprezentuje plik i jest nieprawidłowy, na przykład na dysku niezamapowanym lub nie można znaleźć pliku.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />reprezentuje katalog i jest nieprawidłowy, na przykład na dysku niezamapowanym lub nie można odnaleźć katalogu.</exception>
        <exception cref="T:System.IO.IOException">Ten plik jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.File.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego chcesz uzyskać informacje o dacie i godzinie utworzenia.</param>
        <summary>Zwraca datę i godzinę utworzenia określonego pliku lub katalogu.</summary>
        <returns><see cref="T:System.DateTime" /> Struktura ustawiona na datę i godzinę utworzenia określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli plik opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowany do czasu lokalnego.  
  
 Dyski sformatowane w systemie plików NTFS mogą buforować informacje o pliku, takie jak czas utworzenia pliku, przez krótki czas. W związku z tym może być konieczne jawne ustawienie czasu utworzenia pliku w przypadku zastąpienia lub zastąpienia istniejącego pliku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego chcesz uzyskać informacje o dacie i godzinie utworzenia.</param>
        <summary>Zwraca datę i godzinę utworzenia w uniwersalnym czasie koordynowanym (UTC) dla określonego pliku lub katalogu.</summary>
        <returns><see cref="T:System.DateTime" /> Struktura ustawiona na datę i godzinę utworzenia określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli plik opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Dyski sformatowane w systemie plików NTFS mogą buforować informacje o pliku, takie jak czas utworzenia pliku, przez krótki czas. W związku z tym może być konieczne jawne ustawienie czasu utworzenia pliku w przypadku zastąpienia lub zastąpienia istniejącego pliku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.IO.File.GetCreationTimeUtc%2A> metodę.  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać uzyskany dostęp do informacji o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę ostatniego dostępu do określonego pliku lub katalogu.</summary>
        <returns><see cref="T:System.DateTime" /> Struktura ustawiona na datę i godzinę ostatniego dostępu do określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli plik opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowany do czasu lokalnego.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego ma zostać uzyskany dostęp do informacji o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę, w uniwersalnym czasie koordynowanym (UTC), do ostatniego dostępu do określonego pliku lub katalogu.</summary>
        <returns><see cref="T:System.DateTime" /> Struktura ustawiona na datę i godzinę ostatniego dostępu do określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny.  
  
 Jeśli plik opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego mają zostać zapisane informacje o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę ostatniego zapisu określonego pliku lub katalogu.</summary>
        <returns><see cref="T:System.DateTime" /> Struktura ustawiona na datę i godzinę ostatniego zapisu określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny. Każdy system operacyjny zarządza czasem ostatniego zapisu zgodnie z jego własnymi regułami. Aby zwiększyć wydajność, system operacyjny może nie ustawiać wartości czasu ostatniego zapisu do dokładnego czasu ostatniej operacji zapisu, ale może ustawić ją w celu zamknięcia.  
  
 Jeśli plik opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowany do czasu lokalnego.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.File.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego mają zostać zapisane informacje o dacie i godzinie.</param>
        <summary>Zwraca datę i godzinę, w uniwersalnym czasie koordynowanym (UTC), że określony plik lub katalog został ostatnio zapisany.</summary>
        <returns><see cref="T:System.DateTime" /> Struktura ustawiona na datę i godzinę ostatniego zapisu określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać niedokładną wartość, ponieważ używa funkcji natywnych, których wartości mogą nie być stale aktualizowane przez system operacyjny. Każdy system operacyjny zarządza czasem ostatniego zapisu zgodnie z jego własnymi regułami. Aby zwiększyć wydajność, system operacyjny może nie ustawiać wartości czasu ostatniego zapisu do dokładnego czasu ostatniej operacji zapisu, ale może ustawić ją w celu zamknięcia.  
  
 Jeśli plik opisany w `path` parametrze nie istnieje, ta metoda zwraca 12:00 północy, 1 stycznia 1601 n.e. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.File.Move (sourceFileName, destFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku do przeniesienia. Może zawierać ścieżkę względną lub bezwzględną.</param>
        <param name="destFileName">Nowa ścieżka i nazwa pliku.</param>
        <summary>Przenosi określony plik do nowej lokalizacji, podając opcję określającą nową nazwę pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda działa na woluminach dyskowych i nie zgłasza wyjątku, jeśli źródło i miejsce docelowe są takie same.

Należy pamiętać, że w przypadku próby zamiany pliku przez przeniesienie pliku o tej samej nazwie do tego katalogu <xref:System.IO.IOException> zostanie zgłoszony. W tym celu zamiast tego <xref:System.IO.File.Move(System.String,System.String,System.Boolean)> należy wywołać metodę.

Argumenty `sourceFileName` i`destFileName` mogą zawierać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.

Jeśli spróbujesz przenieść plik między woluminami dyskowymi, a plik jest używany, plik zostanie skopiowany do lokalizacji docelowej, ale nie zostanie usunięty ze źródła.

Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).

## Examples

Poniższy przykład przenosi plik.

[!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
[!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
[!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik docelowy już istnieje.  
  
—lub— 
 <paramref name="sourceFileName" />nie znaleziono.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki określone w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu <paramref name="sourceFileName" /> i zapisu do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="static member Move : string * string * bool -&gt; unit" Usage="System.IO.File.Move (sourceFileName, destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku do przeniesienia. Może zawierać ścieżkę względną lub bezwzględną.</param>
        <param name="destFileName">Nowa ścieżka i nazwa pliku.</param>
        <param name="overwrite"><see langword="true" />Aby zastąpić plik docelowy, jeśli już istnieje; <see langword="false" /> w przeciwnym razie.</param>
        <summary>Przenosi określony plik do nowej lokalizacji, podając opcje, aby określić nową nazwę pliku i zastąpić plik docelowy, jeśli już istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda działa na woluminach dyskowych i nie zgłasza wyjątku, jeśli źródło i miejsce docelowe są takie same.

Argumenty `sourceFileName` i`destFileName` mogą zawierać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.

Jeśli spróbujesz przenieść plik między woluminami dyskowymi, a plik jest używany, plik zostanie skopiowany do lokalizacji docelowej, ale nie zostanie usunięty ze źródła.

Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).

## Examples

Poniższy przykład przenosi plik.

[!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
[!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
[!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="sourceFileName" />nie znaleziono.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera nieprawidłowe znaki określone w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceFileName" />lub <paramref name="destFileName" /> ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu <paramref name="sourceFileName" /> i zapisu do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.FileStream" /> Otwiera w określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia.</param>
        <param name="mode"><see cref="T:System.IO.FileMode" /> Wartość określająca, czy plik jest tworzony, jeśli taki nie istnieje, i określa, czy zawartość istniejących plików jest zachowywana czy zastępowana.</param>
        <summary><see cref="T:System.IO.FileStream" /> Otwiera w określonej ścieżce z dostępem do odczytu/zapisu bez udostępniania.</summary>
        <returns><see cref="T:System.IO.FileStream" /> Otwarty w określonym trybie i ścieżce z dostępem do odczytu/zapisu i nieudostępnianym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy plik tymczasowy i zapisuje w nim tekst. Przykład otwiera plik, przy użyciu T:System.IO.FileMode.Open; oznacza to, że jeśli plik jeszcze nie istnieje, nie został utworzony.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="mode" />jest <see cref="F:System.IO.FileMode.Create" /> i określony plik jest plikiem ukrytym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />Określono nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu i zapisu do określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia.</param>
        <param name="mode"><see cref="T:System.IO.FileMode" /> Wartość określająca, czy plik jest tworzony, jeśli taki nie istnieje, i określa, czy zawartość istniejących plików jest zachowywana czy zastępowana.</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> Wartość określająca operacje, które mogą być wykonywane na pliku.</param>
        <summary><see cref="T:System.IO.FileStream" /> Otwiera w określonej ścieżce, z określonym trybem i dostępem bez udostępniania.</summary>
        <returns>Nieudostępniona <see cref="T:System.IO.FileStream" /> , która zapewnia dostęp do określonego pliku, z określonym trybem i dostępem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 Poniższy przykład otwiera plik z dostępem tylko do odczytu.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.  
  
—lub— 
 <paramref name="access" />określone <see langword="Read" /> i <paramref name="mode" /> określone ,<see langword="Create" /> ,<see langword="Truncate" />,lub <see langword="Append" />. <see langword="CreateNew" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określono plik, który jest tylko do odczytu i <paramref name="access" /> nie <see langword="Read" />jest.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="mode" />jest <see cref="F:System.IO.FileMode.Create" /> i określony plik jest plikiem ukrytym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />lub <paramref name="access" /> określono nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu i zapisu do określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="System.IO.File.Open (path, mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia.</param>
        <param name="mode"><see cref="T:System.IO.FileMode" /> Wartość określająca, czy plik jest tworzony, jeśli taki nie istnieje, i określa, czy zawartość istniejących plików jest zachowywana czy zastępowana.</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> Wartość określająca operacje, które mogą być wykonywane na pliku.</param>
        <param name="share"><see cref="T:System.IO.FileShare" /> Wartość określająca typ dostępu innych wątków do pliku.</param>
        <summary><see cref="T:System.IO.FileStream" /> Otwiera w określonej ścieżce i ma określony tryb z dostępem do odczytu, zapisu lub odczytu/zapisu oraz z określoną opcją udostępniania.</summary>
        <returns><see cref="T:System.IO.FileStream" /> W określonej ścieżce z określonym trybem dostęp do odczytu, zapisu lub odczytu/zapisu oraz z określoną opcją udostępniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład otwiera plik z dostępem tylko do odczytu i bez zezwolenia na udostępnianie plików.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.  
  
—lub— 
 <paramref name="access" />określone <see langword="Read" /> i <paramref name="mode" /> określone ,<see langword="Create" /> ,<see langword="Truncate" />,lub <see langword="Append" />. <see langword="CreateNew" /></exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określono plik, który jest tylko do odczytu i <paramref name="access" /> nie <see langword="Read" />jest.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="mode" />jest <see cref="F:System.IO.FileMode.Create" /> i określony plik jest plikiem ukrytym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" />, <paramref name="access" /> lub<paramref name="share" /> określono nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu i zapisu do określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenRead : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenRead path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do odczytu.</param>
        <summary>Otwiera istniejący plik do odczytu.</summary>
        <returns>Tylko <see cref="T:System.IO.FileStream" /> do odczytu w określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> z przeciążeniem <xref:System.IO.FileMode> konstruktora wartością <xref:System.IO.FileMode.Open> <xref:System.IO.FileAccess> <xref:System.IO.FileAccess.Read> ,wartością<xref:System.IO.FileShare> i wartością. <xref:System.IO.FileShare.Read>  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład otwiera plik do odczytu.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenText : string -&gt; System.IO.StreamReader" Usage="System.IO.File.OpenText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do odczytu.</param>
        <summary>Otwiera istniejący plik tekstowy z kodowaniem UTF-8 na potrzeby odczytu.</summary>
        <returns><see cref="T:System.IO.StreamReader" /> W określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważna z <xref:System.IO.StreamReader.%23ctor%28System.String%29> przeciążeniem konstruktora.  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład otwiera plik tekstowy do odczytu.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z określonego pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member OpenWrite : string -&gt; System.IO.FileStream" Usage="System.IO.File.OpenWrite path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do zapisu.</param>
        <summary>Otwiera istniejący plik lub tworzy nowy plik do zapisu.</summary>
        <returns><see cref="T:System.IO.FileStream" /> Obiekt nieudostępniony w określonej ścieżce z <see cref="F:System.IO.FileAccess.Write" /> dostępem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> Ta metoda jest równoważna z przeciążeniem konstruktora z trybem plików ustawionym na <xref:System.IO.FileMode.OpenOrCreate>, dostęp <xref:System.IO.FileAccess.Write>ustawiony na, a tryb udostępniania ustawiony <xref:System.IO.FileShare.None>na.  
  
 <xref:System.IO.File.OpenWrite%2A> Metoda otwiera plik, jeśli już istnieje dla ścieżki pliku lub tworzy nowy plik, jeśli taki nie istnieje. Dla istniejącego pliku nie dołącza nowego tekstu do istniejącego tekstu. Zamiast tego zastępuje istniejące znaki nowymi znakami. Jeśli nadpiszesz dłuższy ciąg (na przykład "to jest test metody OpenWrite") przy użyciu krótszego ciągu (takiego jak "Second Run"), plik będzie zawierać kombinację ciągów ("druga runtest metody OpenWrite").  
  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, użyj <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 Zwrócony <xref:System.IO.FileStream> błąd nie obsługuje odczytywania. Aby otworzyć plik do odczytu i zapisu, użyj <xref:System.IO.File.Open%2A>.

 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład otwiera plik do odczytu i zapisu.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
—lub— 
 <paramref name="path" />określono plik lub katalog tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllBytes : string -&gt; byte[]" Usage="System.IO.File.ReadAllBytes path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <summary>Otwiera plik binarny, odczytuje zawartość pliku do tablicy bajtów, a następnie zamyka plik.</summary>
        <returns>Tablica bajtowa zawierająca zawartość pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po podanej ścieżce pliku ta metoda otwiera plik, odczytuje zawartość pliku do tablicy bajtowej, a następnie zamyka plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do odczytu z pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllBytesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="System.IO.File.ReadAllBytesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik binarny, odczytuje zawartość pliku do tablicy bajtów, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu, która otacza tablicę bajtową zawierającą zawartość pliku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik tekstowy, odczytuje wszystkie wiersze pliku do tablicy ciągów, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string -&gt; string[]" Usage="System.IO.File.ReadAllLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <summary>Otwiera plik tekstowy, odczytuje wszystkie wiersze pliku, a następnie zamyka plik.</summary>
        <returns>Tablica ciągów zawierająca wszystkie wiersze pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje każdy wiersz pliku, a następnie dodaje każdy wiersz jako element tablicy ciągów. Następnie zamyka plik. Linia jest definiowana jako sekwencja znaków, po której następuje znak powrotu karetki ("\r"), znak wysuwu wiersza ("\n") lub znak powrotu karetki bezpośrednio po znaku wysuwu wiersza. Wynikowy ciąg nie zawiera kończącego powrotu karetki i/lub wysuwu wiersza.  
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaków kolejności bajtów. Można wykryć formaty kodowania UTF-8 i UTF-32 (zarówno big-endian, jak i little-endian).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.ReadAllLines%2A> metody do wyświetlania zawartości pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do odczytu z pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllLines : string * System.Text.Encoding -&gt; string[]" Usage="System.IO.File.ReadAllLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="encoding">Kodowanie zastosowane do zawartości pliku.</param>
        <summary>Otwiera plik, odczytuje wszystkie wiersze pliku z określonym kodowaniem, a następnie zamyka plik.</summary>
        <returns>Tablica ciągów zawierająca wszystkie wiersze pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje każdy wiersz pliku, a następnie dodaje każdy wiersz jako element tablicy ciągów. Następnie zamyka plik. Linia jest definiowana jako sekwencja znaków, po której następuje znak powrotu karetki ("\r"), znak wysuwu wiersza ("\n") lub znak powrotu karetki bezpośrednio po znaku wysuwu wiersza. Wynikowy ciąg nie zawiera kończącego powrotu karetki i/lub wysuwu wiersza.  
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaków kolejności bajtów. Można wykryć formaty kodowania UTF-8 i UTF-32 (zarówno big-endian, jak i little-endian).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.ReadAllLines%2A> metody do wyświetlania zawartości pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do odczytu z pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik tekstowy, odczytuje wszystkie wiersze pliku, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu, która otacza tablicę ciągów zawierającą wszystkie wiersze pliku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllLinesAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string[]&gt;" Usage="System.IO.File.ReadAllLinesAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="encoding">Kodowanie zastosowane do zawartości pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik tekstowy, odczytuje wszystkie wiersze pliku z określonym kodowaniem, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu, która otacza tablicę ciągów zawierającą wszystkie wiersze pliku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik tekstowy, odczytuje cały tekst w pliku do ciągu, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string -&gt; string" Usage="System.IO.File.ReadAllText path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <summary>Otwiera plik tekstowy, odczytuje cały tekst w pliku, a następnie zamyka plik.</summary>
        <returns>Ciąg zawierający cały tekst w pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje cały tekst w pliku i zwraca go jako ciąg. Następnie zamyka plik.
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaków kolejności bajtów. Można wykryć formaty kodowania UTF-8 i UTF-32 (zarówno big-endian, jak i little-endian).  
  
 Użyj przeciążenia <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> metody podczas odczytywania plików, które mogą zawierać zaimportowany tekst, ponieważ nierozpoznane znaki mogą nie zostać prawidłowo odczytane.  
  
 Dojście do pliku ma być zamknięte przez tę metodę, nawet jeśli zostały zgłoszone wyjątki.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.ReadAllText%2A> metody do wyświetlania zawartości pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do odczytu z pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadAllText : string * System.Text.Encoding -&gt; string" Usage="System.IO.File.ReadAllText (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="encoding">Kodowanie zastosowane do zawartości pliku.</param>
        <summary>Otwiera plik, odczytuje cały tekst w pliku z określonym kodowaniem, a następnie zamyka plik.</summary>
        <returns>Ciąg zawierający cały tekst w pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje cały tekst w pliku i zwraca go jako ciąg. Następnie zamyka plik.
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaków kolejności bajtów. Można wykryć formaty kodowania UTF-8 i UTF-32 (zarówno big-endian, jak i little-endian).  
  
 Dojście do pliku ma być zamknięte przez tę metodę, nawet jeśli zostały zgłoszone wyjątki.  
  
 Aby użyć ustawień kodowania skonfigurowanych dla danego systemu operacyjnego, należy określić <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> Właściwość `encoding` dla parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.ReadAllText%2A> metody do wyświetlania zawartości pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> w.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do odczytu z pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik tekstowy, odczytuje cały tekst w pliku, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu, która zawija ciąg zawierający cały tekst w pliku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member ReadAllTextAsync : string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="System.IO.File.ReadAllTextAsync (path, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do otwarcia na potrzeby odczytu.</param>
        <param name="encoding">Kodowanie zastosowane do zawartości pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie otwiera plik tekstowy, odczytuje cały tekst w pliku z określonym kodowaniem, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu, która zawija ciąg zawierający cały tekst w pliku.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje wiersze pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do odczytu.</param>
        <summary>Odczytuje wiersze pliku.</summary>
        <returns>Wszystkie wiersze pliku lub wiersze, które są wynikiem zapytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.File.ReadLines%2A> i<xref:System.IO.File.ReadAllLines%2A> różnią się w następujący sposób: Korzystając z <xref:System.IO.File.ReadAllLines%2A>programu ,możnarozpocząćwyliczaniekolekcjiciągówprzedzwróceniemcałejkolekcji.wprzypadkuużywanianależypoczekać,ażcałatablicaciągówzostaniezwrócona,zanimbędziemożnauzyskać<xref:System.IO.File.ReadLines%2A>dostęp do tablicy. W związku z tym podczas pracy z bardzo dużymi plikami <xref:System.IO.File.ReadLines%2A> może być bardziej wydajny.  
  
 Możesz użyć <xref:System.IO.File.ReadLines%2A> metody, aby wykonać następujące czynności:  
  
-   Wykonaj [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) zapytania dotyczące pliku, aby uzyskać filtrowany zestaw jego wierszy.  
  
-   Zapisz zwróconą kolekcję wierszy do pliku za pomocą <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> metody lub Dołącz je do istniejącego pliku <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> przy użyciu metody.  
  
-   Utwórz natychmiast wypełnione wystąpienie kolekcji, która pobiera <xref:System.Collections.Generic.IEnumerable%601> kolekcję ciągów dla jego konstruktora, takich <xref:System.Collections.Generic.IList%601> jak lub <xref:System.Collections.Generic.Queue%601>.  
  
 Ta metoda używa <xref:System.Text.Encoding.UTF8%2A> wartości kodowania.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wiersze pliku w celu znalezienia wierszy zawierających określone ciągi.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 W poniższym przykładzie zastosowano <xref:System.IO.File.ReadLines%2A> metodę w zapytaniu LINQ, która wylicza wszystkie katalogi dla plików z rozszerzeniem. txt, odczytuje każdy wiersz pliku i wyświetla wiersz, jeśli zawiera ciąg "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="M:System.IO.Path.GetInvalidPathChars" /> przez metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> przez.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />Określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />jest katalogiem.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member ReadLines : string * System.Text.Encoding -&gt; seq&lt;string&gt;" Usage="System.IO.File.ReadLines (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do odczytu.</param>
        <param name="encoding">Kodowanie, które jest stosowane do zawartości pliku.</param>
        <summary>Odczytaj wiersze pliku z określonym kodowaniem.</summary>
        <returns>Wszystkie wiersze pliku lub wiersze, które są wynikiem zapytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby określić kodowanie, które ma zostać użyte do odczytu pliku.  
  
 Metody <xref:System.IO.File.ReadLines%2A> i<xref:System.IO.File.ReadAllLines%2A> różnią się w następujący sposób: Korzystając z programu, można rozpocząć wyliczanie kolekcji ciągów przed zwróceniem całej kolekcji. <xref:System.IO.File.ReadLines%2A> Gdy używasz, musisz poczekać, aż cała tablica ciągów zostanie zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.File.ReadAllLines%2A> W związku z tym podczas pracy z bardzo dużymi plikami <xref:System.IO.File.ReadLines%2A> może być bardziej wydajny.  
  
 Możesz użyć <xref:System.IO.File.ReadLines%2A> metody, aby wykonać następujące czynności:  
  
-   Wykonaj [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) zapytania dotyczące pliku, aby uzyskać filtrowany zestaw jego wierszy.  
  
-   Zapisz zwróconą kolekcję wierszy do pliku za pomocą <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> metody lub Dołącz je do istniejącego pliku <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> przy użyciu metody.  
  
-   Utwórz natychmiast wypełnione wystąpienie kolekcji, która pobiera <xref:System.Collections.Generic.IEnumerable%601> kolekcję ciągów dla jego konstruktora, takich <xref:System.Collections.Generic.IList%601> jak lub <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku określonego <paramref name="path" /> przez.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />Określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />jest katalogiem.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamienia zawartość określonego pliku na zawartość innego pliku, usuwając oryginalny plik i tworząc kopię zapasową zastępowanego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A> Metody zastępują zawartość określonego pliku zawartością innego pliku.  Tworzy również kopię zapasową pliku, który został zastąpiony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationBackupFileName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku, który zastępuje plik określony przez <paramref name="destinationFileName" />.</param>
        <param name="destinationFileName">Nazwa zastępowanego pliku.</param>
        <param name="destinationBackupFileName">Nazwa pliku kopii zapasowej.</param>
        <summary>Zamienia zawartość określonego pliku na zawartość innego pliku, usuwając oryginalny plik i tworząc kopię zapasową zastępowanego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A> Metoda zastępuje zawartość określonego pliku zawartością innego pliku.  Tworzy również kopię zapasową pliku, który został zastąpiony.  
  
 `sourceFileName` Jeśli i `destinationFileName` znajdują się na różnych woluminach, ta metoda zgłosi wyjątek. `destinationBackupFileName` Jeśli znajduje się na innym woluminie z pliku źródłowego, plik kopii zapasowej zostanie usunięty.  
  
 Przekaż `null` do parametru `destinationBackupFileName` , jeśli nie chcesz tworzyć kopii zapasowej zastępowanego pliku.  

 Jeśli już `destinationBackupFileName` istnieje, zostanie zastąpiony zawartością `destinationFileName` pliku.
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.IO.File.Replace%2A> aby zastąpić plik innym plikiem i utworzyć kopię zapasową zastępowanego pliku.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka opisana przez <paramref name="destinationFileName" /> parametr nie jest w formie prawnej.  
  
—lub— 
Ścieżka opisana przez <paramref name="destinationBackupFileName" /> parametr nie jest w formie prawnej.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="destinationFileName" /></exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku opisanego przez <see cref="T:System.IO.FileInfo" /> bieżący obiekt.  
  
—lub— 
Nie można znaleźć pliku opisanego <paramref name="destinationBackupFileName" /> przez parametr.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.  
  
—lub— 
Parametry <paramref name="sourceFileName" /> i<paramref name="destinationFileName" /> określają ten sam plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows 98 Second Edition lub wcześniejszy, a system plików nie jest systemem plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Parametr <paramref name="sourceFileName" /> lub<paramref name="destinationFileName" /> określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Parametry źródłowe lub docelowe określają katalog, a nie plik.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku uprawnienia do zapisu w pliku opisanym <paramref name="destinationBackupFileName" /> przez parametr, jeśli został określony. Akcja zabezpieczeń: Podaż. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * bool -&gt; unit" Usage="System.IO.File.Replace (sourceFileName, destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationBackupFileName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku, który zastępuje plik określony przez <paramref name="destinationFileName" />.</param>
        <param name="destinationFileName">Nazwa zastępowanego pliku.</param>
        <param name="destinationBackupFileName">Nazwa pliku kopii zapasowej.</param>
        <param name="ignoreMetadataErrors"><see langword="true" />Aby zignorować błędy scalania (takie jak atrybuty i listy kontroli dostępu (ACL)) z zastąpionego pliku do pliku zastępującego; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zastępuje zawartość określonego pliku zawartością innego pliku, usuwając oryginalny plik i tworząc kopię zapasową zastępowanego pliku i opcjonalnie ignoruje błędy scalania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A> Metoda zastępuje zawartość określonego pliku zawartością innego pliku.  Tworzy również kopię zapasową pliku, który został zastąpiony.  
  
 `sourceFileName` Jeśli i `destinationFileName` znajdują się na różnych woluminach, ta metoda zgłosi wyjątek. `destinationBackupFileName` Jeśli znajduje się na innym woluminie z pliku źródłowego, plik kopii zapasowej zostanie usunięty.  
  
 Przekaż `null` do parametru `destinationBackupFileName` , jeśli nie chcesz tworzyć kopii zapasowej zastępowanego pliku.  

 Jeśli już `destinationBackupFileName` istnieje, zostanie zastąpiony zawartością `destinationFileName` pliku.
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.IO.File.Replace%2A> aby zastąpić plik innym plikiem i utworzyć kopię zapasową zastępowanego pliku.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka opisana przez <paramref name="destinationFileName" /> parametr nie jest w formie prawnej.  
  
—lub— 
Ścieżka opisana przez <paramref name="destinationBackupFileName" /> parametr nie jest w formie prawnej.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="destinationFileName" /></exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku opisanego przez <see cref="T:System.IO.FileInfo" /> bieżący obiekt.  
  
—lub— 
Nie można znaleźć pliku opisanego <paramref name="destinationBackupFileName" /> przez parametr.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.  
  
—lub— 
Parametry <paramref name="sourceFileName" /> i<paramref name="destinationFileName" /> określają ten sam plik.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny to Windows 98 Second Edition lub wcześniejszy, a system plików nie jest systemem plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Parametr <paramref name="sourceFileName" /> lub<paramref name="destinationFileName" /> określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Parametry źródłowe lub docelowe określają katalog, a nie plik.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku uprawnienia do zapisu w pliku opisanym <paramref name="destinationBackupFileName" /> przez parametr, jeśli został określony. Akcja zabezpieczeń: Podaż. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.FileSecurity -&gt; unit" Usage="System.IO.File.SetAccessControl (path, fileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik służący do dodawania lub usuwania wpisów listy kontroli dostępu (ACL).</param>
        <param name="fileSecurity">Obiekt opisujący wpis listy kontroli dostępu, który ma zostać zastosowany do pliku <paramref name="path" /> opisanego przez parametr. <see cref="T:System.Security.AccessControl.FileSecurity" /></param>
        <summary>Stosuje wpisy listy kontroli dostępu (ACL) opisane przez <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.SetAccessControl%2A> Metoda stosuje wpisy listy kontroli dostępu (ACL) do pliku, który reprezentuje niedziedziczoną listę ACL.  
  
> [!CAUTION]
>  Lista ACL określona dla `fileSecurity` parametru zastępuje istniejącą listę ACL dla tego pliku. Aby dodać uprawnienia dla nowego użytkownika, użyj <xref:System.IO.File.GetAccessControl%2A> metody w celu uzyskania istniejącej listy ACL, zmodyfikuj ją, a następnie użyj <xref:System.IO.File.SetAccessControl%2A> do jej zastosowania z powrotem do pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych działań w danym pliku. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 Metoda utrzymuje tylko <xref:System.Security.AccessControl.FileSecurity> te obiekty, które zostały zmodyfikowane po utworzeniu obiektu. <xref:System.IO.File.SetAccessControl%2A>  <xref:System.Security.AccessControl.FileSecurity> Jeśli obiekt nie został zmodyfikowany, nie zostanie utrwalony w pliku.  W związku z tym nie można pobrać <xref:System.Security.AccessControl.FileSecurity> obiektu z jednego pliku i ponownie zastosować tego samego obiektu do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do innego:  
  
1.  Użyj metody, aby pobrać obiekt z pliku źródłowego. <xref:System.Security.AccessControl.FileSecurity> <xref:System.IO.File.GetAccessControl%2A>  
  
2.  Utwórz nowy <xref:System.Security.AccessControl.FileSecurity> obiekt dla pliku docelowego.  
  
3.  Użyj metody <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> <xref:System.Security.AccessControl.FileSecurity> lub obiektu źródłowego, aby pobrać informacje listy ACL. <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>  
  
4.  Użyj metody <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> <xref:System.Security.AccessControl.FileSecurity> lub, aby skopiować informacje pobrane w kroku 3 do obiektu docelowego. <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>  
  
5.  Ustaw obiekt docelowy <xref:System.Security.AccessControl.FileSecurity> w pliku docelowym <xref:System.IO.File.SetAccessControl%2A> przy użyciu metody.  
  
 W środowiskach NTFS i <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przyznawane użytkownikowi, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia do folderu nadrzędnego. Aby odmówić <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>odmówić w katalogu nadrzędnym.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.IO.File.GetAccessControl%2A> metod i <xref:System.IO.File.SetAccessControl%2A> do dodawania i usuwania wpisu listy kontroli dostępu (ACL) z pliku.  Aby uruchomić ten przykład, należy podać prawidłowe konto użytkownika lub grupy.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> Parametr określa plik, który jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
<paramref name="path" /> Parametr określił katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="fileSecurity" /></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania uprawnień dostępu do pliku. Akcja zabezpieczeń: Podaż. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />,<see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberSignature Language="F#" Value="static member SetAttributes : string * System.IO.FileAttributes -&gt; unit" Usage="System.IO.File.SetAttributes (path, fileAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku.</param>
        <param name="fileAttributes">Bitowe połączenie wartości wyliczenia.</param>
        <summary>Ustawia określony <see cref="T:System.IO.FileAttributes" /> plik w określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Niektóre atrybuty plików, takie jak <xref:System.IO.FileAttributes.Hidden> i <xref:System.IO.FileAttributes.ReadOnly>, można łączyć. Inne atrybuty, takie jak <xref:System.IO.FileAttributes.Normal>, muszą być używane samodzielnie.  
  
 Nie można zmienić stanu <xref:System.IO.File> kompresji obiektu <xref:System.IO.File.SetAttributes%2A> za pomocą metody.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje `GetAttributes` metody i `SetAttributes` , stosując `Archive` atrybuty i `Hidden` do pliku.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest pusty, zawiera tylko spacje, zawiera nieprawidłowe znaki lub atrybut pliku jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego ma zostać ustawione informacje o dacie i godzinie utworzenia.</param>
        <param name="creationTime">A <see cref="T:System.DateTime" /> zawierająca wartość do ustawienia Data i <paramref name="path" />godzina utworzenia. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę utworzenia pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Dyski sformatowane w systemie plików NTFS mogą buforować metadane pliku, takie jak godzina utworzenia pliku, przez krótki czas. W związku z tym może być konieczne jawne ustawienie czasu utworzenia pliku w przypadku zastąpienia lub zastąpienia istniejącego pliku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas wykonywania operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" />Określa wartość spoza zakresu dat, godzin lub obu dozwolonych dla tej operacji.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego ma zostać ustawione informacje o dacie i godzinie utworzenia.</param>
        <param name="creationTimeUtc">A <see cref="T:System.DateTime" /> zawierająca wartość do ustawienia Data i <paramref name="path" />godzina utworzenia. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę w uniwersalnym czasie koordynowanym (UTC), że plik został utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Dyski sformatowane w systemie plików NTFS mogą buforować metadane pliku, takie jak godzina utworzenia pliku, przez krótki czas. W związku z tym może być konieczne jawne ustawienie czasu utworzenia pliku w przypadku zastąpienia lub zastąpienia istniejącego pliku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas wykonywania operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" />Określa wartość spoza zakresu dat, godzin lub obu dozwolonych dla tej operacji.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego ma zostać ustawiony informacje o dacie i godzinie dostępu.</param>
        <param name="lastAccessTime">A <see cref="T:System.DateTime" /> zawierająca wartość, która ma zostać ustawiona dla ostatniego dostępu Data i <paramref name="path" />godzina. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego dostępu do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład sprawdza system plików dla określonego pliku, tworzy go w razie potrzeby, a następnie ustawia i pobiera czas ostatniego dostępu.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego ma zostać ustawiony informacje o dacie i godzinie dostępu.</param>
        <param name="lastAccessTimeUtc">A <see cref="T:System.DateTime" /> zawierająca wartość, która ma zostać ustawiona dla ostatniego dostępu Data i <paramref name="path" />godzina. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę w uniwersalnym czasie koordynowanym (UTC), do ostatniego dostępu do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego mają zostać ustawione informacje o dacie i godzinie.</param>
        <param name="lastWriteTime">A <see cref="T:System.DateTime" /> zawierająca wartość do ustawienia dla daty i <paramref name="path" />godziny ostatniego zapisu. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego zapisu określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład sprawdza system plików dla określonego pliku, w razie potrzeby tworzy plik, a następnie ustawia i pobiera czas ostatniego zapisu w pliku.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.File.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego mają zostać ustawione informacje o dacie i godzinie.</param>
        <param name="lastWriteTimeUtc">A <see cref="T:System.DateTime" /> zawierająca wartość do ustawienia dla daty i <paramref name="path" />godziny ostatniego zapisu. Ta wartość jest wyrażona w czasie UTC.</param>
        <summary>Ustawia datę i godzinę w uniwersalnym czasie koordynowanym (UTC), w którym określony plik został ostatnio zapisany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr może określać informacje o ścieżce względnej lub bezwzględnej. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" />Określa wartość spoza zakresu dat lub godzin dozwolonych dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member WriteAllBytes : string * byte[] -&gt; unit" Usage="System.IO.File.WriteAllBytes (path, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="bytes">Bajty do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisuje określoną tablicę bajtową do pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podano tablicę bajtową i ścieżkę pliku, ta metoda otwiera określony plik, zapisuje zawartość tablicy bajtów do pliku, a następnie zamyka plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" /> lub tablica bajtów jest pusta.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllBytesAsync : string * byte[] * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllBytesAsync (path, bytes, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="bytes">Bajty do zapisu w pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie tworzy nowy plik, zapisuje określoną tablicę bajtową do pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy plik, zapisuje jeden lub więcej ciągów do pliku, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Wiersze do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisuje kolekcję ciągów do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym zachowaniem <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metody jest zapisanie danych przy użyciu kodowania UTF-8 bez znaku kolejności bajtów (BOM). Jeśli konieczne jest uwzględnienie identyfikatora UTF-8, takiego jak znacznik kolejności bajtów, na początku pliku, należy użyć <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> przeciążenia metody z <xref:System.Text.Encoding.UTF8%2A> kodowaniem.  
  
 Jeśli plik docelowy już istnieje, zostanie nadpisany.  
  
 Za pomocą tej metody można utworzyć zawartość klasy <xref:System.Collections.Generic.IEnumerable%601> kolekcji, która przyjmuje w konstruktorze, <xref:System.Collections.Generic.List%601.%23ctor%2A>na przykład, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, lub <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> klasę.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wybrane wiersze z przykładowego pliku danych do pliku.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="M:System.IO.Path.GetInvalidPathChars" /> przez metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Lub<paramref name="contents" /> jest .<see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />jest katalogiem.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Tablica ciągów do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisuje określoną tablicę ciągów do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik docelowy już istnieje, zostanie nadpisany.  
  
 Domyślnym zachowaniem <xref:System.IO.File.WriteAllLines%2A> metody jest zapisanie danych przy użyciu kodowania UTF-8 bez znacznika kolejności bajtów (BOM). Jeśli konieczne jest uwzględnienie identyfikatora UTF-8, takiego jak znacznik kolejności bajtów, na początku pliku, należy użyć <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> przeciążenia metody z <xref:System.Text.Encoding.UTF8%2A> kodowaniem.  
  
 Mając daną tablicę ciągów i ścieżkę pliku, ta metoda otwiera określony plik, zapisuje tablicę ciągów do pliku, a następnie zamyka plik.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.WriteAllLines%2A> metody do zapisu tekstu do pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Lub<paramref name="contents" /> jest .<see langword="null" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * seq&lt;string&gt; * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Wiersze do zapisu w pliku.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <summary>Tworzy nowy plik przy użyciu określonego kodowania, zapisuje kolekcję ciągów do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik docelowy już istnieje, zostanie nadpisany.  
  
 Za pomocą tej metody można utworzyć plik, który zawiera następujące elementy:  
  
-   Wyniki zapytania [LINQ to Objects](https://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) na wierszach pliku uzyskanych przy użyciu <xref:System.IO.File.ReadLines%2A> metody.  
  
-   Zawartość kolekcji implementującej <xref:System.Collections.Generic.IEnumerable%601> ciągi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="M:System.IO.Path.GetInvalidPathChars" /> przez metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />, ,<paramref name="contents" />Lub jest<paramref name="encoding" /> . <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" />jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />jest katalogiem.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllLines : string * string[] * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllLines (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Tablica ciągów do zapisu w pliku.</param>
        <param name="encoding"><see cref="T:System.Text.Encoding" /> Obiekt reprezentujący kodowanie znaków zastosowane do tablicy ciągów.</param>
        <summary>Tworzy nowy plik, zapisuje określoną tablicę ciągów do pliku przy użyciu określonego kodowania, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik docelowy już istnieje, zostanie nadpisany.  
  
 Mając daną tablicę ciągów i ścieżkę pliku, ta metoda otwiera określony plik, zapisuje tablicę ciągów do pliku przy użyciu określonego kodowania, a następnie zamyka ten plik.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.WriteAllLines%2A> metody do zapisu tekstu do pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Lub<paramref name="contents" /> jest .<see langword="null" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Wiersze do zapisu w pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie tworzy nowy plik, zapisuje określone wiersze do pliku, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllLinesAsync : string * seq&lt;string&gt; * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllLinesAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Wiersze do zapisu w pliku.</param>
        <param name="encoding">Kodowanie znaków do użycia.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie tworzy nowy plik, zapisuje określone wiersze do pliku przy użyciu określonego kodowania, a następnie zamyka plik.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy plik, zapisuje zawartość w pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Ciąg do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisuje określony ciąg do pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa kodowania UTF-8 bez znacznika kolejności bajtów (BOM), dlatego użycie <xref:System.Text.Encoding.GetPreamble%2A> metody zwróci pustą tablicę bajtów. Jeśli konieczne jest uwzględnienie identyfikatora UTF-8, takiego jak znacznik kolejności bajtów, na początku pliku, należy użyć <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> przeciążenia metody z <xref:System.Text.Encoding.UTF8%2A> kodowaniem.  
  
 Podano ciąg i ścieżkę pliku, ta metoda otwiera określony plik, zapisuje ciąg do pliku, a następnie zamyka plik.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.WriteAllText%2A> metody do zapisu tekstu do pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="static member WriteAllText : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.File.WriteAllText (path, contents, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Ciąg do zapisu w pliku.</param>
        <param name="encoding">Kodowanie, które ma zostać zastosowane do ciągu.</param>
        <summary>Tworzy nowy plik, zapisuje określony ciąg do pliku przy użyciu określonego kodowania, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podano ciąg i ścieżkę do pliku, ta metoda otwiera określony plik, zapisuje je w pliku przy użyciu określonego kodowania, a następnie zamyka plik. Dojście do pliku ma być zamknięte przez tę metodę, nawet jeśli zostały zgłoszone wyjątki.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.IO.File.WriteAllText%2A> metody do zapisu tekstu do pliku. W tym przykładzie plik zostanie utworzony, jeśli jeszcze nie istnieje, a do niego zostanie dodany tekst.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" />określony plik jest tylko do odczytu.
        
—lub— 
 <paramref name="path" />określono ukryty plik.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
 <paramref name="path" />określony katalog.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />ma nieprawidłowy format.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do zapisu do pliku lub katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Ciąg do zapisu w pliku.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie tworzy nowy plik, zapisuje określony ciąg do pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="static member WriteAllTextAsync : string * string * System.Text.Encoding * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.IO.File.WriteAllTextAsync (path, contents, encoding, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="contents" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Plik do zapisu.</param>
        <param name="contents">Ciąg do zapisu w pliku.</param>
        <param name="encoding">Kodowanie, które ma zostać zastosowane do ciągu.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie tworzy nowy plik, zapisuje określony ciąg w pliku przy użyciu określonego kodowania, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie nadpisany.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

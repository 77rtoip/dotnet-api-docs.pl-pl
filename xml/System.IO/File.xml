<Type Name="File" FullName="System.IO.File">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="53e5db2ee5795153c90cc3385f395b3bed310d76" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30455871" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody statyczne tworzenie, kopiowanie, usuwanie, przenoszenie i Otwieranie pojedynczego pliku i ułatwia tworzenie <see cref="T:System.IO.FileStream" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.File> klasy dla typowych operacji, takich jak kopiowanie, przenoszenie, zmiana nazwy, tworzenie, otwieranie, usuwanie i dołączanie do jednego pliku w czasie. Można również użyć <xref:System.IO.File> klasy do pobierania i ustawiania atrybutów pliku lub <xref:System.DateTime> informacje dotyczące tworzenia, uzyskują dostęp do zapisu pliku. Jeśli chcesz wykonywać operacje na wielu plików, zobacz <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> lub <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Duża liczba <xref:System.IO.File> metody zwracają inne typy operacji We/Wy podczas tworzenia lub otwierania plików. Można używać innych typów je do dalszego modyfikowania pliku. Aby uzyskać więcej informacji, zobacz określonych <xref:System.IO.File> elementów członkowskich, takich jak <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, lub <xref:System.IO.File.Create%2A>.  
  
 Ponieważ wszystkie <xref:System.IO.File> metody są statyczne, może być bardziej wydajne, aby użyć <xref:System.IO.File> zamiast odpowiadającego <xref:System.IO.FileInfo> metody wystąpienia, jeśli chcesz wykonać tylko jedną akcję. Wszystkie <xref:System.IO.File> metody wymagają ścieżkę do pliku, które modyfikujesz.  
  
 Metod statycznych <xref:System.IO.File> klasy sprawdzania zabezpieczeń dla wszystkich metod. Jeśli zamierzasz użyć ponownie obiektu, należy wziąć pod uwagę przy użyciu odpowiednich metod wystąpień <xref:System.IO.FileInfo> , ponieważ nie zawsze będą sprawdzanie zabezpieczeń należy.  
  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników.  
  
 W poniższej tabeli opisano wyliczenia, które są używane, aby dostosować zachowanie różnych <xref:System.IO.File> metody.  
  
|Wyliczenie|Opis|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Określa odczytu i zapisu do pliku.|  
|<xref:System.IO.FileShare>|Określa poziom dostępu do pliku, który jest już używana.|  
|<xref:System.IO.FileMode>|Określa, czy zachowana lub zastąpienie zawartość istniejącego pliku i określa, czy żądania utworzenia istniejący plik spowodowało wyjątku.|  
  
> [!NOTE]
>  W elementach członkowskich, które akceptują ścieżki jako ciąg wejściowy że ścieżka musi być poprawnie sformułowany lub zgłoszony wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale rozpoczyna się od spacji, ścieżka nie jest usuwane w metody klasy. W związku z tym ścieżka jest nieprawidłowo sformułowany i zgłoszony wyjątek. Podobnie ścieżkę lub kombinację ścieżki nie może być w pełni kwalifikowana dwa razy. Na przykład "c:\temp c:\windows" również zgłasza wyjątek w większości przypadków. Upewnij się, czy z ścieżki są poprawnie sformułowany, gdy przy użyciu metod, które przyjmują ciąg ścieżki.  
  
 W elementach członkowskich, które akceptują ścieżką ścieżka może odwoływać się do pliku lub po prostu katalogu. Określona ścieżka znajdują się ścieżką względną lub ścieżką Universal Naming Convention (UNC) dla nazwy serwera i udziału. Na przykład następujące są dopuszczalne ścieżki:  
  
-   "c:\\\MyDir\\\MyFile.txt" w języku C# lub "c:\MyDir\MyFile.txt" w języku Visual Basic.  
  
-   "c:\\\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.  
  
-   "MyDir\\\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" w języku C# lub "\\\MyServer\MyShare" w języku Visual Basic.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.IO.File> klasę, aby sprawdzić, czy plik istnieje, a w zależności od wyniku albo utwórz nowy plik i zapisywać do niego, lub Otwórz istniejący plik i odczytanie z niego. Przed uruchomieniem kodu, należy utworzyć `c:\temp` folderu.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza wiersze do pliku, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Plik do wiersze do dołączenia. Plik jest tworzony, jeśli jeszcze nie istnieje.</param>
        <param name="contents">Wiersze do dołączenia do pliku.</param>
        <summary>Dołącza wiersze do pliku, a następnie zamyka plik. Jeśli określony plik nie istnieje, ta metoda tworzy plik, zapisuje określonych wierszy w pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowe katalogi. W związku z tym wartość `path` parametr może zawierać istniejące katalogi.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wybranych wierszy z przykładowy plik danych do pliku, a następnie dołącza więcej wierszy. Katalog o nazwie `temp` na dysku C musi istnieć na przykład pomyślnie.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden więcej nieprawidłowych znaków zdefiniowanych przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="path" /> lub <paramref name="contents" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowa (np. katalog nie istnieje lub jest mapowany dysk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony przez <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnienia do zapisu do pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Plik do wiersze do dołączenia. Plik jest tworzony, jeśli jeszcze nie istnieje.</param>
        <param name="contents">Wiersze do dołączenia do pliku.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Dołącza wiersze do pliku przy użyciu określonego kodowania, a następnie zamyka plik. Jeśli określony plik nie istnieje, ta metoda tworzy plik, zapisuje określonych wierszy w pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowe katalogi. W związku z tym wartość `path` parametr może zawierać istniejące katalogi.  
  
 Ta metoda służy do utworzenia pliku, który zawiera następujące elementy:  
  
-   Wyniki [LINQ do obiektów](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) zapytanie w wierszach pliku, jak uzyskać za pomocą <xref:System.IO.File.ReadLines%2A> metody.  
  
-   Zawartość kolekcji, który implementuje <xref:System.Collections.Generic.IEnumerable%601> ciągów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden więcej nieprawidłowych znaków zdefiniowanych przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="path" />, <paramref name="contents" />, lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowa (np. katalog nie istnieje lub jest mapowany dysk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony przez <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza określony stringto plików, tworzenie pliku, jeśli jeszcze nie istnieje.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik do dołączenia do określonego ciągu.</param>
        <param name="contents">Ciąg do dołączenia do pliku.</param>
        <summary>Otwiera plik, dołącza określony ciąg do pliku, a następnie zamyka plik. Jeśli plik nie istnieje, ta metoda tworzy plik, zapisuje określony ciąg do pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podany ciąg i ścieżka pliku, ta metoda otwiera określony plik, dołącza ciąg na końcu pliku, a następnie zamyka plik. Dojście do pliku gwarancji zamknięte przez tę metodę, nawet wtedy, gdy wyjątki są zgłaszane.  
  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowe katalogi. W związku z tym wartość `path` parametr może zawierać istniejące katalogi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.AppendAllText%2A> metodę, aby dodać dodatkowy tekst na końcu pliku. W tym przykładzie jest tworzony plik, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego. Jednak katalog o nazwie `temp` na dysku C musi istnieć na przykład pomyślnie.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (np. katalog nie istnieje lub jest mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Plik do dołączenia do określonego ciągu.</param>
        <param name="contents">Ciąg do dołączenia do pliku.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Dołącza określony ciąg do plików, tworzenie pliku, jeśli jeszcze nie istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podany ciąg i ścieżka pliku, ta metoda otwiera określony plik, dołącza ciąg na końcu pliku przy użyciu określonego kodowania, a następnie zamyka plik. Dojście do pliku gwarancji zamknięte przez tę metodę, nawet wtedy, gdy wyjątki są zgłaszane.  
  
 Metoda tworzy plik, jeśli nie istnieje, ale nie tworzy nowe katalogi. W związku z tym wartość `path` parametr może zawierać istniejące katalogi.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.AppendAllText%2A> metodę, aby dodać dodatkowy tekst na końcu pliku. W tym przykładzie jest tworzony plik, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego. Jednak katalog o nazwie `temp` na dysku C musi istnieć na przykład pomyślnie.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (np. katalog nie istnieje lub jest mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku, aby dołączyć do.</param>
        <summary>Tworzy <see cref="T:System.IO.StreamWriter" /> który dołącza tekst UTF-8 kodowany do istniejącego pliku lub do nowego pliku, jeśli określony plik nie istnieje.</summary>
        <returns>Edytor strumienia, który dołącza UTF-8 kodowany tekst do określonego pliku lub do nowego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> przeładowania konstruktora. Jeśli plik określony przez `path` nie istnieje, jest tworzona. Jeśli plik istnieje, operacje zapisu mają <xref:System.IO.StreamWriter> dołączać tekstu do pliku. Dodatkowe wątki mogą odczytać pliku, gdy jest otwarty.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `path` Parametr nie jest rozróżniana wielkość liter.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład dołącza tekstu do pliku. Metoda tworzy nowy plik, jeśli plik nie istnieje. Jednak katalog o nazwie `temp` na dysku C musi istnieć na przykład pomyślnie.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (np. katalog nie istnieje lub jest mapowany dysk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do dołączenia do określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje istniejący plik do nowego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destFileName">Nazwa pliku docelowego. Nie może to być katalog lub istniejący plik.</param>
        <summary>Kopiuje istniejący plik do nowego pliku. Zastępowanie pliku o tej samej nazwie nie jest dozwolone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> przeciążenie metody z `overwrite` ustawiono parametr `false`.  
  
 `sourceFileName` i `destFileName` parametry można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> metody. Ta metoda nie obsługuje symboli wieloznacznych w parametrach.  
  
 Atrybuty oryginalnego pliku są przechowywane w skopiowany plik.  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje pliki do folderu kopii zapasowej C:\archives\2008. Używa dwóch przeciążeń <xref:System.IO.File.Copy%2A> metody w następujący sposób:  
  
-   Najpierw używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> przeciążenie metody, aby skopiować pliki tekstowy (txt). Kod pokazuje, że to przeciążenie nie zezwala na zastępowanie plików, które zostały już skopiowane.  
  
-   Następnie używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody do skopiowania obrazów (pliki jpg). Kod pokazuje, że to przeciążenie umożliwia zastąpienie plików, które zostały już skopiowane.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 —lub—  
  
 <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> Określa katalog.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> Nie znaleziono.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> istnieje.  
  
 —lub—  
  
 Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z <paramref name="sourceFileName" /> i zapisywanie do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Plik do skopiowania.</param>
        <param name="destFileName">Nazwa pliku docelowego. To nie może być katalogiem.</param>
        <param name="overwrite">
          <see langword="true" /> Jeśli plik docelowy, mogą zostać zastąpione; w przeciwnym razie <see langword="false" />.</param>
        <summary>Kopiuje istniejący plik do nowego pliku. Zastępowanie pliku o tej samej nazwie jest dozwolone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` i `destFileName` parametry można określić ścieżkę względną lub bezwzględną informacje. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Ta metoda nie obsługuje symboli wieloznacznych w parametrach.  
  
 Atrybuty oryginalnego pliku są przechowywane w skopiowany plik.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje pliki do folderu kopii zapasowej C:\archives\2008. Używa dwóch przeciążeń <xref:System.IO.File.Copy%2A> metody w następujący sposób:  
  
-   Najpierw używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> przeciążenie metody, aby skopiować pliki tekstowy (txt). Kod pokazuje, że to przeciążenie nie zezwala na zastępowanie plików, które zostały już skopiowane.  
  
 Następnie używa <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenie metody do skopiowania obrazów (pliki jpg). Kod pokazuje, że to przeciążenie umożliwia zastąpienie plików, które zostały już skopiowane.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="destFileName" /> jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 —lub—  
  
 <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> Określa katalog.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> Nie znaleziono.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> istnieje i <paramref name="overwrite" /> jest <see langword="false" />.  
  
 —lub—  
  
 Wystąpił błąd we/wy.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z <paramref name="sourceFileName" /> i zapisywanie do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik w określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku do utworzenia.</param>
        <summary>Tworzy lub zastąpienie plików w określonej ścieżce.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> zapewniający dostęp do odczytu i zapisu do pliku określonego w <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream> Obiekt utworzony przez tę metodę ma wartość domyślną <xref:System.IO.FileShare> wartość <xref:System.IO.FileShare.None>; żaden inny proces lub kod dostęp do utworzonego pliku do czasu zamknięcia oryginalnego dojście do pliku.  
  
 Ta metoda jest odpowiednikiem <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> przeciążenie metody przy użyciu domyślny rozmiar buforu.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli określony plik nie istnieje, jest tworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość zostaną zastąpione.  
  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników. Plik jest otwarty do odczytu/zapisu i muszą zostać zamknięte przed może być otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy plik w określonej ścieżce, zapisuje informacje w pliku i odczytuje z pliku.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="path" /> określony plik jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu do pliku opisanego przez <paramref name="path" /> parametru. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> . Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku.</param>
        <param name="bufferSize">Liczba buforowanych bajtów na potrzeby odczytuje i zapisuje dane w pliku.</param>
        <summary>Tworzy lub zastępuje określonego pliku.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> z określony rozmiar buforu, który zapewnia dostęp do odczytu i zapisu do pliku określonego w <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream> Obiekt utworzony przez tę metodę ma wartość domyślną <xref:System.IO.FileShare> wartość <xref:System.IO.FileShare.None>; żaden inny proces lub kod dostęp do utworzonego pliku do czasu zamknięcia oryginalnego dojście do pliku.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ta metoda jest odpowiednikiem <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> przeładowania konstruktora. Jeśli określony plik nie istnieje, jest tworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość zostaną zastąpione.  
  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników. Plik jest otwarty do odczytu/zapisu i muszą zostać zamknięte przed może być otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy plik z określony rozmiar buforu.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="path" /> określony plik jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu do pliku opisanego przez <paramref name="path" /> parametru. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku.</param>
        <param name="bufferSize">Liczba buforowanych bajtów na potrzeby odczytuje i zapisuje dane w pliku.</param>
        <param name="options">Jeden z <see cref="T:System.IO.FileOptions" /> wartości, które opisano sposób tworzenia i Zastąp plik.</param>
        <summary>Tworzy lub zastępuje określonego pliku, określania rozmiaru buforu i <see cref="T:System.IO.FileOptions" /> wartość, która opisuje sposób tworzenia i Zastąp plik.</summary>
        <returns>Nowy plik o określony rozmiar buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ta metoda jest odpowiednikiem <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> przeładowania konstruktora. Jeśli określony plik nie istnieje, jest tworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość zostaną zastąpione.  
  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników. Plik jest otwarty do odczytu/zapisu i muszą zostać zamknięte przed może być otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="path" /> określony plik jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest on mapowany dysk.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu do pliku opisanego przez <paramref name="path" /> parametru. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku.</param>
        <param name="bufferSize">Liczba buforowanych bajtów na potrzeby odczytuje i zapisuje dane w pliku.</param>
        <param name="options">Jeden z <see cref="T:System.IO.FileOptions" /> wartości, które opisano sposób tworzenia i Zastąp plik.</param>
        <param name="fileSecurity">Jeden z <see cref="T:System.Security.AccessControl.FileSecurity" /> wartości, które określa kontroli dostępu i inspekcji zabezpieczeń dla pliku.</param>
        <summary>Tworzy lub zastępuje określony plik określony rozmiar buforu, opcje pliku i plik zabezpieczeń.</summary>
        <returns>Nowy plik o określony rozmiar buforu, opcje pliku i plik zabezpieczeń.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ta metoda jest odpowiednikiem <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> przeładowania konstruktora. Jeśli określony plik nie istnieje, jest tworzony; Jeśli istnieje i nie jest tylko do odczytu, zawartość zostaną zastąpione.  
  
 Domyślnie pełna odczytu/zapisu do nowych plików dostęp do wszystkich użytkowników. Plik jest otwarty do odczytu/zapisu i muszą zostać zamknięte przed może być otwarty przez inną aplikację.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="path" /> określony plik jest tylko do odczytu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas tworzenia pliku.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu do pliku opisanego przez <paramref name="path" /> parametru. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do zapisu.</param>
        <summary>Tworzy lub otwierania pliku do pisania kodowany w formacie UTF-8. Jeśli plik już istnieje, jej zawartość zostaną zastąpione.</summary>
        <returns>A <see cref="T:System.IO.StreamWriter" /> zapisuje określony plik przy użyciu kodowania UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> przeładowania konstruktora z `append` ustawiono parametr `false`. Jeśli plik określony przez `path` nie istnieje, jest tworzona. Jeśli plik istnieje, jego zawartość zostaną zastąpione. Dodatkowe wątki mogą odczytać pliku, gdy jest otwarty.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy plik tekstu, zapisywanie i odczytywanie.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżki, która opisuje pliku do odszyfrowania.</param>
        <summary>Odszyfrowuje pliku, która została zaszyfrowana przy użyciu bieżącego konta <see cref="M:System.IO.File.Encrypt(System.String)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Decrypt%2A> Metoda służy do odszyfrowywania plików, która została zaszyfrowana przy użyciu <xref:System.IO.File.Encrypt%2A> metody.  <xref:System.IO.File.Decrypt%2A> Metody może odszyfrować tylko pliki, które zostały zaszyfrowane przy użyciu bieżącego konta użytkownika.  
  
 <xref:System.IO.File.Decrypt%2A> Metoda wymaga wyłącznego dostępu do pliku, odszyfrowywany i zgłosi wyjątek, jeśli inny proces jest używany plik. Jeśli plik nie jest zaszyfrowany, <xref:System.IO.File.Decrypt%2A> zwróci wartość różną od zera, co oznacza Powodzenie.  
  
 Zarówno <xref:System.IO.File.Encrypt%2A> — metoda i <xref:System.IO.File.Decrypt%2A> metoda korzysta z dostawcy usług kryptograficznych (CSP) zainstalowany na komputerze i kluczy szyfrowania pliku procesu podczas wywoływania metody.  
  
 Bieżący system plików musi być sformatowany jako NTFS i bieżący system operacyjny musi być systemu Windows NT lub nowszego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.File.Encrypt%2A> — metoda i <xref:System.IO.File.Decrypt%2A> metody do szyfrowania i odszyfrowywania następnie pliku. Plik musi istnieć na przykład do pracy.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez <paramref name="path" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy. Na przykład zaszyfrowany plik jest już otwarty.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.NotSupportedException">System plików nie jest systemu plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> Katalog określony parametr.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu do pliku opisanego przez <paramref name="path" /> parametru. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa pliku, który ma zostać usunięty. Symbole wieloznaczne nie są obsługiwane.</param>
        <summary>Usuwa określony plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określ nazwę pliku z żadnych informacji ścieżkę względną lub bezwzględną `path` parametru. Symboli wieloznacznych nie można dołączyć. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli plik do usunięcia nie istnieje, nie jest wyjątek.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład powoduje skopiowanie grupy plików do folderu kopii zapasowej C:\archives\2008 i usunie je z folderu źródłowego.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Określony plik jest w użyciu.  
  
 —lub—  
  
 Jest otwarte dojście do pliku, a systemu operacyjnego Windows XP lub starszym. Ta otwarte dojście może wynikać z wyliczanie katalogów i plików. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i plików](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 Plik jest plikiem wykonywalnym, który jest używany.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.  
  
 —lub—  
  
 <paramref name="path" /> określony plik tylko do odczytu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w przypadku usunięcia określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżki, w której opisano plików do szyfrowania.</param>
        <summary>Szyfruje pliku, dzięki czemu można go odszyfrować tylko konto używane do szyfrowania pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Encrypt%2A> — Metoda umożliwia zaszyfrowanie pliku, dzięki czemu można go odszyfrować tylko konto używane do wywołania tej metody. Użyj <xref:System.IO.File.Decrypt%2A> metody do odszyfrowania zaszyfrowanych przez plik <xref:System.IO.File.Encrypt%2A> metody.  
  
 <xref:System.IO.File.Encrypt%2A> Metoda wymaga wyłącznego dostępu do pliku szyfrowany i zakończy się niepowodzeniem, jeśli inny proces jest używany plik.  
  
 Zarówno <xref:System.IO.File.Encrypt%2A> — metoda i <xref:System.IO.File.Decrypt%2A> metoda korzysta z dostawcy usług kryptograficznych (CSP) zainstalowany na komputerze i kluczy szyfrowania pliku procesu podczas wywoływania metody.  
  
 Ta metoda nie jest dostępna we wszystkich wersjach systemu Windows. Na przykład nie jest dostępne w wersji głównej.  
  
 Bieżący system plików musi być sformatowany jako NTFS.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.File.Encrypt%2A> — metoda i <xref:System.IO.File.Decrypt%2A> metody do szyfrowania i odszyfrowywania następnie pliku. Plik musi istnieć na przykład do pracy.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez <paramref name="path" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest częścią systemu Windows NT lub nowszego.</exception>
        <exception cref="T:System.NotSupportedException">System plików nie jest systemu plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> Katalog określony parametr.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do odczytu i zapisu do pliku opisanego przez <paramref name="path" /> parametru. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik do sprawdzenia.</param>
        <summary>Określa, czy określony plik istnieje.</summary>
        <returns>
          <see langword="true" /> Jeśli element wywołujący ma wymagane uprawnienia i <paramref name="path" /> zawiera nazwę istniejącego pliku; w przeciwnym razie <see langword="false" />. Ta metoda zwraca również wartość <see langword="false" /> Jeśli <paramref name="path" /> jest <see langword="null" />, nieprawidłową ścieżkę lub ciągiem o zerowej długości. Jeśli element wywołujący nie ma wystarczających uprawnień do odczytu określonego pliku, nie wyjątku i metoda zwraca <see langword="false" /> bez względu na istnienie <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Exists%2A> — Metoda nie powinna być używana do sprawdzania poprawności ścieżki, ta metoda sprawdza tylko, jeśli plik określony w `path` istnieje. Nieprawidłowa ścieżka do przekazywania <xref:System.IO.File.Exists%2A> zwraca `false`. Aby sprawdzić, czy ścieżka zawiera nieprawidłowe znaki, można wywołać <xref:System.IO.Path.GetInvalidPathChars%2A> metoda pobierania znaków, które nie są prawidłowe dla systemu plików. Można również utworzyć wyrażenie regularne, aby sprawdzić, czy ścieżka jest prawidłowa dla danego środowiska. Przykłady dopuszczalne ścieżkach można znaleźć <xref:System.IO.File>.  
  
 Aby sprawdzić, czy katalog istnieje, zobacz <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Należy pamiętać, że inny proces może potencjalnie Zrób coś z pliku jednocześnie w momencie wywołania <xref:System.IO.File.Exists%2A> — metoda i wykonywanie innej operacji na pliku, takich jak <xref:System.IO.File.Delete%2A>.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli `path` opisuje katalogu, ta metoda zwraca `false`. Spacje są usuwane z `path` parametru przed określenie, czy plik istnieje.  
  
 <xref:System.IO.File.Exists%2A> Metoda zwraca `false` przypadku wystąpieniu błędu podczas próby określenia, czy istnieje określony plik. Taka sytuacja może wystąpić w sytuacji, które powodują wystąpienie wyjątków, takich jak przekazanie nazwę pliku z nieprawidłowe znaki lub zbyt wiele znaków, wystąpił błąd lub Brak dysku, lub jeśli element wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład określa, czy plik istnieje.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileInfo.GetAccessControl%2A> metody do pobierania dostępu kontrolują wpisy listę kontroli dostępu (ACL) dla określonego pliku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku zawierającego <see cref="T:System.Security.AccessControl.FileSecurity" /> obiektu, który opisuje informacji listę kontroli dostępu (ACL) kontroli dostępu do pliku.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący listę kontroli dostępu (ACL) wpisy kontroli dostępu dla określonego pliku.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.FileSecurity" /> reguł obiekt hermetyzujący kontroli dostępu dla plików opisanego przez <paramref name="path" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.File.GetAccessControl%2A> metodę, aby pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu do pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 W środowiskach NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przypisywane do użytkownika, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia folderu nadrzędnego. Odrzucanie <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w nadrzędnym katalogu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.File.GetAccessControl%2A> i <xref:System.IO.File.SetAccessControl%2A> metody, aby dodać, a następnie usuń dostęp kontrolować wpis listę kontroli dostępu (ACL) z pliku.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> Katalog określony parametr.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać uprawnienia do odczytu listy kontroli dostępu. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku zawierającego <see cref="T:System.Security.AccessControl.FileSecurity" /> obiektu, który opisuje informacji listę kontroli dostępu (ACL) kontroli dostępu do pliku.</param>
        <param name="includeSections">Jeden z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, które określają typ dostępu kontrolować listę kontroli dostępu (ACL) informacje do odbierania.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt hermetyzujący określonego typu z kontroli dostępu listę kontroli dostępu (ACL) dla określonego pliku.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.FileSecurity" /> reguł obiekt hermetyzujący kontroli dostępu dla plików opisanego przez <paramref name="path" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.File.GetAccessControl%2A> metodę, aby pobrać listę kontroli dostępu (ACL) wpisy kontroli dostępu do pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 W środowiskach NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przypisywane do użytkownika, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia folderu nadrzędnego. Odrzucanie <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w nadrzędnym katalogu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> Katalog określony parametr.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać uprawnienia do odczytu listy kontroli dostępu. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku.</param>
        <summary>Pobiera <see cref="T:System.IO.FileAttributes" /> pliku w ścieżce.</summary>
        <returns>
          <see cref="T:System.IO.FileAttributes" /> Pliku w ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetAttributes` i `SetAttributes` metod, stosując `Archive` i `Hidden` atrybutów pliku.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pusta, zawiera tylko białe znaki lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> reprezentuje plik i jest nieprawidłowy, np. nie można znaleźć w mapowany dysk lub plik.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> reprezentuje katalog i jest nieprawidłowy, np. nie można znaleźć w mapowany dysk lub katalogu.</exception>
        <exception cref="T:System.IO.IOException">Ten plik jest używany przez inny proces.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji o datę i godzinę utworzenia.</param>
        <summary>Zwraca Data i godzina utworzenia określonego pliku lub katalogu.</summary>
        <returns>A <see cref="T:System.DateTime" /> struktury wartość daty i godziny dla określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli plik opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 Dysków NTFS może pamięci podręcznej informacje o pliku, takie jak czas utworzenia pliku, w krótkim okresie czasu. W związku z tym może być konieczne jawnie ustawiona godzina utworzenia pliku, zastępowanie lub zastąpienie istniejącego pliku.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji o datę i godzinę utworzenia.</param>
        <summary>Zwraca daty i godziny, w uniwersalnego czasu koordynowanego (UTC), z określonego pliku lub katalogu.</summary>
        <returns>A <see cref="T:System.DateTime" /> struktury wartość daty i godziny dla określonego pliku lub katalogu. Ta wartość jest wyrażone według czasu UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli plik opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 Dysków NTFS może pamięci podręcznej informacje o pliku, takie jak czas utworzenia pliku, w krótkim okresie czasu. W związku z tym może być konieczne jawnie ustawiona godzina utworzenia pliku, zastępowanie lub zastąpienie istniejącego pliku.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.IO.File.GetCreationTimeUtc%2A> metody.  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, do którego będzie można uzyskać dostępu do informacji daty i godziny.</param>
        <summary>Zwraca określony datę i godzinę ostatniego udostępnienia pliku lub katalogu.</summary>
        <returns>A <see cref="T:System.DateTime" /> struktury ustawioną datę i godzinę ostatniego udostępnienia określonego pliku lub katalogu. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli plik opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, do którego będzie można uzyskać dostępu do informacji daty i godziny.</param>
        <summary>Zwraca datę i godzinę, w uniwersalnego czasu koordynowanego (UTC), ostatniego udostępnienia określonego pliku lub katalogu.</summary>
        <returns>A <see cref="T:System.DateTime" /> struktury ustawioną datę i godzinę ostatniego udostępnienia określonego pliku lub katalogu. Ta wartość jest wyrażone według czasu UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny.  
  
 Jeśli plik opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji o datę i godzinę zapisu.</param>
        <summary>Zwraca datę i godzinę określonego pliku lub katalogu zostały ostatnio zapisane.</summary>
        <returns>A <see cref="T:System.DateTime" /> struktury ustawioną datę i godzinę określonego pliku lub katalogu zostały ostatnio zapisane. Ta wartość jest wyrażona w czasie lokalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny. Każdy system operacyjny zarządza ostatniego zapisu zgodnie z własnych reguł. Aby zwiększyć wydajność, system operacyjny może nie ustawiono wartości w czasie ostatniego zapisu dokładny czas ostatniej operacji zapisu, ale może ustawić ją na Zamknij zbliżenia zamiast tego.  
  
 Jeśli plik opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego można uzyskać informacji o datę i godzinę zapisu.</param>
        <summary>Zwraca datę i godzinę, w uniwersalnego czasu koordynowanego (UTC), określonego pliku lub katalogu ostatnio zapisany do.</summary>
        <returns>A <see cref="T:System.DateTime" /> struktury ustawioną datę i godzinę określonego pliku lub katalogu zostały ostatnio zapisane. Ta wartość jest wyrażone według czasu UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ta metoda może zwracać wartość niedokładne, ponieważ używa funkcji natywnych, których wartości nie może być stale aktualizowany przez system operacyjny. Każdy system operacyjny zarządza ostatniego zapisu zgodnie z własnych reguł. Aby zwiększyć wydajność, system operacyjny może nie ustawiono wartości w czasie ostatniego zapisu dokładny czas ostatniej operacji zapisu, ale może ustawić ją na Zamknij zbliżenia zamiast tego.  
  
 Jeśli plik opisanego w `path` parametr nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC).  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku do przeniesienia. Może zawierać ścieżkę względną lub bezwzględną.</param>
        <param name="destFileName">Nową ścieżkę i nazwę pliku.</param>
        <summary>Przenosi określony plik do nowej lokalizacji, zapewniając opcję, aby określić nową nazwę pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda działa na woluminach dysku, a jej nie zgłasza wyjątek, jeśli źródłowy i docelowy są takie same. Należy pamiętać, jeśli zastąpienie pliku przenoszenie plików o takiej samej nazwie do tego katalogu, możesz uzyskać <xref:System.IO.IOException>. Nie można użyć metody Move, aby zastąpić istniejący plik.  
  
 `sourceFileName` i `destFileName` argumenty mogą one obejmować informacje ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Jeśli przy próbie przeniesienia pliku na woluminach dysku, czy plik jest w użyciu, plik jest kopiowany do lokalizacji docelowej, ale nie zostanie usunięta ze źródła.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład przenosi plik.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Plik docelowy już istnieje.  
  
 —lub—  
  
 <paramref name="sourceFileName" /> Nie znaleziono.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera nieprawidłowe znaki, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka określona w <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest nieprawidłowy, (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> lub <paramref name="destFileName" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z <paramref name="sourceFileName" /> i zapisywanie do <paramref name="destFileName" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera <see cref="T:System.IO.FileStream" /> na określonej ścieżce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Aby otworzyć plik.</param>
        <param name="mode">A <see cref="T:System.IO.FileMode" /> wartość, która określa, czy plik jest tworzony, jeśli nie istnieje i określa, czy zawartość istniejące pliki są zachowywane lub zastąpienie.</param>
        <summary>Otwiera <see cref="T:System.IO.FileStream" /> na określonej ścieżce z dostępem do odczytu/zapisu.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> otwarty w określonym trybie i ścieżki z dostępem do odczytu/zapisu i nie udostępniać.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy plik tymczasowy i zapisuje tekst. Przykład otwarcie pliku przy użyciu T:System.IO.FileMode.Open; oznacza to jeśli plik już nie istniał, jego czy nie można utworzyć.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" /> i określony plik jest plikiem ukrytym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> Określono nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać odczytywanie z oraz zapisywanie do określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Aby otworzyć plik.</param>
        <param name="mode">A <see cref="T:System.IO.FileMode" /> wartość, która określa, czy plik jest tworzony, jeśli nie istnieje i określa, czy zawartość istniejące pliki są zachowywane lub zastąpienie.</param>
        <param name="access">A <see cref="T:System.IO.FileAccess" /> wartość, która określa operacje wykonywane na pliku.</param>
        <summary>Otwiera <see cref="T:System.IO.FileStream" /> na określonej ścieżce, przy użyciu określonego trybu i dostęp.</summary>
        <returns>Nieudostępnionych <see cref="T:System.IO.FileStream" /> zapewniający dostęp do określonego pliku z określonego trybu i dostępem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku z dostępem tylko do odczytu.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 —lub—  
  
 <paramref name="access" /> określony <see langword="Read" /> i <paramref name="mode" /> określonego <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" />, lub <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu i <paramref name="access" /> nie jest <see langword="Read" />.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" /> i określony plik jest plikiem ukrytym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> lub <paramref name="access" /> określono nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać odczytywanie z oraz zapisywanie do określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Aby otworzyć plik.</param>
        <param name="mode">A <see cref="T:System.IO.FileMode" /> wartość, która określa, czy plik jest tworzony, jeśli nie istnieje i określa, czy zawartość istniejące pliki są zachowywane lub zastąpienie.</param>
        <param name="access">A <see cref="T:System.IO.FileAccess" /> wartość, która określa operacje wykonywane na pliku.</param>
        <param name="share">A <see cref="T:System.IO.FileShare" /> określająca typ dostępu ma innych wątków do pliku.</param>
        <summary>Otwiera <see cref="T:System.IO.FileStream" /> na określonej ścieżce, mających określony tryb o odczytu, zapisu lub odczytu/zapisu dostępu i określona opcja udostępniania.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> na określonej ścieżce, mających określony tryb o odczytu, zapisu lub odczytu/zapisu dostępu i określona opcja udostępniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład otwiera plik z dostęp tylko do odczytu i udostępnianie plików niedozwolone.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 —lub—  
  
 <paramref name="access" /> określony <see langword="Read" /> i <paramref name="mode" /> określonego <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" />, lub <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu i <paramref name="access" /> nie jest <see langword="Read" />.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="mode" /> jest <see cref="F:System.IO.FileMode.Create" /> i określony plik jest plikiem ukrytym.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" />, <paramref name="access" />, lub <paramref name="share" /> określono nieprawidłową wartość.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać odczytywanie z oraz zapisywanie do określonego pliku. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do odczytu.</param>
        <summary>Otwiera istniejący plik do odczytu.</summary>
        <returns>Tylko do odczytu <see cref="T:System.IO.FileStream" /> na określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> przeładowania konstruktora z <xref:System.IO.FileMode> wartość <xref:System.IO.FileMode.Open>, <xref:System.IO.FileAccess> wartość <xref:System.IO.FileAccess.Read> i <xref:System.IO.FileShare> wartość <xref:System.IO.FileShare.Read>.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku do odczytu.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do odczytu.</param>
        <summary>Otwiera istniejący plik kodowany tekst UTF-8 do odczytu.</summary>
        <returns>A <see cref="T:System.IO.StreamReader" /> na określonej ścieżce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.IO.StreamReader.%23ctor%28System.String%29> przeładowania konstruktora.  
  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku tekstowego do odczytu.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do czytania z określonego pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, który ma zostać otwarty do zapisu.</param>
        <summary>Otwiera istniejący plik lub tworzy nowy plik do zapisu.</summary>
        <returns>Nieudostępnionych <see cref="T:System.IO.FileStream" /> obiekt na określonej ścieżce z <see cref="F:System.IO.FileAccess.Write" /> dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest odpowiednikiem <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> przeładowania konstruktora tryb pliku ustawiono na <xref:System.IO.FileMode.OpenOrCreate>, dostępu ustawioną <xref:System.IO.FileAccess.Write>i ustaw tryb udostępniania <xref:System.IO.FileShare.None>.  
  
 <xref:System.IO.File.OpenWrite%2A> Metody otwiera plik, jeśli już istnieje dla ścieżki pliku lub tworzy nowy plik, jeśli jeszcze nie istnieje. Dla istniejącego pliku jego nie Dołącz nowy tekst do istniejącego tekstu. Zamiast tego zastępuje on istniejące znaki znakami nowego. W przypadku zastąpienia dłuższy ciąg (takie jak "To jest test metody OpenWrite") z krótszego ciągu (na przykład "Uruchom drugi"), ten plik zawiera mieszane ciągów ("drugi runtest metody OpenWrite").  
  
 `path` Parametr może określać ścieżkę względną lub bezwzględną informacji. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, użyj <xref:System.IO.Directory.GetCurrentDirectory%2A> metody.  
  
 Zwrócona <xref:System.IO.FileStream> nie obsługuje odczytu. Aby otworzyć plik dla odczytu i zapisu, należy użyć <xref:System.IO.File.Open%2A>.

 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład powoduje otwarcie pliku do odczytu i zapisu.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 —lub—  
  
 <paramref name="path" /> należy określić tylko do odczytu pliku lub katalogu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, aby otworzyć do odczytu.</param>
        <summary>Otwiera plik binarny, odczytuje zawartość pliku do tablicy typu byte, a następnie zamyka plik.</summary>
        <returns>Tablica bajtów zawierająca zawartość pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podana ścieżka pliku, ta metoda otwiera plik, odczytuje zawartość pliku do tablicy typu byte, a następnie zamyka plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik tekstowy, odczytuje wszystkie wiersze w pliku w tablicy ciągów, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, aby otworzyć do odczytu.</param>
        <summary>Otwiera plik tekstowy, odczytuje wszystkie wiersze w pliku, a następnie zamyka plik.</summary>
        <returns>Tablica ciągów zawierająca wszystkie wiersze w pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje wiersz każdego pliku, a następnie dodaje każdego wiersza jako elementu tablicy ciągów. Zamknięcie pliku. Wysuwu wiersza jest zdefiniowany jako sekwencję znaków powrotu karetki (\r), wiersz źródła danych ("\n") lub znak powrotu karetki natychmiast znak wiersza. Wynikowy ciąg nie zawiera Trwa przerywanie działania powrotu karetki i/lub wysuwu wiersza.  
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaczniki kolejności bajtów. Kodowanie formaty UTF-8 i UTF-32 (big-endian i little endian) mogą być wykrywane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.ReadAllLines%2A> metodę w celu wyświetlenia zawartości pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Plik, aby otworzyć do odczytu.</param>
        <param name="encoding">Kodowanie stosowane do zawartości pliku.</param>
        <summary>Otwiera plik, odczytuje wszystkie wiersze w pliku przy użyciu określonego kodowania, a następnie zamyka plik.</summary>
        <returns>Tablica ciągów zawierająca wszystkie wiersze w pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje wiersz każdego pliku, a następnie dodanie każdego wiersza jako elementu tablicy ciągów. Zamknięcie pliku. Wysuwu wiersza jest zdefiniowany jako sekwencję znaków powrotu karetki (\r), wiersz źródła danych ("\n") lub znak powrotu karetki natychmiast znak wiersza. Wynikowy ciąg nie zawiera Trwa przerywanie działania powrotu karetki i/lub wysuwu wiersza.  
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaczniki kolejności bajtów. Kodowanie formaty UTF-8 i UTF-32 (big-endian i little endian) mogą być wykrywane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.ReadAllLines%2A> metodę w celu wyświetlenia zawartości pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik tekstowy, odczytuje wszystkie wiersze w pliku w ciągu, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik, aby otworzyć do odczytu.</param>
        <summary>Otwiera plik tekstowy, odczytuje wszystkie wiersze w pliku, a następnie zamyka plik.</summary>
        <returns>Ciąg zawierający wszystkie wiersze w pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje wiersz każdego pliku, a następnie dodanie każdego wiersza jako elementu ciągu. Zamknięcie pliku. Wysuwu wiersza jest zdefiniowany jako sekwencję znaków powrotu karetki (\r), wiersz źródła danych ("\n") lub znak powrotu karetki natychmiast znak wiersza. Wynikowy ciąg nie zawiera Trwa przerywanie działania powrotu karetki i/lub wysuwu wiersza.  
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaczniki kolejności bajtów. Kodowanie formaty UTF-8 i UTF-32 (big-endian i little endian) mogą być wykrywane.  
  
 Użyj <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> przeciążenie metody podczas odczytywania plików, które mogą zawierać importowanych tekstach, ponieważ nierozpoznane znaki mogą nie być odczytywane poprawnie.  
  
 Dojście do pliku gwarancji zamknięte przez tę metodę, nawet wtedy, gdy wyjątki są zgłaszane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.ReadAllText%2A> metodę w celu wyświetlenia zawartości pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Plik, aby otworzyć do odczytu.</param>
        <param name="encoding">Kodowanie stosowane do zawartości pliku.</param>
        <summary>Otwiera plik, odczytuje wszystkie wiersze w pliku przy użyciu określonego kodowania, a następnie zamyka plik.</summary>
        <returns>Ciąg zawierający wszystkie wiersze w pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda otwiera plik, odczytuje wiersz każdego pliku, a następnie dodanie każdego wiersza jako elementu ciągu. Zamknięcie pliku. Wysuwu wiersza jest zdefiniowany jako sekwencję znaków powrotu karetki (\r), wiersz źródła danych ("\n") lub znak powrotu karetki natychmiast znak wiersza. Wynikowy ciąg nie zawiera Trwa przerywanie działania powrotu karetki i/lub wysuwu wiersza.  
  
 Ta metoda próbuje automatycznie wykryć kodowanie pliku na podstawie obecności znaczniki kolejności bajtów. Kodowanie formaty UTF-8 i UTF-32 (big-endian i little endian) mogą być wykrywane.  
  
 Dojście do pliku gwarancji zamknięte przez tę metodę, nawet wtedy, gdy wyjątki są zgłaszane.  
  
 Aby użyć ustawienia kodowania, zgodnie z konfiguracją systemu operacyjnego, należy określić <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> właściwość `encoding` parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.ReadAllText%2A> metodę w celu wyświetlenia zawartości pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony w <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do odczytu z pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje wierszy w pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Plik do odczytu.</param>
        <summary>Odczytuje wierszy w pliku.</summary>
        <returns>Wszystkie wiersze pliku lub wiersze, które są wyniku zapytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.ReadLines%2A> i <xref:System.IO.File.ReadAllLines%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.File.ReadLines%2A>, można uruchomić wyliczanie kolekcji ciągów przed zwróceniem całą kolekcję; Jeśli używasz <xref:System.IO.File.ReadAllLines%2A>, należy poczekać na całą tablicę ciągów zwracane w celu uzyskania dostępu do tablicy. W związku z tym podczas pracy z bardzo dużymi plikami <xref:System.IO.File.ReadLines%2A> może być skuteczniejsza.  
  
 Można użyć <xref:System.IO.File.ReadLines%2A> metody wykonać następujące czynności:  
  
-   Wykonaj [LINQ do obiektów](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) zapytania w pliku do uzyskania odfiltrowanego zbioru jego wierszy.  
  
-   Zapisu zwrócona Kolekcja wierszy w pliku z <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> metody, lub dołącz je do istniejącego pliku z <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> metody.  
  
-   Utwórz wystąpienie natychmiast wypełnione kolekcję, która przyjmuje <xref:System.Collections.Generic.IEnumerable%601> kolekcji ciągów dla jego konstruktora, takich jak <xref:System.Collections.Generic.IList%601> lub <xref:System.Collections.Generic.Queue%601>.  
  
 Ta metoda używa <xref:System.Text.Encoding.UTF8%2A> wartości kodowania.  
  
   
  
## Examples  
 Poniższy przykład odczytuje wiersze pliku można znaleźć wiersze zawierające określonych ciągów.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 W poniższym przykładzie użyto <xref:System.IO.File.ReadLines%2A> metoda zapytania LINQ, który wylicza wszystkie katalogi dla plików z rozszerzeniem txt, odczytuje wiersz każdego pliku i wyświetla wiersz zawiera ciąg "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony przez <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Plik do odczytu.</param>
        <param name="encoding">Kodowanie, które są stosowane do zawartości pliku.</param>
        <summary>Odczytaj wiersze pliku, który ma określonego kodowania.</summary>
        <returns>Wszystkie wiersze pliku lub wiersze, które są wyniku zapytania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia określenie kodowanie do użycia odczytu pliku.  
  
 <xref:System.IO.File.ReadLines%2A> i <xref:System.IO.File.ReadAllLines%2A> metody różnią się w następujący sposób: Jeśli używasz <xref:System.IO.File.ReadLines%2A>, możesz uruchomić wyliczanie kolekcji ciągów przed zwróceniem całą kolekcję. Jeśli używasz <xref:System.IO.File.ReadAllLines%2A>, należy poczekać na całą tablicę ciągów zwrócone, zanim dostęp do tablicy. W związku z tym podczas pracy z bardzo dużymi plikami <xref:System.IO.File.ReadLines%2A> może być skuteczniejsza.  
  
 Można użyć <xref:System.IO.File.ReadLines%2A> metody wykonać następujące czynności:  
  
-   Wykonaj [LINQ do obiektów](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) zapytania w pliku do uzyskania odfiltrowanego zbioru jego wierszy.  
  
-   Zapisu zwrócona Kolekcja wierszy w pliku z <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> metody, lub dołącz je do istniejącego pliku z <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> metody.  
  
-   Utwórz wystąpienie natychmiast wypełnione kolekcję, która przyjmuje <xref:System.Collections.Generic.IEnumerable%601> kolekcji ciągów dla jego konstruktora, takich jak <xref:System.Collections.Generic.IList%601> lub <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik określony przez <paramref name="path" /> nie został znaleziony.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje zawartość innego pliku, usunięcie oryginalnego pliku, a tworzenie kopii zapasowej pliku zastąpionego zawartość określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A> Metody Zamień zawartość innego pliku zawartość określonego pliku.  One również utworzyć kopię zapasową pliku, który został zastąpiony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku, który zastępuje pliku określonego przez <c>Parametr destinationFileName</c>.</param>
        <param name="destinationFileName">Nazwa pliku figury geometrycznej.</param>
        <param name="destinationBackupFileName">Nazwa pliku kopii zapasowej.</param>
        <summary>Zastępuje zawartość innego pliku, usunięcie oryginalnego pliku, a tworzenie kopii zapasowej pliku zastąpionego zawartość określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A> Metoda zastępuje zawartość określonego pliku zawartość innego pliku.  Tworzy kopię zapasową pliku, który został zastąpiony.  
  
 Jeśli `sourceFileName` i `destinationFileName` są na różnych woluminach, ta metoda zgłosi wyjątek. Jeśli `destinationBackupFileName` jest na innym woluminie z pliku źródłowego, pliku kopii zapasowej zostaną usunięte.  
  
 Przekaż `null` do `destinationBackupFileName` parametru, jeśli nie chcesz utworzyć kopię zapasową pliku figury geometrycznej.  

 Jeśli `destinationBackupFileName` już istnieje zostaną zastąpione zawartością `destinationFileName` pliku.
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.File.Replace%2A> metody w celu zastąpienia pliku z innego pliku i utworzyć kopię zapasową pliku zastąpionego.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka opisanego przez <paramref name="destinationFileName" /> niedozwolony format nie został parametr.  
  
 —lub—  
  
 Ścieżka opisanego przez <paramref name="destinationBackupFileName" /> niedozwolony format nie został parametr.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.  
  
 —lub—  
  
 Plik opisanego przez <paramref name="destinationBackupFileName" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.  
  
 \- lub -  
  
 <paramref name="sourceFileName" /> i <paramref name="destinationFileName" /> parametry określają tego samego pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny jest Windows 98 Wydanie drugie lub starszym i nie jest system plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="sourceFileName" /> Lub <paramref name="destinationFileName" /> parametr określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 Parametry źródłowe lub docelowe określ katalog, zamiast pliku.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać uprawnienia do zapisu do pliku opisanego przez <paramref name="destinationBackupFileName" /> parametru, jeśli został określony. Akcja zabezpieczeń: żądanie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku, który zastępuje pliku określonego przez <c>Parametr destinationFileName</c>.</param>
        <param name="destinationFileName">Nazwa pliku figury geometrycznej.</param>
        <param name="destinationBackupFileName">Nazwa pliku kopii zapasowej.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> ignorowanie błędów scalania (takich jak atrybuty i listy kontroli dostępu (ACL)) z pliku zastąpionego do pliku wymiany; w przeciwnym razie <see langword="false" />.</param>
        <summary>Zastępuje zawartość innego pliku, usunięcie oryginalnego pliku, a tworzenie kopii zapasowej pliku zastąpionego zawartość określonego pliku i opcjonalnie ignoruje błędy seryjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A> Metoda zastępuje zawartość określonego pliku zawartość innego pliku.  Tworzy kopię zapasową pliku, który został zastąpiony.  
  
 Jeśli `sourceFileName` i `destinationFileName` są na różnych woluminach, ta metoda zgłosi wyjątek. Jeśli `destinationBackupFileName` jest na innym woluminie z pliku źródłowego, pliku kopii zapasowej zostaną usunięte.  
  
 Przekaż `null` do `destinationBackupFileName` parametru, jeśli nie chcesz utworzyć kopię zapasową pliku figury geometrycznej.  

 Jeśli `destinationBackupFileName` już istnieje zostaną zastąpione zawartością `destinationFileName` pliku.
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.File.Replace%2A> metody w celu zastąpienia pliku z innego pliku i utworzyć kopię zapasową pliku zastąpionego.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka opisanego przez <paramref name="destinationFileName" /> niedozwolony format nie został parametr.  
  
 —lub—  
  
 Ścieżka opisanego przez <paramref name="destinationBackupFileName" /> niedozwolony format nie został parametr.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Określono nieprawidłowy dysk.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik opisanego przez bieżący <see cref="T:System.IO.FileInfo" /> nie można odnaleźć obiektu.  
  
 —lub—  
  
 Plik opisanego przez <paramref name="destinationBackupFileName" /> nie można odnaleźć parametru.</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.  
  
 \- lub -  
  
 <paramref name="sourceFileName" /> i <paramref name="destinationFileName" /> parametry określają tego samego pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.PlatformNotSupportedException">System operacyjny jest Windows 98 Wydanie drugie lub starszym i nie jest system plików NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="sourceFileName" /> Lub <paramref name="destinationFileName" /> parametr określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 Parametry źródłowe lub docelowe określ katalog, zamiast pliku.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać uprawnienia do zapisu do pliku opisanego przez <paramref name="destinationBackupFileName" /> parametru, jeśli został określony. Akcja zabezpieczeń: żądanie. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Aby dodać lub usunąć wpisy listę kontroli dostępu (ACL) kontroli dostępu z pliku.</param>
        <param name="fileSecurity">A <see cref="T:System.Security.AccessControl.FileSecurity" /> obiektu, który opisuje wpisu na liście ACL, można zastosować w pliku opisanego przez <c>ścieżki</c> parametru.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <see cref="T:System.Security.AccessControl.FileSecurity" /> obiekt do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.SetAccessControl%2A> Metoda stosowana wpisów listę kontroli dostępu (ACL) kontroli dostępu do pliku, który reprezentuje noninherited listy ACL.  
  
> [!CAUTION]
>  Określona lista ACL dla `fileSecurity` parametru zastępuje istniejące listy ACL dla pliku. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.File.GetAccessControl%2A> metodę, aby uzyskać istniejące listy ACL, zmodyfikuj go, a następnie użyj <xref:System.IO.File.SetAccessControl%2A> powrót do pliku.  
  
 Listy ACL opisuje fizycznych i/lub grup, którzy lub nie ma praw do określonych akcji na dany plik. Aby uzyskać więcej informacji, zobacz [porady: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 <xref:System.IO.File.SetAccessControl%2A> Metody tylko będzie się powtarzał <xref:System.Security.AccessControl.FileSecurity> obiektów, które zostały zmodyfikowane po utworzeniu obiektu.  Jeśli <xref:System.Security.AccessControl.FileSecurity> obiektu nie został zmodyfikowany, nie będzie można utrwalone w pliku.  W związku z tym nie jest możliwe do pobrania <xref:System.Security.AccessControl.FileSecurity> obiektu z jednego pliku i ponownie zastosuj ten sam obiekt do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do innego:  
  
1.  Użyj <xref:System.IO.File.GetAccessControl%2A> metoda pobierania <xref:System.Security.AccessControl.FileSecurity> obiektów z pliku źródłowego.  
  
2.  Utwórz nową <xref:System.Security.AccessControl.FileSecurity> obiektu dla pliku docelowego.  
  
3.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metody źródła <xref:System.Security.AccessControl.FileSecurity> obiekt, aby pobrać listę kontroli dostępu.  
  
4.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodę, aby skopiować dane pobierane w kroku 3 do miejsca docelowego <xref:System.Security.AccessControl.FileSecurity> obiektu.  
  
5.  Skonfiguruj docelowego <xref:System.Security.AccessControl.FileSecurity> obiektu przy użyciu pliku docelowego <xref:System.IO.File.SetAccessControl%2A> metody.  
  
 W środowiskach NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> są przypisywane do użytkownika, jeśli użytkownik ma <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> uprawnienia folderu nadrzędnego. Odrzucanie <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> i <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Odmów <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> w nadrzędnym katalogu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.File.GetAccessControl%2A> i <xref:System.IO.File.SetAccessControl%2A> metody, aby dodać, a następnie usuń dostęp kontrolować wpis listę kontroli dostępu (ACL) z pliku.  Należy podać prawidłowe konto użytkownika lub grupy do uruchomienia tego przykładu.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Parametr określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> Katalog określony parametr.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> Parametr jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia dostępu do tego pliku. Akcja zabezpieczeń: żądanie. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku.</param>
        <param name="fileAttributes">Bitowe połączenie wartości wyliczenia.</param>
        <summary>Ustawia określony <see cref="T:System.IO.FileAttributes" /> pliku na określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Niektórych plików atrybutów, takich jak <xref:System.IO.FileAttributes.Hidden> i <xref:System.IO.FileAttributes.ReadOnly>, można łączyć. Inne atrybuty, takie jak <xref:System.IO.FileAttributes.Normal>, musi zostać użyty samodzielnie.  
  
 Nie można zmienić stanu kompresji <xref:System.IO.File> przy użyciu <xref:System.IO.File.SetAttributes%2A> metody.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetAttributes` i `SetAttributes` metod, stosując `Archive` i `Hidden` atrybutów pliku.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest pusta, zawiera tylko białe znaki, zawiera nieprawidłowe znaki lub jest on nieprawidłowy atrybut pliku.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na niemapowanym dysku).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego mają zostać ustawione Data i godzina informacji o tworzeniu.</param>
        <param name="creationTime">A <see cref="T:System.DateTime" /> zawierającego wartość do ustawienia dla tworzenia Data i godzina <c>ścieżki</c>. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę utworzenia pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Dysków NTFS może buforować meta-informacje o pliku, takie jak czas utworzenia pliku, w krótkim okresie czasu. W związku z tym może być konieczne jawnie ustawiona godzina utworzenia pliku, zastępowanie lub zastąpienie istniejącego pliku.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas wykonywania operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> Określa wartość spoza zakresu dat, godzin lub obu dozwolony dla tej operacji.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego mają zostać ustawione Data i godzina informacji o tworzeniu.</param>
        <param name="creationTimeUtc">A <see cref="T:System.DateTime" /> zawierającego wartość do ustawienia dla tworzenia Data i godzina <c>ścieżki</c>. Ta wartość jest wyrażone według czasu UTC.</param>
        <summary>Ustawia datę i godzinę, w uniwersalnego czasu koordynowanego (UTC), czy plik został utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Dysków NTFS może buforować meta-informacje o pliku, takie jak czas utworzenia pliku, w krótkim okresie czasu. W związku z tym może być konieczne jawnie ustawiona godzina utworzenia pliku, zastępowanie lub zastąpienie istniejącego pliku.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas wykonywania operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> Określa wartość spoza zakresu dat, godzin lub obu dozwolony dla tej operacji.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego ustawienia dostępu do informacji daty i godziny.</param>
        <param name="lastAccessTime">A <see cref="T:System.DateTime" /> zawierającego wartość do ustawienia dla dostępu Data i godzina ostatniej <c>ścieżki</c>. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego dostępu do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład sprawdza system plików dla określonego pliku, tworzenie go w razie potrzeby, a następnie ustawia i pobiera czas ostatniego dostępu.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego ustawienia dostępu do informacji daty i godziny.</param>
        <param name="lastAccessTimeUtc">A <see cref="T:System.DateTime" /> zawierającego wartość do ustawienia dla dostępu Data i godzina ostatniej <c>ścieżki</c>. Ta wartość jest wyrażone według czasu UTC.</param>
        <summary>Ustawia datę i godzinę, w uniwersalnego czasu koordynowanego (UTC), ostatni uzyskano określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego można ustawić informacji daty i godziny.</param>
        <param name="lastWriteTime">A <see cref="T:System.DateTime" /> zawierającego wartość do ustawienia dla zapisu Data i godzina ostatniej <c>ścieżki</c>. Ta wartość jest wyrażona w czasie lokalnym.</param>
        <summary>Ustawia datę i godzinę ostatniego zapisania do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład sprawdza system plików dla określonego pliku, tworzenia pliku, jeśli to konieczne i następnie ustawia i pobiera ostatniego zapisu w pliku.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Plik, dla którego można ustawić informacji daty i godziny.</param>
        <param name="lastWriteTimeUtc">A <see cref="T:System.DateTime" /> zawierającego wartość do ustawienia dla zapisu Data i godzina ostatniej <c>ścieżki</c>. Ta wartość jest wyrażone według czasu UTC.</param>
        <summary>Ustawia datę i godzinę, w uniwersalnego czasu koordynowanego (UTC), ostatnio zapisany do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` Parametr jest zezwolenie na określanie informacji ścieżkę względną lub bezwzględną. Informacje o ścieżce względnej są interpretowane jako względne w stosunku do bieżącego katalogu roboczego. Aby uzyskać bieżący katalog roboczy, zobacz <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Aby uzyskać listę typowe zadania we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono określonej ścieżki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> Określa wartość spoza zakresu daty lub godziny, dozwolone dla tej operacji.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w określonym pliku. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="bytes">Bajty zapisu do pliku.</param>
        <summary>Tworzy nowy plik, zapisuje określonej tablicy bajtów do pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie zastąpiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podana tablica bajtów i ścieżka pliku, ta metoda otwiera określony plik, zapisuje zawartość tablica bajtów do pliku, a następnie zamyka plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" /> lub tablica bajtów jest pusty.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy plik, zapisuje jeden lub więcej ciągów w pliku, a następnie zamyka plik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="contents">Wiersze do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisuje Kolekcja ciągów w pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne zachowanie <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> metoda służy do zapisania dane przy użyciu kodowania UTF-8 bez znacznika kolejności bajtów (BOM). Jeśli konieczne jest stosowanie identyfikatorem UTF-8, takie jak znacznik kolejności bajtów na początku pliku, należy użyć <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> przeciążenie metody z <xref:System.Text.Encoding.UTF8%2A> kodowania.  
  
 Jeśli plik docelowy już istnieje, zostanie zastąpiony.  
  
 Ta metoda umożliwia tworzenie zawartości dla klasy kolekcji, która przyjmuje <xref:System.Collections.Generic.IEnumerable%601> w swoich konstruktorach, takich jak <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, lub <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> klasy.  
  
   
  
## Examples  
 Poniższy przykład zapisuje wybranych wierszy z przykładowy plik danych do pliku.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="path" /> lub <paramref name="contents" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="contents">Tablica ciągów do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisać tablicy ciągów określonego pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik docelowy już istnieje, zostanie zastąpiony.  
  
 Domyślne zachowanie <xref:System.IO.File.WriteAllLines%2A> metoda jest zapisać danych przy użyciu kodowania UTF-8 bez znacznika kolejności bajtów (BOM). Jeśli konieczne jest stosowanie identyfikatorem UTF-8, takie jak znacznik kolejności bajtów na początku pliku, należy użyć <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> przeciążenie metody z <xref:System.Text.Encoding.UTF8%2A> kodowania.  
  
 Podanej tablicy ciągów i ścieżka pliku, ta metoda otwiera określony plik, zapisuje tablicy ciągów w pliku, a następnie zamyka plik.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.WriteAllLines%2A> metodę zapisywanie tekstu do pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="path" /> lub <paramref name="contents" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="contents">Wiersze do zapisu w pliku.</param>
        <param name="encoding">Znak kodowanie do użycia.</param>
        <summary>Tworzy nowy plik przy użyciu określonego kodowania, zapisuje Kolekcja ciągów w pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik docelowy już istnieje, zostanie zastąpiony.  
  
 Ta metoda służy do utworzenia pliku, który zawiera następujące elementy:  
  
-   Wyniki [LINQ do obiektów](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) zapytanie w wierszach pliku, jak uzyskać za pomocą <xref:System.IO.File.ReadLines%2A> metody.  
  
-   Zawartość kolekcji, który implementuje <xref:System.Collections.Generic.IEnumerable%601> ciągów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="path" />, <paramref name="contents" />, lub <paramref name="encoding" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> jest nieprawidłowy (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> przekracza maksymalną długość zdefiniowana w systemie. Na przykład na platformach opartych na systemie Windows, ścieżki musi być mniejsza niż 248 znaków i nazwy pliku musi być mniejsza niż 260 znaków.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> Określa plik, który jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> jest katalogiem.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="contents">Tablica ciągów do zapisu w pliku.</param>
        <param name="encoding">
          <see cref="T:System.Text.Encoding" /> Obiekt, który reprezentuje kodowania znaków stosowane do tablicy ciągów.</param>
        <summary>Tworzy nowy plik, zapisuje tablicy określony ciąg przy użyciu określonego kodowania pliku, a następnie zamyka plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik docelowy już istnieje, zostanie zastąpiony.  
  
 Podanej tablicy ciągów i ścieżka pliku, ta metoda otwiera określony plik, zapisuje do pliku przy użyciu określonego kodowania tablicy ciągów, a następnie zamyka plik.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.WriteAllLines%2A> metodę zapisywanie tekstu do pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Albo <paramref name="path" /> lub <paramref name="contents" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowy plik, zapisanie zawartości pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie zastąpiony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="contents">Ciąg do zapisu w pliku.</param>
        <summary>Tworzy nowy plik, zapisuje określony ciąg do pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie zastąpiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa UTF-8 kodowanie bez znacznik kolejności bajtów (BOM), za pomocą <xref:System.Text.Encoding.GetPreamble%2A> metoda zwraca tablicę bajtów puste. Jeśli konieczne jest stosowanie identyfikatorem UTF-8, takie jak znacznik kolejności bajtów na początku pliku, należy użyć <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> przeciążenie metody z <xref:System.Text.Encoding.UTF8%2A> kodowania.  
  
 Podany ciąg i ścieżka pliku, ta metoda otwiera określony plik, zapisuje ciąg w pliku, a następnie zamyka plik.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.WriteAllText%2A> metodę zapisywanie tekstu do pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" /> lub <paramref name="contents" /> jest pusta.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Pliku do zapisu.</param>
        <param name="contents">Ciąg do zapisu w pliku.</param>
        <param name="encoding">Kodowanie do zastosowania do ciągu.</param>
        <summary>Tworzy nowy plik, zapisuje określony ciąg przy użyciu określonego kodowania pliku, a następnie zamyka plik. Jeśli plik docelowy już istnieje, zostanie zastąpiony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podany ciąg i ścieżka pliku, ta metoda otwiera określony plik, zapisuje ciąg do pliku przy użyciu określonego kodowania, a następnie zamyka plik. Dojście do pliku gwarancji zamknięte przez tę metodę, nawet wtedy, gdy wyjątki są zgłaszane.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.IO.File.WriteAllText%2A> metodę zapisywanie tekstu do pliku. W tym przykładzie plik jest tworzony, jeśli jeszcze nie istnieje, a tekst jest dodawany do niego.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją w <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> jest <see langword="null" /> lub <paramref name="contents" /> jest pusta.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system. Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład jest na mapowany dysk).</exception>
        <exception cref="T:System.IO.IOException">Podczas otwierania pliku wystąpił błąd We/Wy.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> określony plik jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwane na bieżącej platformie.  
  
 —lub—  
  
 <paramref name="path" /> określony katalog.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> jest w nieprawidłowym formacie.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do zapisu pliku lub katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
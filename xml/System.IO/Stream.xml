<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f796c63ceb316c8533bd75b2bb24d5c056458998" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36484001" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia ogólny widok sekwencji bajtów. To jest klasą abstrakcyjną.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> jest abstrakcyjna klasa podstawowa dla wszystkich strumieni. Strumień jest abstrakcję sekwencję bajtów, takie jak plik, urządzenia wejścia/wyjścia, potok komunikacji międzyprocesowej lub gniazda TCP/IP. <xref:System.IO.Stream> Klasy pochodne Podaj ogólny widok różnego typu dane wejściowe i wyjściowe i izolowanie programisty z szczegóły podstawowej urządzeń i systemu operacyjnego.  
  
 Strumienie obejmują trzy podstawowe operacje:  
  
-   Można czytać ze strumieni. Odczytywanie jest transferu danych ze strumienia do struktury danych, takich jak tablicę bajtów.  
  
-   Możesz zapisywać do strumieni. Zapisywanie jest transferu danych ze strukturą danych w strumieniu.  
  
-   Strumienie może obsługiwać operacji wyszukiwania. Wyszukiwanie odwołuje się do badania i modyfikowania bieżącą pozycję w strumieniu. Wyszukiwanie możliwości zależy od rodzaju magazynu zapasowego strumienia ma. Na przykład strumieni sieci nie znają ujednoliconego pojęcia bieżącej pozycji, a zatem zwykle nie obsługują przeszukiwania.  
  
 Niektórych najczęściej używanych strumieni, które dziedziczą z <xref:System.IO.Stream> są <xref:System.IO.FileStream>, i <xref:System.IO.MemoryStream>.  
  
 W zależności od tego źródła danych lub repozytorium strumienie może obsługiwać tylko niektóre z tych funkcji. Strumień dla jego możliwości można badać przy użyciu <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, i <xref:System.IO.Stream.CanSeek%2A> właściwości <xref:System.IO.Stream> klasy.  
  
 <xref:System.IO.Stream.Read%2A> i <xref:System.IO.Stream.Write%2A> metody odczytywanie i zapisywanie danych w różnych formatach. Dla strumieni, które obsługują wyszukiwanie, użyj <xref:System.IO.Stream.Seek%2A> i <xref:System.IO.Stream.SetLength%2A> metod i <xref:System.IO.Stream.Position%2A> i <xref:System.IO.Stream.Length%2A> właściwości wyszukiwania i modyfikowania bieżącej pozycji i długości strumienia.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Usuwanie <xref:System.IO.Stream> obiekt czyści wszystkie buforowane dane i zasadniczo wywołuje <xref:System.IO.Stream.Flush%2A> metodę. <xref:System.IO.Stream.Dispose%2A> również zwalnia zasoby systemu operacyjnego, takich jak dojścia do plików, połączeń sieciowych lub pamięć używana na potrzeby wewnętrznego buforowania. <xref:System.IO.BufferedStream> Klasa udostępnia możliwości otacza buforowanego strumienia innego strumienia w celu poprawy odczytu i zapisu wydajności.  
  
 Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.IO.Stream> klasa zawiera metody asynchroniczne, aby uprościć operacji asynchronicznych. Zawiera metody asynchronicznej `Async` w swoim imieniu, takie jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.Stream.FlushAsync%2A>. Te metody umożliwiają wykonywanie operacji We/Wy obciąża bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 W przypadku używania w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji, <xref:System.IO.Stream> udostępnia dwie metody rozszerzenia: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> i <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>. Konwertuj tych metod <xref:System.IO.Stream> obiektu do strumienia w [!INCLUDE[wrt](~/includes/wrt-md.md)]. Można również przeprowadzić konwersję strumienia w [!INCLUDE[wrt](~/includes/wrt-md.md)] do <xref:System.IO.Stream> obiektu za pomocą <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> i <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> metody. Aby uzyskać więcej informacji, zobacz [porady: konwertowanie między .NET Framework i strumieni środowiska wykonawczego systemu Windows](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)  
  
 Niektóre implementacje strumienia wykonania lokalnego buforowania danych w celu zwiększenia wydajności. W przypadku tych strumieni, można użyć <xref:System.IO.Stream.Flush%2A> lub <xref:System.IO.Stream.FlushAsync%2A> metody, aby wyczyścić wszystkie bufory wewnętrzne i upewnij się, że wszystkie dane zostały zapisane w podstawowym źródłem danych lub repozytorium.  
  
 Strumień nie magazynu zapasowego (znanej także jako Zasobnik bit), należy użyć <xref:System.IO.Stream.Null> pola można pobrać wystąpienia strumienia, który jest przeznaczony do tego celu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak używać dwóch <xref:System.IO.FileStream> obiektów asynchronicznie skopiować plików z jednego katalogu do innego katalogu. <xref:System.IO.FileStream> Pochodną klasy <xref:System.IO.Stream> klasy. Program obsługi zdarzeń <xref:System.Web.UI.WebControls.Button.Click> kontrolki <xref:System.Windows.Controls.Button> jest oznaczony modyfikatorem `async`, ponieważ wywołuje metodę asynchroniczną.  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Podczas implementacji klasy pochodnej z <see cref="T:System.IO.Stream" />, muszą zawierać implementacje dla <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> i <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> metody. Metod asynchronicznych <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, i <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> Użyj metod synchronicznych <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> i <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> w ich implementacji. W związku z tym Twoje implementacje <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> i <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> będzie działać prawidłowo z metod asynchronicznych. Domyślne implementacje <see cref="M:System.IO.Stream.ReadByte" /> i <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> Tworzenie nowej tablicy bajtowej pojedynczego elementu, a następnie wywołać z implementacji <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> i <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Jeśli pochodzi od <see cref="T:System.IO.Stream" />, firma Microsoft zaleca, aby zastąpić te metody dostępu do Twojej wewnętrznego buforu, jeśli istnieje, aby znacznie lepszą wydajność. Należy również podać implementacje <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, i <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.  Nie zastępuj <see cref="M:System.IO.Stream.Close" /> metody, należy umieścić wszystkie <see cref="T:System.IO.Stream" /> oczyszczania logiki w <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> metody. Aby uzyskać więcej informacji zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.</para>
    </block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Stream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> jest abstrakcyjna klasa podstawowa dla wszystkich strumieni.  
  
 Niektórych najczęściej używanych strumieni, które dziedziczą z <xref:System.IO.Stream> są <xref:System.IO.FileStream>, i <xref:System.IO.MemoryStream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> jaką rozpocząć pisanie dane odczytane ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu odczytu.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to asynchroniczne żądanie odczytu z innych żądań.</param>
        <summary>Rozpoczyna operację asynchroniczną odczytu. (Rozważ użycie <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast.)</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący asynchroniczny odczyt, który może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A>. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.Stream.FlushAsync%2A>, pomocy łatwo zaimplementować asynchronicznej operacji We/Wy.  
  
 Domyślna implementacja `BeginRead` na strumieniu wywołania <xref:System.IO.Stream.Read%2A> metody synchronicznie, co oznacza, że `Read` może spowodować zablokowanie w niektórych strumieni. Jednak wystąpień klas takich jak `FileStream` i `NetworkStream` obsługują w pełni operacji asynchronicznych, jeśli wystąpienie zostało otwarte asynchronicznie. W związku z tym wywołań `BeginRead` nie powoduje blokowania na tych strumieni. Można zastąpić `BeginRead` (przy użyciu delegatów asynchronicznych, na przykład) zapewniające asynchronicznego.  
  
 Przekaż `IAsyncResult` zwrócić wartość do <xref:System.IO.Stream.EndRead%2A> metody strumienia, aby określić liczbę bajtów zostały odczytane i aby zwolnić zasoby systemu operacyjnego używany do odczytu. <xref:System.IO.Stream.EndRead%2A> musi być wywołana raz dla każdego wywołania <xref:System.IO.Stream.BeginRead%2A>. Można to zrobić przy użyciu tego samego kodu, który wywołał `BeginRead` lub wywołanie zwrotne przekazane do `BeginRead`.  
  
 Bieżąca pozycja w strumieniu jest aktualizowana asynchroniczny odczyt lub zapis jest, gdy nie, po zakończeniu operacji We/Wy.  
  
 Wiele równoczesnych żądań asynchronicznych renderowania wiedzą kolejności wykonania żądania.  
  
 Użyj <xref:System.IO.Stream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 Jeśli strumień jest zamknięty lub Przekaż nieprawidłowy argument, istnieją wyjątki zgłaszane bezpośrednio z `BeginRead`. Błędów występujących podczas odczytu żądania asynchronicznego, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i zgłaszanie wyjątków podczas wywoływania metody `EndRead`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Próba asynchroniczny odczyt poza końcem strumienia lub występuje błąd dysku.</exception>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący <see langword="Stream" /> implementacja nie obsługuje operacji odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisywania danych z.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> z której ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, ma być wywoływana po zakończeniu zapisu.</param>
        <param name="state">Obiekt dostarczane przez użytkownika, która odróżnia to żądanie określonego zapis asynchroniczny od innych żądań.</param>
        <summary>Rozpoczyna operację asynchronicznego zapisu. (Rozważ użycie <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast.)</summary>
        <returns>
          <see langword="IAsyncResult" /> Reprezentujący zapis asynchroniczny, który może być oczekujące.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginWrite%2A> i <xref:System.IO.Stream.EndWrite%2A>. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.Stream.FlushAsync%2A>, pomocy łatwo zaimplementować asynchronicznej operacji We/Wy.  
  
 Domyślna implementacja `BeginWrite` na strumieniu wywołania <xref:System.IO.Stream.Write%2A> metody synchronicznie, co oznacza, że `Write` może spowodować zablokowanie w niektórych strumieni. Jednak wystąpień klas takich jak `FileStream` i `NetworkStream` obsługują w pełni operacji asynchronicznych, jeśli wystąpienie zostało otwarte asynchronicznie. W związku z tym wywołań `BeginWrite` nie powoduje blokowania na tych strumieni. Można zastąpić `BeginWrite` (przy użyciu delegatów asynchronicznych, na przykład) zapewniające asynchronicznego.  
  
 Przekaż `IAsyncResult` zwróconych przez metodę bieżącego <xref:System.IO.Stream.EndWrite%2A> zakończeniu zapisu i odpowiednio zwalnia zasoby. <xref:System.IO.Stream.EndWrite%2A> musi być wywołana raz dla każdego wywołania <xref:System.IO.Stream.BeginWrite%2A>. Można to zrobić przy użyciu tego samego kodu, który wywołał `BeginWrite` lub wywołanie zwrotne przekazane do `BeginWrite`. Jeśli wystąpi błąd podczas zapis asynchroniczny, wyjątek nie zostać zgłoszony do `EndWrite` jest wywoływana z `IAsyncResult` zwracane przez tę metodę.  
  
 Jeśli strumień jest zapisywalny, zapisywanie na koniec strumienia rozszerza strumienia.  
  
 Bieżącą pozycję w strumieniu jest aktualizowany podczas generowania asynchroniczny odczyt lub zapis, nie, po zakończeniu operacji We/Wy. Wiele równoczesnych żądań asynchronicznych renderowania wiedzą kolejności wykonania żądania.  
  
 Użyj <xref:System.IO.Stream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 Jeśli strumień jest zamknięty lub Przekaż nieprawidłowy argument, istnieją wyjątki zgłaszane bezpośrednio z `BeginWrite`. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i zgłaszanie wyjątków podczas wywoływania metody `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Próba asynchronicznego zapisu poza końcem strumienia lub występuje błąd dysku.</exception>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowa.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący <see langword="Stream" /> implementacja nie obsługuje operacji zapisu.</exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli strumień nie udostępnia możliwości czytania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasą pochodną <xref:System.IO.Stream> nie obsługuje operacji odczytu, wywołań <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, i <xref:System.IO.Stream.BeginRead%2A> throw metody <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 Poniżej przedstawiono przykład użycia `CanRead` właściwości.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący strumień obsługuje operacji wyszukiwania.</summary>
        <value>
          <see langword="true" /> w przypadku strumienia obsługuje operacji wyszukiwania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasą pochodną <xref:System.IO.Stream> nie obsługuje wyszukiwania, wywołań <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, i <xref:System.IO.Stream.Seek%2A> throw <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy bieżący strumień może upłynął limit czasu.</summary>
        <value>Wartość, która określa, czy bieżący strumień może przekroczono limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanTimeout%2A> Właściwość zawsze zwraca `false`. Niektóre implementacje strumienia wymagane jest zachowanie różnych, takich jak <xref:System.Net.Sockets.NetworkStream>, który upłynie limit czasu, jeśli połączenie sieciowe zostanie przerwana lub utraty. W przypadku wdrażania strumienia, który musi być w stanie limitu czasu, ta właściwość powinna zostać zastąpiona do zwrócenia `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisu.</summary>
        <value>
          <see langword="true" /> Jeśli strumienia obsługuje zapis; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasą pochodną <xref:System.IO.Stream> nie obsługuje zapisywania wywołanie <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, lub <xref:System.IO.Stream.WriteByte%2A> zgłasza <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca `false`.  
  
   
  
## Examples  
 Poniżej przedstawiono przykład użycia `CanWrite` właściwości.  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący strumień i zwalnia wszystkie zasoby (na przykład sockets i dojść do plików), skojarzone z bieżącym strumienia. Zamiast wywołaniem tej metody, upewnij się, czy strumień jest poprawnie usunięta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.Dispose%2A>, określania `true` zwolnić wszystkie zasoby. Nie masz do wywołania w szczególności <xref:System.IO.Stream.Close%2A> metody. Zamiast tego należy upewnić się, że każdy <xref:System.IO.Stream> prawidłowo Dispose. Można zadeklarować <xref:System.IO.Stream> obiektów w `using` bloku (lub `Using` blok w języku Visual Basic) do zapewnienia, że strumień i wszystkie jej zasoby są usuwane, można jawnie wywołać <xref:System.IO.Stream.Dispose%2A> metody.  
  
 Opróżnianie strumienia nie opróżnić jego podstawowym kodera, chyba że jawnie wywołać implementacja <xref:System.IO.Stream.Flush%2A> lub `Close`. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> do `true` oznacza, że dane zostaną opróżnione z buforu w strumieniu, ale nie zostaną opróżnione kodera stanu. Dzięki temu koder ma zachowywać stan (częściowe znaki), aby ją poprawnie kodowania kolejny blok znaków. Ten scenariusz dotyczy UTF8 i UTF7, w której niektóre znaki mogą być kodowane tylko wtedy, gdy odbiera koder sąsiedniego znaku ani znaków.  
  
 Podejmuje próbę manipulowania strumień po zamknięciu strumień może zgłosić <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W klasach pochodnych nie zastępują <see cref="M:System.IO.Stream.Close" /> metody, należy umieścić wszystkie <see langword="Stream" /> oczyszczania logikę w <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> metody. Aby uzyskać więcej informacji zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostaną skopiowane zawartość bieżącego strumienia.</param>
        <summary>Odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopiowanie rozpoczyna się od bieżącej pozycji w strumieniu bieżącej i nie powoduje resetowania pozycji strumienia docelowego po zakończeniu operacji kopiowania.  
  
   
  
## Examples  
 Poniższy przykładowy kod kopiuje zawartość <xref:System.IO.FileStream> do <xref:System.IO.MemoryStream>.  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytu.  - lub - <paramref name="destination" /> nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub <paramref name="destination" /> zostały zamknięte przed <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> wywołano metodę.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostaną skopiowane zawartość bieżącego strumienia.</param>
        <param name="bufferSize">Rozmiar buforu. Ta wartość musi być większa niż zero. Rozmiar domyślny to 81920.</param>
        <summary>Odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia, przy użyciu określony rozmiar buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopiowanie rozpoczyna się od bieżącej pozycji w strumieniu bieżącej i nie powoduje resetowania pozycji strumienia docelowego po zakończeniu operacji kopiowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ma wartość ujemną lub wartość zero.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytu.  - lub - <paramref name="destination" /> nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub <paramref name="destination" /> zostały zamknięte przed <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> wywołano metodę.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostaną skopiowane zawartość bieżącego strumienia.</param>
        <summary>Asynchronicznie odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia.</summary>
        <returns>Zadanie reprezentujące operację asynchroniczną kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Kopiowanie rozpoczyna się w bieżącym położeniu w bieżącym strumienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak używać dwóch <xref:System.IO.FileStream> obiektów asynchronicznie skopiować plików z jednego katalogu do innego. <xref:System.IO.FileStream> Pochodną klasy <xref:System.IO.Stream> klasy.  Zwróć uwagę, że <xref:System.Web.UI.WebControls.Button.Click> programu obsługi zdarzeń dla <xref:System.Windows.Controls.Button> kontroli jest oznaczony atrybutem `async` modyfikator ponieważ wywołuje metody asynchronicznej  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień docelowy albo bieżący strumień jest usunięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje operacji odczytu lub strumień docelowy nie obsługuje zapisywania.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostaną skopiowane zawartość bieżącego strumienia.</param>
        <param name="bufferSize">Rozmiar w bajtach buforu. Ta wartość musi być większa niż zero. Rozmiar domyślny to 81920.</param>
        <summary>Asynchronicznie odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia, przy użyciu określony rozmiar buforu.</summary>
        <returns>Zadanie reprezentujące operację asynchroniczną kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Kopiowanie rozpoczyna się w bieżącym położeniu w bieżącym strumienia.  
  
 Przykład kopiowanie między dwoma strumieniami, zobacz <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> ma wartość ujemną lub wartość zero.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień docelowy albo bieżący strumień jest usunięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje operacji odczytu lub strumień docelowy nie obsługuje zapisywania.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostaną skopiowane zawartość bieżącego strumienia.</param>
        <param name="bufferSize">Rozmiar w bajtach buforu. Ta wartość musi być większa niż zero. Rozmiar domyślny to 81920.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje bajtów ze strumienia bieżącego i zapisuje je w innej strumienia, przy użyciu określony rozmiar buforu i anulowania tokenu.</summary>
        <returns>Zadanie reprezentujące operację asynchroniczną kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Kopiowanie rozpoczyna się w bieżącym położeniu w bieżącym strumienia.  
  
 Przykład kopiowanie między dwoma strumieniami, zobacz <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> ma wartość ujemną lub wartość zero.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień docelowy albo bieżący strumień jest usunięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje operacji odczytu lub strumień docelowy nie obsługuje zapisywania.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przydziela <see cref="T:System.Threading.WaitHandle" /> obiektu.</summary>
        <returns>Odwołanie do przydzielony <see langword="WaitHandle" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołuje się po raz pierwszy, tworzy bieżącej metody `WaitHandle` obiektu i zwraca go. W kolejnych wywołaniach `CreateWaitHandle` zwraca odwołanie do nowego dojście oczekiwania.  
  
 Użyj tej metody, jeśli wdrożenie metod asynchronicznych i wymagają sposób blokowanie w programie <xref:System.IO.Stream.EndRead%2A> lub <xref:System.IO.Stream.EndWrite%2A> aż do zakończenia operacji asynchronicznej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.Stream" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa strumienia, zapisywanie wszystkie zmiany do magazynu zapasowego i zamykający strumienia, aby zwolnić zasoby.  
  
 Wywoływanie `Dispose` umożliwia zasoby używane przez <xref:System.IO.Stream> odbiorczego do innych celów. Aby uzyskać więcej informacji na temat `Dispose`, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Umieść całą logikę oczyszczania dla obiekt strumienia w <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Nie zastępuj <see cref="M:System.IO.Stream.Close" />.  Należy pamiętać, że ze względu na wymagania zgodności z poprzednimi wersjami, ta metoda wdrażania różni się od zalecane wskazówki dotyczące wzorca Dispose.  Ta metoda wywołuje <see cref="M:System.IO.Stream.Close" />, które następnie wywołuje <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.Stream" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zwolnić wszystkie zasoby, określając `true` dla `disposing`. Gdy `disposing` jest `true`, strumienia zapewnia również danych jest opróżniany w buforze podstawowej i uzyskiwanie dostępu do innych obiektów finalizable.  To nie być możliwe przy wywołaniach z finalizator powodu braku kolejności między finalizatory.  
  
 Jeśli strumienia używa do komunikowania się ze źródłem dojścia systemu operacyjnego, należy rozważyć użycie podklasą <xref:System.Runtime.InteropServices.SafeHandle> w tym celu.  
  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. <xref:System.ComponentModel.Component.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.Stream.Dispose%2A> metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.Stream.Dispose%2A> z `disposing` ustawioną `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W klasach pochodnych nie zastępują <see cref="M:System.IO.Stream.Close" /> metody, zamiast tego należy umieścić wszystkie logikę oczyszczania strumienia <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> metody.  <see cref="M:System.ComponentModel.Component.Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see cref="M:System.ComponentModel.Component.Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see cref="M:System.ComponentModel.Component.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia się niezarządzane Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchroniczne, aby zakończyć.</param>
        <summary>Czeka na oczekujące odczyt asynchroniczny zakończyć. (Rozważ użycie <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast.)</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, między (0) i liczba bajtów, żądana. Strumienie zwrócił zero (0) tylko na końcu strumienia, w przeciwnym razie należy zablokować, dopóki nie będzie dostępne co najmniej jednego bajtu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A>. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.Stream.FlushAsync%2A>, pomocy łatwo zaimplementować asynchronicznej operacji We/Wy.  
  
 Wywołanie `EndRead` Aby ustalić liczbę bajtów zostały odczytane ze strumienia.  
  
 `EndRead` może być wywoływana raz dla każdego <xref:System.IAsyncResult> z <xref:System.IO.Stream.BeginRead%2A>.  
  
 Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dojście do oczekująca operacja odczytu jest niedostępna.  - lub - oczekująca operacja nie obsługuje operacji odczytu.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="asyncResult" /> nie pochodzi z <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody dla bieżącej strumienia.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekujących żądania asynchroniczne We/Wy.</param>
        <summary>Kończy operację asynchronicznego zapisu. (Rozważ użycie <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginWrite%2A> i <xref:System.IO.Stream.EndWrite%2A>. Te metody są nadal dostępne w [!INCLUDE[net_v45](~/includes/net-v45-md.md)] do obsługi starszego kodu; jednak nowych metod asynchronicznych, takich jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, i <xref:System.IO.Stream.FlushAsync%2A>, pomocy łatwo zaimplementować asynchronicznej operacji We/Wy.  
  
 `EndWrite` musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.Stream.BeginWrite%2A>.  
  
 Ta metoda umożliwia blokowanie dopiero po ukończeniu operacji We/Wy. Błędów występujących podczas żądania asynchronicznego zapisu, takiej jak awaria dysku podczas wykonywania żądania We/Wy wystąpić w wątku puli wątków i stają się widoczne po wywołaniu `EndWrite`. Wyjątki generowane przez wątek puli wątków nie będą widoczne podczas wywoływania metody `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dojście do działania oczekującej zapisu nie jest dostępna.  - lub - oczekująca operacja nie obsługuje zapisywania.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="asyncResult" /> nie pochodzi z <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody dla bieżącej strumienia.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej usuwa wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąpienie `Flush` dla strumieni, które implementują buforu. Użyj tej metody, aby przenieść wszystkie informacje z bufora źródłowego do miejsca docelowego, wyczyść bufor, lub obie. W zależności od stanu obiektu może być konieczne zmodyfikować bieżącą pozycję w strumieniu (na przykład, jeśli podstawowa strumienia obsługuje operacji wyszukiwania). Aby uzyskać więcej informacji, zobacz <xref:System.IO.Stream.CanSeek%2A>.  
  
 Korzystając z <xref:System.IO.StreamWriter> lub <xref:System.IO.BinaryWriter> klasa, nie mogło opróżnić podstawowym <xref:System.IO.Stream> obiektu. Zamiast tego należy użyć klasy <xref:System.IO.Stream.Flush%2A> lub <xref:System.IO.Stream.Close%2A> metodę, która sprawdza, czy dane są opróżnione do podstawowego strumienia najpierw, a następnie zapisywane do pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie usuwa wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie usuwa wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operację opróżniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasa pochodna, takich jak <xref:System.IO.Compression.DeflateStream> lub <xref:System.IO.Compression.GZipStream>, nie opróżnia bufor w jej implementacja <xref:System.IO.Stream.Flush%2A> metody <xref:System.IO.Stream.FlushAsync%2A> — metoda nie spowoduje to opróżnienie buforu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie usuwa wszystkie bufory dla tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane w podstawowej urządzenia i monitoruje żądania anulowania.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operację opróżniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Jeśli klasa pochodna, takich jak <xref:System.IO.Compression.DeflateStream> lub <xref:System.IO.Compression.GZipStream>, nie opróżnia bufor w jej implementacja <xref:System.IO.Stream.Flush%2A> metody <xref:System.IO.Stream.FlushAsync%2A> — metoda nie spowoduje to opróżnienie buforu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera długość w bajtach strumienia.</summary>
        <value>Wartość typu long reprezentujący długość strumienia w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Klasa pochodna od <see langword="Stream" /> nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A <see langword="Stream" /> z nie magazynu zapasowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Null` przekierować wyniki strumień, który nie będą korzystać z zasobów systemu operacyjnego. Gdy metody `Stream` zawierających zapisu są wywoływane na `Null`, po prostu zwraca wywołanie i są zapisywane żadne dane. `Null` implementuje również `Read` metodę, która zwraca zero przed odczytaniem danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia obsługę <see cref="T:System.Diagnostics.Contracts.Contract" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera lub ustawia pozycję w ramach bieżącego strumienia.</summary>
        <value>Bieżąca pozycja w strumieniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strumień musi obsługiwać wyszukiwania można pobrać lub ustawić pozycji. Użyj <xref:System.IO.Stream.CanSeek%2A> właściwości w celu określenia, czy strumień obsługuje operacji wyszukiwania.  
  
 Wyszukiwanie w dowolne miejsce powyżej długość strumienia jest obsługiwana.  
  
 `Position` Właściwości nie zachować śledzić liczbę bajtów ze strumienia, który zostały wykorzystane, zostało pominięte, lub obie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Po powrocie z tej metody bufor zawiera określonej tablicy bajtów z wartością pomiędzy <c>przesunięcie</c> i (<c>przesunięcie</c> + <c>liczba</c> - 1) zastępuje Bajty odczytane z bieżącego źródła.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> rozpoczęcia przechowywania danych przeczytanie z bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów, które mają być odczytane z bieżącego strumienia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, odczytujący sekwencję bajtów ze strumienia bieżącego i zmienia pozycję w strumieniu przez liczbę bajtów do odczytu.</summary>
        <returns>Całkowita liczba bajtów odczytanych w buforze. Może to być mniejsza niż żądana liczba bajtów Jeśli wiele bajtów nie są obecnie dostępne, czy zero (0), jeśli został osiągnięty koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Stream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu. Użyj <xref:System.IO.Stream.ReadAsync%2A> metodę, aby asynchronicznie odczytywane z bieżącego strumienia.  
  
 Implementacje tej metody odczytu maksymalnie `count` bajtów z bieżącego strumienia i przechowywać je w `buffer` począwszy od `offset`. Bieżącą pozycję w strumieniu jest zaawansowane przez liczbę bajtów odczytanych; Jednak jeśli wystąpi wyjątek, bieżącą pozycję w strumieniu nie jest zmieniany. Implementacje zwraca liczbę bajtów do odczytu. Implementacja zablokuje dopóki co najmniej jednego bajtu danych mogą być odczytywane; w przypadku, gdy nie są dostępne żadne dane. <xref:System.IO.Stream.Read%2A> Zwraca wartość 0, tylko wtedy, gdy nie ma więcej danych w strumieniu i nie więcej oczekuje (na przykład zamkniętego gniazda lub koniec pliku). Implementacja jest bezpłatna do zwrócenia mniej bajtów niż żądana, nawet jeżeli nie osiągnięto koniec strumienia.  
  
 Użyj <xref:System.IO.BinaryReader> do odczytywania typy pierwotne danych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.IO.Stream.Read%2A> do odczytu bloku danych.  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie odczytuje sekwencję bajtów ze strumienia bieżącego i zmienia pozycję w strumieniu przez liczbę bajtów do odczytu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisu danych do.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> jaką rozpocząć pisanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów ze strumienia bieżącego i zmienia pozycję w strumieniu przez liczbę bajtów do odczytu.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów Liczba dostępnych bajtów jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.ReadAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Użyj <xref:System.IO.Stream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można odczytać z pliku asynchronicznie. W przykładzie użyto <xref:System.IO.FileStream> klasy, która jest pochodną <xref:System.IO.Stream> klasy.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisu danych do.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> jaką rozpocząć pisanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów ze strumienia bieżącego zmienia pozycję w strumieniu przez liczbę bajtów odczytanych i monitoruje żądań anulowania.</summary>
        <returns>Zadanie reprezentujące asynchroniczną operacji odczytu. Wartość <paramref name="TResult" /> parametr zawiera całkowitą liczbę bajtów odczytanych w buforze. Wartość wyniku może być mniejsza niż żądana liczba bajtów Liczba dostępnych bajtów jest mniejsza niż żądany numer, czy może być 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.ReadAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Użyj <xref:System.IO.Stream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Na przykład zobacz <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajtów ze strumienia i zmienia pozycję w strumieniu przez jednego bajtu lub zwraca wartość -1, jeśli na koniec strumienia.</summary>
        <returns>Rzutować bajtu bez znaku <see langword="Int32" />, lub wartość -1, jeśli na koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Stream.CanRead%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje odczytu.  
  
 Podejmuje próbę manipulowania strumień po zamknięciu strumień może wywoływać <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytu.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja na <see langword="Stream" /> tworzy nową macierz jednobajtowe, a następnie wywołuje <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Jest to poprawny formalnie, jest nieefektywne. Strumieniem z buforu wewnętrznego należy przesłonić tę metodę i zapewnić bardziej efektywnego wersji, która odczytuje buforu bezpośrednio, unikając alokacji dodatkowe tablicy przy każdym wywołaniu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, w miliseconds, która określa, jak długo strumienia podejmie próbę odczytu przed przekroczeniem limitu czasu.</summary>
        <value>Wartość w miliseconds, która określa, jak długo strumienia podejmie próbę odczytu przed przekroczeniem limitu czasu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IO.Stream.ReadTimeout" /> Metoda zawsze zwraca <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.IO.Stream.ReadTimeout" /> Właściwości powinna zostać zastąpiona, aby zapewnić zachowanie odpowiednie dla tego strumienia. Jeśli strumień nie obsługuje limitu czasu, ta właściwość powinna podnieść <see cref="T:System.InvalidOperationException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie bajtów, względem <c>pochodzenia</c> parametru.</param>
        <param name="origin">Wartości typu <see cref="T:System.IO.SeekOrigin" /> wskazujący punkt odniesienia używany do uzyskania nowego położenia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia pozycję w ramach bieżącego strumienia.</summary>
        <returns>Nowa pozycja w ramach bieżącego strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Stream.CanSeek%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje operacji wyszukiwania.  
  
 Jeśli `offset` jest ujemna, nowe miejsce wymagane do poprzedzać pozycja określona przez `origin` przez liczbę bajtów określona przez `offset`. Jeśli `offset` wynosi zero (0), nowe położenie jest musi być pozycja określona przez `origin`. Jeśli `offset` jest dodatnia, nowe położenie jest wymagana do wykonania pozycja określona przez `origin` przez liczbę bajtów określona przez `offset`.  
  
 Klasy wyprowadzone z `Stream` czy wyszukiwanie pomocy technicznej muszą przesłaniać tę metodę, aby zapewnić funkcje opisane powyżej.  
  
 Wyszukiwanie w dowolne miejsce powyżej długość strumienia jest obsługiwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania, takie jak, jeśli strumień jest tworzony z potoku lub konsola danych wyjściowych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wymagana długość w bajtach bieżący strumień.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia długość bieżącego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określona wartość jest mniejsza niż bieżąca długość strumienia, zostanie obcięta strumienia. Jeśli określona wartość jest większa niż bieżąca długość strumienia, strumień jest rozwinięta. Jeśli strumień jest rozwinięty, zawartość strumienia między stary i nowy długość nie są zdefiniowane.  
  
 Strumień musi obsługiwać zarówno zapisu i wyszukiwania dla `SetLength` do pracy.  
  
 Użyj <xref:System.IO.Stream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis i <xref:System.IO.Stream.CanSeek%2A> właściwości w celu określenia, czy wyszukiwanie jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zarówno zapisu i wyszukiwania, takie jak, jeśli strumień jest tworzony z potoku lub konsola danych wyjściowych.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> Obiektu do synchronizacji.</param>
        <summary>Tworzy bezpieczne wątkowo (zsynchronizowane) otokę określonego <see cref="T:System.IO.Stream" /> obiektu.</summary>
        <returns>Wielowątkowość <see cref="T:System.IO.Stream" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca klasę, która opakowuje określonego <xref:System.IO.Stream> obiektu i ogranicza dostęp wiele wątków. Wszystkie dostęp do <xref:System.IO.Stream> obiekt będzie bezpieczne dla wątków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Ta metoda umożliwia skopiowanie <c>liczba</c> bajtów z <c>buforu</c> do bieżącego strumienia.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> jaką należy zacząć kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Liczba bajtów do zapisania bieżącego strumienia.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, zapisuje sekwencję bajtów do bieżącego strumienia i przechodzi przez liczba zapisanych bajtów bieżącą pozycję w tym strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Stream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis. Użyj <xref:System.IO.Stream.WriteAsync%2A> metodę, aby zapisać bieżący strumień asynchronicznie.  
  
 Jeśli operacja zapisu zakończy się pomyślnie, pozycja w strumieniu przechodzi przez liczba zapisanych bajtów. Jeśli wystąpi wyjątek, pozycja w strumieniu nie jest zmieniany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy, takich jak nie można odnaleźć określonego pliku.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> Metoda została wywołana po strumień został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia i przechodzi przez liczba zapisanych bajtów bieżącą pozycję w tym strumieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisywania danych z.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> z którego należy zacząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia i przechodzi przez liczba zapisanych bajtów bieżącą pozycję w tym strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.WriteAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Użyj <xref:System.IO.Stream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób zapisania asynchronicznie do pliku. W przykładzie użyto <xref:System.IO.FileStream> klasy, która jest pochodną <xref:System.IO.Stream> klasy.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisywania danych z.</param>
        <param name="offset">Zerze przesunięcie w <c>buforu</c> z którego należy zacząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do strumienia bieżącego przesuwa bieżącą pozycję w tym strumieniu przez liczba zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.WriteAsync%2A> Metody umożliwia wykonywanie operacji We/Wy obciążający zasoby bez blokowania głównego wątku. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` i `await` słów kluczowych w języku Visual Basic i C#.  
  
 Użyj <xref:System.IO.Stream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 Jeśli operacja została anulowana przed ukończeniem działania, zwrócone zadania zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Na przykład zobacz <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i <paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajtów do zapisania w strumieniu.</param>
        <summary>Zapisuje bieżącą pozycję w strumieniu bajt i zmienia pozycję w strumieniu przez jednego bajtu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.Stream.CanWrite%2A> właściwości w celu określenia, czy bieżące wystąpienie obsługuje zapis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania lub strumień jest już zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody wywołane po strumień został zamknięty.</exception>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja na <see langword="Stream" /> tworzy nową macierz jednobajtowe, a następnie wywołuje <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Jest to poprawny formalnie, jest nieefektywne. Strumieniem z buforu wewnętrznego należy przesłonić tę metodę i zapewnić bardziej efektywnego wersji, który zapisuje informacje w buforze bezpośrednio, unikając alokacji dodatkowe tablicy przy każdym wywołaniu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, w miliseconds, która określa, jak długo strumienia podejmie próbę zapisu przed przekroczeniem limitu czasu.</summary>
        <value>Wartość w miliseconds, która określa, jak długo strumienia podejmie próbę zapisu przed przekroczeniem limitu czasu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.IO.Stream.WriteTimeout" /> Metoda zawsze zwraca <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="P:System.IO.Stream.WriteTimeout" /> Właściwości powinna zostać zastąpiona, aby zapewnić zachowanie odpowiednie dla tego strumienia. Jeśli strumień nie obsługuje limitu czasu, ta właściwość powinna podnieść <see cref="T:System.InvalidOperationException" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c086b4c1cc57cd79debbea5256d3afd2cf6185d2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69242870" /></Metadata><TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera ogólny widok sekwencji bajtów. Jest to Klasa abstrakcyjna.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream>jest abstrakcyjną klasą bazową wszystkich strumieni. Strumień jest abstrakcją sekwencji bajtów, takich jak plik, urządzenie wejścia/wyjścia, potok komunikacji między procesami lub gniazdo TCP/IP. <xref:System.IO.Stream> Klasa i jej klasy pochodne zapewniają ogólny widok tych różnych typów danych wejściowych i wyjściowych oraz izoluje programistę od szczegółowych informacji o systemie operacyjnym i podstawowych urządzeniach.  
  
 Strumienie obejmują trzy podstawowe operacje:  
  
-   Możesz odczytywać strumienie. Odczyt to transfer danych ze strumienia do struktury danych, takich jak tablica bajtów.  
  
-   Możesz zapisywać w strumieniach. Pisanie to transfer danych ze struktury danych do strumienia.  
  
-   Strumienie mogą obsługiwać wyszukiwanie. Wyszukiwanie odwołuje się do zapytania i modyfikacji bieżącej pozycji w strumieniu. Funkcja wyszukiwania zależy od rodzaju magazynu, w którym znajduje się strumień. Na przykład strumienie sieciowe nie mają ujednoliconej koncepcji bieżącego położenia, dlatego zazwyczaj nie obsługują wyszukiwania.  
  
 Niektóre z najczęściej używanych strumieni, które dziedziczą z <xref:System.IO.Stream> programu <xref:System.IO.FileStream>, to <xref:System.IO.MemoryStream>, i.  
  
 W zależności od źródła danych lub repozytorium, strumienie mogą obsługiwać tylko niektóre z tych funkcji. Możesz wysyłać zapytania do strumienia dla swoich możliwości <xref:System.IO.Stream.CanRead%2A>za pomocą właściwości <xref:System.IO.Stream> , <xref:System.IO.Stream.CanWrite%2A>i <xref:System.IO.Stream.CanSeek%2A> klasy.  
  
 Metody <xref:System.IO.Stream.Read%2A> i<xref:System.IO.Stream.Write%2A> odczytują i zapisują dane w różnych formatach. W przypadku strumieni, które obsługują wyszukiwanie, <xref:System.IO.Stream.Seek%2A> Użyj <xref:System.IO.Stream.SetLength%2A> metod <xref:System.IO.Stream.Position%2A> <xref:System.IO.Stream.Length%2A> i i właściwości oraz, aby wysyłać zapytania i modyfikować bieżącą pozycję i długość strumienia.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 Usunięcie obiektu opróżnia wszystkie dane buforowane i zasadniczo <xref:System.IO.Stream.Flush%2A> wywołuje metodę. <xref:System.IO.Stream> <xref:System.IO.Stream.Dispose%2A>Program zwalnia również zasoby systemu operacyjnego, takie jak dojścia do plików, połączenia sieciowe lub pamięć użyta do wewnętrznego buforowania. <xref:System.IO.BufferedStream> Klasa oferuje możliwość zawijania strumienia buforowanego wokół innego strumienia w celu zwiększenia wydajności odczytu i zapisu.  
  
 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]Począwszy od<xref:System.IO.Stream> , Klasa obejmuje metody asynchroniczne upraszczające asynchroniczne operacje. Metoda `Async` Async zawiera nazwę, taką jak <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>,, i <xref:System.IO.Stream.FlushAsync%2A>. Te metody umożliwiają wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 W przypadku użycia w [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji program <xref:System.IO.Stream> zawiera dwie metody rozszerzające <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> : <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>i. Te metody konwertują <xref:System.IO.Stream> obiekt na strumień [!INCLUDE[wrt](~/includes/wrt-md.md)]w obiekcie. Możesz [!INCLUDE[wrt](~/includes/wrt-md.md)] również skonwertować strumień w <xref:System.IO.Stream> obiekcie do obiektu za pomocą <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> metod i <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> . Aby uzyskać więcej informacji, zobacz [jak: Konwertowanie między strumieniami .NET Framework i środowisko wykonawcze systemu Windows strumieniami](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)  
  
 Niektóre implementacje strumienia wykonują lokalne buforowanie danych bazowych w celu zwiększenia wydajności. W przypadku takich strumieni można użyć <xref:System.IO.Stream.Flush%2A> metody lub <xref:System.IO.Stream.FlushAsync%2A> , aby wyczyścić wszystkie wewnętrzne bufory i upewnić się, że wszystkie dane zostały zapisaną do bazowego źródła danych lub repozytorium.  
  
 Jeśli potrzebujesz strumienia bez magazynu zapasowego (znanego również jako zasobnik bitowy), użyj <xref:System.IO.Stream.Null> pola, aby pobrać wystąpienie strumienia, które jest przeznaczone do tego celu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania dwóch <xref:System.IO.FileStream> obiektów do asynchronicznego kopiowania plików z jednego katalogu do innego katalogu. <xref:System.IO.FileStream> Klasa pochodzi<xref:System.IO.Stream> od klasy. Program obsługi zdarzeń <xref:System.Web.UI.WebControls.Button.Click> kontrolki <xref:System.Windows.Controls.Button> jest oznaczony modyfikatorem `async`, ponieważ wywołuje metodę asynchroniczną.  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Podczas implementowania klasy <see cref="T:System.IO.Stream" />pochodnej, należy podać implementacje <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> dla metod i <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> . Metody <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />asynchroniczne <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> , <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> i<see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> używają metod<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> synchronicznych i w ich implementacjach. W związku z tym implementacje <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> programu <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> i będą działały poprawnie z metodami asynchronicznymi. Domyślne implementacje <see cref="M:System.IO.Stream.ReadByte" /> i <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> Utwórz nową jednoelementową tablicę bajtową, a następnie Wywołaj implementacje <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> dla <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />i. Gdy pochodzą z <see cref="T:System.IO.Stream" />programu, zalecamy przesłonięcie tych metod w celu uzyskania dostępu do buforu wewnętrznego, jeśli istnieje, w celu uzyskania znacznej wydajności. Należy również dostarczyć implementacje <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" /> <see cref="M:System.IO.Stream.Flush" /> <see cref="P:System.IO.Stream.CanWrite" /> ,<see cref="P:System.IO.Stream.Length" />,,,, i<see cref="M:System.IO.Stream.SetLength(System.Int64)" />. <see cref="P:System.IO.Stream.Position" /> <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />  
  
Nie Przesłaniaj <see cref="M:System.IO.Stream.Close" /> metody, zamiast tego należy umieścić <see cref="T:System.IO.Stream" /> całą logikę oczyszczania w <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> metodzie. Aby uzyskać więcej informacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para></block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md">Instrukcje: Konwersja strumieni platformy .NET Framework i strumieni środowiska wykonawczego systemu Windows</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.Stream" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream>jest abstrakcyjną klasą bazową wszystkich strumieni.  
  
 Niektóre z najczęściej używanych strumieni, które dziedziczą z <xref:System.IO.Stream> programu <xref:System.IO.FileStream>, to <xref:System.IO.MemoryStream>, i.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, do którego mają zostać odczytane dane.</param>
        <param name="offset">Przesunięcie bajtu, <paramref name="buffer" /> w którym rozpocznie się zapisywanie danych odczytanych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu odczytu.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie odczytu z innych żądań.</param>
        <summary>Rozpoczęcie asynchronicznej operacji odczytu. (Rozważ użycie <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast niego).</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje on asynchroniczny odczyt, który nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A>. Te metody są nadal dostępne w programie [!INCLUDE[net_v45](~/includes/net-v45-md.md)] w celu obsługi starszego kodu, jednak nowe metody asynchroniczne, takie jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>,, i <xref:System.IO.Stream.FlushAsync%2A>, ułatwiają wdrożenie asynchronicznych operacji we/wy.  
  
 Domyślna implementacja `BeginRead` w strumieniu <xref:System.IO.Stream.Read%2A> wywołuje metodę synchronicznie, co oznacza, że `Read` może blokować pewne strumienie. Jednak wystąpienia klas, takie jak i `FileStream` `NetworkStream` w pełni obsługują operacje asynchroniczne, jeśli wystąpienia zostały otwarte asynchronicznie. W związku z `BeginRead` tym wywołania nie będą blokować tych strumieni. Aby zapewnić asynchroniczne `BeginRead` zachowanie, można przesłonić (na przykład za pomocą delegatów asynchronicznych).  
  
 Przekaż wartość <xref:System.IO.Stream.EndRead%2A> zwracaną do metody strumienia, aby określić, ile bajtów zostało odczytanych i aby zwolnić zasoby systemu operacyjnego używane do odczytu. `IAsyncResult` <xref:System.IO.Stream.EndRead%2A>musi być wywoływana jednokrotnie dla każdego <xref:System.IO.Stream.BeginRead%2A>wywołania do. Można to zrobić przy użyciu tego samego kodu, który został wywołany `BeginRead` , lub w wywołaniu zwrotnym przekazanym do. `BeginRead`  
  
 Bieżące położenie w strumieniu jest aktualizowane, gdy zostanie wystawiony asynchroniczny odczyt lub zapis, a nie po zakończeniu operacji we/wy.  
  
 Wiele jednoczesnych żądań asynchronicznych renderuje kolejność uzupełniania żądań.  
  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.  
  
 Jeśli strumień jest zamknięty lub przeszedł nieprawidłowy argument, wyjątki są zgłaszane od `BeginRead`razu. Błędy występujące podczas asynchronicznego żądania odczytu, takie jak awaria dysku w trakcie żądania we/wy, występuje w wątku puli wątków i generują wyjątki podczas wywoływania `EndRead`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podjęto próbę odczytu asynchronicznego poza końcem strumienia lub wystąpił błąd dysku.</exception>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <exception cref="T:System.NotSupportedException">Bieżąca <see langword="Stream" /> implementacja nie obsługuje operacji odczytu.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchroniczne We/Wy pliku</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, z którego mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu, <paramref name="buffer" /> od którego ma zacząć pisać.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="callback">Opcjonalne asynchroniczne wywołanie zwrotne, które ma być wywoływane po zakończeniu zapisu.</param>
        <param name="state">Obiekt udostępniony przez użytkownika, który odróżnia to konkretne asynchroniczne żądanie zapisu z innych żądań.</param>
        <summary>Rozpoczyna asynchroniczne operacje zapisu. (Rozważ użycie <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast niego).</summary>
        <returns><see langword="IAsyncResult" /> Reprezentuje zapis asynchroniczny, który nadal może być w stanie oczekiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginWrite%2A> i <xref:System.IO.Stream.EndWrite%2A>. Te metody są nadal dostępne w programie [!INCLUDE[net_v45](~/includes/net-v45-md.md)] w celu obsługi starszego kodu, jednak nowe metody asynchroniczne, takie jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>,, i <xref:System.IO.Stream.FlushAsync%2A>, ułatwiają wdrożenie asynchronicznych operacji we/wy.  
  
 Domyślna implementacja `BeginWrite` w strumieniu <xref:System.IO.Stream.Write%2A> wywołuje metodę synchronicznie, co oznacza, że `Write` może blokować pewne strumienie. Jednak wystąpienia klas, takie jak i `FileStream` `NetworkStream` w pełni obsługują operacje asynchroniczne, jeśli wystąpienia zostały otwarte asynchronicznie. W związku z `BeginWrite` tym wywołania nie będą blokować tych strumieni. Aby zapewnić asynchroniczne `BeginWrite` zachowanie, można przesłonić (na przykład za pomocą delegatów asynchronicznych).  
  
 Przekaż zwrócone przez bieżącą metodę do <xref:System.IO.Stream.EndWrite%2A> , aby upewnić się, że zapis kończy się i odpowiednio zwalnia zasoby. `IAsyncResult` <xref:System.IO.Stream.EndWrite%2A>musi być wywoływana jednokrotnie dla każdego <xref:System.IO.Stream.BeginWrite%2A>wywołania do. Można to zrobić przy użyciu tego samego kodu, który został wywołany `BeginWrite` , lub w wywołaniu zwrotnym przekazanym do. `BeginWrite` Jeśli wystąpi błąd podczas zapisu asynchronicznego, wyjątek nie zostanie zgłoszony, dopóki `EndWrite` nie zostanie wywołany `IAsyncResult` z zwróconym przez tę metodę.  
  
 Jeśli strumień jest zapisywalny, zapis na końcu strumienia rozszerza strumień.  
  
 Bieżące położenie w strumieniu jest aktualizowane, gdy zostanie wystawiony asynchroniczny odczyt lub zapis, a nie po zakończeniu operacji we/wy. Wiele jednoczesnych żądań asynchronicznych renderuje kolejność uzupełniania żądań.  
  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.  
  
 Jeśli strumień jest zamknięty lub przeszedł nieprawidłowy argument, wyjątki są zgłaszane od `BeginWrite`razu. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w trakcie żądania we/wy, występuje w wątku puli wątków i generują wyjątki podczas wywoływania `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podjęto próbę zapisu asynchronicznego poza końcem strumienia lub wystąpił błąd dysku.</exception>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów jest nieprawidłowy.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <exception cref="T:System.NotSupportedException">Bieżąca <see langword="Stream" /> implementacja nie obsługuje operacji zapisu.</exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchroniczne We/Wy pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytywanie.</summary>
        <value><see langword="true" />Jeśli strumień obsługuje odczytywanie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> Jeśli klasa pochodna nie obsługuje odczytywania, wywołania <xref:System.NotSupportedException> <xref:System.IO.Stream.Read%2A>metod, <xref:System.IO.Stream.ReadByte%2A>i <xref:System.IO.Stream.BeginRead%2A> .  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.  
  
   
  
## Examples  
 Poniżej przedstawiono przykład użycia `CanRead` właściwości.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżący strumień obsługuje wyszukiwanie.</summary>
        <value><see langword="true" />Jeśli strumień obsługuje wyszukiwanie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream> Jeśli klasa pochodna nie obsługuje wyszukiwania, wywołania do <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A> <xref:System.IO.Stream.Position%2A>, i <xref:System.IO.Stream.Seek%2A> throw <xref:System.NotSupportedException>.  
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy bieżący strumień może przekroczyć limit czasu.</summary>
        <value>Wartość określająca, czy bieżący strumień może przekroczyć limit czasu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zawsze zwraca wartość `false`. <xref:System.IO.Stream.CanTimeout%2A> Niektóre implementacje strumienia wymagają różnych zachowań, takich <xref:System.Net.Sockets.NetworkStream>jak, które przekraczają czas przerwania lub utraty łączności sieciowej. Jeśli wykonujesz strumień, który musi być w stanie przekroczyć limit czasu, ta właściwość powinna zostać przesłonięta w celu zwrócenia `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisywanie.</summary>
        <value><see langword="true" />Jeśli strumień obsługuje zapis; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.Stream> Klasa pochodna nie obsługuje pisania, wywołanie do <xref:System.NotSupportedException> <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>lub <xref:System.IO.Stream.WriteByte%2A> zgłasza. W takich przypadkach jest <xref:System.IO.Stream.Flush%2A> zwykle implementowana jako pusta Metoda w celu zapewnienia pełnej zgodności z innymi <xref:System.IO.Stream> typami, ponieważ jest ona prawidłowa do opróżniania strumienia tylko do odczytu.
  
 Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.  
  
   
  
## Examples  
 Poniżej przedstawiono przykład użycia `CanWrite` właściwości.  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący strumień i zwalnia wszystkie zasoby (takie jak gniazda i uchwyty plików) skojarzone z bieżącym strumieniem. Zamiast wywołania tej metody upewnij się, że strumień jest prawidłowo usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.IO.Stream.Dispose%2A>, określając `true` , aby zwolnić wszystkie zasoby. Nie ma potrzeby wywoływania <xref:System.IO.Stream.Close%2A> metody. Zamiast tego upewnij się, <xref:System.IO.Stream> że każdy obiekt został prawidłowo usunięty. Można zadeklarować <xref:System.IO.Stream> `using` obiekty w bloku (lub `Using` zablokować w Visual Basic), aby upewnić się, że strumień i wszystkie jego zasoby zostaną <xref:System.IO.Stream.Dispose%2A> usunięte lub można jawnie wywołać metodę.  
  
 Opróżnianie strumienia nie spowoduje opróżnienia jego bazowego kodera, chyba że jawnie <xref:System.IO.Stream.Flush%2A> wywoła `Close`implementację lub. Ustawienie <xref:System.IO.StreamWriter.AutoFlush%2A> oznacza, że dane zostaną opróżnione z bufora do strumienia, ale stan kodera nie zostanie opróżniony. `true` Dzięki temu koder może zachować swój stan (częściowe znaki), aby można było poprawnie zakodować następny blok znaków. Ten scenariusz ma wpływ na kodowanie UTF8 i UTF7, gdzie niektóre znaki mogą być kodowane tylko po odebraniu sąsiadującego znaku lub znaków przez koder.  
  
 Próby manipulowania strumieniem po zamknięciu strumienia mogą zgłosić <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W klasach pochodnych nie Przesłaniaj <see cref="M:System.IO.Stream.Close" /> metody, zamiast tego należy umieścić całą <see langword="Stream" /> logikę oczyszczania w <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> metodzie. Aby uzyskać więcej informacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</param>
        <summary>Odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopiowanie rozpoczyna się na bieżącym miejscu w bieżącym strumieniu i nie resetuje pozycji strumienia docelowego po zakończeniu operacji kopiowania.  
  
   
  
## Examples  
 Poniższy przykład kopiuje zawartość <xref:System.IO.FileStream> <xref:System.IO.MemoryStream>do.  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytywania.  
  
—lub— 
 <paramref name="destination" />nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub <paramref name="destination" /> zostały zamknięte <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> przed wywołaniem metody.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</param>
        <param name="bufferSize">Rozmiar buforu. Ta wartość musi być większa od zera. Domyślny rozmiar to 81920.</param>
        <summary>Odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu przy użyciu określonego rozmiaru buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopiowanie rozpoczyna się na bieżącym miejscu w bieżącym strumieniu i nie resetuje pozycji strumienia docelowego po zakończeniu operacji kopiowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" />jest ujemna lub równa zero.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytywania.  
  
—lub— 
 <paramref name="destination" />nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub <paramref name="destination" /> zostały zamknięte <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> przed wywołaniem metody.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</param>
        <summary>Asynchronicznie odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 Kopiowanie rozpoczyna się na bieżącym miejscu w bieżącym strumieniu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania dwóch <xref:System.IO.FileStream> obiektów do asynchronicznego kopiowania plików z jednego katalogu do drugiego. <xref:System.IO.FileStream> Klasa pochodzi<xref:System.IO.Stream> od klasy.  Zauważ, że <xref:System.Web.UI.WebControls.Button.Click> program obsługi zdarzeń <xref:System.Windows.Controls.Button> dla kontrolki jest oznaczony modyfikatorem, `async` ponieważ wywołuje metodę asynchroniczną  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub strumień docelowy został usunięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytywania lub strumień docelowy nie obsługuje zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</param>
        <param name="bufferSize">Rozmiar bufora (w bajtach). Ta wartość musi być większa od zera. Domyślny rozmiar to 81920.</param>
        <summary>Asynchronicznie odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu przy użyciu określonego rozmiaru buforu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 Kopiowanie rozpoczyna się na bieżącym miejscu w bieżącym strumieniu.  
  
 Aby zapoznać się z przykładem kopiowania między dwoma strumieniami <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffersize" />jest ujemna lub równa zero.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub strumień docelowy został usunięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytywania lub strumień docelowy nie obsługuje zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu przy użyciu określonego tokenu anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Kopiowanie rozpoczyna się na bieżącym miejscu w bieżącym strumieniu.  
  
 Aby zapoznać się z przykładem kopiowania między dwoma strumieniami <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</param>
        <param name="bufferSize">Rozmiar bufora (w bajtach). Ta wartość musi być większa od zera. Domyślny rozmiar to 81920.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje bajty z bieżącego strumienia i zapisuje je w innym strumieniu przy użyciu określonego rozmiaru buforu i tokenu anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację kopiowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CopyToAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Kopiowanie rozpoczyna się na bieżącym miejscu w bieżącym strumieniu.  
  
 Aby zapoznać się z przykładem kopiowania między dwoma strumieniami <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffersize" />jest ujemna lub równa zero.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący strumień lub strumień docelowy został usunięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący strumień nie obsługuje odczytywania lub strumień docelowy nie obsługuje zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> Przydziela obiekt.</summary>
        <returns>Odwołanie do przydzieloną <see langword="WaitHandle" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywoływana po raz pierwszy, bieżąca metoda tworzy `WaitHandle` obiekt i zwraca go. W przypadku `CreateWaitHandle` kolejnych wywołań zwraca odwołanie do nowego dojścia oczekiwania.  
  
 Tej metody należy użyć w przypadku implementowania metod asynchronicznych i wymagania sposobu blokowania w <xref:System.IO.Stream.EndRead%2A> lub <xref:System.IO.Stream.EndWrite%2A> do czasu ukończenia operacji asynchronicznej.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.IO.Stream" /> obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.IO.Stream" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa strumień przez zapisanie zmian w magazynie zapasowym i zamknięcie strumienia w celu zwolnienia zasobów.  
  
 Wywołanie `Dispose` zezwala na przydzielenie zasobów używanych <xref:System.IO.Stream> przez program do innych celów. Aby uzyskać więcej informacji `Dispose`na temat, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Umieść całą logikę oczyszczania dla obiektu Stream w <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Nie Przesłaniaj <see cref="M:System.IO.Stream.Close" />.  
  
Należy zauważyć, że ze względu na wymagania dotyczące zgodności z poprzednimi wersjami implementacja tej metody różni się od zalecanych wskazówek dotyczących wzorca Dispose.  Ta metoda wywołuje <see cref="M:System.IO.Stream.Close" />metodę, która następnie <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />wywołuje.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.Stream" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zwolnić wszystkie zasoby, określając `true` dla. `disposing` Gdy `disposing` tak `true`jest, strumień może również zapewnić, że dane są opróżniane do źródłowego buforu i uzyskiwać dostęp do innych obiektów, które można sfinalizować.  Może to nie być możliwe, gdy zostanie wywołana z finalizatora z powodu braku kolejności wśród finalizatorów.  
  
 Jeśli strumień używa dojścia systemu operacyjnego do komunikacji ze źródłem, rozważ użycie podklasy <xref:System.Runtime.InteropServices.SafeHandle> do tego celu.  
  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę. <xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.Stream.Dispose%2A> `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.Stream.Dispose%2A> `false`z `disposing` ustawionym na.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>W klasach pochodnych nie Przesłaniaj <see cref="M:System.IO.Stream.Close" /> metody, zamiast tego należy umieścić całą logikę oczyszczania strumienia <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> w metodzie.  
  
 <see cref="M:System.ComponentModel.Component.Dispose" />może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see cref="M:System.ComponentModel.Component.Dispose" />w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see cref="M:System.ComponentModel.Component.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="stream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IAsyncDisposable.DisposeAsync</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.Stream" />.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację Dispose.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.DisposeAsync%2A> Metoda umożliwia wykonywanie operacji Dispose intensywnie korzystających z zasobów bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i. 
 
 Ta metoda usuwa strumień przez zapisanie zmian w magazynie zapasowym i zamknięcie strumienia w celu zwolnienia zasobów.   
  
 Wywołanie `DisposeAsync` zezwala na przydzielenie zasobów używanych <xref:System.IO.Stream> przez program do innych celów. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchronicznego do zakończenia.</param>
        <summary>Czeka na zakończenie oczekujących asynchronicznych operacji odczytu. (Rozważ użycie <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast niego).</summary>
        <returns>Liczba bajtów odczytanych ze strumienia, z przedziału od zera (0) do liczby żądanych bajtów. Strumienie zwracają zero (0) tylko na końcu strumienia, w przeciwnym razie powinny być blokowane do momentu udostępnienia co najmniej jednego bajtu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginRead%2A> i <xref:System.IO.Stream.EndRead%2A>. Te metody są nadal dostępne w programie [!INCLUDE[net_v45](~/includes/net-v45-md.md)] w celu obsługi starszego kodu, jednak nowe metody asynchroniczne, takie jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>,, i <xref:System.IO.Stream.FlushAsync%2A>, ułatwiają wdrożenie asynchronicznych operacji we/wy.  
  
 Wywołaj `EndRead` , aby określić, ile bajtów odczytano ze strumienia.  
  
 `EndRead`może być wywoływana raz dla każdego <xref:System.IAsyncResult> z <xref:System.IO.Stream.BeginRead%2A>.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dojście do oczekującej operacji odczytu jest niedostępne.  
  
 —lub—  
  
 Oczekująca operacja nie obsługuje odczytywania.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult" />nie pochodzi z <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody w bieżącym strumieniu.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchroniczne We/Wy pliku</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Odwołanie do oczekującego żądania asynchroniczne we/wy.</param>
        <summary>Zamyka asynchroniczne operacje zapisu. (Rozważ użycie <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> zamiast niego).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W programie .NET Framework w wersji 4 i starszych do implementowania asynchronicznych operacji We/Wy należy używać metod takich jak <xref:System.IO.Stream.BeginWrite%2A> i <xref:System.IO.Stream.EndWrite%2A>. Te metody są nadal dostępne w programie [!INCLUDE[net_v45](~/includes/net-v45-md.md)] w celu obsługi starszego kodu, jednak nowe metody asynchroniczne, takie jak <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A> <xref:System.IO.Stream.CopyToAsync%2A>,, i <xref:System.IO.Stream.FlushAsync%2A>, ułatwiają wdrożenie asynchronicznych operacji we/wy.  
  
 `EndWrite`musi być wywoływana dokładnie raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.Stream.BeginWrite%2A>.  
  
 Ta metoda jest blokowana do momentu zakończenia operacji we/wy. Błędy występujące podczas asynchronicznego żądania zapisu, takie jak awaria dysku w trakcie żądania we/wy, występuje w wątku puli wątków i stają się widoczne przy wywołaniu `EndWrite`. Wyjątki zgłoszone przez wątek puli wątków nie będą widoczne podczas wywoływania `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dojście do oczekującej operacji zapisu jest niedostępne.  
  
 —lub—  
  
 Oczekująca operacja nie obsługuje zapisu.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="asyncResult" />nie pochodzi z <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> metody w bieżącym strumieniu.</exception>
        <exception cref="T:System.IO.IOException">Strumień jest zamknięty lub wystąpił błąd wewnętrzny.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchroniczne We/Wy pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, czyści wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąp `Flush` strumienie implementujące bufor. Użyj tej metody, aby przenieść wszystkie informacje z bazowego buforu do jego lokalizacji docelowej, wyczyść bufor lub oba te elementy. W zależności od stanu obiektu może zajść potrzeba zmodyfikowania bieżącej pozycji w strumieniu (na przykład jeśli źródłowy strumień obsługuje wyszukiwanie). Aby uzyskać dodatkowe informacje <xref:System.IO.Stream.CanSeek%2A>, zobacz.  

 W klasie pochodnej <xref:System.IO.Stream> , która nie obsługuje pisania, jest <xref:System.IO.Stream.Flush%2A> zwykle implementowana jako pusta Metoda w celu zapewnienia pełnej zgodności z innymi <xref:System.IO.Stream> typami, ponieważ jest ona prawidłowa do opróżniania strumienia tylko do odczytu.

 Korzystając z <xref:System.IO.StreamWriter> klasy or <xref:System.IO.BinaryWriter> , nie Opróżniaj obiektu podstawowego. <xref:System.IO.Stream> Zamiast tego należy użyć klasy <xref:System.IO.Stream.Flush%2A> lub <xref:System.IO.Stream.Close%2A> metody, aby upewnić się, że dane są najpierw opróżniane do strumienia bazowego, a następnie zapisywane do pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie czyści wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronicznie czyści wszystkie bufory dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację opróżniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klasa pochodna, taka jak <xref:System.IO.Compression.DeflateStream> lub <xref:System.IO.Compression.GZipStream>, nie opróżnia buforu <xref:System.IO.Stream.Flush%2A> w jego implementacji metody, <xref:System.IO.Stream.FlushAsync%2A> Metoda nie opróżnia bufora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie czyści wszystkie bufory dla tego strumienia, powoduje, że wszystkie buforowane dane są zapisywane na podstawowym urządzeniu i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację opróżniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Jeśli klasa pochodna, taka jak <xref:System.IO.Compression.DeflateStream> lub <xref:System.IO.Compression.GZipStream>, nie opróżnia buforu <xref:System.IO.Stream.Flush%2A> w jego implementacji metody, <xref:System.IO.Stream.FlushAsync%2A> Metoda nie opróżnia bufora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera długość w bajtach strumienia.</summary>
        <value>Długa wartość reprezentująca długość strumienia w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Klasa pochodna <see langword="Stream" /> nie obsługuje wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="Stream" /> Bez magazynu zapasowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy `Null` do przekierowywania danych wyjściowych do strumienia, który nie wykorzystuje żadnych zasobów systemu operacyjnego. Gdy metody `Stream` zapewniające zapis są wywoływane w `Null`, wywołanie po prostu zwraca i nie są zapisywane żadne dane. `Null`implementuje `Read` również metodę zwracającą zero bez odczytywania danych.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia pomoc techniczną <see cref="T:System.Diagnostics.Contracts.Contract" />dla programu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera lub ustawia pozycję w bieżącym strumieniu.</summary>
        <value>Bieżąca pozycja w strumieniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strumień musi obsługiwać wyszukiwanie w celu pobrania lub ustawienia pozycji. <xref:System.IO.Stream.CanSeek%2A> Użyj właściwości, aby określić, czy strumień obsługuje wyszukiwanie.  
  
 Wyszukiwanie w dowolnej lokalizacji poza długością strumienia jest obsługiwane.  
  
 `Position` Właściwość nie śledzi liczby bajtów ze strumienia, który został zużyty, pominięty lub oba te elementy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje operacji wyszukiwania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci. Gdy ta metoda zwraca, zawartość tego regionu jest zastępowana przez Bajty odczytane z bieżącego źródła.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, odczytuje sekwencję bajtów z bieżącego strumienia i przesuwa pozycję w strumieniu o liczbę odczytanych bajtów.</summary>
        <returns>Całkowita liczba bajtów odczytywanych w buforze. Wartość ta może być mniejsza niż liczba bajtów przypadających w buforze, jeśli wiele bajtów nie jest obecnie dostępna lub zero (0), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie. Użyj metody <xref:System.IO.Stream.ReadAsync%2A> , aby odczytywać asynchronicznie z bieżącego strumienia.  
  
 Implementacje tej metody odczytują maksymalnie `buffer.Length` bajtów z bieżącego strumienia i przechowują je w. `buffer` Bieżąca pozycja w strumieniu jest zaawansowana przez liczbę odczytanych bajtów; Jeśli jednak wystąpi wyjątek, bieżąca pozycja w strumieniu pozostaje niezmieniona. Implementacje zwracają liczbę odczytanych bajtów. Implementacja zostanie Zablokowani do momentu odczytania co najmniej jednego bajtu danych, w przypadku, gdy żadne dane nie są dostępne. <xref:System.IO.Stream.Read%2A>Zwraca wartość 0 tylko wtedy, gdy nie ma więcej danych w strumieniu i nie ma więcej oczekiwanych (takich jak zamknięte gniazdo lub koniec pliku). Implementacja może zwrócić mniejszą liczbę bajtów niż żądana, nawet jeśli koniec strumienia nie został osiągnięty.  
  
 Służy <xref:System.IO.BinaryReader> do odczytywania typów danych pierwotnych.    
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Gdy ta metoda zwraca, <paramref name="offset" /> bufor zawiera określoną tablicę bajtową z wartościami między i (<paramref name="offset" />  +  <paramref name="count" /> -1) zastąpione przez Bajty odczytane z bieżącego źródła.</param>
        <param name="offset">Przesunięcie bajtu (liczony od zera <paramref name="buffer" /> ), w którym rozpocznie się przechowywanie danych odczytanych z bieżącego strumienia.</param>
        <param name="count">Maksymalna liczba bajtów, które mają być odczytane z bieżącego strumienia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, odczytuje sekwencję bajtów z bieżącego strumienia i przesuwa pozycję w strumieniu o liczbę odczytanych bajtów.</summary>
        <returns>Całkowita liczba bajtów odczytywanych w buforze. Wartość ta może być mniejsza niż liczba bajtów żądana, jeśli nie jest ona obecnie dostępna, lub zero (0), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie. Użyj metody <xref:System.IO.Stream.ReadAsync%2A> , aby odczytywać asynchronicznie z bieżącego strumienia.  
  
 Implementacje tej metody odczytują maksymalnie `count` bajtów z bieżącego strumienia i przechowują je w `buffer` czasie `offset`od. Bieżąca pozycja w strumieniu jest zaawansowana przez liczbę odczytanych bajtów; Jeśli jednak wystąpi wyjątek, bieżąca pozycja w strumieniu pozostaje niezmieniona. Implementacje zwracają liczbę odczytanych bajtów. Implementacja zostanie Zablokowani do momentu odczytania co najmniej jednego bajtu danych, w przypadku, gdy żadne dane nie są dostępne. <xref:System.IO.Stream.Read%2A>Zwraca wartość 0 tylko wtedy, gdy nie ma więcej danych w strumieniu i nie ma więcej oczekiwanych (takich jak zamknięte gniazdo lub koniec pliku). Implementacja może zwrócić mniejszą liczbę bajtów niż żądana, nawet jeśli koniec strumienia nie został osiągnięty.  
  
 Służy <xref:System.IO.BinaryReader> do odczytywania typów danych pierwotnych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.IO.Stream.Read%2A> do odczytywania bloku danych.  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia i przesuwa pozycję w strumieniu o liczbę odczytanych bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci, w którym mają zostać zapisane dane.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia, przesuwa pozycję w strumieniu o liczbę odczytanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość jego <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> właściwości zawiera łączną liczbę bajtów odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba bajtów przydzieloną w buforze, jeśli liczba bajtów nie jest obecnie dostępna lub jeśli osiągnięto koniec strumienia, może być równy 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.ReadAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> wartość <xref:System.Threading.Tasks.Task.Status> właściwości.  
  
 Aby zapoznać się z przykładem <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, w którym mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu, <paramref name="buffer" /> w którym rozpocznie się zapisywanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia i przesuwa pozycję w strumieniu o liczbę odczytanych bajtów.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <paramref name="TResult" /> parametru zawiera łączną liczbę bajtów odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba żądanych bajtów, jeśli liczba aktualnie dostępnych bajtów jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.ReadAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak odczytywać asynchronicznie z pliku. W przykładzie zastosowano <xref:System.IO.FileStream> klasę, która pochodzi <xref:System.IO.Stream> od klasy.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, w którym mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu, <paramref name="buffer" /> w którym rozpocznie się zapisywanie danych ze strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia, przesuwa pozycję w strumieniu o liczbę odczytanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczną operację odczytu. Wartość <paramref name="TResult" /> parametru zawiera łączną liczbę bajtów odczytywanych w buforze. Wartość wynikowa może być mniejsza niż liczba żądanych bajtów, jeśli liczba aktualnie dostępnych bajtów jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.ReadAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Aby zapoznać się z przykładem <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację odczytu.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje bajt ze strumienia i przesuwa pozycję w strumieniu o jeden bajt lub zwraca wartość-1, jeśli na końcu strumienia.</summary>
        <returns>Bajty bez znaku rzutowanie <see langword="Int32" />na lub-1, jeśli na końcu strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanRead%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje odczytywanie.  
  
 Próby manipulowania strumieniem po zamknięciu strumienia mogą zgłosić <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje odczytywania.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <block subset="none" type="overrides"><para>Domyślna implementacja w <see langword="Stream" /> programie tworzy nową tablicę jednobajtową, a następnie <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />wywołuje metodę. Chociaż jest to prawidłowe rozwiązanie, jest niewydajne. Każdy strumień z wewnętrznym buforem powinien przesłonić tę metodę i zapewnić znacznie bardziej wydajną wersję, która odczytuje bufor bezpośrednio, unikając dodatkowej alokacji tablicy dla każdego wywołania.</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość (w milisekundach), która określa, jak długo strumień będzie próbować odczytać przed upływem limitu czasu.</summary>
        <value>Wartość w milisekundach, która określa, jak długo strumień będzie próbować odczytać przed upływem limitu czasu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.IO.Stream.ReadTimeout" /> Metoda zawsze <see cref="T:System.InvalidOperationException" />zgłasza.</exception>
        <block subset="none" type="overrides"><para><see cref="P:System.IO.Stream.ReadTimeout" /> Właściwość powinna zostać zastąpiona, aby zapewnić odpowiednie zachowanie strumienia. Jeśli strumień nie obsługuje limitu czasu, ta właściwość powinna podnieść <see cref="T:System.InvalidOperationException" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Przesunięcie bajtów względem <paramref name="origin" /> parametru.</param>
        <param name="origin">Wartość typu <see cref="T:System.IO.SeekOrigin" /> wskazująca punkt odniesienia używany do uzyskania nowego położenia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ustawia pozycję w bieżącym strumieniu.</summary>
        <returns>Nowa pozycja w bieżącym strumieniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanSeek%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje wyszukiwanie.  
  
 Jeśli `offset` jest ujemna, Nowa pozycja jest wymagana, aby poprzedzać pozycję `origin` określoną przez liczbę bajtów określoną przez `offset`. Jeśli `offset` jest równa zero (0), Nowa pozycja musi być pozycją określoną przez `origin`. Jeśli `offset` jest dodatnia, nowe położenie jest wymagane, aby postępować zgodnie z `origin` pozycją określoną przez `offset`liczbę bajtów określoną przez.  
  
 Klasy pochodzące od `Stream` tej obsługi muszą przesłaniać tę metodę w celu zapewnienia opisanych powyżej funkcji.  
  
 Wyszukiwanie w dowolnej lokalizacji poza długością strumienia jest obsługiwane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje wyszukiwania, na przykład jeśli strumień jest zbudowany z potoku lub danych wyjściowych konsoli.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wymagana długość bieżącego strumienia w bajtach.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, ustawia długość bieżącego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określona wartość jest mniejsza niż bieżąca długość strumienia, strumień zostanie obcięty. Jeśli określona wartość jest większa niż bieżąca długość strumienia, zostanie rozwinięty strumień. Jeśli strumień jest rozwinięty, zawartość strumienia między starą i nową długością nie jest zdefiniowana.  
  
 Strumień musi obsługiwać operacje pisania i wyszukiwania `SetLength` .  
  
 Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje pisanie, <xref:System.IO.Stream.CanSeek%2A> i właściwość, aby określić, czy wyszukiwanie jest obsługiwane. <xref:System.IO.Stream.CanWrite%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zarówno pisania, jak i wyszukiwania, takich jak Jeśli strumień jest zbudowany z potoku lub danych wyjściowych konsoli.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Obiekt do zsynchronizowania.</param>
        <summary>Tworzy otokę z bezpiecznym wątkiem (zsynchronizowaną) <see cref="T:System.IO.Stream" /> wokół określonego obiektu.</summary>
        <returns>Obiekt bezpieczny <see cref="T:System.IO.Stream" /> wątkowo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca klasę, która otacza określony <xref:System.IO.Stream> obiekt i ogranicza dostęp do niego z wielu wątków. Cały dostęp do <xref:System.IO.Stream> obiektu będzie bezpieczny wątkowo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.IO.Stream" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.IO.Stream> gdy wystąpienie jest rzutowane <xref:System.IDisposable> do interfejsu.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci. Ta metoda kopiuje zawartość tego regionu do bieżącego strumienia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje sekwencję bajtów do bieżącego strumienia i zwiększa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie. Użyj metody <xref:System.IO.Stream.WriteAsync%2A> , aby zapisać asynchronicznie w bieżącym strumieniu.  
  
 Jeśli operacja zapisu powiedzie się, pozycja w strumieniu zastąpi przez liczbę zapisanych bajtów. Jeśli wystąpi wyjątek, pozycja w strumieniu pozostaje niezmieniona.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tablica bajtów. Ta metoda kopiuje <paramref name="count" /> bajty <paramref name="buffer" /> z do bieżącego strumienia.</param>
        <param name="offset">Przesunięcie bajtu (liczony od zera <paramref name="buffer" /> ), w którym rozpocznie się kopiowanie bajtów do bieżącego strumienia.</param>
        <param name="count">Liczba bajtów do zapisania w bieżącym strumieniu.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, zapisuje sekwencję bajtów do bieżącego strumienia i zwiększa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie. Użyj metody <xref:System.IO.Stream.WriteAsync%2A> , aby zapisać asynchronicznie w bieżącym strumieniu.  
  
 Jeśli operacja zapisu powiedzie się, pozycja w strumieniu zastąpi przez liczbę zapisanych bajtów. Jeśli wystąpi wyjątek, pozycja w strumieniu pozostaje niezmieniona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, na przykład nie można znaleźć określonego pliku.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />został wywołany po zamknięciu strumienia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia i przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Region pamięci, z której mają zostać zapisane dane.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia, przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.WriteAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Aby zapoznać się z przykładem <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, z którego mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu (liczony <paramref name="buffer" /> od zera), od którego należy rozpocząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia i przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.WriteAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zapisywać asynchronicznie w pliku. W przykładzie zastosowano <xref:System.IO.FileStream> klasę, która pochodzi <xref:System.IO.Stream> od klasy.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor, z którego mają zostać zapisane dane.</param>
        <param name="offset">Przesunięcie bajtu (liczony <paramref name="buffer" /> od zera), od którego należy rozpocząć kopiowanie bajtów do strumienia.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <param name="cancellationToken">Token do monitorowania żądań anulowania. Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia, przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów i monitoruje żądania anulowania.</summary>
        <returns>Zadanie, które reprezentuje asynchroniczny zapis operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.WriteAsync%2A> Metoda umożliwia wykonywanie operacji We/Wy intensywnie obciążających zasoby bez blokowania wątku głównego. Ten aspekt dotyczący wydajności jest szczególnie ważny w aplikacji [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] lub aplikacjach [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)], gdzie czasochłonne operacje strumieniowe mogą zablokować wątek interfejsu użytkownika i spowodować, że aplikacja będzie wyglądać, jakby przestała działać. Metody asynchroniczne są używane w połączeniu z `async` słowami kluczowymi i `await` w Visual Basic C#i.  
  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.  
  
 Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.  
  
 Aby zapoznać się z przykładem <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</exception>
        <exception cref="T:System.ArgumentException">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisu.</exception>
        <exception cref="T:System.ObjectDisposedException">Strumień został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Strumień jest obecnie używany przez poprzednią operację zapisu.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Anulowanie</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Bajt do zapisu w strumieniu.</param>
        <summary>Zapisuje bajty w bieżącym położeniu w strumieniu i przesuwa pozycję w strumieniu o jeden bajt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpi błąd We/Wy.</exception>
        <exception cref="T:System.NotSupportedException">Strumień nie obsługuje zapisywania lub strumień jest już zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Metody zostały wywołane po zamknięciu strumienia.</exception>
        <block subset="none" type="overrides"><para>Domyślna implementacja w <see langword="Stream" /> programie tworzy nową tablicę jednobajtową, a następnie <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />wywołuje metodę. Chociaż jest to prawidłowe rozwiązanie, jest niewydajne. Każdy strumień z wewnętrznym buforem powinien przesłonić tę metodę i zapewnić znacznie bardziej wydajną wersję, która bezpośrednio zapisuje w buforze, unikając dodatkowej alokacji tablicy dla każdego wywołania.</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość (w milisekundach), która określa, jak długo strumień podejmie próbę zapisu przed upływem limitu czasu.</summary>
        <value>Wartość w milisekundach, która określa, jak długo strumień podejmie próbę zapisu przed upływem limitu czasu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.IO.Stream.WriteTimeout" /> Metoda zawsze <see cref="T:System.InvalidOperationException" />zgłasza.</exception>
        <block subset="none" type="overrides"><para><see cref="P:System.IO.Stream.WriteTimeout" /> Właściwość powinna zostać zastąpiona, aby zapewnić odpowiednie zachowanie strumienia. Jeśli strumień nie obsługuje limitu czasu, ta właściwość powinna podnieść <see cref="T:System.InvalidOperationException" />.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>

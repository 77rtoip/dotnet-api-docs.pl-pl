<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4b20188d32caff36d11ff441632a04d34e6b4065" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56402932" /></Metadata><TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody wystąpienia do tworzenia, przenoszenia i wyliczania katalogów i podkatalogów. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.DirectoryInfo> klasy dla typowych operacji, takich jak kopiowanie, przenoszenie, zmiana nazwy, tworzenie i usuwanie katalogów.  
  
 Jeśli chcesz ponownie użyć obiektu, należy wziąć pod uwagę przy użyciu metody wystąpienia <xref:System.IO.DirectoryInfo> zamiast odpowiednich metod statycznych <xref:System.IO.Directory> klasy, ponieważ sprawdzanie zabezpieczeń nie zawsze jest konieczne.  
  
> [!NOTE]
>  W przypadku elementów członkowskich, które akceptują ścieżka jako ciąg wejściowy ta ścieżka musi być poprawnie sformułowany lub zgłaszany jest wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowany, ale zaczyna się od spacji, ścieżki nie są spacje w metody klasy. W związku z tym ścieżka jest źle sformułowany i zgłaszany jest wyjątek. Podobnie ścieżki lub kombinacji ścieżki nie może być w pełni kwalifikowana dwa razy. Na przykład "c:\temp c:\windows" zgłasza również wyjątek w większości przypadków. Upewnij się, Twoje ścieżki są poprawnie sformułowane, korzystając z metod, które akceptują ciąg ścieżki.  
  
 W przypadku elementów członkowskich, które akceptują ścieżki ścieżki mogą odwoływać się do pliku lub po prostu katalogu. Określona ścieżka może również dotyczyć ścieżką względną lub ścieżką Universal Naming Convention (UNC) dla nazwy serwera i udziału. Na przykład następujące warunki są dopuszczalne ścieżki:  
  
-   "c:\\\MyDir\\\MyFile.txt" w języku C# lub "c:\MyDir\MyFile.txt" w języku Visual Basic.  
  
-   "c:\\\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.  
  
-   "MyDir\\\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" w języku C# lub "\\\MyServer\MyShare" w języku Visual Basic.  
  
 Domyślnie Pełny odczyt/zapis dostęp do nowych katalogów otrzymuje dla wszystkich użytkowników.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano niektóre z głównych elementów członkowskich `DirectoryInfo` klasy.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 Poniższy przykład pokazuje, jak można skopiować katalogu i jego zawartość.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis w nowo utworzonym pliku danych</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ciąg określający ścieżkę, na którym chcesz utworzyć <see langword="DirectoryInfo" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.DirectoryInfo" /> klasy w określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie sprawdza, czy katalog istnieje. Ten konstruktor jest symbolem zastępczym dla ciąg, który jest używany do uzyskania dostępu do dysku podczas kolejnych operacji.  
  
 `path` Parametr może być nazwa pliku, w tym pliku w udziale Universal Naming Convention (UNC).  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zawiera ten konstruktor do tworzenia określonego katalogu i podkatalogów i pokazuje, że nie można usunąć katalogu, który zawiera podkatalogi.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> zawiera nieprawidłowe znaki, takie jak ", &lt;, &gt;, lub |.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">podczas odczytu z plików i katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy katalog.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy katalog.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli katalog już istnieje, ta metoda nie działa.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Następujące testy przykład czy określony katalog istnieje, tworzy katalog nie istnieje i usuwa katalog.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można utworzyć katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Kontrola dostępu do zastosowania do katalogu.</param>
        <summary>Tworzy katalogu przy użyciu <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeciążenia służy do tworzenia katalogu przy użyciu kontroli dostępu, więc nie ma żadnych szansy katalogu są dostępne przed zastosowaniem zabezpieczeń.  
  
 Jeśli katalog już istnieje, ta metoda nie działa.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest tylko do odczytu lub nie jest pusty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków, zgodnie z definicją <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.NotSupportedException">Podjęto próbę Tworzenie katalogu na znak dwukropka (:).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać uprawnienia do tworzenia katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy podkatalogu lub podkatalogi w określonej ścieżce. Określona ścieżka może być względem tego wystąpienia <see cref="T:System.IO.DirectoryInfo" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Określona ścieżka. Nie może to być inny dysk woluminu lub nazwa Universal Naming Convention (UNC).</param>
        <summary>Tworzy podkatalogu lub podkatalogi w określonej ścieżce. Określona ścieżka może być względem tego wystąpienia <see cref="T:System.IO.DirectoryInfo" /> klasy.</summary>
        <returns>Ostatnie katalogu wskazanym na <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w `path` są tworzone, chyba że jakaś część `path` jest nieprawidłowy. `path` Parametr określa ścieżkę do katalogu, nie ścieżka do pliku. Jeśli podkatalogu już istnieje, ta metoda nie działa.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano Tworzenie podkatalogu. W tym przykładzie utworzono katalogi są usuwane po utworzeniu. W związku z tym aby przetestować ten przykład, komentarz usuwania wierszy w kodzie.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> nie określa prawidłową ścieżkę pliku lub zawiera nieprawidłowe <see langword="DirectoryInfo" /> znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException">Nie można utworzyć podkatalogu.  
  
—lub— 
Plik lub katalog ma już nazwę określonego przez <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień dostępu do kodu można utworzyć katalogu.  
  
—lub— 
Obiekt wywołujący nie ma uprawnienia dostępu kodu do odczytu katalogu opisanego przez zwrócony <see cref="T:System.IO.DirectoryInfo" /> obiektu.  Taka sytuacja może wystąpić podczas <paramref name="path" /> parametru w tym artykule opisano istniejącego katalogu.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> zawiera znak dwukropka (:), który nie jest częścią Etykieta dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Określona ścieżka. Nie może to być inny dysk woluminu lub nazwa Universal Naming Convention (UNC).</param>
        <param name="directorySecurity">Zabezpieczenia do zastosowania.</param>
        <summary>Tworzy podkatalogu lub podkatalogi w określonej ścieżce za pomocą określonego zabezpieczenia. Określona ścieżka może być względem tego wystąpienia <see cref="T:System.IO.DirectoryInfo" /> klasy.</summary>
        <returns>Ostatnie katalogu wskazanym na <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w `path` są tworzone, chyba że jakaś część `path` jest nieprawidłowy. `path` Parametr określa ścieżkę do katalogu, nie ścieżka do pliku. Jeśli podkatalogu już istnieje, ta metoda nie działa.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> nie określa prawidłową ścieżkę pliku lub zawiera nieprawidłowe <see langword="DirectoryInfo" /> znaków.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.IO.IOException">Nie można utworzyć podkatalogu.  
  
—lub— 
Plik lub katalog ma już nazwę określonego przez <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień dostępu do kodu można utworzyć katalogu.  
  
—lub— 
Obiekt wywołujący nie ma uprawnienia dostępu kodu do odczytu katalogu opisanego przez zwrócony <see cref="T:System.IO.DirectoryInfo" /> obiektu.  Taka sytuacja może wystąpić podczas <paramref name="path" /> parametru w tym artykule opisano istniejącego katalogu.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> zawiera znak dwukropka (:), który nie jest częścią Etykieta dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa <see cref="T:System.IO.DirectoryInfo" /> wraz z jego zawartością ze ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Spowoduje to usunięcie <see cref="T:System.IO.DirectoryInfo" /> Jeśli jest on pusty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zgłasza wyjątek, Jeśli spróbujesz usunąć katalogu, który nie jest pusty.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Katalog zawiera plik tylko do odczytu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, opisano w tym <see cref="T:System.IO.DirectoryInfo" /> obiekt nie istnieje lub nie został odnaleziony.</exception>
        <exception cref="T:System.IO.IOException">Katalog nie jest pusty.  
  
—lub— 
Katalog znajduje się bieżący katalog roboczy aplikacji.  
  
—lub— 
Jest otwarte dojście do katalogu, a systemem operacyjnym jest Windows XP lub starszym. To otwarte dojście może wynikać z wyliczanie katalogów. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i plików](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do tworzenia katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive"><see langword="true" /> Aby usunąć ten katalog, jego podkatalogów i wszystkich plików; w przeciwnym razie <see langword="false" />.</param>
        <summary>Usuwa to wystąpienie <see cref="T:System.IO.DirectoryInfo" />, określając, czy chcesz usunąć podkatalogów i plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `DirectoryInfo` nie ma pliki lub podkatalogi, ta metoda usuwa `DirectoryInfo` nawet wtedy, gdy `recursive` jest `false`. Podjęto próbę usunięcia `DirectoryInfo` nie jest pusty po `recursive` jest `false` zgłasza <xref:System.IO.IOException>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, usunięcie katalogu. Ponieważ katalog jest usuwany, najpierw komentarz `Delete` wiersza, aby sprawdzić, czy katalog istnieje. Następnie usuń komentarz ten sam wiersz kodu, aby sprawdzić, czy katalog został pomyślnie usunięty.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Katalog zawiera plik tylko do odczytu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, opisano w tym <see cref="T:System.IO.DirectoryInfo" /> obiekt nie istnieje lub nie został odnaleziony.</exception>
        <exception cref="T:System.IO.IOException">Katalog znajduje się tylko do odczytu.  
  
—lub— 
Katalog zawiera jeden lub więcej plików i podkatalogów i <paramref name="recursive" /> jest <see langword="false" />.  
  
—lub— 
Katalog znajduje się bieżący katalog roboczy aplikacji.  
  
—lub— 
Jest otwarte dojście, katalogu lub jednego z jego plików, i system operacyjny Windows XP lub starszym. To otwarte dojście może wynikać z wyliczanie katalogów i plików. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i plików](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Flagi wymagane dla uprawnień zapisu do zapisu <see langword="DirectoryInfo" /> i podkatalogi do usunięcia.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalny zbiór informacji o katalogu w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny zbiór informacji o katalogu w bieżącym katalogu.</summary>
        <returns>Wyliczalne zbiór katalogów w bieżącym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> i <xref:System.IO.DirectoryInfo.GetDirectories%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.DirectoryInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetDirectories%2A>, należy poczekać całą gamę <xref:System.IO.DirectoryInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza podkatalogów w katalogu C:\Program Files i używa zapytania LINQ do zwracania nazwy wszystkie katalogi, które zostały utworzone przed 2009, sprawdzając wartość <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> właściwości.  
  
 Jeśli potrzebujesz tylko nazwy podkatalogów, używa się statycznej <xref:System.IO.Directory> klasy w celu zapewnienia lepszej wydajności. Aby uzyskać przykład, zobacz <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> metody.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazwy katalogów.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny informacji katalogu, który jest zgodny ze wzorcem wyszukiwania.</summary>
        <returns>Wyliczalny kolekcję katalogi odpowiada <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> i <xref:System.IO.DirectoryInfo.GetDirectories%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.DirectoryInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetDirectories%2A>, należy poczekać całą gamę <xref:System.IO.DirectoryInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazwy katalogów.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać w bieżącym katalogu i wszystkich podkatalogach. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny informacji katalogu, który odpowiada opcję wyszukiwania określonego wzorca i wyszukiwanie podkatalogu.</summary>
        <returns>Wyliczalny kolekcję katalogi odpowiada <paramref name="searchPattern" /> i <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> i <xref:System.IO.DirectoryInfo.GetDirectories%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.DirectoryInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetDirectories%2A>, należy poczekać całą gamę <xref:System.IO.DirectoryInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
   
  
## Examples  
 W poniższym przykładzie, zaczynając od określonego katalogu użyto tę metodę i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> metodę, aby wyliczyć plików i katalogów w katalogu uruchamiania i wyświetlić szczegóły każdego pliki o ponad 10 MB rozmiar.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalny zbiór informacji o pliku w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny zbiór informacji o pliku w bieżącym katalogu.</summary>
        <returns>Wyliczalne zbiór plików w bieżącym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i <xref:System.IO.DirectoryInfo.GetFiles%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A>, należy poczekać całą gamę <xref:System.IO.FileInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład wylicza pliki w określonym katalogu i używa zapytania LINQ do zwracania nazwy wszystkich plików, które zostały utworzone przed 2009, sprawdzając wartość <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> właściwości.  
  
 Jeśli potrzebujesz tylko nazwy plików, używa się statycznej <xref:System.IO.Directory> klasy w celu zapewnienia lepszej wydajności. Aby uzyskać przykład, zobacz <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 Poniższy przykład pokazuje, jak wyliczyć pliki w katalogu za pomocą opcji wyszukiwania innym. W przykładzie założono katalogu, który zawiera pliki o nazwie log1.txt, log2.txt, test1.txt test2.txt, test3.txt i podkatalogu, który zawiera plik o nazwie SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazw plików.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny informacje o pliku, który pasuje do wzorca wyszukiwania.</summary>
        <returns>Wyliczalny kolekcję plików, który odpowiada <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i <xref:System.IO.DirectoryInfo.GetFiles%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A>, należy poczekać całą gamę <xref:System.IO.FileInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyliczyć pliki w katalogu za pomocą opcji wyszukiwania innym. W przykładzie założono katalogu, który zawiera pliki o nazwie log1.txt, log2.txt, test1.txt test2.txt, test3.txt i podkatalogu, który zawiera plik o nazwie SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład okazał się na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazw plików.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać w bieżącym katalogu i wszystkich podkatalogach. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny informacje o pliku, odpowiadający opcję wyszukiwania określonego wzorca i wyszukiwanie podkatalogu.</summary>
        <returns>Wyliczalny kolekcję plików, który odpowiada <paramref name="searchPattern" /> i <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i <xref:System.IO.DirectoryInfo.GetFiles%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A>, należy poczekać całą gamę <xref:System.IO.FileInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wyliczyć pliki w katalogu za pomocą opcji wyszukiwania innym. W przykładzie założono katalogu, który zawiera pliki o nazwie log1.txt, log2.txt, test1.txt test2.txt, test3.txt i podkatalogu, który zawiera plik o nazwie SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalny zbiór informacje o systemie plików w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalny zbiór informacje o systemie plików w bieżącym katalogu.</summary>
        <returns>Wyliczalne zbiór informacje o systemie plików w bieżącym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> i <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileSystemInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, należy poczekać całą gamę <xref:System.IO.FileSystemInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazwy katalogów.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca kolekcję wyliczalny informacje o systemie plików, który jest zgodny ze wzorcem wyszukiwania.</summary>
        <returns>Wyliczalne kolekcję obiektów informacji systemu plików jest zgodna <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> i <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileSystemInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, należy poczekać całą gamę <xref:System.IO.FileSystemInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazwy katalogów.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać w bieżącym katalogu i wszystkich podkatalogach. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca kolekcję wyliczalny informacje o systemie plików, odpowiadający opcję wyszukiwania określonego wzorca i wyszukiwanie podkatalogu.</summary>
        <returns>Wyliczalne kolekcję obiektów informacji systemu plików jest zgodna <paramref name="searchPattern" /> i <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> i <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileSystemInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, należy poczekać całą gamę <xref:System.IO.FileSystemInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwrócona Kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji zostanie uruchomione nowe wyliczenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy katalog istnieje.</summary>
        <value><see langword="true" /> Jeśli katalog istnieje; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.Exists%2A> Właściwość zwraca `false` sytuacji wszelkie błędy podczas próby określenia, czy istnieje określony plik. Taka sytuacja może wystąpić w sytuacji, które zgłaszają wyjątki, takich jak przekazanie nazwy pliku zawierającej nieprawidłowe znaki lub zbyt wiele znaków, ile niepowodzeniem lub brakuje dysku, czy obiekt wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie `Exists` właściwość w kontekście kopiowanie katalog źródłowy do katalogu docelowego.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę katalogu.</summary>
        <value>Ciąg zawierający pełną ścieżkę.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>    
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera listę kontroli dostępu (ACL) wpisy kontroli dostępu, dla bieżącego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metody do pobierania dostępu kontrolują wpisy listę kontroli dostępu (ACL) dla bieżącego pliku.  
  
 Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który hermetyzuje wpisów listę kontroli dostępu (ACL) kontroli dostępu dla katalogu opisanego przez bieżącą <see cref="T:System.IO.DirectoryInfo" /> obiektu.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który hermetyzuje zasad kontroli dostępu do katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tego przeciążenia metody jest równoważne z wywoływaniem <xref:System.IO.Directory.GetAccessControl%2A> przeciążenie metody i określając dostęp kontrolować sekcje <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> w języku Visual Basic).  
  
 Użyj <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metody do pobierania wpisów listę kontroli dostępu (ACL) kontroli dostępu dla bieżącego pliku.  
  
 Listy ACL w tym artykule opisano użytkowników indywidualnych i/lub grupy, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.DirectoryInfo.GetAccessControl%2A> i <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metody, aby dodać, a następnie usuń dostęp kontrolować listę kontroli dostępu (ACL) wpis z katalogu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub zmodyfikowane katalogu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Katalog znajduje się tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd We/Wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Microsoft Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Jedną z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, które określa typ dostępu kontrolować listę kontroli dostępu (ACL) informacji do odbierania.</param>
        <summary>Pobiera <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który hermetyzuje określony typ pozycji listy (ACL) kontroli dostępu dla katalogu opisanego przez bieżącą <see cref="T:System.IO.DirectoryInfo" /> obiektu.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt, który hermetyzuje kontroli dostępu reguły dla pliku opisanego przez <paramref name="path" /> parametru.  
  
Wyjątki 
 <list type="table"><listheader><term> Typ wyjątku 
 </term><description> Warunek 
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> Nie można odnaleźć lub zmodyfikowane katalogu.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Bieżący proces nie ma dostępu, aby otworzyć katalog.  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> Wystąpił błąd We/Wy podczas otwierania katalogu.  
  
 </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> Bieżący system operacyjny nie jest Microsoft Windows 2000 lub nowszym.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Katalog znajduje się tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metody do pobierania wpisów listę kontroli dostępu (ACL) kontroli dostępu dla bieżącego pliku.  
  
 Listy ACL w tym artykule opisano użytkowników indywidualnych i/lub grupy, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca podkatalogów w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podkatalogów w bieżącym katalogu.</summary>
        <returns>Tablica <see cref="T:System.IO.DirectoryInfo" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych podkatalogów, ta metoda zwraca pustą tablicę. Ta metoda nie jest cykliczna.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład pobiera wszystkich katalogów w katalogu głównym i wyświetla nazwy katalogów.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see cref="T:System.IO.DirectoryInfo" /> obiekt jest nieprawidłowy, np. Trwa na niemapowanym dysku.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Odczytywanie katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazwy katalogów.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca tablicę katalogów w bieżącym <see cref="T:System.IO.DirectoryInfo" /> pasujących do podanych kryteriów wyszukiwania.</summary>
        <returns>Tablica typu <see langword="DirectoryInfo" /> pasującego <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład jest liczona katalogi w ścieżce, zawierające określony literę.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see langword="DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z plików i katalogów oraz dostęp do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazwy katalogów.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać w bieżącym katalogu i wszystkich podkatalogach.</param>
        <summary>Zwraca tablicę katalogów w bieżącym <see cref="T:System.IO.DirectoryInfo" /> i dopasowania podanych kryteriów wyszukiwania przy użyciu wartości w celu ustalenia, czy podkatalogi wyszukiwania.</summary>
        <returns>Tablica typu <see langword="DirectoryInfo" /> pasującego <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 Jeżeli nie żadnych podkatalogów, lub podkatalogi nie odpowiada `searchPattern` parametru, ta metoda zwraca pustą tablicę.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład wyświetla listę wszystkich katalogów i plików, które zaczynają się od litera "c" w "c:\\".  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka hermetyzowane w <see langword="DirectoryInfo" /> obiektu jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z plików i katalogów oraz dostęp do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca listę plików z bieżącego katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę plików z bieżącego katalogu.</summary>
        <returns>Tablica typu <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i <xref:System.IO.DirectoryInfo.GetFiles%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A>, należy poczekać całą gamę <xref:System.IO.FileInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Jeśli nie ma żadnych plików w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę.  
  
 Nie jest gwarantowana kolejność nazw plików zwrócone; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można pobrać listy plików z katalogu za pomocą opcji wyszukiwania innym. W przykładzie założono katalogu, który zawiera pliki o nazwie log1.txt, log2.txt, test1.txt test2.txt, test3.txt i podkatalogu, który zawiera plik o nazwie SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa, np. Trwa na niemapowanym dysku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Odczytywanie katalogów. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazw plików.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca listę plików z bieżącego katalogu pasujących do podanego wzorca.</summary>
        <returns>Tablica typu <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i <xref:System.IO.DirectoryInfo.GetFiles%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A>, należy poczekać całą gamę <xref:System.IO.FileInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Jeśli nie ma żadnych plików w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę.  
  
 Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern` parametru.  
  
|wieloznaczny|Opis|  
|------------------------|-----------------|  
|*|Zero lub więcej znaków.|  
|?|Dokładnie zero lub jeden znak.|  
  
 Nie jest gwarantowana kolejność nazw plików zwrócone; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 Symbole wieloznaczne są dozwolone. Na przykład `searchPattern` ciągu wyszukiwania "*.txt" dla wszystkich plików mających rozszerzenie "txt" nazw. `searchPattern` Ciąg "s\*" wyszukiwania dla wszystkich plików nazw rozpoczynających się od litera "s". Jeśli ma żadnych plików lub nie pliki dopasowane `searchPattern` ciągu w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę.  
  
> [!NOTE]
>  Korzystając z gwiazdki jako symbolu wieloznacznego w `searchPattern` (na przykład "*.txt"), zachowanie pasujące różni się zależnie od długości określone rozszerzenie pliku. A `searchPattern` przy użyciu pliku rozszerzenie dokładnie trzy znaki zwraca pliki z rozszerzeniem trzech lub więcej znaków, jeśli pierwsze trzy znaki są takie same rozszerzenie pliku określonego w `searchPattern`. A `searchPattern` przy użyciu pliku rozszerzenie jeden, dwa lub więcej niż trzy znaki zwraca tylko pliki z rozszerzeniami dokładnie tak długo, zgodne z rozszerzeniem pliku określonego w `searchPattern`. Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki w katalogu, "więc Plik1.txt" i "file1.txtother", wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik podczas wyszukiwania wzorzec" pliku\*.txt "zwraca zarówno pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza względem format nazwy pliku w formacie 8.3 i format nazwy pliku długie nazwy plików, wyszukiwanie wzorca podobny do "* 1\*.txt" może zwracać nieoczekiwane nazwy. Na przykład za pomocą wzorca wyszukiwania "\*1\*.txt" zwróci "długa_nazwa_pliku.txt", ponieważ równoważne format nazwy pliku w formacie 8.3 będzie "longf~1.txt".  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można pobrać listy plików z katalogu za pomocą opcji wyszukiwania innym. W przykładzie założono katalogu, który zawiera pliki o nazwie log1.txt, log2.txt, test1.txt test2.txt, test3.txt i podkatalogu, który zawiera plik o nazwie SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki i odczytywanie ich z niego plików i katalogów. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazw plików.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać w bieżącym katalogu i wszystkich podkatalogach.</param>
        <summary>Zwraca listę plików z bieżącego katalogu pasujących do podanego wzorca i przy użyciu wartości w celu ustalenia, czy podkatalogi wyszukiwania.</summary>
        <returns>Tablica typu <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i <xref:System.IO.DirectoryInfo.GetFiles%2A> metody różnią się w następujący sposób:  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, możesz rozpocząć wyliczanie kolekcji <xref:System.IO.FileInfo> obiektów przed zwróceniem całą kolekcję.  
  
-   Kiedy używasz <xref:System.IO.DirectoryInfo.GetFiles%2A>, należy poczekać całą gamę <xref:System.IO.FileInfo> obiekty, które mają zostać zwrócone, zanim można uzyskać dostęp do tablicy.  
  
 W związku z tym, podczas pracy z wieloma plikami i katalogami, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> może być bardziej wydajne.  
  
 Jeśli nie ma żadnych plików w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę.  
  
 Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|wieloznaczny|Opis|  
|------------------------|-----------------|  
|* (gwiazdka)|Zero lub więcej znaków.|  
|? (znak zapytania)|Dokładnie zero lub jeden znak.|  
  
 Nie jest gwarantowana kolejność nazw plików zwrócone; Użyj <xref:System.Array.Sort%2A> metodę, jeśli określone sortowanie jest wymagana.  
  
 Symbole wieloznaczne są dozwolone. Na przykład `searchPattern` ciągu wyszukiwania "*.txt" dla wszystkich plików mających rozszerzenie "txt" nazw. `searchPattern` Ciąg "s\*" wyszukiwania dla wszystkich plików nazw rozpoczynających się od litera "s". Jeśli ma żadnych plików lub nie pliki dopasowane `searchPattern` ciągu w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę.  
  
> [!NOTE]
>  Korzystając z gwiazdki jako symbolu wieloznacznego w `searchPattern` (na przykład "*.txt"), zachowanie pasujące różni się zależnie od długości określone rozszerzenie pliku. A `searchPattern` przy użyciu pliku rozszerzenie dokładnie trzy znaki zwraca pliki z rozszerzeniem trzech lub więcej znaków, jeśli pierwsze trzy znaki są takie same rozszerzenie pliku określonego w `searchPattern`. A `searchPattern` przy użyciu pliku rozszerzenie jeden, dwa lub więcej niż trzy znaki zwraca tylko pliki z rozszerzeniami dokładnie tak długo, zgodne z rozszerzeniem pliku określonego w `searchPattern`. Korzystając z symbolami wieloznacznymi znak zapytania, Metoda ta zwraca tylko te pliki, które spełniają określone rozszerzenie pliku. Na przykład, biorąc pod uwagę dwa pliki w katalogu, "więc Plik1.txt" i "file1.txtother", wzorzec wyszukiwania "plik?. txt"zwraca tylko pierwszy plik podczas wyszukiwania wzorzec" pliku\*.txt "zwraca zarówno pliki.  
  
 Na poniższej liście przedstawiono zachowanie różnych długościach dla `searchPattern` parametru:  
  
-   "* .abc" zwraca pliki mające of.abc,.abcd,.abcde,.abcdef rozszerzenia i tak dalej.  
  
-   "*.abcd" zwraca tylko pliki mające rozszerzenie of.abcd.  
  
-   "*.abcde" zwraca tylko pliki mające rozszerzenie of.abcde.  
  
-   "*.abcdef" zwraca tylko pliki mające rozszerzenie of.abcdef.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza względem format nazwy pliku w formacie 8.3 i format nazwy pliku długie nazwy plików, wyszukiwanie wzorca podobny do "* 1\*.txt" może zwracać nieoczekiwane nazwy. Na przykład za pomocą wzorca wyszukiwania "\*1\*.txt" zwróci "długa_nazwa_pliku.txt", ponieważ równoważne format nazwy pliku w formacie 8.3 będzie "longf~1.txt".  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można pobrać listy plików z katalogu za pomocą opcji wyszukiwania innym. W przykładzie założono katalogu, który zawiera pliki o nazwie log1.txt, log2.txt, test1.txt test2.txt, test3.txt i podkatalogu, który zawiera plik o nazwie SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Aby uzyskać dostęp do ścieżki i odczytywanie ich z niego plików i katalogów. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera tablicę silnie typizowane <see cref="T:System.IO.FileSystemInfo" /> obiekty reprezentujące plików i podkatalogów w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę silnie typizowane <see cref="T:System.IO.FileSystemInfo" /> wpisów, reprezentującą wszystkich plików i podkatalogów w katalogu.</summary>
        <returns>Tablica silnie typizowane <see cref="T:System.IO.FileSystemInfo" /> wpisów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych plików lub katalogów w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę. Ta metoda nie jest cykliczna.  
  
 Aby uzyskać podkatalogi <xref:System.IO.FileSystemInfo> mogą być rzutowane obiektów zwróconych przez tę metodę do klasy pochodnej <xref:System.IO.DirectoryInfo>. Użyj <xref:System.IO.FileAttributes> wartość zwrócona przez obiekt <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> właściwości, aby określić, czy <xref:System.IO.FileSystemInfo> reprezentuje plik lub katalog.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład liczby plików i katalogów w określonym katalogu.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazw katalogów i plików.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Pobiera tablicę silnie typizowane <see cref="T:System.IO.FileSystemInfo" /> obiekty reprezentujące plików i podkatalogów, które odpowiadają określonym kryteriom wyszukiwania.</summary>
        <returns>Tablica silnie typizowane <see langword="FileSystemInfo" /> obiektów spełniających kryteria wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 Ta metoda nie jest cykliczna.  
  
 Aby uzyskać podkatalogi <xref:System.IO.FileSystemInfo> mogą być rzutowane obiektów zwróconych przez tę metodę do klasy pochodnej <xref:System.IO.DirectoryInfo>. Użyj <xref:System.IO.FileAttributes> wartość zwrócona przez obiekt <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> właściwości, aby określić, czy <xref:System.IO.FileSystemInfo> reprezentuje plik lub katalog.  
  
 Symbole wieloznaczne są dozwolone. Na przykład `searchPattern` ciąg "* t" wyszukuje wszystkie nazwy katalogów w `path` kończąc na literę "t". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy katalogów w `path` rozpoczynające się od litery "s".  
  
 Ciąg ".." można używać tylko w `searchPattern` Jeśli jest określona jako część prawidłowej nazwy katalogu, takie jak w nazwie katalogu ".. "b". Nie można przenieść w górę hierarchii katalogów. Jeśli żadne pliki lub katalogi, lub nie są pliki lub katalogi, które odpowiadają `searchPattern` ciągu w <xref:System.IO.DirectoryInfo>, ta metoda zwraca pustą tablicę.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład liczby plików i katalogów, pasujących do wzorca wyszukiwania.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z plików i katalogów oraz dostęp do ścieżki. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowywania nazw katalogów i filesa.  Ten parametr może zawierać kombinację prawidłową ścieżkę literału i symboli wieloznacznych (* i?) znaki, ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, które określa, czy operacja wyszukiwania powinien zawierać w bieżącym katalogu i wszystkich podkatalogach. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Pobiera tablicę <see cref="T:System.IO.FileSystemInfo" /> obiektami, które reprezentują pliki i podkatalogi spełniające określone kryteria wyszukiwania.</summary>
        <returns>Tablica wpisy systemu plików, które pasują do kryteriów wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` może być kombinacją znaków literałowych i symboli wieloznacznych, ale go nie obsługuje wyrażeń regularnych. Następujące specyfikatory symboli wieloznacznych są dozwolone w `searchPattern`.  
  
|Specyfikator symboli wieloznacznych|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tym miejscu.|  
|? (znak zapytania)|Zero lub jeden znak w tym miejscu.|  
  
 Znaki inne niż symbol wieloznaczny są znaki literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się od litery "t". ". `searchPattern` Ciąg "s\*" wyszukuje wszystkie nazwy `path` rozpoczynające się od litery "s".  
  
 Aby uzyskać podkatalogi <xref:System.IO.FileSystemInfo> mogą być rzutowane obiektów zwróconych przez tę metodę do klasy pochodnej <xref:System.IO.DirectoryInfo>. Użyj <xref:System.IO.FileAttributes> wartość zwrócona przez obiekt <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> właściwości, aby określić, czy <xref:System.IO.FileSystemInfo> reprezentuje plik lub katalog.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> nie jest prawidłowym <see cref="T:System.IO.SearchOption" /> wartość.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład, jest na niemapowanym dysku).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Nazwa i ścieżka, do którego ma zostać przeniesiona z tego katalogu. Miejsce docelowe nie może być inny wolumin dysku lub katalog o identycznej nazwie. Może to być istniejący katalog, do którego chcesz dodać ten katalog jak podkatalog.</param>
        <summary>Przenosi <see cref="T:System.IO.DirectoryInfo" /> wystąpienia i jego zawartość do nowej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyrzuca <xref:System.IO.IOException> Jeśli, na przykład spróbujesz przenieść c:\mydir c:\public i c:\public już istnieje. Należy określić "c:\\\public\\\mydir" jako `destDirName` parametr, lub określ nową nazwę katalogu, takie jak "c:\\\newdir".  
  
 Ta metoda umożliwia przenoszenie katalog do katalogu tylko do odczytu. Atrybut odczytu/zapisu katalogu nie ma wpływ.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano przenoszenia katalogu.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destDirName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destDirName" /> jest pustym ciągiem ("").</exception>
        <exception cref="T:System.IO.IOException">Nastąpiła próba można przenieść katalogu do innego woluminu.  
  
—lub— 
 <paramref name="destDirName" /> już istnieje.  
  
—lub— 
Nie masz uprawnień dostępu do tej ścieżki.  
  
—lub— 
Katalog, przenoszone i katalog docelowy mają taką samą nazwę.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można odnaleźć katalogu docelowego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików i katalogów oraz dostęp do katalogu docelowego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tego <see cref="T:System.IO.DirectoryInfo" /> wystąpienia.</summary>
        <value>Nazwa katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.IO.DirectoryInfo.Name%2A> właściwość zwraca tylko nazwę katalogu, takie jak "Bin". Aby uzyskać pełną ścieżkę, taką jak "c:\public\Bin", należy użyć <xref:System.IO.FileSystemInfo.FullName%2A> właściwości.  
  
 <xref:System.IO.DirectoryInfo.Name%2A> Właściwość <xref:System.IO.DirectoryInfo> wymaga nie uprawnień (poza uprawnień do odczytu do katalogu, które są niezbędne do utworzenia <xref:System.IO.DirectoryInfo.Exists%2A>), ale można podawać nazwę katalogu. W razie potrzeby ręcznie out <xref:System.IO.DirectoryInfo> w chronionym katalogu o nazwie kryptograficznie bezpieczny, Utwórz katalog fikcyjnego do użycia niezaufanego kodu.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę bieżącego `DirectoryInfo` tylko wystąpienia.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera określony podkatalog w katalogu nadrzędnym.</summary>
        <value>Katalogu nadrzędnego lub <see langword="null" /> czy ścieżka jest pusta, czy ścieżka pliku wskazuje katalog główny (taki jak "\\", "C:" lub * "\\\server\share").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, odnoszące się do katalogu nadrzędnego w określonym katalogu.  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z plików i katalogów oraz dostęp do ścieżki. Powiązane wyliczenia: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera główną część katalogu.</summary>
        <value>Obiekt, który reprezentuje katalog główny katalog.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład przedstawia główne lokalizacje dla określonych katalogach.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytu z plików i katalogów oraz dostęp do ścieżki. Powiązane wyliczenia: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Obiekt, który opisuje wpisu listy ACL dotyczą katalog opisanego przez <paramref name="path" /> parametru.</param>
        <summary>Stosuje listę kontroli dostępu (ACL) wpisów kontroli dostępu, opisanego przez <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu w katalogu opisanego przez bieżącą <see cref="T:System.IO.DirectoryInfo" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listy kontroli dostępu (ACL) w tym artykule opisano użytkowników indywidualnych i/lub grupy, którzy lub nie ma praw do określonych akcji dla danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie pozycji listy kontroli dostępu](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> Metodę stosuje się wpisy listy kontroli dostępu do pliku, który reprezentuje noninherited listy ACL.  
  
> [!CAUTION]
>  Listy ACL określonych dla `directorySecurity` zastępuje istniejące listy ACL dla katalogu. Aby dodać uprawnienia dla nowego użytkownika, należy użyć <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodę, aby uzyskać istniejącej listy ACL i zmodyfikuj go.  
  
 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> Metody tylko będzie się powtarzał <xref:System.Security.AccessControl.DirectorySecurity> obiekty, które zostały zmodyfikowane po utworzeniu obiektu.  Jeśli <xref:System.Security.AccessControl.DirectorySecurity> obiekt nie został zmodyfikowany, go nie zostaną utrwalone w pliku.  W związku z tym, nie jest możliwe do pobrania <xref:System.Security.AccessControl.DirectorySecurity> obiektu z jednego pliku i ponowne zastosowanie tego samego obiektu do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do drugiego:  
  
1.  Użyj <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metodę, która pobierze <xref:System.Security.AccessControl.DirectorySecurity> obiektu z pliku źródłowego.  
  
2.  Utwórz nową <xref:System.Security.AccessControl.DirectorySecurity> obiektu dla pliku docelowego.  
  
3.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> metoda źródła <xref:System.Security.AccessControl.DirectorySecurity> obiektu można pobrać informacji o listy ACL.  
  
4.  Użyj <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> lub <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> metodę, aby skopiować informacje o pobranego w kroku 3 do miejsca docelowego <xref:System.Security.AccessControl.DirectorySecurity> obiektu.  
  
5.  Skonfiguruj docelowego <xref:System.Security.AccessControl.DirectorySecurity> obiektu za pomocą pliku docelowego <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.DirectoryInfo.GetAccessControl%2A> i <xref:System.IO.DirectoryInfo.SetAccessControl%2A> metody, aby dodać, a następnie usuń dostęp kontrolować listę kontroli dostępu (ACL) wpis z katalogu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="directorySecurity" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub modyfikacji pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do otwierania pliku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Microsoft Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia można wyliczyć listy kontroli dostępu (ACL) dla katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Powiązane wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca oryginalnej ścieżki, która została przekazana przez użytkownika.</summary>
        <returns>Oryginalna ścieżka, która została przekazana przez użytkownika.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu do pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ceed6829b5a0a3adab04cfbb9318ee9b329320d1" /><Meta Name="ms.sourcegitcommit" Value="a81314feefaa9d10797d6bfe39dab52ca7fd1709" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/22/2019" /><Meta Name="ms.locfileid" Value="69973068" /></Metadata><TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia metody instancji służące do tworzenia, przechodzenia i wyliczania katalogów i podkatalogów. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo> Użyj klasy dla typowych operacji, takich jak kopiowanie, przesuwanie, zmiana nazwy, tworzenie i Usuwanie katalogów.  
  
 Jeśli zamierzasz wielokrotnie ponownie użyć obiektu, rozważ użycie metody <xref:System.IO.DirectoryInfo> instancji zamiast odpowiednich metod <xref:System.IO.Directory> statycznych klasy, ponieważ sprawdzanie zabezpieczeń nie zawsze jest konieczne.  
  
> [!NOTE]
>  W elementach członkowskich, które akceptują ścieżkę jako ciąg wejściowy, ta ścieżka musi być poprawnie sformułowana lub występuje wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale zaczyna się od spacji, ścieżka nie jest przycięta w metodach klasy. W związku z tym ścieżka jest źle sformułowana i zgłaszany jest wyjątek. Podobnie ścieżka lub kombinacja ścieżek nie mogą być w pełni kwalifikowane dwukrotnie. Na przykład "c:\Temp c:\Windows" wywołuje również wyjątek w większości przypadków. Upewnij się, że ścieżki są poprawnie sformułowane podczas korzystania z metod, które akceptują ciąg ścieżki.  
  
 W elementach członkowskich, które akceptują ścieżkę, ścieżka może odwoływać się do pliku lub tylko katalogu. Określona ścieżka może również odwoływać się do ścieżki względnej lub ścieżki Universal Naming Convention (UNC) dla serwera i nazwy udziału. Na przykład wszystkie następujące są dopuszczalne ścieżki:  
  
-   "c:\\\mydir\\\MyFile.txt" in C#lub "c:\MyDir\MyFile.txt" w Visual Basic.  
  
-   "c:\\\mydir" in C#lub "c:\mydir" w Visual Basic.  
  
-   "Mydir\\\MySubdir" in C#lub "MyDir\MySubDir" w Visual Basic.  
  
-   "\\\\ C#\MyServer \MyShare" in lub"\\\MyServer\MyShare" w Visual Basic.\\\\  
  
 Domyślnie pełny dostęp do odczytu i zapisu do nowych katalogów jest udzielany wszystkim użytkownikom.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład demonstruje niektóre główne elementy członkowskie `DirectoryInfo` klasy.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 Poniższy przykład ilustruje sposób kopiowania katalogu i jego zawartości.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ciąg określający ścieżkę, w której ma zostać utworzony <see langword="DirectoryInfo" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.DirectoryInfo" /> klasy w określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie sprawdza, czy katalog istnieje. Ten konstruktor jest symbolem zastępczym dla ciągu, który jest używany do uzyskiwania dostępu do dysku podczas kolejnych operacji.  
  
 `path` Parametr może być nazwą pliku, łącznie z plikiem w udziale Universal Naming Convention (UNC).  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków przy użyciu określonego ustawienia kulturowego i pobierania tych samych znaków przy użyciu innego ustawienia kulturowego znaki mogą nie być interpretowane i mogą powodować wyjątek.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład używa tego konstruktora do utworzenia określonego katalogu i podkatalogu oraz pokazuje, że nie można usunąć katalogu, który zawiera podkatalogi.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera nieprawidłowe znaki, takie jak " &lt;, &gt;, lub |.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików i katalogów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy katalog.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy katalog.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli katalog już istnieje, ta metoda nie wykonuje żadnych operacji.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy określony katalog istnieje, tworzy katalog, jeśli nie istnieje, i usuwa katalog.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Nie można utworzyć katalogu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pisania plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Kontrola dostępu, która ma zostać zastosowana do katalogu.</param>
        <summary>Tworzy katalog przy użyciu <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia metody, aby utworzyć katalog z kontrolą dostępu, więc nie ma możliwości dostępu do katalogu przed zastosowaniem zabezpieczeń.  
  
 Jeśli katalog już istnieje, ta metoda nie wykonuje żadnych operacji.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Katalog określony przez <paramref name="path" /> jest tylko do odczytu lub nie jest pusty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych <see cref="F:System.IO.Path.InvalidPathChars" />przez.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.NotSupportedException">Tworzenie katalogu tylko z dwukropkiem (:) podjęto próbę wykonania znaku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania uprawnień do tworzenia katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy podkatalog lub podkatalogi dla określonej ścieżki. Określona ścieżka może być względna dla tego wystąpienia <see cref="T:System.IO.DirectoryInfo" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Określona ścieżka. Nie może to być inna nazwa woluminu dysku lub Universal Naming Convention (UNC).</param>
        <summary>Tworzy podkatalog lub podkatalogi dla określonej ścieżki. Określona ścieżka może być względna dla tego wystąpienia <see cref="T:System.IO.DirectoryInfo" /> klasy.</summary>
        <returns>Ostatni katalog określony w <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w programie `path` są tworzone, chyba że pewna `path` część jest nieprawidłowa. `path` Parametr określa ścieżkę katalogu, a nie ścieżkę pliku. Jeśli podkatalog już istnieje, ta metoda nie wykonuje żadnych operacji.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje tworzenie podkatalogu. W tym przykładzie utworzone katalogi zostaną usunięte po utworzeniu. W związku z tym, aby przetestować ten przykład, należy dodać komentarz do usuwania wierszy w kodzie.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />nie określa prawidłowej ścieżki pliku lub zawiera nieprawidłowe <see langword="DirectoryInfo" /> znaki.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.IO.IOException">Nie można utworzyć podkatalogu.  
  
—lub— 
Plik lub katalog ma już nazwę określoną przez <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień dostępu do kodu w celu utworzenia katalogu.  
  
—lub— 
Obiekt wywołujący nie ma uprawnień dostępu do kodu, aby odczytać katalog opisany przez zwrócony <see cref="T:System.IO.DirectoryInfo" /> obiekt.  Taka sytuacja może wystąpić, <paramref name="path" /> gdy parametr opisuje istniejący katalog.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera dwukropek (:) to nie jest część etykiety dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Określona ścieżka. Nie może to być inna nazwa woluminu dysku lub Universal Naming Convention (UNC).</param>
        <param name="directorySecurity">Zabezpieczenia do zastosowania.</param>
        <summary>Tworzy podkatalog lub podkatalogi w określonej ścieżce z określonym zabezpieczeniami. Określona ścieżka może być względna dla tego wystąpienia <see cref="T:System.IO.DirectoryInfo" /> klasy.</summary>
        <returns>Ostatni katalog określony w <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie katalogi określone w programie `path` są tworzone, chyba że pewna `path` część jest nieprawidłowa. `path` Parametr określa ścieżkę katalogu, a nie ścieżkę pliku. Jeśli podkatalog już istnieje, ta metoda nie wykonuje żadnych operacji.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />nie określa prawidłowej ścieżki pliku lub zawiera nieprawidłowe <see langword="DirectoryInfo" /> znaki.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.IO.IOException">Nie można utworzyć podkatalogu.  
  
—lub— 
Plik lub katalog ma już nazwę określoną przez <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień dostępu do kodu w celu utworzenia katalogu.  
  
—lub— 
Obiekt wywołujący nie ma uprawnień dostępu do kodu, aby odczytać katalog opisany przez zwrócony <see cref="T:System.IO.DirectoryInfo" /> obiekt.  Taka sytuacja może wystąpić, <paramref name="path" /> gdy parametr opisuje istniejący katalog.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera dwukropek (:) to nie jest część etykiety dysku ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.IO.DirectoryInfo" /> Usuwa i jego zawartość ze ścieżki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa ten <see cref="T:System.IO.DirectoryInfo" /> element, jeśli jest pusty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład zgłasza wyjątek, Jeśli podjęto próbę usunięcia katalogu, który nie jest pusty.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Katalog zawiera plik tylko do odczytu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog opisany przez ten <see cref="T:System.IO.DirectoryInfo" /> obiekt nie istnieje lub nie można go znaleźć.</exception>
        <exception cref="T:System.IO.IOException">Katalog nie jest pusty.  
  
—lub— 
Katalog jest bieżącym katalogiem roboczym aplikacji.  
  
—lub— 
Istnieje otwarte dojście do katalogu, a system operacyjny to Windows XP lub wcześniejsza wersja. To otwarte dojście może wynikać z wyliczania katalogów. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i](~/docs/standard/io/how-to-enumerate-directories-and-files.md)plików.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do pisania katalogów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive"><see langword="true" />Aby usunąć ten katalog, jego podkatalogi i wszystkie pliki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Usuwa wystąpienie klasy <see cref="T:System.IO.DirectoryInfo" />, określając, czy należy usunąć podkatalogi i pliki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie `DirectoryInfo` `recursive` `false`ma żadnych plików lub podkatalogów, ta metoda usuwa parzystą, jeśli jest. `DirectoryInfo` Próba usunięcia elementu `DirectoryInfo` , który nie jest pusty, gdy `recursive` jest `false` zgłaszany <xref:System.IO.IOException>.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład demonstruje usunięcie katalogu. Ponieważ katalog jest usuwany, najpierw Skomentuj `Delete` wiersz, aby sprawdzić, czy katalog istnieje. Następnie Usuń komentarz z tego samego wiersza kodu, aby sprawdzić, czy katalog został usunięty pomyślnie.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Katalog zawiera plik tylko do odczytu.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog opisany przez ten <see cref="T:System.IO.DirectoryInfo" /> obiekt nie istnieje lub nie można go znaleźć.</exception>
        <exception cref="T:System.IO.IOException">Katalog jest tylko do odczytu.  
  
—lub— 
Katalog zawiera jeden lub więcej plików lub podkatalogów <paramref name="recursive" />. <see langword="false" />  
  
—lub— 
Katalog jest bieżącym katalogiem roboczym aplikacji.  
  
—lub— 
Istnieje otwarte dojście do katalogu lub jednego z jego plików, a system operacyjny to Windows XP lub wcześniejsza wersja. To otwarte dojście może wynikać z wyliczania katalogów i plików. Aby uzyskać więcej informacji, zobacz [jak: Wyliczanie katalogów i](~/docs/standard/io/how-to-enumerate-directories-and-files.md)plików.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Flaga zapisu jest wymagana dla uprawnień <see langword="DirectoryInfo" /> do zapisu w podkatalogach i do usunięcia.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalną kolekcję informacji katalogowych w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalną kolekcję informacji katalogowych w bieżącym katalogu.</summary>
        <returns>Wyliczalna kolekcja katalogów w bieżącym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> i<xref:System.IO.DirectoryInfo.GetDirectories%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.DirectoryInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.DirectoryInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład wylicza podkatalogi w katalogu C:\Program Files i używa zapytania LINQ do zwrócenia nazw wszystkich katalogów, które zostały utworzone przed 2009, sprawdzając wartość <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> właściwości.  
  
 Jeśli potrzebujesz tylko nazw podkatalogów, użyj klasy statycznej <xref:System.IO.Directory> w celu zapewnienia lepszej wydajności. Aby zapoznać się z przykładem <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> , zobacz metodę.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca wyliczalną kolekcję informacji o katalogu, które pasują do określonego wzorca wyszukiwania.</summary>
        <returns>Wyliczalna kolekcja katalogów, które <paramref name="searchPattern" />pasują do siebie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> i<xref:System.IO.DirectoryInfo.GetDirectories%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.DirectoryInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.DirectoryInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować tylko bieżący katalog lub wszystkie podkatalogi. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca wyliczalną kolekcję informacji o katalogu, które pasują do określonego wzorca wyszukiwania i opcji przeszukiwania podkatalogu.</summary>
        <returns>Wyliczalna kolekcja katalogów, które <paramref name="searchPattern" /> pasują do i <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> i<xref:System.IO.DirectoryInfo.GetDirectories%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.DirectoryInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.DirectoryInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład, zaczynając od określonego katalogu, używa tej metody i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> metody do wyliczania plików i katalogów w katalogu Start i wyświetlania szczegółów wszystkich plików o rozmiarze przekraczającym 10 MB.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalną kolekcję informacji o pliku w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalną kolekcję informacji o pliku w bieżącym katalogu.</summary>
        <returns>Wyliczalna Kolekcja plików w bieżącym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i<xref:System.IO.DirectoryInfo.GetFiles%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład wylicza pliki w określonym katalogu i używa zapytania LINQ do zwrócenia nazw wszystkich plików, które zostały utworzone przed 2009, sprawdzając wartość <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> właściwości.  
  
 Jeśli potrzebujesz tylko nazw plików, użyj klasy statycznej <xref:System.IO.Directory> w celu zapewnienia lepszej wydajności. Aby zapoznać się z przykładem <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> , zobacz metodę.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 Poniższy przykład przedstawia sposób wyliczania plików w katalogu za pomocą różnych opcji wyszukiwania. W przykładzie przyjęto założenie, że katalog ma pliki o nazwie LOG1. txt, log2 —. txt, test1. txt, TEST2. txt, test3. txt, i podkatalog, który ma plik o nazwie subfile. txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca wyliczalną kolekcję informacji o pliku, które pasują do wzorca wyszukiwania.</summary>
        <returns>Wyliczalna Kolekcja plików, które <paramref name="searchPattern" />pasują do siebie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i<xref:System.IO.DirectoryInfo.GetFiles%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wyliczania plików w katalogu za pomocą różnych opcji wyszukiwania. W przykładzie przyjęto założenie, że katalog ma pliki o nazwie LOG1. txt, log2 —. txt, test1. txt, TEST2. txt, test3. txt, i podkatalog, który ma plik o nazwie subfile. txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować tylko bieżący katalog lub wszystkie podkatalogi. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca wyliczalną kolekcję informacji o pliku, które pasują do określonego wzorca wyszukiwania i opcji przeszukiwania podkatalogu.</summary>
        <returns>Wyliczalna Kolekcja plików, które <paramref name="searchPattern" /> pasują do i <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i<xref:System.IO.DirectoryInfo.GetFiles%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wyliczania plików w katalogu za pomocą różnych opcji wyszukiwania. W przykładzie przyjęto założenie, że katalog ma pliki o nazwie LOG1. txt, log2 —. txt, test1. txt, TEST2. txt, test3. txt, i podkatalog, który ma plik o nazwie subfile. txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wyliczalną kolekcję informacji o systemie plików w bieżącym katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wyliczalną kolekcję informacji o systemie plików w bieżącym katalogu.</summary>
        <returns>Wyliczalna kolekcja informacji o systemie plików w bieżącym katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> i<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileSystemInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileSystemInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca wyliczalną kolekcję informacji o systemie plików zgodną z określonym wzorcem wyszukiwania.</summary>
        <returns>Wyliczalna kolekcja obiektów informacji o systemie plików, <paramref name="searchPattern" />które pasują do siebie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> i<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileSystemInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileSystemInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować tylko bieżący katalog lub wszystkie podkatalogi. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Zwraca wyliczalną kolekcję informacji o systemie plików zgodną z określonym wzorcem wyszukiwania i opcją wyszukiwania podkatalogu.</summary>
        <returns>Wyliczalna kolekcja obiektów informacji o systemie plików, <paramref name="searchPattern" /> które <paramref name="searchOption" />pasują do i.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> i<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileSystemInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileSystemInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> katalogami, może być bardziej wydajne.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Zwracana kolekcja nie jest buforowana; Każde wywołanie <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> metody w kolekcji spowoduje rozpoczęcie nowego wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy katalog istnieje.</summary>
        <value><see langword="true" />Jeśli katalog istnieje; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.IO.DirectoryInfo.Exists%2A> zwraca`false` , jeśli wystąpi błąd podczas próby ustalenia, czy określony plik istnieje. Może się to zdarzyć w sytuacjach, w których są wywoływane wyjątki, takie jak przekazywanie nazwy pliku z nieprawidłowymi znakami lub zbyt wiele znaków, Niepowodzenie lub brak dysku lub jeśli obiekt wywołujący nie ma uprawnienia do odczytu pliku.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Exists` właściwości w kontekście kopiowania katalogu źródłowego do katalogu docelowego.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną ścieżkę katalogu.</summary>
        <value>Ciąg zawierający pełną ścieżkę.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>    
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wpisy listy kontroli dostępu (ACL) dla bieżącego katalogu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metod, aby pobrać wpisy listy kontroli dostępu (ACL) dla bieżącego pliku.  
  
 Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt, który hermetyzuje wpisy listy kontroli dostępu (ACL) dla katalogu opisanego przez bieżący <see cref="T:System.IO.DirectoryInfo" /> obiekt. <see cref="T:System.Security.AccessControl.DirectorySecurity" /></summary>
        <returns><see cref="T:System.Security.AccessControl.DirectorySecurity" /> Obiekt, który hermetyzuje reguły kontroli dostępu dla katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.IO.Directory.GetAccessControl%2A> tego przeciążenia metody jest równoznaczne z wywołaniem przeciążenia metody i określeniem sekcji <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> kontroli dostępu<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> (`Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>wVisualBasic). `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>  
  
 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy kontroli dostępu (ACL) dla bieżącego pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych akcji dotyczących danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metody <xref:System.IO.DirectoryInfo.SetAccessControl%2A> i, aby dodać, a następnie usunąć wpis listy kontroli dostępu (ACL) z katalogu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub zmodyfikować katalogu.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Katalog jest tylko do odczytu.  
  
 —lub—  
  
 Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
 —lub—  
  
 Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy podczas otwierania katalogu.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Microsoft Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do wyliczania listy kontroli dostępu (ACL) dla katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />,<see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">Jedna z <see cref="T:System.Security.AccessControl.AccessControlSections" /> wartości, która określa typ informacji listy kontroli dostępu (ACL) do odbierania.</param>
        <summary>Pobiera obiekt, który hermetyzuje określony typ wpisów listy kontroli dostępu (ACL) dla katalogu opisanego przez bieżący <see cref="T:System.IO.DirectoryInfo" /> obiekt. <see cref="T:System.Security.AccessControl.DirectorySecurity" /></summary>
        <returns>Obiekt, który hermetyzuje reguły kontroli dostępu dla pliku opisanego <paramref name="path" /> przez parametr. <see cref="T:System.Security.AccessControl.DirectorySecurity" />  
  
Wyjątki 
 <list type="table"><listheader><term> Typ wyjątku 
 </term><description> Warunek 
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> Nie można odnaleźć lub zmodyfikować katalogu.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Bieżący proces nie ma dostępu do otwierania katalogu.  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> Wystąpił błąd we/wy podczas otwierania katalogu.  
  
 </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> Bieżący system operacyjny nie jest systemem Microsoft Windows 2000 lub nowszym.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Katalog jest tylko do odczytu.  
  
—lub— 
Ta operacja nie jest obsługiwana na bieżącej platformie.  
  
—lub— 
Obiekt wywołujący nie posiada wymaganych uprawnień.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.GetAccessControl%2A> Użyj metody, aby pobrać wpisy listy kontroli dostępu (ACL) dla bieżącego pliku.  
  
 Lista ACL opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych akcji dotyczących danego pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do wyliczania listy kontroli dostępu (ACL) dla katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />,<see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca podkatalogi bieżącego katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca podkatalogi bieżącego katalogu.</summary>
        <returns>Tablica <see cref="T:System.IO.DirectoryInfo" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie ma żadnych podkatalogów, ta metoda zwraca pustą tablicę. Ta metoda nie jest cykliczna.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład pobiera wszystkie katalogi w katalogu głównym i wyświetla nazwy katalogów.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see cref="T:System.IO.DirectoryInfo" /> obiekcie jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania katalogów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca tablicę katalogów w bieżącym <see cref="T:System.IO.DirectoryInfo" /> zgodne z podanym kryterium wyszukiwania.</summary>
        <returns>Tablica dopasowania <see langword="DirectoryInfo" /> <paramref name="searchPattern" />typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład zlicza katalogi w ścieżce zawierającej określony literę.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see langword="DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików i katalogów oraz do uzyskiwania dostępu do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować tylko bieżący katalog lub wszystkie podkatalogi.</param>
        <summary>Zwraca tablicę katalogów w bieżącym <see cref="T:System.IO.DirectoryInfo" /> dopasowaniu do danego kryterium wyszukiwania i korzystając z wartości, aby określić, czy przeszukiwać podkatalogi.</summary>
        <returns>Tablica dopasowania <see langword="DirectoryInfo" /> <paramref name="searchPattern" />typu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Jeśli nie ma żadnych podkatalogów lub żadne podkatalogi nie pasują `searchPattern` do parametru, ta metoda zwraca pustą tablicę.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.DirectoryInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład wyświetla listę wszystkich katalogów i plików, które zaczynają się literą "c" w "c:\\".  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka Zahermetyzowana w <see langword="DirectoryInfo" /> obiekcie jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików i katalogów oraz do uzyskiwania dostępu do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca listę plików z bieżącego katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca listę plików z bieżącego katalogu.</summary>
        <returns>Tablica typu <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i<xref:System.IO.DirectoryInfo.GetFiles%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Jeśli w programie <xref:System.IO.DirectoryInfo>nie ma żadnych plików, Metoda ta zwraca pustą tablicę.  
  
 Kolejność zwróconych nazw plików nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać listę plików z katalogu przy użyciu różnych opcji wyszukiwania. W przykładzie przyjęto założenie, że katalog ma pliki o nazwie LOG1. txt, log2 —. txt, test1. txt, TEST2. txt, test3. txt, i podkatalog, który ma plik o nazwie subfile. txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa, na przykład na dysku niezamapowanym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania katalogów. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Zwraca listę plików z bieżącego katalogu zgodnej z podanym wzorcem wyszukiwania.</summary>
        <returns>Tablica typu <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i<xref:System.IO.DirectoryInfo.GetFiles%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Jeśli w programie <xref:System.IO.DirectoryInfo>nie ma żadnych plików, Metoda ta zwraca pustą tablicę.  
  
 W `searchPattern` parametrze są dozwolone następujące specyfikatory wieloznaczne.  
  
|Symbol wieloznaczny|Opis|  
|------------------------|-----------------|  
|*|Zero lub więcej znaków.|  
|?|Dokładnie zero lub jeden znak.|  
  
 Kolejność zwróconych nazw plików nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 Symbole wieloznaczne są dozwolone. Na przykład `searchPattern` ciąg "*. txt" wyszukuje wszystkie nazwy plików mające rozszerzenie "txt". Ciąg "s\*" wyszukuje wszystkie nazwy plików zaczynające się literą "s". `searchPattern` Jeśli nie ma żadnych plików lub nie ma plików zgodnych `searchPattern` z ciągiem <xref:System.IO.DirectoryInfo>w, Metoda ta zwraca pustą tablicę.  
  
> [!NOTE]
>  Przy użyciu symbolu wieloznacznego gwiazdki w `searchPattern` (na przykład "*. txt") zachowanie dopasowywania różni się w zależności od długości określonego rozszerzenia pliku. A `searchPattern` rozszerzenie pliku o dokładnie trzech znakach zwraca pliki o rozszerzeniu trzech lub więcej znaków, gdzie pierwsze trzy znaki pasują do rozszerzenia pliku określonego `searchPattern`w. Z rozszerzeniem jednego, dwóch lub więcej niż trzy znaki zwraca tylko pliki z rozszerzeniami o dokładnie takiej długości, które pasują do rozszerzenia pliku określonego `searchPattern`w. `searchPattern` Przy użyciu symbolu wieloznacznego znaku zapytania ta metoda zwraca tylko te pliki, które pasują do określonego rozszerzenia pliku. Na przykład w przypadku dwóch plików w katalogu "plik1. txt" i "plik1. txtother" jest to wzór wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza nazwy plików w formacie nazwy pliku 8,3 i formacie długiej nazwy pliku, wzór wyszukiwania podobny do "* 1\*. txt" może zwracać nieoczekiwane nazwy plików. Na przykład użycie wzorca wyszukiwania "\*1\*. txt" zwróci "LongFileName. txt", ponieważ odpowiednik formatu nazwy pliku 8,3 to "longf ~ 1. txt".  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać listę plików z katalogu przy użyciu różnych opcji wyszukiwania. W przykładzie przyjęto założenie, że katalog ma pliki o nazwie LOG1. txt, log2 —. txt, test1. txt, TEST2. txt, test3. txt, i podkatalog, który ma plik o nazwie subfile. txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do ścieżki i odczytu z plików i katalogów. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw plików.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować tylko bieżący katalog lub wszystkie podkatalogi.</param>
        <summary>Zwraca listę plików z bieżącego katalogu zgodnego z danym wzorcem wyszukiwania i korzystając z wartości, aby określić, czy przeszukiwać podkatalogi.</summary>
        <returns>Tablica typu <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> i<xref:System.IO.DirectoryInfo.GetFiles%2A> różnią się w następujący sposób:  
  
-   Korzystając z <xref:System.IO.FileInfo> programu ,możnarozpocząćwyliczaniekolekcjiobiektówprzedzwróceniem<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>całej kolekcji.  
  
-   Gdy używasz <xref:System.IO.FileInfo> , musisz poczekać, aż cała tablica obiektów ma zostać zwrócona, zanim będzie można uzyskać dostęp do tablicy. <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
 W związku z tym, gdy pracujesz z wieloma plikami i <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> katalogami, może być bardziej wydajne.  
  
 Jeśli w programie <xref:System.IO.DirectoryInfo>nie ma żadnych plików, Metoda ta zwraca pustą tablicę.  
  
 Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Opis|  
|------------------------|-----------------|  
|* (gwiazdka)|Zero lub więcej znaków.|  
|? (znak zapytania)|Dokładnie zero lub jeden znak.|  
  
 Kolejność zwróconych nazw plików nie jest gwarantowana; Użyj metody <xref:System.Array.Sort%2A> , jeśli wymagana jest określona kolejność sortowania.  
  
 Symbole wieloznaczne są dozwolone. Na przykład `searchPattern` ciąg "*. txt" wyszukuje wszystkie nazwy plików mające rozszerzenie "txt". Ciąg "s\*" wyszukuje wszystkie nazwy plików zaczynające się literą "s". `searchPattern` Jeśli nie ma żadnych plików lub nie ma plików zgodnych `searchPattern` z ciągiem <xref:System.IO.DirectoryInfo>w, Metoda ta zwraca pustą tablicę.  
  
> [!NOTE]
>  Przy użyciu symbolu wieloznacznego gwiazdki w `searchPattern` (na przykład "*. txt") zachowanie dopasowywania różni się w zależności od długości określonego rozszerzenia pliku. A `searchPattern` rozszerzenie pliku o dokładnie trzech znakach zwraca pliki o rozszerzeniu trzech lub więcej znaków, gdzie pierwsze trzy znaki pasują do rozszerzenia pliku określonego `searchPattern`w. Z rozszerzeniem jednego, dwóch lub więcej niż trzy znaki zwraca tylko pliki z rozszerzeniami o dokładnie takiej długości, które pasują do rozszerzenia pliku określonego `searchPattern`w. `searchPattern` Przy użyciu symbolu wieloznacznego znaku zapytania ta metoda zwraca tylko te pliki, które pasują do określonego rozszerzenia pliku. Na przykład w przypadku dwóch plików w katalogu "plik1. txt" i "plik1. txtother" jest to wzór wyszukiwania "plik". txt "zwraca tylko pierwszy plik, natomiast wzorzec wyszukiwania" plik\*. txt "zwraca oba pliki.  
  
 Na poniższej liście przedstawiono zachowanie różnych długości dla `searchPattern` parametru:  
  
-   "*. abc" zwraca pliki mające rozszerzenie. ABC,. abcd,. abcd,. abcdef i tak dalej.  
  
-   "*. abcd" zwraca tylko pliki mające rozszerzenie. abcd.  
  
-   "*. abcde" zwraca tylko pliki mające rozszerzenie. abcd.  
  
-   "*. abcdef" zwraca tylko pliki mające rozszerzenie. abcdef.  
  
> [!NOTE]
>  Ponieważ ta metoda sprawdza nazwy plików w formacie nazwy pliku 8,3 i formacie długiej nazwy pliku, wzór wyszukiwania podobny do "* 1\*. txt" może zwracać nieoczekiwane nazwy plików. Na przykład użycie wzorca wyszukiwania "\*1\*. txt" zwróci "LongFileName. txt", ponieważ odpowiednik formatu nazwy pliku 8,3 to "longf ~ 1. txt".  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileInfo> właściwości:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać listę plików z katalogu przy użyciu różnych opcji wyszukiwania. W przykładzie przyjęto założenie, że katalog ma pliki o nazwie LOG1. txt, log2 —. txt, test1. txt, TEST2. txt, test3. txt, i podkatalog, który ma plik o nazwie subfile. txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do ścieżki i odczytu z plików i katalogów. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera tablicę obiektów o jednoznacznie <see cref="T:System.IO.FileSystemInfo" /> określonym typie reprezentujących pliki i podkatalogi bieżącego katalogu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę wpisów o jednoznacznie <see cref="T:System.IO.FileSystemInfo" /> określonym typie reprezentujących wszystkie pliki i podkatalogi w katalogu.</summary>
        <returns>Tablica wpisów o jednoznacznie określonym <see cref="T:System.IO.FileSystemInfo" /> typie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli w programie <xref:System.IO.DirectoryInfo>nie ma plików lub katalogów, Metoda ta zwraca pustą tablicę. Ta metoda nie jest cykliczna.  
  
 W przypadku podkatalogów <xref:System.IO.FileSystemInfo> obiekty zwracane przez tę metodę mogą być rzutowane na klasę <xref:System.IO.DirectoryInfo>pochodną. Użyj wartości zwróconej <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> przez właściwość, aby określić, <xref:System.IO.FileSystemInfo> czy reprezentuje plik lub katalog. <xref:System.IO.FileAttributes>  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład zlicza pliki i katalogi w określonym katalogu.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów i plików.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <summary>Pobiera tablicę obiektów o jednoznacznie <see cref="T:System.IO.FileSystemInfo" /> określonym typie reprezentującą pliki i podkatalogi zgodne z określonymi kryteriami wyszukiwania.</summary>
        <returns>Tablica obiektów o jednoznacznie określonym <see langword="FileSystemInfo" /> typie pasujących do kryteriów wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 Ta metoda nie jest cykliczna.  
  
 W przypadku podkatalogów <xref:System.IO.FileSystemInfo> obiekty zwracane przez tę metodę mogą być rzutowane na klasę <xref:System.IO.DirectoryInfo>pochodną. Użyj wartości zwróconej <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> przez właściwość, aby określić, <xref:System.IO.FileSystemInfo> czy reprezentuje plik lub katalog. <xref:System.IO.FileAttributes>  
  
 Symbole wieloznaczne są dozwolone. Na przykład `searchPattern` ciąg "* t" wyszukuje wszystkie `path` nazwy katalogów kończące się literą "t". Ciąg "s\*" wyszukuje wszystkie nazwy katalogów na `path` początku literą "s". `searchPattern`  
  
 Ciąg ".." może być używany tylko w `searchPattern` przypadku, gdy jest określony jako część prawidłowej nazwy katalogu, takiej jak nazwa katalogu "a. b ". Nie można jej użyć do przeniesienia hierarchii katalogów. Jeśli nie ma plików lub katalogów lub nie ma plików lub katalogów, które pasują `searchPattern` do ciągu <xref:System.IO.DirectoryInfo>w, Metoda ta zwraca pustą tablicę.  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Poniższy przykład zlicza pliki i katalogi zgodne z określonym wzorcem wyszukiwania.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików i katalogów oraz do uzyskiwania dostępu do ścieżki. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Ciąg wyszukiwania do dopasowania do nazw katalogów i plików.  Ten parametr może zawierać kombinację prawidłowej ścieżki literału i symboli wieloznacznych (* i?), ale nie obsługuje wyrażeń regularnych.</param>
        <param name="searchOption">Jedna z wartości wyliczenia, która określa, czy operacja wyszukiwania powinna obejmować tylko bieżący katalog lub wszystkie podkatalogi. Wartość domyślna to <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Pobiera tablicę <see cref="T:System.IO.FileSystemInfo" /> obiektów, które reprezentują pliki i podkatalogi spełniające określone kryteria wyszukiwania.</summary>
        <returns>Tablica wpisów systemu plików, które pasują do kryteriów wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`może być kombinacją znaków literału i symboli wieloznacznych, ale nie obsługuje wyrażeń regularnych. Następujące specyfikatory wieloznaczne są dozwolone w `searchPattern`.  
  
|Symbol wieloznaczny|Dopasowania|  
|------------------------|-------------|  
|* (gwiazdka)|Zero lub więcej znaków w tej pozycji.|  
|? (znak zapytania)|Zero lub jeden znak w tym położeniu.|  
  
 Znaki inne niż symbol wieloznaczny są znakami literału. Na przykład ciąg "* t" wyszukuje wszystkie nazwy kończące się literą "t". ". Ciąg "s\*" wyszukuje wszystkie nazwy na `path` początku literą "s". `searchPattern`  
  
 W przypadku podkatalogów <xref:System.IO.FileSystemInfo> obiekty zwracane przez tę metodę mogą być rzutowane na klasę <xref:System.IO.DirectoryInfo>pochodną. Użyj wartości zwróconej <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> przez właściwość, aby określić, <xref:System.IO.FileSystemInfo> czy reprezentuje plik lub katalog. <xref:System.IO.FileAttributes>  
  
 Ta metoda wstępnie wypełnia wartości następujących <xref:System.IO.FileSystemInfo> właściwości:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metodę.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" />nie jest prawidłową <see cref="T:System.IO.SearchOption" /> wartością.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Określona ścieżka jest nieprawidłowa (na przykład znajduje się na dysku niezamapowanym).</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Nazwa i ścieżka, do której ma zostać przeniesiony ten katalog. Lokalizacja docelowa nie może być innym woluminem dysku ani katalogiem o identycznej nazwie. Może to być katalog istniejący, do którego chcesz dodać ten katalog jako podkatalog.</param>
        <summary><see cref="T:System.IO.DirectoryInfo" /> Przenosi wystąpienie i jego zawartość do nowej ścieżki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zgłasza <xref:System.IO.IOException> Jeśli, na przykład, próbujesz przenieść c:\mydir do c:\public, a c:\public już istnieje. Należy określić wartość "c:\\\public\\\mydir" jako `destDirName` parametr lub określić nową nazwę katalogu, na przykład "c:\\\newdir".  
  
 Ta metoda umożliwia przeniesienie katalogu do katalogu tylko do odczytu. Nie dotyczy atrybutu odczytu/zapisu w żadnym katalogu.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład demonstruje przeniesienie katalogu.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destDirName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destDirName" />jest pustym ciągiem ("" ").</exception>
        <exception cref="T:System.IO.IOException">Podjęto próbę przeniesienia katalogu do innego woluminu.  
  
—lub— 
 <paramref name="destDirName" />już istnieje.  
  
—lub— 
Nie masz uprawnień dostępu do tej ścieżki.  
  
—lub— 
Przeniesiony katalog i katalog docelowy mają tę samą nazwę.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można znaleźć katalogu docelowego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików i katalogów oraz do uzyskiwania dostępu do katalogu docelowego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />,<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tego <see cref="T:System.IO.DirectoryInfo" /> wystąpienia.</summary>
        <value>Nazwa katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.IO.DirectoryInfo.Name%2A> Właściwość zwraca tylko nazwę katalogu, na przykład "bin". Aby uzyskać pełną ścieżkę, taką jak "c:\public\Bin", użyj <xref:System.IO.FileSystemInfo.FullName%2A> właściwości.  
  
 Właściwość a <xref:System.IO.DirectoryInfo> nie wymaga uprawnień (poza uprawnieniem odczyt do katalogu niezbędnego do skonstruowania), <xref:System.IO.DirectoryInfo.Exists%2A>ale może podać nazwę katalogu. <xref:System.IO.DirectoryInfo.Name%2A> Jeśli konieczne jest przekazanie <xref:System.IO.DirectoryInfo> do chronionego katalogu przy użyciu nazwy zabezpieczonej kryptograficznie, Utwórz fikcyjny katalog do użycia w niezaufanym kodzie.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład wyświetla nazwę tylko bieżącego `DirectoryInfo` wystąpienia.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera katalog nadrzędny określonego podkatalogu.</summary>
        <value>Katalog nadrzędny lub <see langword="null" /> , jeśli ścieżka ma wartość null lub jeśli ścieżka pliku jest oznaczona jako główna (na `\`przykład, `C:\`lub `\\server\share`).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> W .NET Framework `Parent` zwraca ścieżkę względną.
> W programie .NET Core `Parent` funkcja zwraca w pełni kwalifikowaną ścieżkę.

Aby zapewnić spójne zachowanie w różnych wersjach i zapewnić jawne zamiar, należy pobrać wartość jednej z następujących właściwości w <xref:System.IO.DirectoryInfo> wystąpieniu zwracanym przez. `Parent`
- <xref:System.IO.DirectoryInfo.Name>, która zwraca prostą nazwę katalogu (na przykład `bin`).
- <xref:System.IO.DirectoryInfo.FullName>, która zwraca ścieżkę bezwzględną katalogu. 


Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).


## Examples

Poniższy przykład odnosi się do katalogu nadrzędnego określonego katalogu.

[!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
[!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
[!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików i katalogów oraz do uzyskiwania dostępu do ścieżki. Skojarzone wyliczenia: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />,<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera główną część katalogu.</summary>
        <value>Obiekt, który reprezentuje katalog główny katalogu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla lokalizacje główne dla określonych katalogów.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania z plików i katalogów oraz do uzyskiwania dostępu do ścieżki. Skojarzone wyliczenia: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />,<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Obiekt opisujący wpis listy kontroli dostępu, który ma zostać zastosowany do katalogu <paramref name="path" /> opisanego przez parametr.</param>
        <summary>Stosuje wpisy listy kontroli dostępu (ACL) opisane przez <see cref="T:System.Security.AccessControl.DirectorySecurity" /> obiekt do katalogu opisanego przez bieżący <see cref="T:System.IO.DirectoryInfo" /> obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista kontroli dostępu (ACL) opisuje osoby i/lub grupy, które mają lub nie mają uprawnień do określonych akcji w danym pliku lub katalogu. Aby uzyskać więcej informacji, zobacz [jak: Dodawanie lub usuwanie wpisów](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)listy Access Control.  
  
 <xref:System.IO.DirectoryInfo.SetAccessControl%2A> Metoda stosuje wpisy ACL do pliku, który reprezentuje niedziedziczoną listę ACL.  
  
> [!CAUTION]
>  Lista ACL określona dla `directorySecurity` zastąpi istniejącą listę ACL dla katalogu. Aby dodać uprawnienia dla nowego użytkownika, użyj <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metody w celu uzyskania istniejącej listy ACL i zmodyfikuj ją.  
  
 Metoda utrzymuje tylko <xref:System.Security.AccessControl.DirectorySecurity> te obiekty, które zostały zmodyfikowane po utworzeniu obiektu. <xref:System.IO.DirectoryInfo.SetAccessControl%2A>  <xref:System.Security.AccessControl.DirectorySecurity> Jeśli obiekt nie został zmodyfikowany, nie zostanie utrwalony w pliku.  W związku z tym nie można pobrać <xref:System.Security.AccessControl.DirectorySecurity> obiektu z jednego pliku i ponownie zastosować tego samego obiektu do innego pliku.  
  
 Aby skopiować informacje listy ACL z jednego pliku do innego:  
  
1.  Użyj metody, aby pobrać obiekt z pliku źródłowego. <xref:System.Security.AccessControl.DirectorySecurity> <xref:System.IO.DirectoryInfo.GetAccessControl%2A>  
  
2.  Utwórz nowy <xref:System.Security.AccessControl.DirectorySecurity> obiekt dla pliku docelowego.  
  
3.  Użyj metody <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> <xref:System.Security.AccessControl.DirectorySecurity> lub obiektu źródłowego, aby pobrać informacje listy ACL. <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>  
  
4.  Użyj metody <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> <xref:System.Security.AccessControl.DirectorySecurity> lub, aby skopiować informacje pobrane w kroku 3 do obiektu docelowego. <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>  
  
5.  Ustaw obiekt docelowy <xref:System.Security.AccessControl.DirectorySecurity> w pliku docelowym <xref:System.IO.DirectoryInfo.SetAccessControl%2A> przy użyciu metody.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.IO.DirectoryInfo.GetAccessControl%2A> metody <xref:System.IO.DirectoryInfo.SetAccessControl%2A> i, aby dodać, a następnie usunąć wpis listy kontroli dostępu (ACL) z katalogu.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="directorySecurity" /></exception>
        <exception cref="T:System.SystemException">Nie można odnaleźć lub zmodyfikować pliku.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Bieżący proces nie ma dostępu do otwierania pliku.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Microsoft Windows 2000 lub nowszym.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uprawnienia do wyliczania listy kontroli dostępu (ACL) dla katalogu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Skojarzone wyliczenia: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />,<see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca oryginalną ścieżkę, która została przeniesiona <see cref="T:System.IO.DirectoryInfo" /> do konstruktora. Zamiast tej metody <see cref="P:System.IO.DirectoryInfo.Name" /> Użyj właściwości lubdlapełnejścieżkilubnazwypliku/katalogu.<see cref="P:System.IO.DirectoryInfo.FullName" /></summary>
        <returns>Oryginalna ścieżka, która została przeniesiona przez użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> Ciąg zwracany przez <xref:System.IO.DirectoryInfo.ToString%2A> metodę reprezentuje ścieżkę, która została przekazana <xref:System.IO.DirectoryInfo> do konstruktora. Zamiast wywoływania `ToString` metody, należy pobrać wartość jednej z następujących właściwości, w zależności od zamiaru:
> - <xref:System.IO.DirectoryInfo.Name>, aby uzyskać nazwę katalogu bez informacji o ścieżce nadrzędnej.
> - <xref:System.IO.DirectoryInfo.FullName>, aby uzyskać w pełni kwalifikowaną ścieżkę katalogu.

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>

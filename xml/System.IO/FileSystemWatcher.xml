<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e87b26ec400399826b4f5e5b8d1daf942933af86" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36485084" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wykrywa w systemie plików zmienić powiadomień i generuje zdarzenia, gdy katalogu lub pliku w katalogu, zmiany.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileSystemWatcher> Aby obejrzeć zmiany w określonym katalogu. Można śledzić zmiany w pliki i podkatalogi określonego katalogu. Można utworzyć składnika do monitorowania plików na komputerze lokalnym, dysku sieciowym lub komputerze zdalnym.  
  
 Aby obejrzeć zmiany we wszystkich plikach, ustaw <xref:System.IO.FileSystemWatcher.Filter%2A> właściwości na ciąg pusty ("") lub użyć symboli wieloznacznych ("*.\*"). Aby obejrzeć określonego pliku, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku. Na przykład, aby obejrzeć zmiany w pliku Moje_dok.txt, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> dla właściwości "Moje_dok.txt". Można również obejrzeć zmiany w typ pliku. Na przykład, aby obejrzeć zmiany w plikach tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> dla właściwości "\*txt".  
  
 Istnieje kilka typów zmian, które można śledzić w pliku lub katalogu. Na przykład można śledzić zmiany w `Attributes`, `LastWrite` datę i godzinę, lub `Size` plików lub katalogów. Odbywa się przez ustawienie <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> jedną z właściwości <xref:System.IO.NotifyFilters> wartości. Aby uzyskać więcej informacji na typ zmian możesz obserwować, zobacz <xref:System.IO.NotifyFilters>.  
  
 Można śledzić zmiany nazwy, usunięcia lub tworzenia plików lub katalogów. Na przykład, aby obejrzeć zmianę pliki tekstowe, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> dla właściwości "*.txt" i wywołanie <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> metody z <xref:System.IO.WatcherChangeTypes.Renamed> jego parametru.  
  
 System operacyjny Windows powiadamia składnika zmian plików w buforze utworzone przez <xref:System.IO.FileSystemWatcher>. Jeśli wprowadzono wiele zmian w krótkim czasie, może się przelewać buforu. Powoduje to, że składnik utratę śledzenie zmian w katalogu, i udostępni jedynie zbiorcze powiadomień. Zwiększenie rozmiaru buforu z <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwość jest kosztowne, ponieważ pochodzi z niestronicowanej pamięci, która nie może być wymieniony na dysku, więc należy jeszcze buforu niewielkie dużych wystarczająca liczba na kilku dowolnego pliku zdarzenia zmian. Aby uniknąć przepełnienia buforu, użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwości, więc można odfiltrować niechciane powiadomienia o zmianie.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.IO.FileSystemWatcher>, zobacz <xref:System.IO.FileSystemWatcher.%23ctor%2A> konstruktora.  
  
 Należy pamiętać następujące, korzystając z <xref:System.IO.FileSystemWatcher> klasy.  
  
-   Ukryte pliki nie są ignorowane.  
  
-   W niektórych systemach <xref:System.IO.FileSystemWatcher> raporty zmiany do plików przy użyciu krótkich format nazwy pliku w formacie 8.3. Na przykład zmiany "LongFileName.LongExtension" mogą być raportowane jako "LongFil ~. Długa".  
  
-   Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. A <xref:System.Security.SecurityException> jest generowany, gdy bezpośredniego obiektu wywołującego lub Klasa pochodna nie ma uprawnienia pełnego zaufania. Aby uzyskać szczegółowe informacje dotyczące żądania kontroli zabezpieczeń, zobacz [Linkdemand](~/docs/framework/misc/link-demands.md).  
  
-   Maksymalny rozmiar, można ustawić dla <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwość monitorowania katalogu za pośrednictwem sieci jest 64 KB.  
  
> [!NOTE]
>  Uruchomiona <xref:System.IO.FileSystemWatcher> nie jest obsługiwana w systemach Windows 98.  
  
## <a name="copying-and-moving-folders"></a>Kopiowanie i przenoszenie folderów  
 System operacyjny i <xref:System.IO.FileSystemWatcher> obiektu zinterpretować działania kopiowania i wklejania lub Akcja przenoszenia, jako Akcja Zmień nazwę folderu i jego zawartość. Jeśli wyciąć i wkleić folderu z plikami w folderze są monitorowane <xref:System.IO.FileSystemWatcher> obiektu raporty tylko folder jako nowy, ale nie do zawartości, ponieważ zasadniczo są tylko zmienione.  
  
 Aby otrzymać powiadomienie, że zawartość folderów zostały przeniesione lub kopiowane do folderu monitorowane, należy podać <xref:System.IO.FileSystemWatcher.OnChanged%2A> i <xref:System.IO.FileSystemWatcher.OnRenamed%2A> metody obsługi zdarzeń zgodnie z sugestią podaną w poniższej tabeli.  
  
|Program obsługi zdarzeń|Obsługi zdarzeń|Wykonuje|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Raport zmiany atrybutów pliku, utworzonych plików i usuniętych plików.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Wyświetl listę stary i nowy ścieżek o zmienionej nazwie pliki i foldery, rozszerzanie cyklicznie, w razie potrzeby.|  
  
## <a name="events-and-buffer-sizes"></a>Zdarzenia i rozmiary buforów  
 Należy pamiętać, że istnieje kilka możliwych mogą mieć wpływ na system plików zdarzenia zmian są generowane w sposób opisany w następujących czynności:  
  
-   Typowe operacje systemu plików może podnieść więcej niż jedno zdarzenie. Na przykład, jeśli plik zostanie przeniesiony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. Przeniesienie pliku złożonych operacji, która składa się z wielu proste operacje, w związku z tym wywoływanie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowego pliku zdarzeń systemowych, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
-   <xref:System.IO.FileSystemWatcher> Można oglądać dysków, dopóki nie są one przełączono lub usunięte. <xref:System.IO.FileSystemWatcher> Nie wywoływanie zdarzeń dysków CD lub DVD, ponieważ nie można zmienić właściwości i sygnatury czasowe. Komputer zdalny musi mieć jeden z platformy wymagane zainstalowane w celu poprawnego działania składnika.  
  
-   Jeśli wiele <xref:System.IO.FileSystemWatcher> obiektów oglądania tego samego ścieżkę UNC w systemie Windows XP przed dodatkiem Service Pack 1 lub Windows 2000 z dodatkiem SP2 lub wcześniej, a następnie tylko jeden z obiektów zostanie wywołaj zdarzenie. Na komputerach z systemem Windows XP z dodatkiem SP1 lub nowszym, Windows 2000 z dodatkiem SP3 lub nowszej lub Windows Server 2003, wszystkie <xref:System.IO.FileSystemWatcher> obiektów zgłosi odpowiednie zdarzenia.  
  
 Należy pamiętać, że <xref:System.IO.FileSystemWatcher> może nie zdarzenie po przekroczeniu rozmiar buforu. Aby uniknąć, Brak zdarzeń, wykonaj następujące wytyczne:  
  
-   Zwiększ rozmiar buforu przez ustawienie <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
-   Unikaj obserwowanie pliki o długich nazwach, ponieważ długiej nazwy pliku przyczynia się do zapełnia się w buforze. Rozważ zmianę nazwy tych plików przy użyciu krótszej nazwy.  
  
-   Zachowaj programu obsługi kodu możliwie krótki zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> Aby obejrzeć katalogu określonym w czasie wykonywania. Składnik ustawiono oczekiwał na zmiany w `LastWrite` i `LastAccess` czas, tworzenie, usuwanie, lub zmiana nazw plików tekstowych w katalogu. Jeśli plik jest zmienione, utworzone lub usunięte, ścieżka do pliku drukuje do konsoli. Gdy zostanie zmieniona nazwa pliku, ścieżki stary i nowy drukowanie do konsoli.  
  
 Użyj <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw w tym przykładzie.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">w przypadku tworzenia klasy pochodnej z <see cref="T:System.Diagnostics.ProcessStartInfo" /> klasy. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Nazwane zestawy uprawnień: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można oglądać komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można oglądać komputera zdalnego systemu Windows NT 4.0 z komputera z systemem Windows NT 4.0.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.IO.FileSystemWatcher>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|bitowe połączenie lub `LastWrite`, `FileName`, i `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Obejrzyj wszystkie pliki.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|pusty ciąg ("")|  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określony katalog do <xref:System.IO.FileSystemWatcher.Path%2A> jest ustawiona, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obiekt, aby obejrzeć katalogu określonym w czasie wykonywania. <xref:System.IO.FileSystemWatcher> Obiektu Obserwujący zmiany w `LastWrite` i `LastAccess` razy oraz tworzenie, usuwanie lub zmiana tekstu pliki w katalogu. Jeśli plik jest zmienione, utworzone lub usunięte, ścieżka do pliku wyświetla się do konsoli. Gdy zostanie zmieniona nazwa pliku, ścieżki stary i nowy wyświetlane w konsoli.  
  
 W tym przykładzie użyto <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do monitorowania, standard lub notacji Universal Naming Convention (UNC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy podany katalog określony do monitorowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określony katalog do <xref:System.IO.FileSystemWatcher.Path%2A> jest ustawiona, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Składnik obserwować plików na komputerze osobistym, dysk sieciowy lub komputerze zdalnym.  
  
 Nie można oglądać komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można oglądać komputera zdalnego systemu Windows NT 4.0 z komputera z systemem Windows NT 4.0. <xref:System.IO.FileSystemWatcher.Filter%2A> Właściwość jest ustawieniem domyślnym oglądanie wszystkich plików.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest pustym ciągiem ("").  - lub - ścieżki określonej za pomocą <paramref name="path" /> parametr nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> jest za długa.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do monitorowania, standard lub notacji Universal Naming Convention (UNC).</param>
        <param name="filter">Typ plików, które należy monitorować. Na przykład "*.txt" Obserwujący zmiany do wszystkich plików tekstowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy określonego katalogu i typy plików do monitorowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określony katalog do <xref:System.IO.FileSystemWatcher.Path%2A> jest ustawiona, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Składnik obserwować plików na komputerze osobistym, dysk sieciowy lub komputerze zdalnym.  
  
 Nie można oglądać komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można oglądać komputera zdalnego systemu Windows NT 4.0 z komputera z systemem Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Parametr jest <see langword="null" />.  - lub - <paramref name="filter" /> parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest pustym ciągiem ("").  - lub - ścieżki określonej za pomocą <paramref name="path" /> parametr nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> jest za długa.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjowanie <see cref="T:System.IO.FileSystemWatcher" /> używane w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika w formularzu lub używany przez inny składnik. <xref:System.IO.FileSystemWatcher.EndInit%2A> Metoda kończy się inicjowania. Przy użyciu <xref:System.IO.FileSystemWatcher.BeginInit%2A> i <xref:System.IO.FileSystemWatcher.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed> Zdarzenie jest wywoływane, gdy zostaną wprowadzone zmiany, rozmiar, atrybuty systemu ostatniego zapisu czasu, czas ostatniego dostępu lub uprawnienia pliku lub katalogu w katalogu monitorowane.  
  
> [!NOTE]
>  Typowe operacje systemu plików może podnieść więcej niż jedno zdarzenie. Na przykład, jeśli plik zostanie przeniesiony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. Przeniesienie pliku złożonych operacji, która składa się z wielu proste operacje, w związku z tym wywoływanie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowego pliku zdarzeń systemowych, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
 Użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Aby ograniczyć liczbę powiadomień wywoływane, gdy to zdarzenie jest obsługiwane.  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed> Zdarzenie jest wywoływane nieoczekiwanie, gdy plik zostanie zmieniona, ale nie jest wywoływane, gdy zostanie zmieniona nazwa katalogu. Aby obejrzeć zmianę, użyj <xref:System.IO.FileSystemWatcher.Renamed> zdarzeń.  
  
> [!NOTE]
>  Kolejność <xref:System.IO.FileSystemWatcher.Changed> zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> zdarzeń mogą ulec zmianie, gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość nie jest `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Changed> zdarzeń, aby wyświetlić ścieżkę pliku do konsoli zmianie obserwowanych pliku.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> jest tworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiada bezpośrednio do zdarzenia, ale te wystąpienia powodować zdarzenia, które mają być zgłaszane. Podczas kopiowania pliku lub katalogu, system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do którego została skopiowana plik, jeśli jest on obserwowane tego katalogu. Jeśli katalogu, z którego została skopiowana został są monitorowane przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład możesz utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ma ustawioną wartość "C:\My dokumenty" Obejrzyj i FileSystemWatcher2 ustawiono Obejrzyj "C:\Your dokumenty". Po skopiowaniu pliku "Moje dokumenty" do "Swoje dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzeń zostanie wygenerowany przez FileSystemWatcher2, ale żadne zdarzenie jest wywoływane dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przenoszenie pliku lub katalogu wywołałoby dwa zdarzenia. W poprzednim przykładzie, jeśli przenieść pliku "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może być zgłaszany przez FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może być zgłaszany przez FileSystemWatcher1.  
  
> [!NOTE]
>  Typowe operacje systemu plików może podnieść więcej niż jedno zdarzenie. Na przykład, jeśli plik zostanie przeniesiony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. Przeniesienie pliku złożonych operacji, która składa się z wielu proste operacje, w związku z tym wywoływanie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowego pliku zdarzeń systemowych, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Kolejność <xref:System.IO.FileSystemWatcher.Created> zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> zdarzeń mogą ulec zmianie, gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość nie jest `null`.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest zgłaszane, natychmiast po utworzeniu pliku. Jeśli plik jest kopiowany lub przenoszone do katalogu obserwowanych, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzeń zostanie wygenerowany, następuje co najmniej jeden <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Created> zdarzenie, aby wyświetlić ścieżkę pliku do konsoli zawsze, gdy tworzony jest plik monitorowane.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> zostanie usunięta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiada bezpośrednio do zdarzenia, ale te wystąpienia powodować zdarzenia, które mają być zgłaszane. Podczas kopiowania pliku lub katalogu, system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do którego została skopiowana plik, jeśli jest on obserwowane tego katalogu. Jeśli katalogu, z którego została skopiowana został są monitorowane przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład możesz utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ma ustawioną wartość "C:\My dokumenty" Obejrzyj i FileSystemWatcher2 ustawiono Obejrzyj "C:\Your dokumenty". Po skopiowaniu pliku "Moje dokumenty" do "Swoje dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzeń zostanie wygenerowany przez FileSystemWatcher2, ale żadne zdarzenie jest wywoływane dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przenoszenie pliku lub katalogu wywołałoby dwa zdarzenia. W poprzednim przykładzie, jeśli przenieść pliku "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może być zgłaszany przez FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może być zgłaszany przez FileSystemWatcher1.  
  
> [!NOTE]
>  Typowe operacje systemu plików może podnieść więcej niż jedno zdarzenie. Na przykład, jeśli plik zostanie przeniesiony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. Przeniesienie pliku złożonych operacji, która składa się z wielu proste operacje, w związku z tym wywoływanie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowego pliku zdarzeń systemowych, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Kolejność <xref:System.IO.FileSystemWatcher.Deleted> zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> zdarzeń mogą ulec zmianie, gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość nie jest `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń, aby wyświetlić ścieżkę pliku do konsoli zawsze, gdy monitorowane plik zostanie usunięty.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.FileSystemWatcher" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. <xref:System.ComponentModel.Component.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.FileSystemWatcher.Dispose%2A> metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.FileSystemWatcher.Dispose%2A> z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.Compression.DeflateStream> odwołania. Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see cref="M:System.ComponentModel.Component.Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see cref="M:System.ComponentModel.Component.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia się niezarządzane Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy składnik jest włączone.</summary>
        <value>
          <see langword="true" /> Jeśli włączony jest składnik; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />. Jeśli używasz składnika w projektancie w [! INCLUDE[vsprvslong](~/includes/vsprvslong-MD.MD)], wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnik nie wygenerował zdarzeń, chyba że ustawisz <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> do `true`.  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określony katalog do <xref:System.IO.FileSystemWatcher.Path%2A> właściwość została ustawiona i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> Metoda umożliwia obsługę zdarzeń do wywołania do reagowania na zmiany plików, nawet jeśli ta właściwość jest ustawiona na `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> Aby obejrzeć katalogu określonym w czasie wykonywania. Składnik ustawiono oczekiwał na zmiany w `LastWrite` i `LastAccess` czas, tworzenie, usuwanie, lub zmiana nazw plików tekstowych w katalogu. Jeśli plik jest zmienione, utworzone lub usunięte, ścieżka do pliku drukuje do konsoli. Gdy zostanie zmieniona nazwa pliku, ścieżki stary i nowy drukowanie do konsoli.  
  
 Użyj <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw w tym przykładzie.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.IO.FileSystemWatcher" /> Obiekt został usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nie jest bieżący system operacyjny Microsoft Windows NT lub nowszego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Katalog określony w <see cref="P:System.IO.FileSystemWatcher.Path" /> nie można odnaleźć.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> nie zostało ustawione lub jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.IO.FileSystemWatcher" /> używane w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika w formularzu lub używany przez inny składnik. <xref:System.IO.FileSystemWatcher.BeginInit%2A> Metoda uruchamia inicjowania. Przy użyciu <xref:System.IO.FileSystemWatcher.BeginInit%2A> i <xref:System.IO.FileSystemWatcher.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpienie <see cref="T:System.IO.FileSystemWatcher" /> nie może kontynuować monitorowanie zmian lub gdy przepełnienie buforu wewnętrznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane zawsze, gdy coś uniemożliwia <xref:System.IO.FileSystemWatcher> obiektu monitorowania zmian. Na przykład, jeśli obiekt jest monitorowanie zmian w katalogu zdalnym i połączenie do tego katalogu zostanie przerwane <xref:System.IO.FileSystemWatcher.Error> zdarzenia.  
  
 System powiadamia o zmianach pliku i przechowuje te zmiany w buforze, który składnik tworzy i przekazuje do interfejsów API. Jeśli wprowadzono wiele zmian w krótkim czasie, może się przelewać buforu. Powoduje to, że składnik utratę śledzenie zmian w katalogu, i udostępni jedynie zbiorcze powiadomień. Zwiększanie rozmiaru buforu jest kosztowna, ponieważ pochodzi on z innej niż stronicowanej pamięci, która nie może być wymieniony na dysku, Zachowaj tak buforu możliwie jak najmniejszy. Aby uniknąć przepełnienia buforu, użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwości, aby odfiltrować niechciane powiadomienia o zmianie.  
  
> [!NOTE]
>  Typowe operacje systemu plików może podnieść więcej niż jedno zdarzenie. Na przykład, jeśli plik zostanie przeniesiony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. Przeniesienie pliku złożonych operacji, która składa się z wielu proste operacje, w związku z tym wywoływanie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowego pliku zdarzeń systemowych, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg filtru używany do określenia, które pliki są monitorowane w katalogu.</summary>
        <value>Ciąg filtru. Wartość domyślna to "*. \*"(Obserwujący wszystkie pliki.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obejrzeć zmiany we wszystkich plikach, ustaw <xref:System.IO.FileSystemWatcher.Filter%2A> właściwości na ciąg pusty (""). Aby obejrzeć określonego pliku, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku. Na przykład, aby obejrzeć zmiany w pliku Moje_dok.txt, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> dla właściwości "Moje_dok.txt". Można również obejrzeć zmiany w typ pliku. Na przykład, aby obejrzeć zmiany w plikach tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> dla właściwości "*.txt". Użycie wielu filtrów, takich jak "\*.txt&#124;\*doc" nie jest obsługiwana.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> Właściwość można zmienić po <xref:System.IO.FileSystemWatcher> obiektu rozpoczął odbieranie zdarzeń.  
  
 Aby uzyskać więcej informacji dotyczących filtrowania niechciane powiadomień, zobacz <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> akceptuje symboli wieloznacznych dla pasujących plików, jak pokazano w poniższych przykładach.  
  
|Ciąg filtru|Obserwujący następujące pliki|  
|-------------------|---------------------------------|  
|*.\*|Wszystkie pliki (ustawienie domyślne). Ciąg pusty ("") oczekuje również wszystkie pliki.|  
|*.txt|Wszystkie pliki z rozszerzeniem "txt".|  
|*recipe.doc|Wszystkie pliki w "przepisu" z rozszerzeniem "doc".|  
|win*.xml|Wszystkie pliki z rozszerzeniem "xml" począwszy od "Windows".|  
|Sprzedaż * 200?. xls|Dopasowuje następujące czynności:<br /><br /> Lipiec sprzedaży 2001.xlsSales sie 2002.xlsSales marca 2004.xls<br /><br /> który jest niezgodny:<br /><br /> 1999.xls lis sprzedaży|  
|MyReport.Doc|Oczekuje tylko MyReport.doc|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> Aby obejrzeć katalogu określonym w czasie wykonywania. Składnik ustawiono oczekiwał na zmiany w `LastWrite` i `LastAccess` czas, tworzenie, usuwanie, lub zmiana nazw plików tekstowych w katalogu. Jeśli plik jest zmienione, utworzone lub usunięte, ścieżka do pliku drukuje do konsoli. Gdy zostanie zmieniona nazwa pliku, ścieżki stary i nowy drukowanie do konsoli.  
  
 Użyj <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw w tym przykładzie.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy powinno być monitorowane podkatalogów w określonej ścieżce.</summary>
        <value>
          <see langword="true" /> Jeśli chcesz monitorować podkatalogi; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> do `true` Aby obejrzeć powiadomienia o zmianach dla plików i katalogów zawartych w katalogu określonym za pomocą <xref:System.IO.FileSystemWatcher.Path%2A> właściwości i jego podkatalogach. Ustawienie <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwości `false` pomaga zmniejszyć liczbę powiadomień wysyłanych do buforu wewnętrznego. Aby uzyskać więcej informacji o filtrowaniu niechciane powiadomień, zobacz <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
 Gdy `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> jest rekursywna za pośrednictwem sub całego drzewa, nie tylko katalogi bezpośrednio podrzędne. Zwraca ścieżkę względną do pliku lub katalogu w obrębie drzewa sub <xref:System.IO.FileSystemEventArgs.Name%2A> właściwość <xref:System.IO.FileSystemEventArgs> i <xref:System.IO.RenamedEventArgs.OldName%2A> właściwość <xref:System.IO.RenamedEventArgs>w oparciu o zmiany obserwujesz dla. Można uzyskać w pełni kwalifikowaną ścieżkę <xref:System.IO.FileSystemEventArgs.FullPath%2A> właściwość <xref:System.IO.FileSystemEventArgs> i <xref:System.IO.RenamedEventArgs.OldFullPath%2A> właściwość <xref:System.IO.RenamedEventArgs>w oparciu o zmiany obserwujesz dla.  
  
 Jeśli katalog został utworzony w drzewie sub katalogu obserwujesz, i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> jest `true`, ten katalog jest automatycznie będą monitorowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar (w bajtach) buforu wewnętrznego.</summary>
        <value>Rozmiar buforu wewnętrznego w bajtach. Wartość domyślna to 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można ustawić buforu 4 KB lub większą, ale nie może przekraczać 64 KB. Jeśli spróbujesz ustawić <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości do mniej niż 4096 bajtów, wartość jest odrzucany i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwość jest ustawiona na 4096 bajtów. Aby uzyskać najlepszą wydajność należy użyć wielokrotnością 4 KB na komputerach opartych na Intel.  
  
 System powiadamia składnika zmian plików i przechowuje te zmiany w buforze składnik tworzy i przekazuje do interfejsów API. Każde zdarzenie służy do 16 bajtów pamięci, nie zawiera nazwy pliku. Jeśli wprowadzono wiele zmian w krótkim czasie, może się przelewać buforu. Powoduje to, że składnik utratę śledzenie zmian w katalogu, i udostępni jedynie zbiorcze powiadomień. Zwiększanie rozmiaru buforu może uniemożliwić zdarzenia zmian Brak system plików. Zwiększanie rozmiaru buforu jest jednak kosztowne, ponieważ pochodzi on z niestronicowanej pamięci, które nie mogą być wymieniane na dysku, więc należy możliwie jak najmniejszy rozmiar buforu. Aby uniknąć przepełnienia buforu, użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwości, aby odfiltrować niechciane powiadomienia o zmianie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ zmiany, które należy obserwować.</summary>
        <value>Jeden z <see cref="T:System.IO.NotifyFilters" /> wartości. Wartość domyślna to bitowe połączenie lub <see langword="LastWrite" />, <see langword="FileName" />, i <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można łączyć elementów członkowskich <xref:System.IO.NotifyFilters> wyliczenia, które należy obserwować więcej niż jeden typ zmiany w czasie. Na przykład można obserwować zmiany rozmiaru pliku i zmiany w `LastWrite` czasu. To zgłasza zdarzenie, w dowolnym momencie zmianę w rozmiarze pliku lub folderu lub zmiany w `LastWrite` czasu pliku lub folderu.  
  
 Jest jednym ze sposobów odfiltruj niechciane powiadomienia. Aby uzyskać więcej informacji o filtrowaniu niechciane powiadomień, zobacz <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> Aby obejrzeć katalogu określonym w czasie wykonywania. Składnik ustawiono oczekiwał na zmiany w `LastWrite` i `LastAccess` czas, tworzenie, usuwanie, lub zmiana nazw plików tekstowych w katalogu. Jeśli plik jest zmienione, utworzone lub usunięte, ścieżka do pliku drukuje do konsoli. Gdy zostanie zmieniona nazwa pliku, ścieżki stary i nowy drukowanie do konsoli.  
  
 Użyj <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw w tym przykładzie.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość nie jest prawidłową bitowe lub kombinację <see cref="T:System.IO.NotifyFilters" /> wartości.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Wartość, która jest ustawiona jest nieprawidłowa.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.IO.FileSystemWatcher.Changed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> jest wywoływana podczas wprowadzania zmian do rozmiar, atrybuty systemowe, czas ostatniego zapisu, czas ostatniego dostępu lub uprawnień zabezpieczeń dla pliku lub katalogu w katalogu monitorowane.  
  
 Użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> właściwości do ograniczania liczby zdarzeń wywoływane, gdy <xref:System.IO.FileSystemWatcher.Changed> zdarzenie jest obsługiwane.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest zgłaszane, natychmiast po utworzeniu pliku. Jeśli plik jest kopiowany lub przenoszone do katalogu obserwowanych, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzeń zostanie wygenerowany, następuje co najmniej jeden <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenia.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> metody.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.IO.FileSystemWatcher.Created" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> jest wywoływane, gdy plik lub katalog jest tworzony w katalogu monitorowane.  
  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiada bezpośrednio do zdarzenia, ale te wystąpienia powodować zdarzenia, które mają być zgłaszane. Podczas kopiowania pliku lub katalogu, system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do którego została skopiowana plik, jeśli jest on obserwowane tego katalogu. Jeśli katalogu, z którego została skopiowana został są monitorowane przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład możesz utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ma ustawioną wartość "C:\My dokumenty" Obejrzyj i FileSystemWatcher2 ustawiono Obejrzyj "C:\Your dokumenty". Jeśli kopiowanie pliku z "Moje dokumenty" i wklej go do "Swoje dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzeń zostanie wygenerowany w FileSystemWatcher2, ale żadne zdarzenie jest wywoływane dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przenoszenie pliku lub katalogu zgłasza dwa zdarzenia. Z poprzedniego przykładu, jeśli przenieść pliku "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzenie będzie zgłaszane w FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzenie będzie zgłaszane w FileSystemWatcher1.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest zgłaszane, natychmiast po utworzeniu pliku. Jeśli plik jest kopiowany lub przenoszone do katalogu obserwowanych, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzeń zostanie wygenerowany, następuje co najmniej jeden <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenia.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> metody.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.IO.FileSystemWatcher.Deleted" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> jest wywoływana, gdy plik lub katalog, w ramach katalogu monitorowana, zostanie usunięta.  
  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiada bezpośrednio do zdarzenia, ale te wystąpienia powodować zdarzenia, które mają być zgłaszane. Podczas kopiowania pliku lub katalogu, system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do którego została skopiowana plik, jeśli jest on obserwowane tego katalogu. Jeśli katalogu, z którego została skopiowana został są monitorowane przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład możesz utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ma ustawioną wartość "C:\My dokumenty" Obejrzyj i FileSystemWatcher2 ustawiono Obejrzyj "C:\Your dokumenty". Po skopiowaniu pliku "Moje dokumenty" do "Swoje dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzeń zostanie wygenerowany przez FileSystemWatcher2, ale żadne zdarzenie jest wywoływane dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przenoszenie pliku lub katalogu zgłasza dwa zdarzenia. W poprzednim przykładzie, jeśli przenieść pliku "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może być zgłaszany przez FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może być zgłaszany przez FileSystemWatcher1.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> metody.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.IO.ErrorEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.IO.FileSystemWatcher.Error" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> jest wywoływana po wystąpieniu błędu.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> metody.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.RenamedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.IO.FileSystemWatcher.Renamed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> jest wywoływane, gdy plik lub katalog w katalogu monitorowanych zostanie zmieniona. Jego <xref:System.IO.RenamedEventArgs> argument zawiera informacje na temat operacji zmiany nazwy, takie jak typ zmiany, ścieżka starej i nowej i starej i nowej nazwy. Należy pamiętać, że jego <xref:System.IO.FileSystemEventArgs.Name> właściwości może mieć wartości null dla zmieniona zdarzenia, jeśli <xref:System.IO.FileSystemWatcher> uzyskać niezgodni starej i nowej nazwy zdarzenia z systemu operacyjnego. 
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> metody.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę katalogu do monitorowania.</summary>
        <value>Ścieżka do monitorowania. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To jest pełna ścieżka do katalogu. Jeśli <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwość jest `true`, jest to katalog główny, w którym system oczekuje na zmiany; w przeciwnym razie jest to katalog tylko obserwowana. Aby obejrzeć określonego pliku, należy ustawić <xref:System.IO.FileSystemWatcher.Path%2A> właściwości do katalogu pełną, poprawne i <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku.  
  
 <xref:System.IO.FileSystemWatcher.Path%2A> Właściwość obsługuje ścieżek Universal Naming Convention (UNC).  
  
> [!NOTE]
>  Tej właściwości należy ustawić przed składnika można obserwować zmiany.  
  
 Gdy zostanie zmieniona nazwa katalogu, <xref:System.IO.FileSystemWatcher> automatycznie reattaches się do nowo zmieniono nazwę elementu. Na przykład jeśli ustawisz <xref:System.IO.FileSystemWatcher.Path%2A> dla właściwości "C:\My dokumenty" i ręcznie zmień nazwę w katalogu "C:\Your dokumenty", składnik kontynuuje nasłuchiwania powiadomienia o zmianach dla katalogu zmienionej. Jednak gdy na żądanie użytkownika <xref:System.IO.FileSystemWatcher.Path%2A> właściwość zawiera starej ścieżki. Dzieje się tak, ponieważ składnik określa katalog Obserwujący oparte na dojście, a nie nazwę katalogu. Zmiana nazwy nie ma wpływu na dojście. Zatem w przypadku zniszczyć składnika, a następnie utwórz ją ponownie bez aktualizowania <xref:System.IO.FileSystemWatcher.Path%2A> właściwości, aplikacja zakończy się niepowodzeniem, ponieważ katalog już istnieje.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> Aby obejrzeć katalogu określonym w czasie wykonywania. Składnik ustawiono oczekiwał na zmiany w `LastWrite` i `LastAccess` czas, tworzenie, usuwanie, lub zmiana nazw plików tekstowych w katalogu. Jeśli plik jest zmienione, utworzone lub usunięte, ścieżka do pliku drukuje do konsoli. Gdy zostanie zmieniona nazwa pliku, ścieżki stary i nowy drukowanie do konsoli.  
  
 Użyj <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw w tym przykładzie.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona ścieżka nie istnieje lub nie można odnaleźć.  - lub - określona ścieżka zawiera znaki symboli wieloznacznych.  - lub - określona ścieżka zawiera nieprawidłowe znaki ścieżki.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed` Zdarzenie jest <xref:System.IO.RenamedEventHandler> delegata, który ma podpis następujące:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs> Obiektu zawiera informacje o operacji zmiany nazwy, takie jak typ zmiany nazwy ( <xref:System.IO.FileSystemEventArgs.ChangeType> właściwości), nazwę starej i nowej i starej i nowej ścieżki. Należy pamiętać, że <xref:System.IO.FileSystemEventArgs.Name> właściwości może mieć wartości null dla zmieniona zdarzenia, jeśli <xref:System.IO.FileSystemWatcher> uzyskać niezgodni starej i nowej nazwy zdarzenia z systemu operacyjnego.

 Zmiana nazwy katalogu, który obserwujesz nie generuje powiadomienie. Powiadomienia pojawienia się tylko w przypadku wpisów w katalogu, który obserwujesz.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Renamed> zdarzeń do wyświetlenia ścieżkę pliku do konsoli zawsze, gdy monitorowane pliku zostanie zmieniona.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> dla <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> Dla <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązania witryny <xref:System.ComponentModel.Component> do <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> i umożliwić komunikację między nimi, a także umożliwiają kontener, aby zarządzać jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń utworzony w wyniku zmiany katalogu.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Reprezentujący obiekt używany do organizowania wywołań obsługi zdarzeń utworzony w wyniku zmiany katalogu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> jest `null`, metod obsługi <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia są wywoływane w wątku z puli wątków systemu. Aby uzyskać więcej informacji na pule wątków systemu, zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia są obsługiwane przez składnik visual formularzy systemu Windows, takich jak <xref:System.Windows.Forms.Button>, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać lub może spowodować wyjątek. Tego uniknąć, ustawiając <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> składnika formularzy systemu Windows, co powoduje, że metody, które obsługują <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> zdarzeń ma być wywołane na tym samym wątku, w której utworzono składnika.  
  
 Jeśli <xref:System.IO.FileSystemWatcher> jest używany wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w projektancie formularzy systemu Windows, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> automatycznie ustawia kontrolkę, która zawiera <xref:System.IO.FileSystemWatcher>. Na przykład, jeśli zostanie <xref:System.IO.FileSystemWatcher> na Projektant Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość <xref:System.IO.FileSystemWatcher> ustawiono wystąpienie Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Metoda synchroniczna zwraca struktury, która zawiera szczegółowe informacje dotyczące zmian, który wystąpił.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">
          <see cref="T:System.IO.WatcherChangeTypes" /> Można wyszukiwać.</param>
        <summary>Metoda synchroniczna zwraca struktury, która zawiera szczegółowe informacje dotyczące zmian, który wystąpił, dla danego typu zmiana, którą chcesz monitorować.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> zawiera szczegółowe informacje dotyczące zmian, który wystąpił.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda oczekuje przez czas nieokreślony, dopóki pierwsza zmiana występuje, a następnie zwraca. Jest to ten sam, jak za pomocą <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> z `timeout` parametru ustawioną wartość -1.  
  
> [!NOTE]
>  Ta metoda umożliwia program obsługi zdarzeń do wywołania na odpowiadanie na zmiany pliku nawet wtedy, gdy <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> właściwość jest ustawiona na `false`.  
  
 W niektórych systemach <xref:System.IO.FileSystemWatcher> raporty zmiany do plików przy użyciu krótkich format nazwy pliku w formacie 8.3. Na przykład zmiany "LongFileName.LongExtension" mogą być raportowane jako "LongFi ~. Długa".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">
          <see cref="T:System.IO.WatcherChangeTypes" /> Można wyszukiwać.</param>
        <param name="timeout">Czas (w milisekundach) oczekiwania przed przekroczeniem limitu czasu.</param>
        <summary>Metoda synchroniczna zwraca struktury, która zawiera szczegółowe informacje dotyczące zmian, który wystąpił, dla danego typu zmiana, którą chcesz monitorować i czas (w milisekundach) oczekiwania przed przekroczeniem limitu czasu.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> zawiera szczegółowe informacje dotyczące zmian, który wystąpił.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda oczekuje, aż nastąpi zmiana lub został przekroczony. Wartość -1 dla `timeout` parametru oznacza czekanie w nieskończoność.  
  
> [!NOTE]
>  Ta metoda umożliwia program obsługi zdarzeń do wywołania na odpowiadanie na zmiany pliku nawet wtedy, gdy <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> właściwość jest ustawiona na `false`.  
  
 W niektórych systemach <xref:System.IO.FileSystemWatcher> raporty zmiany do plików przy użyciu krótkich format nazwy pliku w formacie 8.3. Na przykład zmiany "LongFileName.LongExtension" mogą być raportowane jako "LongFi ~. Długa".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9804627f9162207d228105246faab6e636e6c42c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58735978" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Nasłuchuje w systemie plików zmienić powiadomień i wywołuje zdarzenia w przypadku katalogu lub pliku w katalogu, zmiany.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileSystemWatcher> obejrzeć zmiany w określonym katalogu. Możesz obserwować zmiany plików i podkatalogów określonego katalogu. Można utworzyć składnika, aby obejrzeć plików na komputerze lokalnym, na dysku sieciowym lub komputerze zdalnym.  
  
 Aby obejrzeć zmiany we wszystkich plikach, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwości na ciąg pusty ("") lub użyj symboli wieloznacznych ("*.\*"). Aby obejrzeć określonego pliku, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku. Na przykład, aby obserwować zmiany w pliku Moje_dok.txt, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość "Moje_dok.txt". Możesz też obejrzeć zmiany w typ pliku. Na przykład, aby obserwować zmiany w plikach tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość "\*.txt".  
  
 Istnieje kilka rodzajów zmian, które można śledzić w pliku lub katalogu. Na przykład możesz obserwować zmiany w `Attributes`, `LastWrite` datę i godzinę, lub `Size` plików lub katalogów. Jest to realizowane przez ustawienie <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> jedną z właściwości <xref:System.IO.NotifyFilters> wartości. Aby uzyskać więcej informacji na temat typu zmian, możesz obejrzeć, zobacz <xref:System.IO.NotifyFilters>.  
  
 Możesz obejrzeć o zmianę nazwy, usuwanie i tworzenie plików lub katalogów. Na przykład, aby obejrzeć o zmianę nazwy plików tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość "*.txt", a następnie wywołać <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> metody z <xref:System.IO.WatcherChangeTypes.Renamed> określona dla jej parametru.  
  
 System operacyjny Windows powiadomi składnika zmian plików w buforze, utworzone przez <xref:System.IO.FileSystemWatcher>. Jeśli wprowadzono wiele zmian w krótkim czasie, może przepełnienie buforu. Powoduje to, że składnik utratę informacji o zmiany w katalogu i udostępni jedynie zbiorcze powiadomień. Zwiększenie rozmiaru buforu z <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwość jest kosztowne, ponieważ pochodzi on z pamięci niestronicowanej, którego nie można ich odpowiedniki na dysku, więc Zachowaj buforu niewielkie jeszcze dużych wystarczająco dużo, aby nie przegap dowolnego pliku zdarzenia zmian. Aby uniknąć przepełnienia buforu, należy użyć <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> powiadomienia o zmianie właściwości, dzięki czemu można odfiltrować niepożądane.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.IO.FileSystemWatcher>, zobacz <xref:System.IO.FileSystemWatcher.%23ctor%2A> konstruktora.  
  
 . Należy pamiętać o następujących, korzystając z <xref:System.IO.FileSystemWatcher> klasy.  
  
-   Ukryte pliki nie są ignorowane.  
  
-   W niektórych systemach <xref:System.IO.FileSystemWatcher> raportów zmiany do plików za pomocą krótki format nazwy pliku w formacie 8.3. Na przykład zmiana "LongFileName.LongExtension" mogą być raportowane jako "LongFil ~. Długa".  
  
-   Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. Element <xref:System.Security.SecurityException> jest generowany, gdy bezpośredniego obiektu wywołującego lub Klasa pochodna nie mają uprawnień pełnego zaufania. Aby uzyskać szczegółowe informacje na temat wymaganych zabezpieczeń, zobacz [zapotrzebowania na łącza](~/docs/framework/misc/link-demands.md).  
  
-   Maksymalny rozmiar, można ustawić dla <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwość monitorowania z katalogiem za pośrednictwem sieci wynosi 64 KB.  
  
> [!NOTE]
>  Uruchamianie <xref:System.IO.FileSystemWatcher> na Windows 98 nie jest obsługiwane.  
  
## <a name="copying-and-moving-folders"></a>Kopiowanie i przenoszenie folderów  
 System operacyjny i <xref:System.IO.FileSystemWatcher> obiektu interpretacji wycinania i wklejania lub akcji przeniesienia, jako akcja zmiany nazwy, folderu i jego zawartość. Jeśli wycinania i wklejania folderu z plikami w folderze obserwowany, <xref:System.IO.FileSystemWatcher> obiektu zgłasza tylko w folderze, co nowego, ale nie do zawartości, ponieważ zasadniczo są tylko zmienione.  
  
 Aby otrzymać powiadomienie, że zawartość folderów zostały przeniesione lub skopiowany do folderu monitorowane, należy podać <xref:System.IO.FileSystemWatcher.OnChanged%2A> i <xref:System.IO.FileSystemWatcher.OnRenamed%2A> metody obsługi zdarzeń, zgodnie z sugestią podaną w poniższej tabeli.  
  
|Program obsługi zdarzeń|Zdarzenia obsługiwane|Wykonuje|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Należy sporządzić raport zmiany atrybutów pliku, utworzone pliki i usunięte pliki.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Wyświetl listę stare i nowe ścieżki uwzględniają zmiany nazw plików i folderów, rozszerzając cyklicznie, jeśli to konieczne.|  
  
## <a name="events-and-buffer-sizes"></a>Zdarzenia i rozmiary buforów  
 Należy pamiętać, że istnieje kilka możliwych mogą mieć wpływ na zdarzenia zmian systemu plików, które są wywoływane, zgodnie z opisem, wykonując następujące czynności:  
  
-   Typowe operacje systemu plików mogą zgłaszać więcej niż jedno zdarzenie. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. W związku z tym przeniesienie pliku złożoną operacją, która składa się z wielu proste operacje, podjęcie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowy plik zdarzenia systemowe, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
-   <xref:System.IO.FileSystemWatcher> Obserwować dysków tak długo, jak nie są one przełączono lub usunięte. <xref:System.IO.FileSystemWatcher> Nie zgłaszać zdarzenia dla dysków CD lub DVD, ponieważ nie można zmienić właściwości i sygnatury czasowe. Komputerów zdalnych musi mieć jedną z platform wymagane, zainstalowane w celu poprawnego składnika.  
  
-   Jeśli wiele <xref:System.IO.FileSystemWatcher> obiektów obserwujesz tego samego ścieżkę UNC w Windows XP przed dodatkiem Service Pack 1 lub Windows 2000 z dodatkiem SP2 lub starszej, a następnie tylko jeden z obiektów będzie wywołać zdarzenie. Na komputerach z systemem Windows XP z dodatkiem SP1 lub nowszym, Windows 2000 z dodatkiem SP3 lub nowszej lub Windows Server 2003, wszystkie <xref:System.IO.FileSystemWatcher> obiektów zgłosi odpowiednie zdarzenia.  
  
 Należy pamiętać, że <xref:System.IO.FileSystemWatcher> może ominęło Cię wydarzenie w przypadku przekroczenia rozmiaru buforu. Aby uniknąć, Brak zdarzeń, należy przestrzegać następujących wytycznych:  
  
-   Zwiększ rozmiar buforu, ustawiając <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
-   Należy unikać pliki o długich nazw plików, oglądając, ponieważ zawierający długiej nazwy pliku, który przyczynia się do zapełnia się w buforze. Należy wziąć pod uwagę, zmiana nazwy tych plików, używając krótszej nazwy.  
  
-   Zachowaj możliwie krótkie kod obsługi zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obejrzeć katalogu określonego w czasie wykonywania. Składnik jest ustawiona na obserwowanie zmian w `LastWrite` i `LastAccess` czas tworzenia, usuwania, lub zmiana nazwy plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku drukuje do konsoli. Po zmianie nazwy pliku, ścieżki stare i nowe drukowanie do konsoli.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">dla elementu pochodnego dla <see cref="T:System.Diagnostics.ProcessStartInfo" /> klasy. Zapotrzebowanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Nazwane zestawy uprawnień: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Za pomocą klasy FileSystemWatcher składnika w formularzu Windows</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można oglądać komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można oglądać komputera zdalnego systemu Windows NT 4.0 z komputera z systemem Windows NT 4.0.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.IO.FileSystemWatcher>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|bitową kombinacją OR `LastWrite`, `FileName`, i `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Obejrzyj wszystkie pliki.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|Pusty ciąg ("")|  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> jest ustawiona, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obiektu, aby obejrzeć w katalogu wskazanym w czasie wykonywania. <xref:System.IO.FileSystemWatcher> Obiekt oczekuje na zmiany w `LastWrite` i `LastAccess` razy, a także do tworzenia, usuwania lub zmiany nazwy tekstu pliki w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku wyświetla w konsoli. Pliku została zmieniona, ścieżki stary i nowy są wyświetlane w konsoli.  
  
 W tym przykładzie użyto <xref:System.Diagnostics> i <xref:System.IO> przestrzeni nazw.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do monitorowania, standard lub notacji Universal Naming Convention (UNC).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy, biorąc pod uwagę określonego katalogu do monitorowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> jest ustawiona, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Składnik obserwować plików na komputerze osobistym, na dysku sieciowym lub komputerze zdalnym.  
  
 Nie można oglądać komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można oglądać komputera zdalnego systemu Windows NT 4.0 z komputera z systemem Windows NT 4.0. <xref:System.IO.FileSystemWatcher.Filter%2A> Domyślnie właściwością, aby obejrzeć wszystkie pliki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
Ścieżka określona przez <paramref name="path" /> parametr nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> jest zbyt długa.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do monitorowania, standard lub notacji Universal Naming Convention (UNC).</param>
        <param name="filter">Typ plików, aby obejrzeć. Na przykład "*.txt" oczekuje na zmiany do wszystkich plików tekstowych.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy, biorąc pod uwagę określony katalog i typów plików, do monitorowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> jest ustawiona, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Składnik obserwować plików na komputerze osobistym, na dysku sieciowym lub komputerze zdalnym.  
  
 Nie można oglądać komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można oglądać komputera zdalnego systemu Windows NT 4.0 z komputera z systemem Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="filter" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
Ścieżka określona przez <paramref name="path" /> parametr nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> jest zbyt długa.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się inicjowanie <see cref="T:System.IO.FileSystemWatcher" /> w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika w formularzu lub używany przez inny składnik. <xref:System.IO.FileSystemWatcher.EndInit%2A> Metoda kończy się inicjowanie. Za pomocą <xref:System.IO.FileSystemWatcher.BeginInit%2A> i <xref:System.IO.FileSystemWatcher.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed> Zdarzenie jest wywoływane, gdy zostaną wprowadzone zmiany rozmiaru, atrybutów systemowych, ostatniego zapisu czasu, czas ostatniego dostępu i uprawnień zabezpieczeń pliku lub katalogu w katalogu, które są monitorowane.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą zgłaszać więcej niż jedno zdarzenie. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. W związku z tym przeniesienie pliku złożoną operacją, która składa się z wielu proste operacje, podjęcie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowy plik zdarzenia systemowe, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
 Użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Aby ograniczyć liczbę powiadomienia wywoływane, gdy to zdarzenie jest obsługiwane.  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed> Zdarzenie jest zgłaszane nieoczekiwanie po pliku została zmieniona, ale nie jest zgłaszany, gdy zmieniono jego nazwę katalogu. Aby obejrzeć o zmianę nazwy, należy użyć <xref:System.IO.FileSystemWatcher.Renamed> zdarzeń.  
  
> [!NOTE]
>  Kolejność, w której <xref:System.IO.FileSystemWatcher.Changed> zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> zdarzenia mogą ulec zmianie, gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość nie jest `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Changed> zdarzenie, aby wyświetlić ścieżkę pliku do konsoli po każdej zmianie pliku obserwowanych.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> zostanie utworzony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiadają bezpośrednio na zdarzenie, ale takie sytuacje powodować zdarzenia zgłoszenie. Podczas kopiowania pliku lub katalogu, to system zgłosi <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do której plik został skopiowany, jeśli jest obserwowany tego katalogu. Jeśli katalog, z którego został skopiowany został obserwowany przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiona na "C:\My Documents" Obejrzyj i FileSystemWatcher2 jest ustawiona na oglądanie "C:\Your dokumenty". W przypadku kopiowania pliku z "Moje dokumenty" na "Your dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzenia zostaną podniesione przez FileSystemWatcher2, ale nie zdarzenie jest wywoływane dla FileSystemWatcher1. W odróżnieniu od kopiowanie, przenoszenie pliku lub katalogu zainicjowałaby dwa zdarzenia. W poprzednim przykładzie, jeśli plik został przeniesiony "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może zostać wywołane przez FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może zostać wywołane przez FileSystemWatcher1.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą zgłaszać więcej niż jedno zdarzenie. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. W związku z tym przeniesienie pliku złożoną operacją, która składa się z wielu proste operacje, podjęcie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowy plik zdarzenia systemowe, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Kolejność, w której <xref:System.IO.FileSystemWatcher.Created> zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> zdarzenia mogą ulec zmianie, gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość nie jest `null`.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest wywoływane, gdy tylko zostanie utworzony plik. Jeśli plik jest kopiowane lub przenoszone do obserwowanych katalogu, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzenia zostaną podniesione natychmiast, następuje co najmniej jeden <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Created> zdarzenie, aby wyświetlić ścieżkę pliku do konsoli, zawsze wtedy, gdy tworzony jest plik obserwowanych.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> zostanie usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiadają bezpośrednio na zdarzenie, ale takie sytuacje powodować zdarzenia zgłoszenie. Podczas kopiowania pliku lub katalogu, to system zgłosi <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do której plik został skopiowany, jeśli jest obserwowany tego katalogu. Jeśli katalog, z którego został skopiowany został obserwowany przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiona na "C:\My Documents" Obejrzyj i FileSystemWatcher2 jest ustawiona na oglądanie "C:\Your dokumenty". W przypadku kopiowania pliku z "Moje dokumenty" na "Your dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzenia zostaną podniesione przez FileSystemWatcher2, ale nie zdarzenie jest wywoływane dla FileSystemWatcher1. W odróżnieniu od kopiowanie, przenoszenie pliku lub katalogu zainicjowałaby dwa zdarzenia. W poprzednim przykładzie, jeśli plik został przeniesiony "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może zostać wywołane przez FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może zostać wywołane przez FileSystemWatcher1.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą zgłaszać więcej niż jedno zdarzenie. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. W związku z tym przeniesienie pliku złożoną operacją, która składa się z wielu proste operacje, podjęcie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowy plik zdarzenia systemowe, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Kolejność, w której <xref:System.IO.FileSystemWatcher.Deleted> zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> zdarzenia mogą ulec zmianie, gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość nie jest `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Deleted> zdarzenie, aby wyświetlić ścieżkę pliku do konsoli zawsze wtedy, gdy monitorowane plik zostanie usunięty.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.FileSystemWatcher" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną <xref:System.ComponentModel.Component.Dispose%2A> metody i <xref:System.Object.Finalize%2A> metody. <xref:System.ComponentModel.Component.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.FileSystemWatcher.Dispose%2A> metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.FileSystemWatcher.Dispose%2A> z `disposing` równa `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.IO.Compression.DeflateStream> odwołania. Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> Uważaj, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see cref="M:System.ComponentModel.Component.Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see cref="M:System.ComponentModel.Component.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy składnik jest włączone.</summary>
        <value><see langword="true" /> Jeśli składnik jest włączone; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />. Jeśli używasz składnika w projektancie w [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnik nie będzie wywoływać zdarzenia, chyba że <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> do `true`.  
  
> [!NOTE]
>  Składnik nie będzie oczekiwał określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> właściwość została ustawiona i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> Metoda umożliwia programów obsługi zdarzeń do wywoływane w celu reagowania na zmiany plików, nawet wtedy, gdy ta właściwość jest ustawiona `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obejrzeć katalogu określonego w czasie wykonywania. Składnik jest ustawiona na obserwowanie zmian w `LastWrite` i `LastAccess` czas tworzenia, usuwania, lub zmiana nazwy plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku drukuje do konsoli. Po zmianie nazwy pliku, ścieżki stare i nowe drukowanie do konsoli.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.IO.FileSystemWatcher" /> Obiekt został usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest Microsoft Windows NT lub nowszego.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Katalog określony w <see cref="P:System.IO.FileSystemWatcher.Path" /> nie został odnaleziony.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> nie została ustawiona lub jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.IO.FileSystemWatcher" /> w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika w formularzu lub używany przez inny składnik. <xref:System.IO.FileSystemWatcher.BeginInit%2A> Metoda uruchamia inicjowania. Za pomocą <xref:System.IO.FileSystemWatcher.BeginInit%2A> i <xref:System.IO.FileSystemWatcher.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpienie <see cref="T:System.IO.FileSystemWatcher" /> nie może kontynuować monitorowanie zmian lub gdy przepełnienia buforu wewnętrznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane zawsze wtedy, gdy coś, co uniemożliwia <xref:System.IO.FileSystemWatcher> obiektu monitorowania zmian. Na przykład, jeśli obiekt monitoruje zmiany w katalogu zdalnym i połączenia do tego katalogu zostało utracone lub <xref:System.IO.FileSystemWatcher.Error> zdarzenie jest wywoływane.  
  
 System z powiadomieniem o zmiany w plikach i przechowuje te zmiany w buforze, który składnik tworzy i przechodzi do interfejsów API. Jeśli wprowadzono wiele zmian w krótkim czasie, może przepełnienie buforu. Powoduje to, że składnik utratę informacji o zmiany w katalogu i udostępni jedynie zbiorcze powiadomień. Zwiększenie rozmiaru buforu jest kosztowne, ponieważ pochodzi on z innej stronicowanej pamięci, która nie może być wymieniane na dysku, więc Zachowaj buforu tak małej, jak to możliwe. Aby uniknąć przepełnienia buforu, należy użyć <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> powiadomienia o zmianie właściwości, aby odfiltrować niepożądane.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą zgłaszać więcej niż jedno zdarzenie. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, kilka <xref:System.IO.FileSystemWatcher.OnChanged%2A> i niektóre <xref:System.IO.FileSystemWatcher.OnCreated%2A> i <xref:System.IO.FileSystemWatcher.OnDeleted%2A> zdarzeń może zostać wywołane. W związku z tym przeniesienie pliku złożoną operacją, która składa się z wielu proste operacje, podjęcie wielu zdarzeń. Ponadto niektóre aplikacje (na przykład oprogramowania antywirusowego) może spowodować dodatkowy plik zdarzenia systemowe, które są wykrywane przez <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg filtru, używany do określenia, jakie pliki są monitorowane w katalogu.</summary>
        <value>Ciąg filtru. Wartość domyślna to "*. \*"(Obserwuje wszystkie pliki.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obejrzeć zmiany we wszystkich plikach, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwości na ciąg pusty (""). Aby obejrzeć określonego pliku, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku. Na przykład, aby obserwować zmiany w pliku Moje_dok.txt, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość "Moje_dok.txt". Możesz też obejrzeć zmiany w typ pliku. Na przykład, aby obserwować zmiany w plikach tekstu, ustaw <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość "*.txt". Korzystanie z wielu filtrów, takich jak "\*.txt&#124;\*doc" nie jest obsługiwane.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> Właściwość można zmienić po <xref:System.IO.FileSystemWatcher> obiektu została uruchomiona, odbierania zdarzeń.  
  
 Aby uzyskać więcej informacji dotyczących filtrowania powiadomień niechciane zobacz <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> akceptuje symbole wieloznaczne pasujących plików, jak pokazano w poniższych przykładach.  
  
|Ciąg filtru|Obserwuje następujące pliki|  
|-------------------|---------------------------------|  
|*.\*|Wszystkie pliki (domyślnie). Ciąg pusty ("") również obserwuje wszystkich plików.|  
|*.txt|Wszystkie pliki z rozszerzeniem "txt".|  
|*recipe.doc|Wszystkie pliki kończące się na "przepisu" rozszerzeniem "doc".|  
|win*.xml|Wszystkie pliki z rozszerzeniem "xml" począwszy od "win".|  
|Sprzedaż * 200?. xls|Pasuje do następujących czynności:<br /><br /> Lipca sprzedaży 2001.xlsSales sie 2002.xlsSales marca 2004.xls<br /><br /> ale nie pasuje:<br /><br /> 1999.xls lis sprzedaży|  
|MyReport.Doc|Oczekuje tylko MyReport.doc|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obejrzeć katalogu określonego w czasie wykonywania. Składnik jest ustawiona na obserwowanie zmian w `LastWrite` i `LastAccess` czas tworzenia, usuwania, lub zmiana nazwy plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku drukuje do konsoli. Po zmianie nazwy pliku, ścieżki stare i nowe drukowanie do konsoli.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy podkatalogi w określonej ścieżce powinny być monitorowane.</summary>
        <value><see langword="true" /> Jeśli chcesz monitorować podkatalogów; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> do `true` kiedy chcesz obejrzeć powiadomienia o zmianach dla plików i katalogów znajdujących się w katalogu określonym za pomocą <xref:System.IO.FileSystemWatcher.Path%2A> właściwości i jego podkatalogach. Ustawienie <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwość `false` pomaga zmniejszyć liczbę powiadomień wysyłanych do wewnętrznego buforu. Aby uzyskać więcej informacji na temat filtrowania powiadomień niepożądane, zobacz <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
 Gdy `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> jest rekursywna za pośrednictwem sub całego drzewa, nie tylko bezpośrednie podrzędne katalogów. Zwraca ścieżkę względną do pliku lub katalogu w obrębie drzewa sub <xref:System.IO.FileSystemEventArgs.Name%2A> właściwość <xref:System.IO.FileSystemEventArgs> i <xref:System.IO.RenamedEventArgs.OldName%2A> właściwość <xref:System.IO.RenamedEventArgs>, w zależności od zmian, które obserwujesz dla. Możesz uzyskać w pełni kwalifikowaną ścieżkę z <xref:System.IO.FileSystemEventArgs.FullPath%2A> właściwość <xref:System.IO.FileSystemEventArgs> i <xref:System.IO.RenamedEventArgs.OldFullPath%2A> właściwość <xref:System.IO.RenamedEventArgs>, w zależności od zmian obserwujesz dla.  
  
 Jeśli katalog jest tworzony w drzewie sub katalogu obserwujesz, i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> jest `true`, ten katalog jest automatycznie będą monitorowane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar (w bajtach) buforu wewnętrznego.</summary>
        <value>Rozmiar wewnętrznego buforu, w bajtach. Wartość domyślna to 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz ustawić buforu 4 KB lub większy, ale nie może przekraczać 64 KB. Jeśli spróbujesz ustawić <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości do mniej niż 4096 bajtów, wartość jest odrzucana i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> ustawioną 4096 bajtów. Aby uzyskać najlepszą wydajność należy użyć wielokrotności 4 KB na komputerach opartych na Intel.  
  
 System powiadamia składnika zmian w plikach i przechowuje te zmiany w buforze składnik tworzy i przechodzi do interfejsów API. Każde zdarzenie można użyć maksymalnie 16 bajtów pamięci, nie zawiera nazwy pliku. Jeśli wprowadzono wiele zmian w krótkim czasie, może przepełnienie buforu. Powoduje to, że składnik utratę informacji o zmiany w katalogu i udostępni jedynie zbiorcze powiadomień. Zwiększenie rozmiaru buforu może uniemożliwić systemu plików brakuje zdarzenia zmian. Zwiększenie rozmiaru buforu jest jednak kosztowne, ponieważ pochodzi on z niestronicowanej pamięci, która nie może ich odpowiedniki na dysku, więc Zachowaj buforu tak małej, jak to możliwe. Aby uniknąć przepełnienia buforu, należy użyć <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> powiadomienia o zmianie właściwości, aby odfiltrować niepożądane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ zmiany do obserwacji.</summary>
        <value>Jedną z <see cref="T:System.IO.NotifyFilters" /> wartości. Wartością domyślną jest bitową kombinacją OR <see langword="LastWrite" />, <see langword="FileName" />, i <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można połączyć elementów członkowskich <xref:System.IO.NotifyFilters> wyliczeniu, aby obejrzeć dla więcej niż jednego typu na raz. Na przykład możesz obserwować zmiany rozmiaru pliku i zmiany w `LastWrite` czasu. To zgłasza zdarzenie, w dowolnym momencie zmianę w rozmiarze pliku lub folderu lub zmiany w `LastWrite` czasu dla pliku lub folderu.  
  
 To jest jednym ze sposobów, aby odfiltrować niechciane powiadomienia. Aby uzyskać więcej informacji na temat filtrowania powiadomień niepożądane, zobacz <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, i <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obejrzeć katalogu określonego w czasie wykonywania. Składnik jest ustawiona na obserwowanie zmian w `LastWrite` i `LastAccess` czas tworzenia, usuwania, lub zmiana nazwy plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku drukuje do konsoli. Po zmianie nazwy pliku, ścieżki stare i nowe drukowanie do konsoli.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość nie jest prawidłową bitową kombinacją OR <see cref="T:System.IO.NotifyFilters" /> wartości.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Wartość, która jest ustawiona jest nieprawidłowa.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.IO.FileSystemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.IO.FileSystemWatcher.Changed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> jest wywoływana, gdy zostaną wprowadzone zmiany rozmiaru, atrybutów systemowych, czas ostatniego zapisu, czas ostatniego dostępu lub uprawnienia zabezpieczeń pliku lub katalogu w katalogu są monitorowane.  
  
 Użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> właściwości, aby ograniczyć liczbę zdarzeń wywołane, gdy <xref:System.IO.FileSystemWatcher.Changed> zdarzenie jest obsługiwane.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest wywoływane, gdy tylko zostanie utworzony plik. Jeśli plik jest kopiowane lub przenoszone do obserwowanych katalogu, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzenia zostaną podniesione natychmiast, następuje co najmniej jeden <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenia.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> metody.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.IO.FileSystemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.IO.FileSystemWatcher.Created" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> jest wywoływana, gdy plik lub katalog jest tworzony w katalogu, które są monitorowane.  
  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiadają bezpośrednio na zdarzenie, ale takie sytuacje powodować zdarzenia zgłoszenie. Podczas kopiowania pliku lub katalogu, to system zgłosi <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do której plik został skopiowany, jeśli jest obserwowany tego katalogu. Jeśli katalog, z którego został skopiowany został obserwowany przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiona na "C:\My Documents" Obejrzyj i FileSystemWatcher2 jest ustawiona na oglądanie "C:\Your dokumenty". Jeśli kopiowanie pliku "Moje dokumenty" i wklej go do "Your dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzenia zostaną podniesione w FileSystemWatcher2, ale nie zdarzenie jest wywoływane dla FileSystemWatcher1. W odróżnieniu od kopiowanie, przenoszenie pliku lub katalogu zgłasza dwa zdarzenia. W poprzednim przykładzie, jeśli plik został przeniesiony "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może być wywoływany w FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może być zgłaszany WE FileSystemWatcher1.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest wywoływane, gdy tylko zostanie utworzony plik. Jeśli plik jest kopiowane lub przenoszone do obserwowanych katalogu, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzenia zostaną podniesione natychmiast, następuje co najmniej jeden <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenia.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> metody.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.IO.FileSystemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.IO.FileSystemWatcher.Deleted" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> jest wywoływana, gdy plik lub katalog, w ramach katalogu monitorowane, zostanie usunięty.  
  
 Niektórych typowych zdarzeń, takich jak kopiowanie lub przenoszenie pliku lub katalogu, nie odpowiadają bezpośrednio na zdarzenie, ale takie sytuacje powodować zdarzenia zgłoszenie. Podczas kopiowania pliku lub katalogu, to system zgłosi <xref:System.IO.FileSystemWatcher.Created> zdarzeń w katalogu, do której plik został skopiowany, jeśli jest obserwowany tego katalogu. Jeśli katalog, z którego został skopiowany został obserwowany przez inne wystąpienie <xref:System.IO.FileSystemWatcher>, żadne zdarzenie będzie uruchamiany. Na przykład utworzyć dwa wystąpienia <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiona na "C:\My Documents" Obejrzyj i FileSystemWatcher2 jest ustawiona na oglądanie "C:\Your dokumenty". W przypadku kopiowania pliku z "Moje dokumenty" na "Your dokumenty" <xref:System.IO.FileSystemWatcher.Created> zdarzenia zostaną podniesione przez FileSystemWatcher2, ale nie zdarzenie jest wywoływane dla FileSystemWatcher1. W odróżnieniu od kopiowanie, przenoszenie pliku lub katalogu zgłasza dwa zdarzenia. W poprzednim przykładzie, jeśli plik został przeniesiony "Moje dokumenty" do "Your dokumentów" <xref:System.IO.FileSystemWatcher.Created> zdarzeń może zostać wywołane przez FileSystemWatcher2 i <xref:System.IO.FileSystemWatcher.Deleted> zdarzeń może zostać wywołane przez FileSystemWatcher1.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> metody.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.ErrorEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.IO.FileSystemWatcher.Error" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> jest wywoływana, gdy wystąpi błąd.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> metody.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.IO.RenamedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.IO.FileSystemWatcher.Renamed" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> jest wywoływana, gdy plik lub katalog w katalogu monitorowanych została zmieniona. Jego <xref:System.IO.RenamedEventArgs> argument zawiera informacje na temat operacji zmiany nazwy, takie jak typ zmian, ścieżka starych i nowych i starych i nowych nazw. Należy pamiętać, że jego <xref:System.IO.FileSystemEventArgs.Name> właściwość może mieć wartości null dla zmieniono jego nazwę zdarzenia, jeśli <xref:System.IO.FileSystemWatcher> uzyskać niezgodne starych i nowych nazw zdarzeń z systemu operacyjnego. 
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> metody.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę katalogu, aby obejrzeć.</summary>
        <value>Ścieżka do monitorowania. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to w pełni kwalifikowaną ścieżkę do katalogu. Jeśli <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> właściwość `true`, jest to katalog główny, w którym system oczekuje na zmiany; w przeciwnym razie jest to katalog tylko, którzy oglądali transmisje stacji. Aby obejrzeć określonego pliku, należy ustawić <xref:System.IO.FileSystemWatcher.Path%2A> właściwość, aby w pełni kwalifikowaną, prawidłowy katalog i <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku.  
  
 <xref:System.IO.FileSystemWatcher.Path%2A> Właściwość obsługuje ścieżki Universal Naming Convention (UNC).  
  
> [!NOTE]
>  Przed składnika można śledzić zmiany, należy ustawić tę właściwość.  
  
 Po zmianie nazwy katalogu <xref:System.IO.FileSystemWatcher> automatyczne ponowne dołączenie następuje ponowne się do nowo zmieniono nazwę elementu. Na przykład jeśli ustawisz <xref:System.IO.FileSystemWatcher.Path%2A> właściwość "C:\My dokumenty" i następnie ręcznie zmień nazwę katalogu "C:\Your dokumentów", składnik będzie nadal nasłuchuje powiadomień o zmianach na nowo zmieniono nazwę katalogu. Jednak jeśli poprosisz o <xref:System.IO.FileSystemWatcher.Path%2A> właściwości zawiera starej ścieżki. Dzieje się tak, ponieważ składnik określa, jakie katalogu obserwuje oparte na uchwyt, a nie nazwę katalogu. Zmiana nazwy nie wpływa na dojście. Zatem jeśli zniszczyć składnika, a następnie utwórz ją ponownie bez aktualizowania <xref:System.IO.FileSystemWatcher.Path%2A> właściwości, aplikacja ulegnie awarii, ponieważ katalog już istnieje.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obejrzeć katalogu określonego w czasie wykonywania. Składnik jest ustawiona na obserwowanie zmian w `LastWrite` i `LastAccess` czas tworzenia, usuwania, lub zmiana nazwy plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku drukuje do konsoli. Po zmianie nazwy pliku, ścieżki stare i nowe drukowanie do konsoli.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona ścieżka nie istnieje lub nie został odnaleziony.  
  
—lub— 
Określona ścieżka zawiera znaki symboli wieloznacznych.  
  
—lub— 
Określona ścieżka zawiera nieprawidłowe znaki ścieżki.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy plik lub katalog w określonym <see cref="P:System.IO.FileSystemWatcher.Path" /> została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed` Zdarzenie jest <xref:System.IO.RenamedEventHandler> delegata, która ma następujący podpis:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs> Obiektu zawiera informacje dotyczące operacji zmiany nazwy, takie jak typ zmiany nazwy ( <xref:System.IO.FileSystemEventArgs.ChangeType> właściwości), stara i Nowa nazwa i ścieżka stare i nowe. Należy pamiętać, że <xref:System.IO.FileSystemEventArgs.Name> właściwość może mieć wartości null dla zmieniono jego nazwę zdarzenia, jeśli <xref:System.IO.FileSystemWatcher> uzyskać niezgodne starych i nowych nazw zdarzeń z systemu operacyjnego.

 Zmiana nazwy katalogu, które oglądasz nie zgłosi powiadomienie. Powiadomienia są tylko wywoływane dla wpisów w katalogu, które oglądasz.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.IO.FileSystemWatcher.Renamed> zdarzenie, aby wyświetlić ścieżkę pliku do konsoli zawsze wtedy, gdy monitorowane pliku została zmieniona.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> dla <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> Dla <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązania witryny <xref:System.ComponentModel.Component> do <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> i umożliwić komunikację między nimi, a także umożliwiają kontener, aby zarządzać jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, utworzony w wyniku zmiany katalogu.</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Reprezentujący obiekt używany do organizowania wywołań obsługi zdarzeń, utworzony w wyniku zmiany katalogu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> jest `null`, metody obsługi <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia są wywoływane w wątku z puli wątków systemu. Aby uzyskać więcej informacji na temat pul wątków systemu, zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia są obsługiwane przez visual składnika Windows Forms, takie jak <xref:System.Windows.Forms.Button>, dostęp do składnika za pośrednictwem puli wątków systemu mogą nie działać, lub może spowodować wyjątek. Tego uniknąć, ustawiając <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> do składnika Windows Forms, co powoduje, że metody, które obsługują <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia, które ma być wywołane na tym samym wątku, na którym została utworzona składnika.  
  
 Jeśli <xref:System.IO.FileSystemWatcher> jest używana wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w Projektancie Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> automatycznie ustawia do formantu, który zawiera <xref:System.IO.FileSystemWatcher>. Na przykład jeśli umieścisz <xref:System.IO.FileSystemWatcher> w Projektancie formularza Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> właściwość <xref:System.IO.FileSystemWatcher> jest ustawiona na wystąpienie formularza Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Metodą synchroniczną, która zwraca strukturę, która zawiera szczegółowe informacje dotyczące zmian, który wystąpił.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType"><see cref="T:System.IO.WatcherChangeTypes" /> Do obserwacji.</param>
        <summary>Metoda synchroniczna, która zwraca strukturę, która zawiera szczegółowe informacje dotyczące zmian, które wystąpiły, biorąc pod uwagę typ zmiany, którą chcesz monitorować.</summary>
        <returns>Element <see cref="T:System.IO.WaitForChangedResult" /> zawierający szczegółowe informacje dotyczące zmian, który wystąpił.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda czeka, dopóki nie wystąpi pierwszej zmiany, a następnie zwraca. To jest taka sama, jak przy użyciu <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> z `timeout` parametru ustawioną wartość -1.  
  
> [!NOTE]
>  Ta metoda umożliwia program obsługi zdarzeń do wywołania na odpowiadanie na zmiany plików nawet wtedy, gdy <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> właściwość jest ustawiona na `false`.  
  
 W niektórych systemach <xref:System.IO.FileSystemWatcher> raportów zmiany do plików za pomocą krótki format nazwy pliku w formacie 8.3. Na przykład zmiana "LongFileName.LongExtension" mogą być raportowane jako "LongFi ~. Długa".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType"><see cref="T:System.IO.WatcherChangeTypes" /> Do obserwacji.</param>
        <param name="timeout">Czas (w milisekundach) oczekiwania przed przekroczeniem limitu czasu.</param>
        <summary>Metoda synchroniczna, która zwraca strukturę, która zawiera szczegółowe informacje dotyczące zmian, które wystąpiły, biorąc pod uwagę typ zmiany, który chcesz monitorować i czas (w milisekundach) oczekiwania przed przekroczeniem limitu czasu.</summary>
        <returns>Element <see cref="T:System.IO.WaitForChangedResult" /> zawierający szczegółowe informacje dotyczące zmian, który wystąpił.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda czeka, aż nastąpi zmiana lub został przekroczony. Wartość -1 dla `timeout` parametru oznacza czekanie w nieskończoność.  
  
> [!NOTE]
>  Ta metoda umożliwia program obsługi zdarzeń do wywołania na odpowiadanie na zmiany plików nawet wtedy, gdy <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> właściwość jest ustawiona na `false`.  
  
 W niektórych systemach <xref:System.IO.FileSystemWatcher> raportów zmiany do plików za pomocą krótki format nazwy pliku w formacie 8.3. Na przykład zmiana "LongFileName.LongExtension" mogą być raportowane jako "LongFi ~. Długa".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
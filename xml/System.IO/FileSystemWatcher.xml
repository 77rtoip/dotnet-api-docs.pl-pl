<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a0e57bcd8632ec302753a2471d27c2e55714b410" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541124" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Nasłuchuje powiadomień o zmianie systemu plików i zgłasza zdarzenia, gdy katalog lub plik w katalogu ulegnie zmianie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.IO.FileSystemWatcher> , aby obejrzeć zmiany w określonym katalogu. Możesz obejrzeć zmiany w plikach i podkatalogach określonego katalogu. Można utworzyć składnik do oglądania plików na komputerze lokalnym, dysku sieciowym lub komputerze zdalnym.  
  
 Aby obejrzeć zmiany we wszystkich plikach, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na pusty ciąg ("") lub użyć symboli wieloznacznych ("*.\*"). Aby obejrzeć określony plik, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku. Na przykład aby obejrzeć zmiany w pliku MyDoc. txt, ustaw <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na "MyDoc. txt". Możesz również obejrzeć zmiany w określonym typie pliku. Na przykład aby obejrzeć zmiany w plikach tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na "\*. txt".  
  
 Istnieje kilka typów zmian, które można obejrzeć w katalogu lub pliku. Na przykład można obejrzeć zmiany w `Attributes` `LastWrite` , dacie `Size` i godzinie lub plików lub katalogów. Jest to realizowane przez ustawienie <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> właściwości na jedną <xref:System.IO.NotifyFilters> z wartości. Aby uzyskać więcej informacji na temat typu zmian, które można obejrzeć, <xref:System.IO.NotifyFilters>Zobacz.  
  
 Można obejrzeć zmiany nazw, usuwania lub tworzenia plików lub katalogów. Na przykład aby obejrzeć zmiany nazwy plików tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na "*. txt" i <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> wywołać metodę z <xref:System.IO.WatcherChangeTypes.Renamed> określonym parametrem.  
  
 System operacyjny Windows powiadamia składnik o zmianach plików w buforze utworzonym przez <xref:System.IO.FileSystemWatcher>. Jeśli w krótkim czasie występuje wiele zmian, bufor może przepełnić. Powoduje to, że składnik utraci śledzenie zmian w katalogu i udostępnia tylko powiadomienia zbiorcze. Zwiększenie rozmiaru buforu z <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwością jest kosztowne, ponieważ pochodzi ona z niestronicowanej pamięci, która nie może zostać zamieniony na dysk, dlatego przechowuj bufor jako mały, który jest wystarczająco duży, aby nie trafiać żadnych zdarzeń zmiany pliku. Aby uniknąć przepełnienia buforu, użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> właściwości <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> i, aby można było odfiltrować niechciane powiadomienia o zmianach.  
  
 Aby uzyskać listę początkowych wartości właściwości dla wystąpienia <xref:System.IO.FileSystemWatcher>, <xref:System.IO.FileSystemWatcher.%23ctor%2A> Zobacz Konstruktor.  
  
 Podczas używania <xref:System.IO.FileSystemWatcher> klasy należy zwrócić uwagę na następujące kwestie.  
  
-   Ukryte pliki nie są ignorowane.  
  
-   W niektórych systemach program <xref:System.IO.FileSystemWatcher> raportuje zmiany w plikach przy użyciu krótkiego formatu nazwy pliku 8,3. Na przykład zmiana "LongFileName. LongExtension" może być raportowana jako "LongFil ~. Długość ".  
  
-   Ta klasa zawiera żądanie łącza i dziedziczenia na poziomie klasy stosowane do wszystkich składowych. Występuje <xref:System.Security.SecurityException> , gdy bezpośredni obiekt wywołujący lub Klasa pochodna nie ma uprawnienia pełnego zaufania. Aby uzyskać szczegółowe informacje o wymaganiach dotyczących zabezpieczeń, zobacz [wymagania dotyczące linków](~/docs/framework/misc/link-demands.md).  
  
-   Maksymalny rozmiar, jaki można ustawić dla <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości monitorowania katalogu za pośrednictwem sieci, to 64 KB.  
  
> [!NOTE]
>  Uruchamianie <xref:System.IO.FileSystemWatcher> w systemie Windows 98 nie jest obsługiwane.  
  
## <a name="copying-and-moving-folders"></a>Kopiowanie i przenoszenie folderów  
 System operacyjny i <xref:System.IO.FileSystemWatcher> obiekt interpretują akcję wycinania i wklejania albo akcję Przenieś jako akcję zmiany nazwy dla folderu i jego zawartości. Jeśli wytniesz i wkleisz folder z plikami w monitorowanym folderze, obiekt będzie <xref:System.IO.FileSystemWatcher> zgłaszać tylko folder jako nowy, ale nie jego zawartość, ponieważ zasadniczo zmieniono jego nazwę.  
  
 Aby otrzymywać powiadomienia o przeniesieniu lub skopiowaniu zawartości folderów do monitorowanego folderu, określ <xref:System.IO.FileSystemWatcher.OnChanged%2A> metody obsługi zdarzeń i <xref:System.IO.FileSystemWatcher.OnRenamed%2A> Zaproponuj je w poniższej tabeli.  
  
|Procedura obsługi zdarzeń|Zdarzenia obsłużone|Wykonywany|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Raportuj zmiany w atrybutach plików, utworzonych plikach i usuniętych plikach.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Wyświetl listę starych i nowych ścieżek plików i folderów, które zostały zmienione, w razie konieczności rozwinięcie rekursywnie.|  
  
## <a name="events-and-buffer-sizes"></a>Zdarzenia i rozmiary buforów  
 Należy zauważyć, że niektóre czynniki mogą wpłynąć na to, które zdarzenia zmiany systemu plików są wywoływane, zgodnie z opisem w następujących tematach:  
  
-   Typowe operacje systemu plików mogą spowodować wystąpienie więcej niż jednego zdarzenia. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, mogą <xref:System.IO.FileSystemWatcher.OnChanged%2A> zostać zgłoszone <xref:System.IO.FileSystemWatcher.OnDeleted%2A> kilka <xref:System.IO.FileSystemWatcher.OnCreated%2A> i zdarzenia. Przeniesienie pliku jest skomplikowaną operacją, która składa się z wielu prostych operacji, a tym samym wywołuje wiele zdarzeń. Podobnie niektóre aplikacje (na przykład oprogramowanie antywirusowe) mogą spowodować dodatkowe zdarzenia systemu plików, które są wykrywane przez <xref:System.IO.FileSystemWatcher>program.  
  
-   <xref:System.IO.FileSystemWatcher> Może obserwować dyski, o ile nie zostały one przełączone ani usunięte. Program <xref:System.IO.FileSystemWatcher> nie zgłasza zdarzeń dotyczących dysków CD i DVD, ponieważ nie można zmienić sygnatur czasowych i właściwości. Aby składnik działał prawidłowo, komputery zdalne muszą mieć zainstalowane jedną z wymaganych platform.  
  
-   Jeśli wiele <xref:System.IO.FileSystemWatcher> obiektów ogląda tę samą ścieżkę UNC w systemie Windows XP przed dodatkiem Service Pack 1 lub Windows 2000 z dodatkiem SP2 lub starszym, tylko jeden z obiektów zwróci zdarzenie. Na komputerach z systemem Windows XP z dodatkiem SP1 lub nowszym, Windows 2000 z dodatkiem SP3 lub <xref:System.IO.FileSystemWatcher> nowszym lub Windows Server 2003 wszystkie obiekty zostaną podniesione odpowiednie zdarzenia.  
  
 Należy zauważyć, <xref:System.IO.FileSystemWatcher> że w przypadku przekroczenia rozmiaru buforu może wystąpić pominięcie zdarzenia. Aby uniknąć brakujących zdarzeń, postępuj zgodnie z następującymi wskazówkami:  
  
-   Zwiększ rozmiar buforu przez ustawienie <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości.  
  
-   Unikaj oglądania plików o długich nazwach plików, ponieważ długa nazwa pliku przyczynia się do wypełniania buforu. Rozważ zmianę nazwy tych plików przy użyciu krótszych nazw.  
  
-   Przechowuj kod obsługi zdarzeń jak najkrótszy, jak to możliwe.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> , aby obejrzeć katalog określony w czasie wykonywania. Składnik jest ustawiony do śledzenia zmian w `LastWrite` `LastAccess` czasie, tworzenia, usuwania lub zmieniania nazw plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku zostanie wydrukowana do konsoli programu. Po zmianie nazwy pliku stare i nowe ścieżki są drukowane do konsoli programu.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">do wyprowadzania z <see cref="T:System.Diagnostics.ProcessStartInfo" /> klasy. Wartość żądania: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Nazwane zestawy uprawnień: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Używanie składnika FileSystemWatcher w formularzu systemu Windows</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.FileSystemWatcher" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można obejrzeć komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można obejrzeć zdalnego komputera z systemem Windows NT 4,0 z komputera z systemem Windows NT 4,0.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.IO.FileSystemWatcher>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|bitowe lub kombinacje `LastWrite`, `FileName`i`DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Obejrzyj wszystkie pliki).|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|pusty ciąg ("")|  
  
> [!NOTE]
>  Składnik nie będzie oglądać określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> nie jest ustawiony, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> obiekt, aby obejrzeć katalog określony w czasie wykonywania. Obiekt czuje się pod kątem `LastWrite` zmian `LastAccess` w czasie i w przypadku tworzenia, usuwania lub zmiany nazwy plików tekstowych w katalogu. <xref:System.IO.FileSystemWatcher> Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku będzie wyświetlana w konsoli programu. Po zmianie nazwy pliku stare i nowe ścieżki są wyświetlane w konsoli programu.  
  
 W tym przykładzie są <xref:System.Diagnostics> stosowane <xref:System.IO> przestrzenie nazw i.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do monitorowania w notacji standardowej lub Universal Naming Convention (UNC).</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileSystemWatcher" /> klasy, używając określonego katalogu do monitorowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Składnik nie będzie oglądać określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> nie jest ustawiony, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Składnik może oglądać pliki na komputerze osobistym, dysku sieciowym lub komputerze zdalnym.  
  
 Nie można obejrzeć komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można obejrzeć zdalnego komputera z systemem Windows NT 4,0 z komputera z systemem Windows NT 4,0. <xref:System.IO.FileSystemWatcher.Filter%2A> Właściwość jest domyślnie ustawiona na oglądanie wszystkich plików.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
Ścieżka określona za pomocą <paramref name="path" /> parametru nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />jest zbyt długi.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Katalog do monitorowania w notacji standardowej lub Universal Naming Convention (UNC).</param>
        <param name="filter">Typ plików do monitorowania. Na przykład "*. txt" obserwuje zmiany we wszystkich plikach tekstowych.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.IO.FileSystemWatcher" /> klasy, uwzględniając określony katalog i typ plików do monitorowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Składnik nie będzie oglądać określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> nie jest ustawiony, i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Składnik może oglądać pliki na komputerze osobistym, dysku sieciowym lub komputerze zdalnym.  
  
 Nie można obejrzeć komputera zdalnego, który nie ma systemu Windows NT lub Windows 2000. Nie można obejrzeć zdalnego komputera z systemem Windows NT 4,0 z komputera z systemem Windows NT 4,0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="path" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="filter" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr jest pustym ciągiem ("").  
  
—lub— 
Ścieżka określona za pomocą <paramref name="path" /> parametru nie istnieje.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" />jest zbyt długi.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjalizację <see cref="T:System.IO.FileSystemWatcher" /> użytą w formularzu lub używaną przez inny składnik. Inicjalizacja występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] projektowe używa tej metody do uruchamiania inicjowania składnika używanego w formularzu lub używanego przez inny składnik. <xref:System.IO.FileSystemWatcher.EndInit%2A> Metoda przerywa inicjalizację. Użycie metod <xref:System.IO.FileSystemWatcher.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.IO.FileSystemWatcher.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostanie zmieniony plik lub katalog w <see cref="P:System.IO.FileSystemWatcher.Path" /> określonym pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed> Zdarzenie jest zgłaszane w przypadku zmiany rozmiaru, atrybutów systemowych, czasu ostatniego zapisu, czasu ostatniego dostępu lub uprawnień zabezpieczeń pliku lub katalogu w monitorowanym katalogu.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą spowodować wystąpienie więcej niż jednego zdarzenia. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, mogą <xref:System.IO.FileSystemWatcher.OnChanged%2A> zostać zgłoszone <xref:System.IO.FileSystemWatcher.OnDeleted%2A> kilka <xref:System.IO.FileSystemWatcher.OnCreated%2A> i zdarzenia. Przeniesienie pliku jest skomplikowaną operacją, która składa się z wielu prostych operacji, a tym samym wywołuje wiele zdarzeń. Podobnie niektóre aplikacje (na przykład oprogramowanie antywirusowe) mogą spowodować dodatkowe zdarzenia systemu plików, które są wykrywane przez <xref:System.IO.FileSystemWatcher>program.  
  
 Użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> , aby ograniczyć liczbę powiadomień wyzwalanych w przypadku obsługi tego zdarzenia.  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed> Zdarzenie jest nieoczekiwane zgłoszone w przypadku zmiany nazwy pliku, ale nie jest zgłaszane w przypadku zmiany nazwy katalogu. Aby obejrzeć zmianę nazwy, użyj <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia.  
  
> [!NOTE]
>  Kolejność, w <xref:System.IO.FileSystemWatcher.Changed> której zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> zdarzeń, może ulec zmianie, gdy właściwość `null`nie jest.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.IO.FileSystemWatcher.Changed> zdarzenia do wyświetlania ścieżki pliku do konsoli za każdym razem, gdy plik obserwowany zostanie zmieniony.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy tworzony jest plik lub katalog w <see cref="P:System.IO.FileSystemWatcher.Path" /> określonym pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre typowe wystąpienia, takie jak kopiowanie lub przeniesienie pliku lub katalogu, nie są bezpośrednio powiązane ze zdarzeniem, ale te wystąpienia powodują podniesienie poziomu zdarzeń. Podczas kopiowania pliku lub katalogu system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzenie w katalogu, do którego plik został skopiowany, jeśli ten katalog jest monitorowany. Jeśli katalog <xref:System.IO.FileSystemWatcher>, z którego została skopiowana była obserwowana przez inne wystąpienie, nie zostanie zgłoszone żadne zdarzenie. Można na przykład utworzyć dwa wystąpienia programu <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiony na Obejrzyj "C:\Moje dokumenty", a FileSystemWatcher2 jest ustawiony na Obejrzyj "C:\Your dokumenty". Jeśli skopiujesz plik z folderu "Moje dokumenty" do folderu "dokumenty", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie zgłoszone przez FileSystemWatcher2, ale żadne zdarzenie nie zostanie zgłoszone dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przeniesienie pliku lub katalogu spowodowałoby wystąpienie dwóch zdarzeń. W poprzednim przykładzie, jeśli przeniesiono plik z lokalizacji "Moje dokumenty" do "dokumentów", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie wywołane przez FileSystemWatcher2 <xref:System.IO.FileSystemWatcher.Deleted> , a zdarzenie zostanie wywołane przez FileSystemWatcher1.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą spowodować wystąpienie więcej niż jednego zdarzenia. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, mogą <xref:System.IO.FileSystemWatcher.OnChanged%2A> zostać zgłoszone <xref:System.IO.FileSystemWatcher.OnDeleted%2A> kilka <xref:System.IO.FileSystemWatcher.OnCreated%2A> i zdarzenia. Przeniesienie pliku jest skomplikowaną operacją, która składa się z wielu prostych operacji, a tym samym wywołuje wiele zdarzeń. Podobnie niektóre aplikacje (na przykład oprogramowanie antywirusowe) mogą spowodować dodatkowe zdarzenia systemu plików, które są wykrywane przez <xref:System.IO.FileSystemWatcher>program.  
  
> [!NOTE]
>  Kolejność, w <xref:System.IO.FileSystemWatcher.Created> której zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> zdarzeń, może ulec zmianie, gdy właściwość `null`nie jest.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest zgłaszane zaraz po utworzeniu pliku. Jeśli plik jest kopiowany lub transferowany do monitorowanego katalogu, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzenie zostanie wywołane natychmiast, po którym następuje co najmniej jedno <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.IO.FileSystemWatcher.Created> zdarzenia, aby wyświetlić ścieżkę pliku do konsoli za każdym razem, gdy zostanie utworzony obserwowany plik.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostanie usunięty plik lub katalog z <see cref="P:System.IO.FileSystemWatcher.Path" /> określonego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre typowe wystąpienia, takie jak kopiowanie lub przeniesienie pliku lub katalogu, nie są bezpośrednio powiązane ze zdarzeniem, ale te wystąpienia powodują podniesienie poziomu zdarzeń. Podczas kopiowania pliku lub katalogu system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzenie w katalogu, do którego plik został skopiowany, jeśli ten katalog jest monitorowany. Jeśli katalog <xref:System.IO.FileSystemWatcher>, z którego została skopiowana była obserwowana przez inne wystąpienie, nie zostanie zgłoszone żadne zdarzenie. Można na przykład utworzyć dwa wystąpienia programu <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiony na Obejrzyj "C:\Moje dokumenty", a FileSystemWatcher2 jest ustawiony na Obejrzyj "C:\Your dokumenty". Jeśli skopiujesz plik z folderu "Moje dokumenty" do folderu "dokumenty", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie zgłoszone przez FileSystemWatcher2, ale żadne zdarzenie nie zostanie zgłoszone dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przeniesienie pliku lub katalogu spowodowałoby wystąpienie dwóch zdarzeń. W poprzednim przykładzie, jeśli przeniesiono plik z lokalizacji "Moje dokumenty" do "dokumentów", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie wywołane przez FileSystemWatcher2 <xref:System.IO.FileSystemWatcher.Deleted> , a zdarzenie zostanie wywołane przez FileSystemWatcher1.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą spowodować wystąpienie więcej niż jednego zdarzenia. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, mogą <xref:System.IO.FileSystemWatcher.OnChanged%2A> zostać zgłoszone <xref:System.IO.FileSystemWatcher.OnDeleted%2A> kilka <xref:System.IO.FileSystemWatcher.OnCreated%2A> i zdarzenia. Przeniesienie pliku jest skomplikowaną operacją, która składa się z wielu prostych operacji, a tym samym wywołuje wiele zdarzeń. Podobnie niektóre aplikacje (na przykład oprogramowanie antywirusowe) mogą spowodować dodatkowe zdarzenia systemu plików, które są wykrywane przez <xref:System.IO.FileSystemWatcher>program.  
  
> [!NOTE]
>  Kolejność, w <xref:System.IO.FileSystemWatcher.Deleted> której zdarzenie jest zgłaszane w odniesieniu do innych <xref:System.IO.FileSystemWatcher> <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> zdarzeń, może ulec zmianie, gdy właściwość `null`nie jest.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.IO.FileSystemWatcher.Deleted> zdarzenia do wyświetlania ścieżki pliku do konsoli za każdym razem, gdy plik obserwowany zostanie usunięty.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.FileSystemWatcher" />program.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.FileSystemWatcher" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę. <xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.FileSystemWatcher.Dispose%2A> `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.FileSystemWatcher.Dispose%2A> `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.IO.Compression.DeflateStream> których odwołują się te odwołania. `disposing` Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see cref="M:System.ComponentModel.Component.Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see cref="M:System.ComponentModel.Component.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy składnik jest włączony.</summary>
        <value><see langword="true" />Jeśli składnik jest włączony; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />. Jeśli używasz składnika w projektancie w programie [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], wartość domyślna to. <see langword="true" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnik nie będzie zgłaszać zdarzeń, chyba że <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ustawisz wartość `true`.  
  
> [!NOTE]
>  Składnik nie będzie oglądać określonego katalogu, dopóki <xref:System.IO.FileSystemWatcher.Path%2A> właściwość nie zostanie ustawiona i <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> jest `true`.  
  
 Metoda umożliwia wywoływanie programów obsługi zdarzeń w celu reagowania na zmiany plików, nawet jeśli ta właściwość jest ustawiona `false`na. <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> , aby obejrzeć katalog określony w czasie wykonywania. Składnik jest ustawiony do śledzenia zmian w `LastWrite` `LastAccess` czasie, tworzenia, usuwania lub zmieniania nazw plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku zostanie wydrukowana do konsoli programu. Po zmianie nazwy pliku stare i nowe ścieżki są drukowane do konsoli programu.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.IO.FileSystemWatcher" /> Obiekt został usunięty.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Bieżący system operacyjny nie jest systemem Microsoft Windows NT lub nowszym.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można znaleźć katalogu <see cref="P:System.IO.FileSystemWatcher.Path" /> określonego w elemencie.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" />nie został ustawiony lub jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka inicjalizację <see cref="T:System.IO.FileSystemWatcher" /> użytą w formularzu lub używaną przez inny składnik. Inicjalizacja występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] projektowe używa tej metody do zakończenia inicjowania składnika używanego w formularzu lub używanego przez inny składnik. <xref:System.IO.FileSystemWatcher.BeginInit%2A> Metoda uruchamia inicjalizację. Użycie metod <xref:System.IO.FileSystemWatcher.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.IO.FileSystemWatcher.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wystąpienie programu <see cref="T:System.IO.FileSystemWatcher" /> nie może kontynuować monitorowania zmian lub przepełnienie buforu wewnętrznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane za każdym razem, <xref:System.IO.FileSystemWatcher> gdy jakiś obiekt nie będzie monitorował zmian. Na przykład jeśli obiekt monitoruje zmiany w katalogu zdalnym i połączenie z tym katalogiem zostanie utracone, <xref:System.IO.FileSystemWatcher.Error> zdarzenie jest zgłaszane.  
  
 System powiadamia o zmianach w pliku i przechowuje te zmiany w buforze, który składnik tworzy i przekazuje do interfejsów API. Jeśli w krótkim czasie występuje wiele zmian, bufor może przepełnić. Powoduje to, że składnik utraci śledzenie zmian w katalogu i udostępnia tylko powiadomienia zbiorcze. Zwiększenie rozmiaru buforu jest kosztowne, ponieważ pochodzi on z niestronicowanej pamięci, która nie może zostać zamieniony na dysk, dlatego przechowuj bufor możliwie jak najmniejszy. Aby uniknąć przepełnienia buforu, użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>właściwości <xref:System.IO.FileSystemWatcher.Filter%2A>, i <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> , aby odfiltrować niechciane powiadomienia o zmianach.  
  
> [!NOTE]
>  Typowe operacje systemu plików mogą spowodować wystąpienie więcej niż jednego zdarzenia. Na przykład, gdy plik jest przenoszony z jednego katalogu do innego, mogą <xref:System.IO.FileSystemWatcher.OnChanged%2A> zostać zgłoszone <xref:System.IO.FileSystemWatcher.OnDeleted%2A> kilka <xref:System.IO.FileSystemWatcher.OnCreated%2A> i zdarzenia. Przeniesienie pliku jest skomplikowaną operacją, która składa się z wielu prostych operacji, a tym samym wywołuje wiele zdarzeń. Podobnie niektóre aplikacje (na przykład oprogramowanie antywirusowe) mogą spowodować dodatkowe zdarzenia systemu plików, które są wykrywane przez <xref:System.IO.FileSystemWatcher>program.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg filtru używany do określania, które pliki są monitorowane w katalogu.</summary>
        <value>Ciąg filtru. Wartość domyślna to "*. \*"(Zegarki wszystkie pliki).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obejrzeć zmiany we wszystkich plikach, ustaw <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na pusty ciąg (""). Aby obejrzeć określony plik, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na nazwę pliku. Na przykład aby obejrzeć zmiany w pliku MyDoc. txt, ustaw <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na "MyDoc. txt". Możesz również obejrzeć zmiany w określonym typie pliku. Na przykład aby obejrzeć zmiany w plikach tekstowych, należy ustawić <xref:System.IO.FileSystemWatcher.Filter%2A> właściwość na "*. txt". Użycie wielu filtrów, takich jak "\*. txt&#124;\*. doc", nie jest obsługiwane.  
  
 Właściwość można zmienić po rozpoczęciu <xref:System.IO.FileSystemWatcher> wysyłania zdarzeń przez obiekt. <xref:System.IO.FileSystemWatcher.Filter%2A>  
  
 Aby uzyskać więcej informacji na temat filtrowania niechcianych powiadomień, <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>zobacz <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>właściwości, <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> i.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>akceptuje symbole wieloznaczne dla pasujących plików, jak pokazano w poniższych przykładach.  
  
|Ciąg filtru|Obserwuje następujące pliki|  
|-------------------|---------------------------------|  
|*.\*|Wszystkie pliki (domyślnie). Pusty ciąg ("") również obserwuje wszystkie pliki.|  
|*. txt|Wszystkie pliki z rozszerzeniem "txt".|  
|* przepis. doc|Wszystkie pliki kończące się na "przepisach" z rozszerzeniem "doc".|  
|win*.xml|Wszystkie pliki zaczynające się od "win" z rozszerzeniem "XML".|  
|Sprzedaż * 200?. xls|Pasuje do następujących:<br /><br />— Sprzedaż w lipcu 2001 r. xls <br/>— Sales sie 2002. xls <br/>— Sprzedaż w marcu 2004 r. xls<br /><br /> ale nie pasuje:<br /><br />– Sales lis 1999. xls|  
|MyReport.Doc|Obserwuje tylko raport. doc|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> , aby obejrzeć katalog określony w czasie wykonywania. Składnik jest ustawiony do śledzenia zmian w `LastWrite` `LastAccess` czasie, tworzenia, usuwania lub zmieniania nazw plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku zostanie wydrukowana do konsoli programu. Po zmianie nazwy pliku stare i nowe ścieżki są drukowane do konsoli programu.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich filtrów używanych do określania, które pliki są monitorowane w katalogu.</summary>
        <value>Kolekcja filtrów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby blokowane przez bieżące wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> Metoda nie jest wywoływana przez kod aplikacji, ale automatycznie podczas wyrzucania elementów bezużytecznych, chyba że moduł wyrzucania elementów bezużytecznych wyłączył finalizację. Aby uzyskać więcej informacji, zobacz <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> i <xref:System.Object.Finalize>. Ta metoda przesłania <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy podkatalogi w określonej ścieżce mają być monitorowane.</summary>
        <value><see langword="true" />Jeśli chcesz monitorować Podkatalogi; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> <xref:System.IO.FileSystemWatcher.Path%2A> na `true` , gdy chcesz oglądać powiadomienia o zmianach dotyczące plików i katalogów zawartych w katalogu określonym za pomocą właściwości, a jego podkatalogach. Ustawienie właściwości, aby `false` pomóc w zmniejszeniu liczby powiadomień wysyłanych do bufora wewnętrznego. <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Aby uzyskać więcej informacji na temat filtrowania niechcianych powiadomień, <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> zobacz <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwości i.  
  
 Gdy `true` ,<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> jest cykliczny za pomocą całego poddrzewa, a nie tylko bezpośrednich katalogów podrzędnych. <xref:System.IO.FileSystemEventArgs.Name%2A> Ścieżka względna do pliku lub katalogu w poddrzewie zwraca <xref:System.IO.FileSystemEventArgs> Właściwość i <xref:System.IO.RenamedEventArgs.OldName%2A> Właściwość <xref:System.IO.RenamedEventArgs>, w zależności od zmian, które są obserwowane. W zależności od zmian, które <xref:System.IO.FileSystemEventArgs.FullPath%2A> są obserwowane <xref:System.IO.RenamedEventArgs>, można uzyskać <xref:System.IO.FileSystemEventArgs> w pełni <xref:System.IO.RenamedEventArgs.OldFullPath%2A> kwalifikowaną ścieżkę z właściwości i właściwości.  
  
 Jeśli katalog zostanie utworzony w poddrzewie katalogu, który jest oglądany, a <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> to `true`katalog zostanie automatycznie wyświetlony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar (w bajtach) bufora wewnętrznego.</summary>
        <value>Wewnętrzny rozmiar buforu w bajtach. Wartość domyślna to 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bufor może być ustawiony na 4 KB lub większy, ale nie może przekraczać 64 KB. Jeśli spróbujesz ustawić <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> właściwość na mniejszą niż 4096 bajtów, wartość zostanie odrzucona, <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> a właściwość zostanie ustawiona na 4096 bajtów. Aby uzyskać najlepszą wydajność, należy użyć wielokrotności 4 KB na komputerach opartych na procesorze Intel.  
  
 System powiadamia składnik o zmianach plików i przechowuje te zmiany w buforze, który składnik tworzy i przekazuje do interfejsów API. Każde zdarzenie może korzystać z maksymalnie 16 bajtów pamięci, bez uwzględniania nazwy pliku. Jeśli w krótkim czasie występuje wiele zmian, bufor może przepełnić. Powoduje to, że składnik utraci śledzenie zmian w katalogu i udostępnia tylko powiadomienia zbiorcze. Zwiększenie rozmiaru buforu może uniemożliwić brakujące zdarzenia zmiany systemu plików. Jednak zwiększenie rozmiaru buforu jest kosztowne, ponieważ pochodzi z niestronicowanej pamięci, która nie może zostać zamieniony na dysk, dlatego przechowuj bufor jak najmniejszej ilości. Aby uniknąć przepełnienia buforu, użyj <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> właściwości <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> i, aby odfiltrować niechciane powiadomienia o zmianach.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ zmian, które mają być obserwowane.</summary>
        <value>Jedna z <see cref="T:System.IO.NotifyFilters" /> wartości. Wartość domyślna to wartość bitowa lub kombinacja wartości <see langword="LastWrite" />, <see langword="FileName" />, i <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz połączyć elementy członkowskie <xref:System.IO.NotifyFilters> wyliczenia, aby obejrzeć więcej niż jeden typ zmiany jednocześnie. Na przykład można obejrzeć zmiany rozmiaru pliku oraz zmiany w `LastWrite` czasie. Powoduje to zdarzenie w dowolnym momencie zmiany rozmiaru pliku lub folderu lub zmiany `LastWrite` czasu pliku lub folderu.  
  
 Jest to jeden ze sposobów odfiltrowania niechcianych powiadomień. Aby uzyskać więcej informacji na temat filtrowania niechcianych powiadomień, <xref:System.IO.FileSystemWatcher.Filter%2A>zobacz <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>właściwości, <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> i.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> , aby obejrzeć katalog określony w czasie wykonywania. Składnik jest ustawiony do śledzenia zmian w `LastWrite` `LastAccess` czasie, tworzenia, usuwania lub zmieniania nazw plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku zostanie wydrukowana do konsoli programu. Po zmianie nazwy pliku stare i nowe ścieżki są drukowane do konsoli programu.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość nie jest prawidłową wartością bitową lub kombinacją <see cref="T:System.IO.NotifyFilters" /> wartości.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Wartość, która jest ustawiana, jest nieprawidłowa.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Changed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A>jest wywoływana, gdy wprowadzane są zmiany rozmiaru, atrybuty systemu, czas ostatniego zapisu, czas ostatniego dostępu lub uprawnienia zabezpieczeń pliku lub katalogu w monitorowanym katalogu.  
  
 Użyj właściwości <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> , aby ograniczyć liczbę zdarzeń wywoływanych, <xref:System.IO.FileSystemWatcher.Changed> gdy zdarzenie jest obsługiwane.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest zgłaszane zaraz po utworzeniu pliku. Jeśli plik jest kopiowany lub transferowany do monitorowanego katalogu, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzenie zostanie wywołane natychmiast, po którym następuje co najmniej jedno <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenie.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Created" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>jest wywoływana, gdy plik lub katalog jest tworzony w monitorowanym katalogu.  
  
 Niektóre typowe wystąpienia, takie jak kopiowanie lub przeniesienie pliku lub katalogu, nie są bezpośrednio powiązane ze zdarzeniem, ale te wystąpienia powodują podniesienie poziomu zdarzeń. Podczas kopiowania pliku lub katalogu system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzenie w katalogu, do którego plik został skopiowany, jeśli ten katalog jest monitorowany. Jeśli katalog <xref:System.IO.FileSystemWatcher>, z którego została skopiowana była obserwowana przez inne wystąpienie, nie zostanie zgłoszone żadne zdarzenie. Można na przykład utworzyć dwa wystąpienia programu <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiony na Obejrzyj "C:\Moje dokumenty", a FileSystemWatcher2 jest ustawiony na Obejrzyj "C:\Your dokumenty". Jeśli skopiujesz plik z lokalizacji "Moje dokumenty" i wkleisz go do "dokumentów", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie zgłoszone w FileSystemWatcher2, ale żadne zdarzenie nie zostanie zgłoszone dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przeniesienie pliku lub katalogu wywołuje dwa zdarzenia. W poprzednim przykładzie, jeśli przeniesiono plik z lokalizacji "Moje dokumenty" do "dokumentów", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie zgłoszone w FileSystemWatcher2, <xref:System.IO.FileSystemWatcher.Deleted> a zdarzenie zostanie wywołane w FileSystemWatcher1.  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> Zdarzenie jest zgłaszane zaraz po utworzeniu pliku. Jeśli plik jest kopiowany lub transferowany do monitorowanego katalogu, <xref:System.IO.FileSystemWatcher.OnCreated%2A> zdarzenie zostanie wywołane natychmiast, po którym następuje co najmniej jedno <xref:System.IO.FileSystemWatcher.OnChanged%2A> zdarzenie.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Deleted" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A>jest wywoływana, gdy plik lub katalog znajdujący się w monitorowanym katalogu jest usuwany.  
  
 Niektóre typowe wystąpienia, takie jak kopiowanie lub przeniesienie pliku lub katalogu, nie są bezpośrednio powiązane ze zdarzeniem, ale te wystąpienia powodują podniesienie poziomu zdarzeń. Podczas kopiowania pliku lub katalogu system zgłasza <xref:System.IO.FileSystemWatcher.Created> zdarzenie w katalogu, do którego plik został skopiowany, jeśli ten katalog jest monitorowany. Jeśli katalog <xref:System.IO.FileSystemWatcher>, z którego została skopiowana była obserwowana przez inne wystąpienie, nie zostanie zgłoszone żadne zdarzenie. Można na przykład utworzyć dwa wystąpienia programu <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 jest ustawiony na Obejrzyj "C:\Moje dokumenty", a FileSystemWatcher2 jest ustawiony na Obejrzyj "C:\Your dokumenty". Jeśli skopiujesz plik z folderu "Moje dokumenty" do folderu "dokumenty", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie zgłoszone przez FileSystemWatcher2, ale żadne zdarzenie nie zostanie zgłoszone dla FileSystemWatcher1. W przeciwieństwie do kopiowania, przeniesienie pliku lub katalogu wywołuje dwa zdarzenia. W poprzednim przykładzie, jeśli przeniesiono plik z lokalizacji "Moje dokumenty" do "dokumentów", <xref:System.IO.FileSystemWatcher.Created> zdarzenie zostanie wywołane przez FileSystemWatcher2 <xref:System.IO.FileSystemWatcher.Deleted> , a zdarzenie zostanie wywołane przez FileSystemWatcher1.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.ErrorEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Error" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A>jest wywoływana, gdy wystąpi błąd.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.RenamedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.IO.FileSystemWatcher.Renamed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A>jest wywoływana, gdy zostanie zmieniona nazwa pliku lub katalogu w monitorowanym katalogu. Jego <xref:System.IO.RenamedEventArgs> argument zawiera informacje o operacji zmiany nazwy, takie jak typ zmiany, stara i Nowa ścieżka oraz stara i Nowa nazwa. Należy pamiętać, <xref:System.IO.FileSystemEventArgs.Name> że jej właściwość może mieć wartość null dla zdarzeń <xref:System.IO.FileSystemWatcher> o zmienionej nazwie, jeśli nie można uzyskać pasujących starych i nowych zdarzeń nazw z systemu operacyjnego. 
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę katalogu do obserwowania.</summary>
        <value>Ścieżka do monitorowania. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to w pełni kwalifikowana ścieżka do katalogu. Jeśli właściwość jest `true`, katalog jest katalogiem głównym, w którym system obserwuje zmiany; w przeciwnym razie jest to jedyny katalog obserwowany. <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Aby obejrzeć określony plik, należy ustawić <xref:System.IO.FileSystemWatcher.Path%2A> właściwość w pełni kwalifikowany, prawidłowy katalog <xref:System.IO.FileSystemWatcher.Filter%2A> i właściwość na nazwę pliku.  
  
 <xref:System.IO.FileSystemWatcher.Path%2A> Właściwość obsługuje ścieżki Universal Naming Convention (UNC).  
  
> [!NOTE]
>  Aby składnik mógł obejrzeć zmiany, należy ustawić tę właściwość.  
  
 Po zmianie nazwy <xref:System.IO.FileSystemWatcher> katalogu automatycznie dołącza się do nowo zmienionego elementu. Jeśli na przykład ustawisz <xref:System.IO.FileSystemWatcher.Path%2A> właściwość na "c:\Moje dokumenty", a następnie ręcznie zmienisz nazwę katalogu na "dokumenty C:\Your", składnik nadal nasłuchuje powiadomień o zmianach w katalogu nowo zmienionej nazwy. Jednak po poproszeniu <xref:System.IO.FileSystemWatcher.Path%2A> o Właściwość zawiera starą ścieżkę. Dzieje się tak, ponieważ składnik określa, który katalog jest obsługiwany na podstawie uchwytu, a nie nazwę katalogu. Zmiana nazwy nie ma wpływu na dojście. Dlatego jeśli niszczysz składnik, a następnie utworzysz go ponownie bez aktualizowania <xref:System.IO.FileSystemWatcher.Path%2A> właściwości, aplikacja zakończy się niepowodzeniem, ponieważ katalog już nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileSystemWatcher> , aby obejrzeć katalog określony w czasie wykonywania. Składnik jest ustawiony do śledzenia zmian w `LastWrite` `LastAccess` czasie, tworzenia, usuwania lub zmieniania nazw plików tekstowych w katalogu. Jeśli plik zostanie zmieniony, utworzony lub usunięty, ścieżka do pliku zostanie wydrukowana do konsoli programu. Po zmianie nazwy pliku stare i nowe ścieżki są drukowane do konsoli programu.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona ścieżka nie istnieje lub nie można jej znaleźć.  
  
 —lub—  
  
 Określona ścieżka zawiera symbole wieloznaczne.  
  
 —lub—  
  
 Określona ścieżka zawiera nieprawidłowe znaki ścieżki.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostanie zmieniona nazwa pliku lub katalogu <see cref="P:System.IO.FileSystemWatcher.Path" /> w określonej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed` Zdarzenie<xref:System.IO.RenamedEventHandler> jest delegatem, który ma następujący podpis:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Obiekt zawiera informacje o operacji zmiany nazwy, takie jak typ zmiany nazwy <xref:System.IO.FileSystemEventArgs.ChangeType> (właściwości), stara i Nowa nazwa oraz stara i Nowa ścieżka. <xref:System.IO.RenamedEventArgs> Należy pamiętać, <xref:System.IO.FileSystemEventArgs.Name> że właściwość może mieć wartość null dla zdarzeń o <xref:System.IO.FileSystemWatcher> zmienionej nazwie, jeśli nie ma pasujących starych i nowych zdarzeń nazw z systemu operacyjnego.

 Zmiana nazwy katalogu, który oglądasz, nie spowoduje zgłoszenia powiadomienia. Powiadomienia są wywoływane tylko w przypadku wpisów znajdujących się w katalogu, w którym się oglądasz.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.IO.FileSystemWatcher.Renamed> zdarzenia, aby wyświetlić ścieżkę pliku do konsoli za każdym razem, gdy zostanie zmieniona nazwa oglądanego pliku.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> <see cref="T:System.IO.FileSystemWatcher" />dla elementu.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> Dla .<see cref="T:System.IO.FileSystemWatcher" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokacje są <xref:System.ComponentModel.Component> powiązane <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> z i umożliwiają komunikację między nimi, a także umożliwiają kontenerowi zarządzanie jego składnikami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, który został wygenerowany w wyniku zmiany katalogu.</summary>
        <value>Reprezentuje obiekt służący do organizowania wywołań obsługi zdarzeń, któresąwydawanewwynikuzmianykatalogu.<see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> tak `null`jest, <xref:System.IO.FileSystemWatcher.Created> <xref:System.IO.FileSystemWatcher.Changed> <xref:System.IO.FileSystemWatcher.Renamed> metody obsługujące zdarzenia, ,isąwywoływanewwątkuzpuliwątkówsystemowych.<xref:System.IO.FileSystemWatcher.Deleted> Aby uzyskać więcej informacji na temat pul wątków systemowych <xref:System.Threading.ThreadPool>, zobacz.  
  
 <xref:System.IO.FileSystemWatcher.Changed>Gdy ,<xref:System.IO.FileSystemWatcher.Created>, ,i<xref:System.IO.FileSystemWatcher.Renamed> zdarzenia<xref:System.Windows.Forms.Button>są obsługiwane przez składnik Visual Windows Forms, na przykład, uzyskanie dostępu do składnika za pomocą puli wątków systemowych może nie zadziałało lub może spowodować wyjątek. <xref:System.IO.FileSystemWatcher.Deleted> Należy tego uniknąć, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> ustawiając składnik Windows Forms, co powoduje, że metody <xref:System.IO.FileSystemWatcher.Changed>, które obsługują zdarzenia <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, i <xref:System.IO.FileSystemWatcher.Renamed> , są wywoływane w tym samym wątku, w którym został utworzony składnik.  
  
 Jeśli jest używany wewnątrz [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] w projektancie Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> <xref:System.IO.FileSystemWatcher>automatycznie ustawia kontrolkę zawierającą. <xref:System.IO.FileSystemWatcher> Na przykład jeśli umieścisz <xref:System.IO.FileSystemWatcher> w projektancie dla formularza Form1 (który dziedziczy z <xref:System.Windows.Forms.Form>) <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Właściwość <xref:System.IO.FileSystemWatcher> jest ustawiona na wystąpienie formularza Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Metoda synchroniczna zwracająca strukturę, która zawiera określone informacje o zmianie, która wystąpiła.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType"><see cref="T:System.IO.WatcherChangeTypes" /> Do czujki.</param>
        <summary>Metoda synchroniczna zwracająca strukturę, która zawiera określone informacje dotyczące zmiany, która wystąpiła, przy uwzględnieniu typu zmiany, która ma być monitorowana.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> , która zawiera określone informacje o zmianie, która wystąpiła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda czeka na czas nieokreślony do momentu pierwszej zmiany, a następnie zwraca. Jest to takie samo, jak <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> użycie `timeout` z parametrem ustawionym na-1.  
  
> [!NOTE]
>  Ta metoda umożliwia wywoływanie procedury obsługi zdarzeń w celu reagowania na zmiany plików, nawet <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> Jeśli właściwość jest ustawiona `false`na.  
  
 W niektórych systemach program <xref:System.IO.FileSystemWatcher> raportuje zmiany w plikach przy użyciu krótkiego formatu nazwy pliku 8,3. Na przykład zmiana "LongFileName. LongExtension" może być raportowana jako "LongFi ~. Długość ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType"><see cref="T:System.IO.WatcherChangeTypes" /> Do czujki.</param>
        <param name="timeout">Czas oczekiwania (w milisekundach) przed upływem limitu czasu.</param>
        <summary>Metoda synchroniczna zwracająca strukturę, która zawiera określone informacje dotyczące zmiany, która wystąpiła, w zależności od typu zmiany, która ma być monitorowana, oraz czasu (w milisekundach) oczekiwania przed upływem limitu czasu.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> , która zawiera określone informacje o zmianie, która wystąpiła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda czeka na zmianę lub Przekroczono limit czasu. Wartość-1 `timeout` parametru oznacza oczekiwanie na czas nieokreślony.  
  
> [!NOTE]
>  Ta metoda umożliwia wywoływanie procedury obsługi zdarzeń w celu reagowania na zmiany plików, nawet <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> Jeśli właściwość jest ustawiona `false`na.  
  
 W niektórych systemach program <xref:System.IO.FileSystemWatcher> raportuje zmiany w plikach przy użyciu krótkiego formatu nazwy pliku 8,3. Na przykład zmiana "LongFileName. LongExtension" może być raportowana jako "LongFi ~. Długość ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc86d6c3ee6fc3371120e8af5ad912ed3d62dbe4" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69243125" /></Metadata><TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type MemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7728a-101">Tworzy strumień, którego zapasowy magazyn jest pamięcią.</span><span class="sxs-lookup"><span data-stu-id="7728a-101">Creates a stream whose backing store is memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-102">Bieżąca pozycja strumienia to pozycja, w której może zostać przeprowadzona następna operacja odczytu lub zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-102">The current position of a stream is the position at which the next read or write operation could take place.</span></span> <span data-ttu-id="7728a-103">Bieżącą pozycję można pobrać lub ustawić za pomocą <xref:System.IO.MemoryStream.Seek%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="7728a-103">The current position can be retrieved or set through the <xref:System.IO.MemoryStream.Seek%2A> method.</span></span> <span data-ttu-id="7728a-104">Gdy tworzone <xref:System.IO.MemoryStream> jest nowe wystąpienie, bieżące położenie jest ustawione na zero.</span><span class="sxs-lookup"><span data-stu-id="7728a-104">When a new instance of <xref:System.IO.MemoryStream> is created, the current position is set to zero.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 <span data-ttu-id="7728a-105">Strumienie pamięci utworzone za pomocą tablicy bajtowej bez znaku zapewniają strumień danych o niezmiennym rozmiarze.</span><span class="sxs-lookup"><span data-stu-id="7728a-105">Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</span></span> <span data-ttu-id="7728a-106">W przypadku korzystania z tablicy bajtowej nie można dołączać ani zmniejszać strumienia, chociaż można modyfikować istniejącą zawartość w zależności od parametrów przekazaną do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="7728a-106">When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</span></span> <span data-ttu-id="7728a-107">Puste strumienie pamięci są zmieniane i mogą być zapisywane i odczytywane z.</span><span class="sxs-lookup"><span data-stu-id="7728a-107">Empty memory streams are resizable, and can be written to and read from.</span></span>  
  
 <span data-ttu-id="7728a-108">Jeśli obiekt jest dodawany do pliku resx lub pliku Resources, należy <xref:System.Resources.ResourceManager.GetStream%2A> wywołać metodę w czasie wykonywania, aby ją pobrać. <xref:System.IO.MemoryStream></span><span class="sxs-lookup"><span data-stu-id="7728a-108">If a <xref:System.IO.MemoryStream> object is added to a ResX file or a .resources file, call the <xref:System.Resources.ResourceManager.GetStream%2A> method at runtime to retrieve it.</span></span>  
  
 <span data-ttu-id="7728a-109">Jeśli obiekt jest serializowany do pliku zasobów, <xref:System.IO.UnmanagedMemoryStream>w rzeczywistości zostanie Zserializowany jako. <xref:System.IO.MemoryStream></span><span class="sxs-lookup"><span data-stu-id="7728a-109">If a <xref:System.IO.MemoryStream> object is serialized to a resource file it will actually be serialized as an <xref:System.IO.UnmanagedMemoryStream>.</span></span> <span data-ttu-id="7728a-110">Takie zachowanie zapewnia lepszą wydajność, a także możliwość uzyskania wskaźnika bezpośrednio do danych bez konieczności przechodzenia między <xref:System.IO.Stream> metodami.</span><span class="sxs-lookup"><span data-stu-id="7728a-110">This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <xref:System.IO.Stream> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-111">Poniższy przykład kodu pokazuje, jak odczytywać i zapisywać dane przy użyciu pamięci jako magazynu zapasowego.</span><span class="sxs-lookup"><span data-stu-id="7728a-111">The following code example shows how to read and write data using memory as a backing store.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-112">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-112">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-113">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-113">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-114">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-114">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7728a-115">Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.MemoryStream" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-115">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-116">Inicjuje nowe wystąpienie <see cref="T:System.IO.MemoryStream" /> klasy z rozszerzalną pojemnością zainicjowaną na zero.</span><span class="sxs-lookup"><span data-stu-id="7728a-116">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-117">Właściwości <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>i `true`są ustawionena.<xref:System.IO.MemoryStream.CanWrite%2A></span><span class="sxs-lookup"><span data-stu-id="7728a-117">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="7728a-118">Pojemność bieżącego strumienia zostanie automatycznie zwiększona podczas korzystania <xref:System.IO.MemoryStream.SetLength%2A> z metody w celu ustawienia długości wartości większej niż pojemność bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-118">The capacity of the current stream automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span>  
  
 <span data-ttu-id="7728a-119">Ten konstruktor uwidacznia strumień źródłowy, który <xref:System.IO.MemoryStream.GetBuffer%2A> zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="7728a-119">This constructor exposes the underlying stream, which <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-120">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-120">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-121">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-121">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-122">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-122">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream buffer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-123">Tablica bajtów bez znaku, z której ma zostać utworzony bieżący strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-123">The array of unsigned bytes from which to create the current stream.</span></span></param>
        <summary><span data-ttu-id="7728a-124">Inicjuje nowe wystąpienie o <see cref="T:System.IO.MemoryStream" /> niezmiennym rozmiarze klasy w oparciu o określoną tablicę bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-124">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-125">Właściwości <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>i `true`są ustawionena.<xref:System.IO.MemoryStream.CanWrite%2A></span><span class="sxs-lookup"><span data-stu-id="7728a-125">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span> <span data-ttu-id="7728a-126"><xref:System.IO.MemoryStream.Capacity%2A>jest ustawiona na długość określonej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-126"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span> <span data-ttu-id="7728a-127">Nowy strumień może być zapisany w, ale nie można go zmieniać.</span><span class="sxs-lookup"><span data-stu-id="7728a-127">The new stream can be written to, but is not resizable.</span></span>  
  
 <span data-ttu-id="7728a-128">Nie można ustawić długości strumienia na wartość większą niż początkowa długość określonej tablicy bajtów; strumień można jednak obciąć (zobacz <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7728a-128">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7728a-129">Ten konstruktor nie uwidacznia bazowego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-129">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7728a-130"><xref:System.IO.MemoryStream.GetBuffer%2A>zgłasza <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-130"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-131"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-131"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-132">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-132">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-133">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-133">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-134">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-134">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="7728a-135">Początkowy rozmiar tablicy wewnętrznej w bajtach.</span><span class="sxs-lookup"><span data-stu-id="7728a-135">The initial size of the internal array in bytes.</span></span></param>
        <summary><span data-ttu-id="7728a-136">Inicjuje nowe wystąpienie <see cref="T:System.IO.MemoryStream" /> klasy z rozszerzalną pojemnością, która została zainicjowana w określony sposób.</span><span class="sxs-lookup"><span data-stu-id="7728a-136">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-137">Właściwości <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>i `true`są ustawionena.<xref:System.IO.MemoryStream.CanWrite%2A></span><span class="sxs-lookup"><span data-stu-id="7728a-137">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="7728a-138">Wydajność zostaje automatycznie zwiększona przy użyciu <xref:System.IO.MemoryStream.SetLength%2A> metody, aby ustawić długość wartości większej niż pojemność bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-138">The capacity automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span> <span data-ttu-id="7728a-139">Z wyjątkiem `MemoryStream` `MemoryStream`konstrukcji z parametrem Byte [] operacje zapisu na końcu rozwiń. `MemoryStream`</span><span class="sxs-lookup"><span data-stu-id="7728a-139">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
 <span data-ttu-id="7728a-140">Ten Konstruktor przedstawia źródłowy strumień, który <xref:System.IO.MemoryStream.GetBuffer%2A> zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="7728a-140">This constructor exposes the underlying stream that <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-141">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-141">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-142"><paramref name="capacity" />jest wartością ujemną.</span><span class="sxs-lookup"><span data-stu-id="7728a-142"><paramref name="capacity" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-143">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-143">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-144">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-144">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-145">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-145">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-146">Tablica bajtów bez znaku, z której ma zostać utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-146">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="writable"><span data-ttu-id="7728a-147">Ustawienie <see cref="P:System.IO.MemoryStream.CanWrite" /> właściwości, które określa, czy strumień obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-147">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="7728a-148">Inicjuje nowe wystąpienie o <see cref="T:System.IO.MemoryStream" /> niezmiennym rozmiarze klasy w oparciu o określoną tablicę bajtową <see cref="P:System.IO.MemoryStream.CanWrite" /> z ustawioną określoną właściwością.</span><span class="sxs-lookup"><span data-stu-id="7728a-148">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-149">Właściwości <xref:System.IO.MemoryStream.CanRead%2A> `true`i <xref:System.IO.MemoryStream.CanSeek%2A> są ustawione na.</span><span class="sxs-lookup"><span data-stu-id="7728a-149">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="7728a-150"><xref:System.IO.MemoryStream.Capacity%2A>jest ustawiona na długość określonej tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-150"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span>  
  
 <span data-ttu-id="7728a-151">Nie można ustawić długości strumienia na wartość większą niż początkowa długość określonej tablicy bajtów; strumień można jednak obciąć (zobacz <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7728a-151">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7728a-152">Ten konstruktor nie uwidacznia bazowego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-152">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7728a-153"><xref:System.IO.MemoryStream.GetBuffer%2A>zgłasza <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-153"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-154"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-154"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-155">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-155">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-156">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-156">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-157">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-157">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-158">Tablica bajtów bez znaku, z której ma zostać utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-158">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="7728a-159">Indeks <paramref name="buffer" /> , w którym rozpoczyna się strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-159">The index into <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-160">Długość strumienia w bajtach.</span><span class="sxs-lookup"><span data-stu-id="7728a-160">The length of the stream in bytes.</span></span></param>
        <summary><span data-ttu-id="7728a-161">Inicjuje nowe wystąpienie o <see cref="T:System.IO.MemoryStream" /> niezmiennym rozmiarze klasy w oparciu o określony region (indeks) tablicy bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-161">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-162">Właściwości <xref:System.IO.MemoryStream.CanRead%2A> `true`, <xref:System.IO.MemoryStream.CanSeek%2A>, i <xref:System.IO.MemoryStream.CanWrite%2A> są ustawione na, ale nie można zmienić pojemności.</span><span class="sxs-lookup"><span data-stu-id="7728a-162">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`, but the capacity cannot be changed.</span></span> <span data-ttu-id="7728a-163"><xref:System.IO.MemoryStream.Capacity%2A>jest ustawiony na `count`.</span><span class="sxs-lookup"><span data-stu-id="7728a-163"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="7728a-164">Nie można ustawić długości strumienia na wartość większą niż początkowa długość określonej tablicy bajtów; strumień można jednak obciąć (zobacz <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7728a-164">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7728a-165">Ten konstruktor nie uwidacznia bazowego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-165">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7728a-166"><xref:System.IO.MemoryStream.GetBuffer%2A>zgłasza <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-166"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="7728a-167">Można jednak zapisywać w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="7728a-167">However, you can write to the stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-168"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-168"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-169"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="7728a-169"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-170">Długość buforu minus <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-170">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-171">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-171">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-172">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-172">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-173">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-173">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-174">Tablica bajtów bez znaku, z której ma zostać utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-174">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="7728a-175">Indeks, w <paramref name="buffer" /> którym rozpoczyna się strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-175">The index in <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-176">Długość strumienia w bajtach.</span><span class="sxs-lookup"><span data-stu-id="7728a-176">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="7728a-177">Ustawienie <see cref="P:System.IO.MemoryStream.CanWrite" /> właściwości, które określa, czy strumień obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-177">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="7728a-178">Inicjuje nowe wystąpienie o <see cref="T:System.IO.MemoryStream" /> niezmiennym rozmiarze klasy na podstawie określonego regionu tablicy bajtów <see cref="P:System.IO.MemoryStream.CanWrite" /> z ustawioną właściwością.</span><span class="sxs-lookup"><span data-stu-id="7728a-178">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-179">Właściwości <xref:System.IO.MemoryStream.CanRead%2A> `true`i <xref:System.IO.MemoryStream.CanSeek%2A> są ustawione na.</span><span class="sxs-lookup"><span data-stu-id="7728a-179">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="7728a-180"><xref:System.IO.MemoryStream.Capacity%2A>jest ustawiony na `count`.</span><span class="sxs-lookup"><span data-stu-id="7728a-180"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="7728a-181">Nie można ustawić długości strumienia na wartość większą niż początkowa długość określonej tablicy bajtów; strumień można jednak obciąć (zobacz <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7728a-181">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7728a-182">Ten konstruktor nie uwidacznia bazowego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-182">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7728a-183"><xref:System.IO.MemoryStream.GetBuffer%2A>zgłasza <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-183"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="7728a-184">Można jednak zapisywać w strumieniu, jeśli `writable` jest. `true`</span><span class="sxs-lookup"><span data-stu-id="7728a-184">However, you can write to the stream if `writable` is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-185"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-185"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-186"><paramref name="index" />lub <paramref name="count" /> są ujemne.</span><span class="sxs-lookup"><span data-stu-id="7728a-186"><paramref name="index" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-187">Długość buforu minus <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-187">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-188">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-188">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-189">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-189">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-190">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-190">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable, publiclyVisible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="writable" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-191">Tablica bajtów bez znaku, z której ma zostać utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-191">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="7728a-192">Indeks <paramref name="buffer" /> , w którym rozpoczyna się strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-192">The index into <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-193">Długość strumienia w bajtach.</span><span class="sxs-lookup"><span data-stu-id="7728a-193">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="7728a-194">Ustawienie <see cref="P:System.IO.MemoryStream.CanWrite" /> właściwości, które określa, czy strumień obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-194">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <param name="publiclyVisible"><span data-ttu-id="7728a-195"><see langword="true" />w celu <see cref="M:System.IO.MemoryStream.GetBuffer" />włączenia, która zwraca tablicę bajtów bez znaku, z której został utworzony strumień; <see langword="false" />w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="7728a-195"><see langword="true" /> to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="7728a-196">Inicjuje nowe wystąpienie <see cref="T:System.IO.MemoryStream" /> klasy na podstawie określonego regionu tablicy bajtowej, <see cref="P:System.IO.MemoryStream.CanWrite" /> z ustawioną właściwością określoną i możliwość wywołania <see cref="M:System.IO.MemoryStream.GetBuffer" /> zestawu zgodnie z określonym.</span><span class="sxs-lookup"><span data-stu-id="7728a-196">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-197">Właściwości <xref:System.IO.MemoryStream.CanRead%2A> `true`i <xref:System.IO.MemoryStream.CanSeek%2A> są ustawione na.</span><span class="sxs-lookup"><span data-stu-id="7728a-197">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="7728a-198"><xref:System.IO.MemoryStream.Capacity%2A>jest ustawiony na `count`.</span><span class="sxs-lookup"><span data-stu-id="7728a-198"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="7728a-199">Nowe wystąpienie strumienia można zapisać w, ale <xref:System.IO.MemoryStream.Capacity%2A> nie można zmienić tablicy bazowego bajtu.</span><span class="sxs-lookup"><span data-stu-id="7728a-199">The new stream instance can be written to, but the <xref:System.IO.MemoryStream.Capacity%2A> of the underlying byte array cannot be changed.</span></span> <span data-ttu-id="7728a-200">Nie można ustawić długości strumienia na wartość większą niż początkowa długość określonej tablicy bajtów; strumień można jednak obciąć (zobacz <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7728a-200">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-201"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-201"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-202"><paramref name="index" />lub <paramref name="count" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="7728a-202"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-203">Długość buforu minus <paramref name="index" /> jest mniejsza niż <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-203">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-204">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-204">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-205">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-205">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-206">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-206">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.MemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7728a-207">Pobiera wartość wskazującą, czy bieżący strumień obsługuje odczytywanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-207">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="7728a-208"><see langword="true" />Jeśli strumień jest otwarty.</span><span class="sxs-lookup"><span data-stu-id="7728a-208"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-209">Jeśli klasa pochodna <xref:System.IO.Stream> nie obsługuje odczytywania, wywołania <xref:System.IO.MemoryStream.Read%2A> metod i <xref:System.IO.MemoryStream.ReadByte%2A> generują <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-209">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.MemoryStream.Read%2A> and <xref:System.IO.MemoryStream.ReadByte%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="7728a-210">Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.</span><span class="sxs-lookup"><span data-stu-id="7728a-210">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-211">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-211">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-212">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-212">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-213">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-213">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.MemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7728a-214">Pobiera wartość wskazującą, czy bieżący strumień obsługuje wyszukiwanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-214">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="7728a-215"><see langword="true" />Jeśli strumień jest otwarty.</span><span class="sxs-lookup"><span data-stu-id="7728a-215"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-216"><xref:System.IO.Stream> Jeśli klasa pochodna nie obsługuje wyszukiwania, wywołania do <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A> <xref:System.IO.MemoryStream.Position%2A>, i <xref:System.IO.MemoryStream.Seek%2A> throw <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-216">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, and <xref:System.IO.MemoryStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="7728a-217">Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.</span><span class="sxs-lookup"><span data-stu-id="7728a-217">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-218">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-218">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-219">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-219">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-220">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-220">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.MemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7728a-221">Pobiera wartość wskazującą, czy bieżący strumień obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-221">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="7728a-222"><see langword="true" />Jeśli strumień obsługuje zapis; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="7728a-222"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-223">Jeśli <xref:System.IO.Stream> Klasa pochodna nie obsługuje pisania, wywołanie do <xref:System.NotSupportedException> <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>lub <xref:System.IO.Stream.WriteByte%2A> zgłasza.</span><span class="sxs-lookup"><span data-stu-id="7728a-223">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="7728a-224">Jeśli strumień jest zamknięty, ta właściwość zwraca wartość `false`.</span><span class="sxs-lookup"><span data-stu-id="7728a-224">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-225">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-226">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-227">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.IO.MemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7728a-228">Pobiera lub ustawia liczbę bajtów przydzieloną dla tego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-228">Gets or sets the number of bytes allocated for this stream.</span></span></summary>
        <value><span data-ttu-id="7728a-229">Długość części do użycia buforu dla strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-229">The length of the usable portion of the buffer for the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-230">`Capacity`jest długością buforu dla tablic bajtowych dostarczonych przez system.</span><span class="sxs-lookup"><span data-stu-id="7728a-230">`Capacity` is the buffer length for system-provided byte arrays.</span></span> <span data-ttu-id="7728a-231">`Capacity`nie można ustawić wartości mniejszej niż bieżąca długość strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-231">`Capacity` cannot be set to a value less than the current length of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-232">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-232">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-233">Ustawiono pojemność równą wartości ujemnej lub mniejszej niż bieżąca długość strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-233">A capacity is set that is negative or less than the current length of the stream.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-234">Bieżący strumień jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-234">The current stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-235"><see langword="set" />jest wywoływana w strumieniu, którego pojemność nie może być modyfikowana.</span><span class="sxs-lookup"><span data-stu-id="7728a-235"><see langword="set" /> is invoked on a stream whose capacity cannot be modified.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-236">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-236">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-237">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-237">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-238">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-238">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="memoryStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-239">Zamyka strumień do odczytu i zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-239">Closes the stream for reading and writing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="7728a-240">Ta metoda przesłania <xref:System.IO.Stream.Close?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7728a-240">This method overrides <xref:System.IO.Stream.Close?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="7728a-241">Bufor jest nadal dostępny <xref:System.IO.MemoryStream> po zamknięciu strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-241">The buffer is still available on a <xref:System.IO.MemoryStream> once the stream has been closed.</span></span>

<span data-ttu-id="7728a-242">Opróżnianie strumienia nie spowoduje opróżnienia jego bazowego kodera, <xref:System.IO.MemoryStream.Flush> chyba `Close`że zostanie jawnie wywołana lub.</span><span class="sxs-lookup"><span data-stu-id="7728a-242">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.MemoryStream.Flush> or `Close`.</span></span> <span data-ttu-id="7728a-243">Ustawienie <xref:System.IO.StreamWriter.AutoFlush> wartości true oznacza, że dane zostaną opróżnione z bufora do strumienia, ale stan kodera nie zostanie opróżniony.</span><span class="sxs-lookup"><span data-stu-id="7728a-243">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="7728a-244">Dzięki temu koder może zachować swój stan (częściowe znaki), aby można było poprawnie zakodować następny blok znaków.</span><span class="sxs-lookup"><span data-stu-id="7728a-244">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="7728a-245">Ten scenariusz ma wpływ na kodowanie UTF8 i UTF7, gdzie niektóre znaki mogą być kodowane tylko po odebraniu sąsiadujących znaków.</span><span class="sxs-lookup"><span data-stu-id="7728a-245">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="7728a-246">Próba manipulowania strumieniem po jego zamknięciu może zgłosić <xref:System.ObjectDisposedException>.</span><span class="sxs-lookup"><span data-stu-id="7728a-246">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="7728a-247">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-247">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>

```vb
Finally
    memStream.Close()
End Try
```

]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-248">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-248">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-249">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-249">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-250">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-250">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="memoryStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="7728a-251">Strumień, do którego zostanie skopiowana zawartość bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-251">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="7728a-252">Rozmiar bufora (w bajtach).</span><span class="sxs-lookup"><span data-stu-id="7728a-252">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="7728a-253">Ta wartość musi być większa od zera.</span><span class="sxs-lookup"><span data-stu-id="7728a-253">This value must be greater than zero.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="7728a-254">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-254">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="7728a-255">Asynchronicznie odczytuje wszystkie bajty z bieżącego strumienia i zapisuje je w innym strumieniu przy użyciu określonego rozmiaru buforu i tokenu anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-255">Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="7728a-256">Zadanie, które reprezentuje asynchroniczną operację kopiowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-256">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-257"><paramref name="destination" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-257"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-258"><paramref name="buffersize" />jest ujemna lub równa zero.</span><span class="sxs-lookup"><span data-stu-id="7728a-258"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-259">Bieżący strumień lub strumień docelowy został usunięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-259">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-260">Bieżący strumień nie obsługuje odczytywania lub strumień docelowy nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-260">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="memoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="7728a-261"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</span><span class="sxs-lookup"><span data-stu-id="7728a-261"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="7728a-262">Zwalnia niezarządzane zasoby używane przez <see cref="T:System.IO.MemoryStream" /> klasę i opcjonalnie zwalnia zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="7728a-262">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-263">Ta metoda jest wywoływana przez metodę publiczną <xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę.</span><span class="sxs-lookup"><span data-stu-id="7728a-263">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="7728a-264"><xref:System.ComponentModel.Component.Dispose%2A>wywołuje metodę chronioną <xref:System.IO.MemoryStream.Dispose%2A> `disposing` z parametrem ustawionym `true`na.</span><span class="sxs-lookup"><span data-stu-id="7728a-264"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.MemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="7728a-265"><xref:System.Object.Finalize%2A>wywołuje <xref:System.IO.MemoryStream.Dispose%2A> `false`z `disposing` ustawionym na.</span><span class="sxs-lookup"><span data-stu-id="7728a-265"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.MemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="7728a-266">Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.IO.MemoryStream> których odwołują się te odwołania. `disposing`</span><span class="sxs-lookup"><span data-stu-id="7728a-266">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.MemoryStream> references.</span></span> <span data-ttu-id="7728a-267">Ta metoda wywołuje <xref:System.ComponentModel.Component.Dispose%2A> metodę każdego przywoływanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="7728a-267">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="7728a-268">
            <see cref="M:System.ComponentModel.Component.Dispose" />może być wywoływana wiele razy przez inne obiekty.</span><span class="sxs-lookup"><span data-stu-id="7728a-268">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="7728a-269">W przypadku <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see cref="M:System.ComponentModel.Component.Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do.</span><span class="sxs-lookup"><span data-stu-id="7728a-269">When overriding <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="7728a-270">Aby uzyskać więcej informacji na temat sposobu <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="7728a-270">For more information about how to implement <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="7728a-271">Aby uzyskać więcej informacji <see cref="M:System.ComponentModel.Component.Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="7728a-271">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="memoryStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="memoryStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="memoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-272"><see cref="M:System.IO.Stream.Flush" /> Zastępuje metodę, tak aby nie była wykonywana żadna akcja.</span><span class="sxs-lookup"><span data-stu-id="7728a-272">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-273">Ta metoda przesłania <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> metodę.</span><span class="sxs-lookup"><span data-stu-id="7728a-273">This method overrides the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="7728a-274">Ponieważ wszystkie dane zapisywane w <xref:System.IO.MemoryStream> obiekcie są zapisywane w pamięci RAM, ta metoda jest nadmiarowa.</span><span class="sxs-lookup"><span data-stu-id="7728a-274">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-275">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-275">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-276">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-276">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-277">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-277">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="7728a-278">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-278">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="7728a-279">Asynchronicznie czyści wszystkie bufory dla tego strumienia i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-279">Asynchronously clears all buffers for this stream, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="7728a-280">Zadanie, które reprezentuje asynchroniczną operację opróżniania.</span><span class="sxs-lookup"><span data-stu-id="7728a-280">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-281">Ponieważ wszystkie dane zapisywane w <xref:System.IO.MemoryStream> obiekcie są zapisywane w pamięci RAM, ta metoda jest nadmiarowa.</span><span class="sxs-lookup"><span data-stu-id="7728a-281">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 <span data-ttu-id="7728a-282">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="7728a-282">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="7728a-283">Można utworzyć token anulowania, tworząc wystąpienie <xref:System.Threading.CancellationTokenSource> klasy i <xref:System.Threading.CancellationTokenSource.Token%2A> przekazując właściwość jako `cancellationToken` parametr.</span><span class="sxs-lookup"><span data-stu-id="7728a-283">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-284">Strumień został usunięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-284">The stream has been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="7728a-285">Anulowanie</span><span class="sxs-lookup"><span data-stu-id="7728a-285">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberSignature Language="F#" Value="abstract member GetBuffer : unit -&gt; byte[]&#xA;override this.GetBuffer : unit -&gt; byte[]" Usage="memoryStream.GetBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-286">Zwraca tablicę bajtów bez znaku, z której został utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-286">Returns the array of unsigned bytes from which this stream was created.</span></span></summary>
        <returns><span data-ttu-id="7728a-287">Tablica bajtów, z której został utworzony ten strumień lub tablica źródłowa, jeśli tablica bajtów nie została dostarczona do <see cref="T:System.IO.MemoryStream" /> konstruktora podczas konstruowania bieżącego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-287">The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-288">Należy zauważyć, że bufor zawiera przydzieloną liczbę bajtów, które mogą być nieużywane.</span><span class="sxs-lookup"><span data-stu-id="7728a-288">Note that the buffer contains allocated bytes which might be unused.</span></span> <span data-ttu-id="7728a-289">Na przykład jeśli ciąg "test" jest zapisywana w <xref:System.IO.MemoryStream> obiekcie, długość buforu zwróconego z <xref:System.IO.MemoryStream.GetBuffer%2A> to 256, nie 4, z nieużywanym 252 bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-289">For example, if the string "test" is written into the <xref:System.IO.MemoryStream> object, the length of the buffer returned from <xref:System.IO.MemoryStream.GetBuffer%2A> is 256, not 4, with 252 bytes unused.</span></span> <span data-ttu-id="7728a-290">Aby uzyskać tylko dane w buforze, należy użyć <xref:System.IO.MemoryStream.ToArray%2A> metody, <xref:System.IO.MemoryStream.ToArray%2A> ale tworzy kopię danych w pamięci.</span><span class="sxs-lookup"><span data-stu-id="7728a-290">To obtain only the data in the buffer, use the <xref:System.IO.MemoryStream.ToArray%2A> method; however, <xref:System.IO.MemoryStream.ToArray%2A> creates a copy of the data in memory.</span></span>  
  
 <span data-ttu-id="7728a-291">Bufor może być `null`również.</span><span class="sxs-lookup"><span data-stu-id="7728a-291">The buffer can also be `null`.</span></span>  
  
 <span data-ttu-id="7728a-292">Aby utworzyć `MemoryStream` wystąpienie z publicznie widocznym buforem, użyj <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, lub <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span><span class="sxs-lookup"><span data-stu-id="7728a-292">To create a `MemoryStream` instance with a publicly visible buffer, use <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, or <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span></span> <span data-ttu-id="7728a-293">Jeśli bieżący strumień jest zmienny, dwa wywołania tej metody nie zwracają tej samej tablicy, jeśli rozmiar tablicy bazowego bajtu zostanie zmieniony między wywołaniami.</span><span class="sxs-lookup"><span data-stu-id="7728a-293">If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</span></span> <span data-ttu-id="7728a-294">Aby uzyskać dodatkowe informacje, <xref:System.IO.MemoryStream.Capacity%2A>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="7728a-294">For additional information, see <xref:System.IO.MemoryStream.Capacity%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7728a-295">Ta metoda działa, gdy strumień pamięci jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-295">This method works when the memory stream is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7728a-296"><see langword="MemoryStream" /> Wystąpienie nie zostało utworzone z publicznie widocznym buforem.</span><span class="sxs-lookup"><span data-stu-id="7728a-296">The <see langword="MemoryStream" /> instance was not created with a publicly visible buffer.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-297">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-297">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-298">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-298">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-299">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-299">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.MemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7728a-300">Pobiera długość strumienia w bajtach.</span><span class="sxs-lookup"><span data-stu-id="7728a-300">Gets the length of the stream in bytes.</span></span></summary>
        <value><span data-ttu-id="7728a-301">Długość strumienia w bajtach.</span><span class="sxs-lookup"><span data-stu-id="7728a-301">The length of the stream in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7728a-302">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-302">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-303">Strumień jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-303">The stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-304">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-304">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-305">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-305">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-306">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-306">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected override void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="override this.ObjectInvariant : unit -&gt; unit" Usage="memoryStream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-307">Zapewnia pomoc techniczną <see cref="T:System.Diagnostics.Contracts.Contract" />dla programu.</span><span class="sxs-lookup"><span data-stu-id="7728a-307">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.MemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7728a-308">Pobiera lub ustawia bieżącą pozycję w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="7728a-308">Gets or sets the current position within the stream.</span></span></summary>
        <value><span data-ttu-id="7728a-309">Bieżąca pozycja w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="7728a-309">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7728a-310">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-310">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-311">Pozycja jest ustawiona na wartość ujemną lub wartość większą niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-311">The position is set to a negative value or a value greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-312">Strumień jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-312">The stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-313">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-313">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-314">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-314">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-315">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-315">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="memoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="memoryStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-316">Gdy ta metoda zwraca, zawiera określoną tablicę bajtową z wartościami między <paramref name="offset" /> i (<paramref name="offset" />  +  <paramref name="count" /> -1) zastąpione przez znaki odczytane z bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-316">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the characters read from the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="7728a-317">Przesunięcie bajtu (liczony od zera <paramref name="buffer" /> ), w którym rozpocznie się przechowywanie danych z bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-317">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing data from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-318">Maksymalna liczba bajtów do odczytania.</span><span class="sxs-lookup"><span data-stu-id="7728a-318">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="7728a-319">Odczytuje blok bajtów z bieżącego strumienia i zapisuje dane w buforze.</span><span class="sxs-lookup"><span data-stu-id="7728a-319">Reads a block of bytes from the current stream and writes the data to a buffer.</span></span></summary>
        <returns><span data-ttu-id="7728a-320">Całkowita liczba bajtów zapisywana w buforze.</span><span class="sxs-lookup"><span data-stu-id="7728a-320">The total number of bytes written into the buffer.</span></span> <span data-ttu-id="7728a-321">Może to być mniejsze niż liczba bajtów żądana, jeśli liczba bajtów nie jest obecnie dostępna lub zero, jeśli osiągnięto koniec strumienia przed odczytaniem jakichkolwiek bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-321">This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-322">Ta metoda przesłania <xref:System.IO.Stream.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="7728a-322">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="7728a-323">Parametr daje przesunięcie pierwszego bajtu, w `buffer` którym zapisywane są dane z bieżącego strumienia. `offset`</span><span class="sxs-lookup"><span data-stu-id="7728a-323">The `offset` parameter gives the offset of the first byte in `buffer` to which data from the current stream is written.</span></span> <span data-ttu-id="7728a-324">`count` Parametr zawiera maksymalną liczbę bajtów odczytywanych z bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-324">The `count` parameter gives the maximum number of bytes to read from the current stream.</span></span> <span data-ttu-id="7728a-325">Zwracana wartość to rzeczywista liczba odczytanych bajtów lub zero, jeśli osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-325">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span>  
  
 <span data-ttu-id="7728a-326">Jeśli operacja odczytu zakończy się pomyślnie, bieżąca pozycja w strumieniu zostanie zaawansowana przez liczbę odczytanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-326">If the read operation is successful, the current position within the stream advances by the number of bytes read.</span></span> <span data-ttu-id="7728a-327">Jeśli wystąpi wyjątek, bieżąca pozycja w strumieniu pozostaje niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="7728a-327">If an exception occurs, the current position within the stream remains unchanged.</span></span>  
  
 <span data-ttu-id="7728a-328">`Read` Metoda zwróci wartość zero tylko wtedy, gdy osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-328">The `Read` method will return zero only if the end of the stream is reached.</span></span> <span data-ttu-id="7728a-329">We wszystkich innych przypadkach `Read` zawsze odczytuje co najmniej jeden bajt ze strumienia przed zwróceniem.</span><span class="sxs-lookup"><span data-stu-id="7728a-329">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="7728a-330">Według definicji, jeśli nie są dostępne żadne dane ze strumienia po wywołaniu `Read` `Read` metody, metoda zwróci wartość zero (koniec strumienia zostanie osiągnięty automatycznie).</span><span class="sxs-lookup"><span data-stu-id="7728a-330">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns zero (the end of the stream is reached automatically).</span></span> <span data-ttu-id="7728a-331">Implementacja może zwrócić mniejszą liczbę bajtów niż żądana, nawet jeśli koniec strumienia nie został osiągnięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-331">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="7728a-332">Służy <xref:System.IO.BinaryReader> do odczytywania typów danych pierwotnych.</span><span class="sxs-lookup"><span data-stu-id="7728a-332">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7728a-333">Jeśli tablica bajtów określona w `buffer` parametrze jest bazowym buforem zwracanym <xref:System.IO.MemoryStream.GetBuffer%2A> przez metodę, zawartość tablicy jest zastępowana i nie jest zgłaszany żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="7728a-333">If the byte array specified in the `buffer` parameter is the underlying buffer returned by the <xref:System.IO.MemoryStream.GetBuffer%2A> method, the array contents are overwritten, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-334">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-334">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-335"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-335"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-336"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="7728a-336"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-337"><paramref name="offset" />odjęta od długości buforu jest mniejsza niż <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-337"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-338">Bieżące wystąpienie strumienia jest zamknięte.</span><span class="sxs-lookup"><span data-stu-id="7728a-338">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-339">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-339">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-340">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-340">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-341">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-341">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="memoryStream.ReadAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="memoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-342">Bufor, w którym mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="7728a-342">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="7728a-343">Przesunięcie bajtu, <paramref name="buffer" /> w którym rozpocznie się zapisywanie danych ze strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-343">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-344">Maksymalna liczba bajtów do odczytania.</span><span class="sxs-lookup"><span data-stu-id="7728a-344">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="7728a-345">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-345">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="7728a-346">Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-346">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="7728a-347">Asynchronicznie odczytuje sekwencję bajtów z bieżącego strumienia, przesuwa pozycję w strumieniu o liczbę odczytanych bajtów i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-347">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="7728a-348">Zadanie, które reprezentuje asynchroniczną operację odczytu.</span><span class="sxs-lookup"><span data-stu-id="7728a-348">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="7728a-349">Wartość <paramref name="TResult" /> parametru zawiera łączną liczbę bajtów odczytywanych w buforze.</span><span class="sxs-lookup"><span data-stu-id="7728a-349">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="7728a-350">Wartość wynikowa może być mniejsza niż liczba żądanych bajtów, jeśli liczba aktualnie dostępnych bajtów jest mniejsza niż żądana liczba, lub może być równa 0 (zero), jeśli osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-350">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-351">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="7728a-351">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="7728a-352">Można utworzyć token anulowania, tworząc wystąpienie <xref:System.Threading.CancellationTokenSource> klasy i <xref:System.Threading.CancellationTokenSource.Token%2A> przekazując właściwość jako `cancellationToken` parametr.</span><span class="sxs-lookup"><span data-stu-id="7728a-352">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-353"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-353"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-354"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="7728a-354"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-355">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</span><span class="sxs-lookup"><span data-stu-id="7728a-355">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-356">Strumień nie obsługuje odczytywania.</span><span class="sxs-lookup"><span data-stu-id="7728a-356">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-357">Strumień został usunięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-357">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7728a-358">Strumień jest obecnie używany przez poprzednią operację odczytu.</span><span class="sxs-lookup"><span data-stu-id="7728a-358">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="memoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-359">Odczytuje bajt z bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-359">Reads a byte from the current stream.</span></span></summary>
        <returns><span data-ttu-id="7728a-360">Bajt jest rzutowany na <see cref="T:System.Int32" />, lub-1, jeśli osiągnięto koniec strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-360">The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-361">Ta metoda przesłania <xref:System.IO.Stream.ReadByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="7728a-361">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
 <span data-ttu-id="7728a-362">Jeśli operacja odczytu zakończy się pomyślnie, bieżąca pozycja w strumieniu jest zaawansowana o jeden bajt.</span><span class="sxs-lookup"><span data-stu-id="7728a-362">If the read operation is successful, the current position within the stream is advanced by one byte.</span></span> <span data-ttu-id="7728a-363">Jeśli wystąpi wyjątek, bieżąca pozycja w strumieniu nie jest zmieniana.</span><span class="sxs-lookup"><span data-stu-id="7728a-363">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-364">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-364">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-365">Bieżące wystąpienie strumienia jest zamknięte.</span><span class="sxs-lookup"><span data-stu-id="7728a-365">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-366">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-366">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-367">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-367">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-368">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-368">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="memoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="7728a-369">Nowa pozycja w strumieniu.</span><span class="sxs-lookup"><span data-stu-id="7728a-369">The new position within the stream.</span></span> <span data-ttu-id="7728a-370">Jest to względne względem <paramref name="loc" /> parametru i może być dodatnie lub ujemne.</span><span class="sxs-lookup"><span data-stu-id="7728a-370">This is relative to the <paramref name="loc" /> parameter, and can be positive or negative.</span></span></param>
        <param name="loc"><span data-ttu-id="7728a-371">Wartość typu <see cref="T:System.IO.SeekOrigin" />, która działa jako punkt odwołania wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="7728a-371">A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point.</span></span></param>
        <summary><span data-ttu-id="7728a-372">Ustawia pozycję w bieżącym strumieniu na określoną wartość.</span><span class="sxs-lookup"><span data-stu-id="7728a-372">Sets the position within the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="7728a-373">Nowa pozycja w strumieniu obliczana przez połączenie początkowego punktu odniesienia i przesunięcia.</span><span class="sxs-lookup"><span data-stu-id="7728a-373">The new position within the stream, calculated by combining the initial reference point and the offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-374">Ta metoda przesłania <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7728a-374">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7728a-375">Wyszukiwanie w dowolnej lokalizacji poza długością strumienia jest obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="7728a-375">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="7728a-376">Nie należy używać <xref:System.IO.MemoryStream.Seek%2A> metody do określenia nowej pozycji w strumieniu, <xref:System.IO.MemoryStream> jeśli została zainicjowana z przesunięciem innym niż zero.</span><span class="sxs-lookup"><span data-stu-id="7728a-376">Do not use the <xref:System.IO.MemoryStream.Seek%2A> method to determine the new position in the stream if the <xref:System.IO.MemoryStream> was initialized with a non-zero offset.</span></span> <span data-ttu-id="7728a-377">Jeśli to zrobisz, <xref:System.IO.MemoryStream.Seek%2A> zwróci niedokładną wartość.</span><span class="sxs-lookup"><span data-stu-id="7728a-377">If you do, <xref:System.IO.MemoryStream.Seek%2A> will return an inaccurate value.</span></span> <span data-ttu-id="7728a-378">Zamiast tego należy użyć <xref:System.IO.MemoryStream.Position%2A> właściwości, aby uzyskać nowe położenie strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-378">Instead, use the <xref:System.IO.MemoryStream.Position%2A> property to get the new position of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-379">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-379">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7728a-380">Podjęto próbę wyszukiwania przed początkiem strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-380">Seeking is attempted before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-381"><paramref name="offset" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-381"><paramref name="offset" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-382">Jest nieprawidłowy <see cref="T:System.IO.SeekOrigin" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-382">There is an invalid <see cref="T:System.IO.SeekOrigin" />.</span></span>  
  
<span data-ttu-id="7728a-383">—lub—</span><span class="sxs-lookup"><span data-stu-id="7728a-383">-or-</span></span> 
 <span data-ttu-id="7728a-384"><paramref name="offset" />spowodowała przepełnienie arytmetyczne.</span><span class="sxs-lookup"><span data-stu-id="7728a-384"><paramref name="offset" /> caused an arithmetic overflow.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-385">Bieżące wystąpienie strumienia jest zamknięte.</span><span class="sxs-lookup"><span data-stu-id="7728a-385">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-386">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-386">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-387">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-387">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-388">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-388">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="memoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7728a-389">Wartość, dla której ma zostać ustawiona długość.</span><span class="sxs-lookup"><span data-stu-id="7728a-389">The value at which to set the length.</span></span></param>
        <summary><span data-ttu-id="7728a-390">Ustawia długość bieżącego strumienia do określonej wartości.</span><span class="sxs-lookup"><span data-stu-id="7728a-390">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-391">Ta metoda przesłania <xref:System.IO.Stream.SetLength%2A>.</span><span class="sxs-lookup"><span data-stu-id="7728a-391">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="7728a-392">Jeśli określona wartość jest mniejsza niż bieżąca długość strumienia, strumień zostanie obcięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-392">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="7728a-393">Jeśli po obcięciu bieżąca pozycja w strumieniu <xref:System.IO.MemoryStream.ReadByte%2A> jest poza końcem strumienia, metoda zwróci wartość-1 <xref:System.IO.MemoryStream.Read%2A> , Metoda odczytuje zero bajtów do podanej tablicy <xref:System.IO.MemoryStream.WriteByte%2A> bajtowej i <xref:System.IO.MemoryStream.Write%2A> dołączy metody określone bajty na końcu strumienia, zwiększając jego długość.</span><span class="sxs-lookup"><span data-stu-id="7728a-393">If after the truncation the current position within the stream is past the end of the stream, the <xref:System.IO.MemoryStream.ReadByte%2A> method returns -1, the <xref:System.IO.MemoryStream.Read%2A> method reads zero bytes into the provided byte array, and <xref:System.IO.MemoryStream.Write%2A> and <xref:System.IO.MemoryStream.WriteByte%2A> methods append specified bytes at the end of the stream, increasing its length.</span></span> <span data-ttu-id="7728a-394">Jeśli określona wartość jest większa niż bieżąca pojemność, a strumień zostanie zmieniony, pojemność zostanie zwiększona, a bieżąca pozycja w strumieniu jest niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="7728a-394">If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</span></span> <span data-ttu-id="7728a-395">Jeśli długość zostanie zwiększona, zawartość strumienia między starą i nową długością zostanie zainicjowana do zera.</span><span class="sxs-lookup"><span data-stu-id="7728a-395">If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7728a-396"><xref:System.IO.MemoryStream> Wystąpienie musi obsługiwać zapis, aby ta metoda działała.</span><span class="sxs-lookup"><span data-stu-id="7728a-396">A <xref:System.IO.MemoryStream> instance must support writing for this method to work.</span></span> <span data-ttu-id="7728a-397"><xref:System.IO.MemoryStream.CanWrite%2A> Użyj właściwości, aby określić, czy bieżące wystąpienie obsługuje zapisywanie.</span><span class="sxs-lookup"><span data-stu-id="7728a-397">Use the <xref:System.IO.MemoryStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="7728a-398">Aby uzyskać dodatkowe informacje, <xref:System.IO.Stream.CanWrite%2A>Zobacz.</span><span class="sxs-lookup"><span data-stu-id="7728a-398">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-399">Bieżący strumień nie jest zmienny i <paramref name="value" /> jest większy niż bieżąca pojemność.</span><span class="sxs-lookup"><span data-stu-id="7728a-399">The current stream is not resizable and <paramref name="value" /> is larger than the current capacity.</span></span>  
  
<span data-ttu-id="7728a-400">—lub—</span><span class="sxs-lookup"><span data-stu-id="7728a-400">-or-</span></span> 
<span data-ttu-id="7728a-401">Bieżący strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-401">The current stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-402"><paramref name="value" />jest ujemna lub jest większa niż maksymalna długość <see cref="T:System.IO.MemoryStream" />, gdzie maksymalna długość to (<see cref="F:System.Int32.MaxValue" /> -Origin), a wartość początkowa to indeks w buforze źródłowym, w którym zaczyna się strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-402"><paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />, where the maximum length is(<see cref="F:System.Int32.MaxValue" /> - origin), and origin is the index into the underlying buffer at which the stream starts.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-403">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-403">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-404">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-404">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-405">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-405">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; byte[]&#xA;override this.ToArray : unit -&gt; byte[]" Usage="memoryStream.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7728a-406">Zapisuje zawartość strumienia do tablicy bajtów, niezależnie od <see cref="P:System.IO.MemoryStream.Position" /> właściwości.</span><span class="sxs-lookup"><span data-stu-id="7728a-406">Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</span></span></summary>
        <returns><span data-ttu-id="7728a-407">Nowa tablica bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-407">A new byte array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-408">Ta metoda pomija nieużywane bajty <xref:System.IO.MemoryStream> z tablicy.</span><span class="sxs-lookup"><span data-stu-id="7728a-408">This method omits unused bytes in <xref:System.IO.MemoryStream> from the array.</span></span> <span data-ttu-id="7728a-409">Aby uzyskać cały bufor, użyj <xref:System.IO.MemoryStream.GetBuffer%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="7728a-409">To get the entire buffer, use the <xref:System.IO.MemoryStream.GetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="7728a-410">Ta metoda zwraca kopię zawartości <xref:System.IO.MemoryStream> tablicy jako bajtowej.</span><span class="sxs-lookup"><span data-stu-id="7728a-410">This method returns a copy of the contents of the <xref:System.IO.MemoryStream> as a byte array.</span></span> <span data-ttu-id="7728a-411">Jeśli bieżące wystąpienie zostało skonstruowane w podanej tablicy bajtowej, zwracana jest kopia sekcji tablicy, do której to wystąpienie ma dostęp.</span><span class="sxs-lookup"><span data-stu-id="7728a-411">If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</span></span> <span data-ttu-id="7728a-412">Aby uzyskać <xref:System.IO.MemoryStream.%23ctor%2A> szczegółowe informacje, zobacz Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="7728a-412">See the <xref:System.IO.MemoryStream.%23ctor%2A> constructor for details.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7728a-413">Ta metoda działa po <xref:System.IO.MemoryStream> zamknięciu.</span><span class="sxs-lookup"><span data-stu-id="7728a-413">This method works when the <xref:System.IO.MemoryStream> is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-414">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-414">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-415">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-415">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-416">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-416">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberSignature Language="F#" Value="abstract member TryGetBuffer :  -&gt; bool&#xA;override this.TryGetBuffer :  -&gt; bool" Usage="memoryStream.TryGetBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" RefType="out" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-417">Segment tablicy bajtów, z którego został utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-417">The byte array segment from which this stream was created.</span></span></param>
        <summary><span data-ttu-id="7728a-418">Zwraca tablicę bajtów bez znaku, z której został utworzony ten strumień.</span><span class="sxs-lookup"><span data-stu-id="7728a-418">Returns the array of unsigned bytes from which this stream was created.</span></span> <span data-ttu-id="7728a-419">Zwracana wartość wskazuje, czy konwersja powiodła się.</span><span class="sxs-lookup"><span data-stu-id="7728a-419">The return value indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="7728a-420"><see langword="true" />Jeśli konwersja zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="7728a-420"><see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="memoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="memoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-421">Bufor, z którego mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="7728a-421">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="7728a-422">Przesunięcie bajtu (liczony od zera <paramref name="buffer" /> ), w którym rozpocznie się kopiowanie bajtów do bieżącego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-422">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-423">Maksymalna liczba bajtów do zapisania.</span><span class="sxs-lookup"><span data-stu-id="7728a-423">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="7728a-424">Zapisuje blok bajtów do bieżącego strumienia przy użyciu danych odczytanych z bufora.</span><span class="sxs-lookup"><span data-stu-id="7728a-424">Writes a block of bytes to the current stream using data read from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-425">Ta metoda przesłania <xref:System.IO.Stream.Write%2A>.</span><span class="sxs-lookup"><span data-stu-id="7728a-425">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="7728a-426">Parametr określa przesunięcie pierwszego bajtu w `buffer` do `count` zapisu, a parametr daje liczbę bajtów do zapisania. `offset`</span><span class="sxs-lookup"><span data-stu-id="7728a-426">The `offset` parameter gives the offset of the first byte in `buffer` to write from, and the `count` parameter gives the number of bytes to write.</span></span> <span data-ttu-id="7728a-427">Jeśli operacja zapisu powiedzie się, bieżąca pozycja w strumieniu jest zaawansowana przez liczbę zapisanych bajtów.</span><span class="sxs-lookup"><span data-stu-id="7728a-427">If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="7728a-428">Jeśli wystąpi wyjątek, bieżąca pozycja w strumieniu nie jest zmieniana.</span><span class="sxs-lookup"><span data-stu-id="7728a-428">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
 <span data-ttu-id="7728a-429">Z wyjątkiem `MemoryStream` `MemoryStream`konstrukcji z parametrem Byte [] operacje zapisu na końcu rozwiń. `MemoryStream`</span><span class="sxs-lookup"><span data-stu-id="7728a-429">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-430">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-430">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-431"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-431"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-432">Strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-432">The stream does not support writing.</span></span> <span data-ttu-id="7728a-433">Aby uzyskać dodatkowe informacje <see cref="P:System.IO.Stream.CanWrite" />, zobacz.</span><span class="sxs-lookup"><span data-stu-id="7728a-433">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
<span data-ttu-id="7728a-434">—lub—</span><span class="sxs-lookup"><span data-stu-id="7728a-434">-or-</span></span> 
<span data-ttu-id="7728a-435">Bieżąca pozycja jest bliżej od <paramref name="count" /> bajtów do końca strumienia i nie można zmodyfikować pojemności.</span><span class="sxs-lookup"><span data-stu-id="7728a-435">The current position is closer than <paramref name="count" /> bytes to the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-436"><paramref name="offset" />odjęta od długości buforu jest mniejsza niż <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-436"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-437"><paramref name="offset" />lub <paramref name="count" /> są ujemne.</span><span class="sxs-lookup"><span data-stu-id="7728a-437"><paramref name="offset" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7728a-438">Wystąpi błąd We/Wy.</span><span class="sxs-lookup"><span data-stu-id="7728a-438">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-439">Bieżące wystąpienie strumienia jest zamknięte.</span><span class="sxs-lookup"><span data-stu-id="7728a-439">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-440">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-440">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-441">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-441">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-442">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-442">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="memoryStream.WriteAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="7728a-443">Bufor, z którego mają zostać zapisane dane.</span><span class="sxs-lookup"><span data-stu-id="7728a-443">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="7728a-444">Przesunięcie bajtu (liczony <paramref name="buffer" /> od zera), od którego należy rozpocząć kopiowanie bajtów do strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-444">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="7728a-445">Maksymalna liczba bajtów do zapisania.</span><span class="sxs-lookup"><span data-stu-id="7728a-445">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="7728a-446">Token do monitorowania żądań anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-446">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="7728a-447">Wartość domyślna to <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-447">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="7728a-448">Asynchronicznie zapisuje sekwencję bajtów do bieżącego strumienia, przesuwa bieżącą pozycję w tym strumieniu o liczbę zapisanych bajtów i monitoruje żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="7728a-448">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="7728a-449">Zadanie, które reprezentuje asynchroniczny zapis operacji.</span><span class="sxs-lookup"><span data-stu-id="7728a-449">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-450">Jeśli operacja zostanie anulowana przed zakończeniem, zwrócone zadanie zawiera <xref:System.Threading.Tasks.TaskStatus.Canceled> wartość <xref:System.Threading.Tasks.Task.Status%2A> właściwości.</span><span class="sxs-lookup"><span data-stu-id="7728a-450">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="7728a-451">Można utworzyć token anulowania, tworząc wystąpienie <xref:System.Threading.CancellationTokenSource> klasy i <xref:System.Threading.CancellationTokenSource.Token%2A> przekazując właściwość jako `cancellationToken` parametr.</span><span class="sxs-lookup"><span data-stu-id="7728a-451">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-452"><paramref name="buffer" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-452"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7728a-453"><paramref name="offset" />lub <paramref name="count" /> jest ujemna.</span><span class="sxs-lookup"><span data-stu-id="7728a-453"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7728a-454">Suma <paramref name="offset" /> i<paramref name="count" /> jest większa niż długość buforu.</span><span class="sxs-lookup"><span data-stu-id="7728a-454">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-455">Strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-455">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-456">Strumień został usunięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-456">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7728a-457">Strumień jest obecnie używany przez poprzednią operację zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-457">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="memoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7728a-458">Bajt do zapisania.</span><span class="sxs-lookup"><span data-stu-id="7728a-458">The byte to write.</span></span></param>
        <summary><span data-ttu-id="7728a-459">Zapisuje bajt w bieżącym strumieniu w bieżącym położeniu.</span><span class="sxs-lookup"><span data-stu-id="7728a-459">Writes a byte to the current stream at the current position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-460">Ta metoda przesłania <xref:System.IO.Stream.WriteByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="7728a-460">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="7728a-461">Z wyjątkiem `MemoryStream` `MemoryStream`konstrukcji z parametrem Byte [] operacje zapisu na końcu rozwiń. `MemoryStream`</span><span class="sxs-lookup"><span data-stu-id="7728a-461">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7728a-462">Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.IO.MemoryStream> klasy.</span><span class="sxs-lookup"><span data-stu-id="7728a-462">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7728a-463">Strumień nie obsługuje zapisu.</span><span class="sxs-lookup"><span data-stu-id="7728a-463">The stream does not support writing.</span></span> <span data-ttu-id="7728a-464">Aby uzyskać dodatkowe informacje <see cref="P:System.IO.Stream.CanWrite" />, zobacz.</span><span class="sxs-lookup"><span data-stu-id="7728a-464">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
<span data-ttu-id="7728a-465">—lub—</span><span class="sxs-lookup"><span data-stu-id="7728a-465">-or-</span></span> 
<span data-ttu-id="7728a-466">Bieżąca pozycja znajduje się na końcu strumienia i nie można zmodyfikować pojemności.</span><span class="sxs-lookup"><span data-stu-id="7728a-466">The current position is at the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-467">Bieżący strumień jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-467">The current stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-468">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-468">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-469">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-469">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-470">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-470">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.IO.Stream -&gt; unit&#xA;override this.WriteTo : System.IO.Stream -&gt; unit" Usage="memoryStream.WriteTo stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="7728a-471">Strumień, do którego ma zostać zapisany strumień pamięci.</span><span class="sxs-lookup"><span data-stu-id="7728a-471">The stream to write this memory stream to.</span></span></param>
        <summary><span data-ttu-id="7728a-472">Zapisuje całą zawartość tego strumienia pamięci w innym strumieniu.</span><span class="sxs-lookup"><span data-stu-id="7728a-472">Writes the entire contents of this memory stream to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7728a-473">Gdy bieżący strumień jest otwarty, ta metoda jest równoważna wywołaniu <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> na źródłowym buforze tego strumienia.</span><span class="sxs-lookup"><span data-stu-id="7728a-473">When the current stream is open, this method is equivalent to calling <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> on the underlying buffer of this stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7728a-474"><paramref name="stream" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="7728a-474"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7728a-475">Bieżący lub docelowy strumień jest zamknięty.</span><span class="sxs-lookup"><span data-stu-id="7728a-475">The current or target stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="7728a-476">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="7728a-476">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="7728a-477">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-477">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="7728a-478">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="7728a-478">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>

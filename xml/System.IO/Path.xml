<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9a48816eaf276227c477a80d52f4d81cdeefb517" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68906336" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="470bc-101">Wykonuje operacje na <see cref="T:System.String" /> wystąpieniach, które zawierają informacje o ścieżce pliku lub katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="470bc-102">Te operacje są wykonywane w sposób Międzyplatformowy.</span><span class="sxs-lookup"><span data-stu-id="470bc-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="470bc-103">Ścieżka to ciąg, który zawiera lokalizację pliku lub katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="470bc-104">Ścieżka nie musi wskazywać lokalizacji na dysku; na przykład ścieżka może być mapowana na lokalizację w pamięci lub na urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="470bc-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="470bc-105">Dokładny Format ścieżki jest określany przez bieżącą platformę.</span><span class="sxs-lookup"><span data-stu-id="470bc-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="470bc-106">Na przykład w niektórych systemach ścieżka może rozpoczynać się od litery dysku lub woluminu, podczas gdy ten element nie jest obecny w innych systemach.</span><span class="sxs-lookup"><span data-stu-id="470bc-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="470bc-107">W niektórych systemach ścieżki plików mogą zawierać rozszerzenia, które wskazują typ informacji przechowywanych w pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="470bc-108">Format rozszerzenia nazwy pliku zależy od platformy; na przykład niektóre systemy ograniczają rozszerzenia do trzech znaków, a inne nie.</span><span class="sxs-lookup"><span data-stu-id="470bc-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="470bc-109">Bieżąca platforma określa również zestaw znaków użytych do oddzielenia elementów ścieżki oraz zestaw znaków, które nie mogą być używane podczas określania ścieżek.</span><span class="sxs-lookup"><span data-stu-id="470bc-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="470bc-110">Ze względu na te różnice pola `Path` klasy oraz dokładne zachowanie niektórych elementów członkowskich `Path` klasy są zależne od platformy.</span><span class="sxs-lookup"><span data-stu-id="470bc-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="470bc-111">Ścieżka może zawierać bezwzględne lub względne informacje o lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="470bc-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="470bc-112">Ścieżki bezwzględne w pełni określają lokalizację: plik lub katalog można jednoznacznie zidentyfikować, niezależnie od bieżącej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="470bc-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="470bc-113">Ścieżki względne określają lokalizację częściową: bieżąca lokalizacja jest używana jako punkt początkowy podczas lokalizowania pliku określonego ze ścieżką względną.</span><span class="sxs-lookup"><span data-stu-id="470bc-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="470bc-114">Aby określić bieżący katalog, wywołaj <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="470bc-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="470bc-115">Program .NET Core 1,1 i jego nowsze wersje oraz .NET Framework 4.6.2 i nowsze wersje obsługują również dostęp do obiektów systemu plików, które są nazwami urządzeń\\, na przykład\""? \c:.</span><span class="sxs-lookup"><span data-stu-id="470bc-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="470bc-116">Aby uzyskać więcej informacji na temat formatów ścieżki plików w systemie Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="470bc-117">Większość elementów członkowskich `Path` klasy nie współdziała z systemem plików i nie weryfikuje istnienia pliku określonego przez ciąg ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="470bc-118">`Path`elementy członkowskie klasy, które modyfikują ciąg ścieżki, <xref:System.IO.Path.ChangeExtension%2A>takie jak, nie mają wpływu na nazwy plików w systemie plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="470bc-119">`Path`Członkowie mogą jednak sprawdzić zawartość określonego ciągu ścieżki i zgłosić <xref:System.ArgumentException> wyjątek, jeśli ciąg zawiera znaki, które nie są prawidłowe w ciągach ścieżki, jak zdefiniowano w znakach zwracanych <xref:System.IO.Path.GetInvalidPathChars%2A> przez metodę.</span><span class="sxs-lookup"><span data-stu-id="470bc-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="470bc-120">Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i znaki Unicode od 16 do 18 i 20 do 25.</span><span class="sxs-lookup"><span data-stu-id="470bc-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="470bc-121">Członkowie `Path` klasy umożliwiają szybkie i łatwe wykonywanie typowych operacji, takich jak określenie, czy rozszerzenie nazwy pliku jest częścią ścieżki, i połączenie dwóch ciągów w jedną nazwę ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="470bc-122">Wszystkie elementy członkowskie `Path` klasy są statyczne i dlatego mogą być wywoływane bez wystąpienia ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="470bc-123">W elementach członkowskich, które akceptują ścieżkę jako ciąg wejściowy, ta ścieżka musi być poprawnie sformułowana lub występuje wyjątek.</span><span class="sxs-lookup"><span data-stu-id="470bc-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="470bc-124">Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale zaczyna się od spacji, ścieżka nie jest przycięta w metodach klasy.</span><span class="sxs-lookup"><span data-stu-id="470bc-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="470bc-125">W związku z tym ścieżka jest źle sformułowana i zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="470bc-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="470bc-126">Podobnie ścieżka lub kombinacja ścieżek nie mogą być w pełni kwalifikowane dwukrotnie.</span><span class="sxs-lookup"><span data-stu-id="470bc-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="470bc-127">Na przykład "c:\Temp c:\Windows" wywołuje również wyjątek w większości przypadków.</span><span class="sxs-lookup"><span data-stu-id="470bc-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="470bc-128">Upewnij się, że ścieżki są poprawnie sformułowane podczas korzystania z metod, które akceptują ciąg ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="470bc-129">W elementach członkowskich, które akceptują ścieżkę, ścieżka może odwoływać się do pliku lub tylko katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="470bc-130">Określona ścieżka może również odwoływać się do ścieżki względnej lub ścieżki Universal Naming Convention (UNC) dla serwera i nazwy udziału.</span><span class="sxs-lookup"><span data-stu-id="470bc-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="470bc-131">Na przykład wszystkie następujące są dopuszczalne ścieżki:</span><span class="sxs-lookup"><span data-stu-id="470bc-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="470bc-132">"c:\\\mydir\\\MyFile.txt" in C#lub "c:\MyDir\MyFile.txt" w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="470bc-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="470bc-133">"c:\\\mydir" in C#lub "c:\mydir" w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="470bc-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="470bc-134">"Mydir\\\MySubdir" in C#lub "MyDir\MySubDir" w Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="470bc-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="470bc-135">"\\\\ C#\MyServer \MyShare" in lub"\\\MyServer\MyShare" w Visual Basic.\\\\</span><span class="sxs-lookup"><span data-stu-id="470bc-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="470bc-136">Ponieważ wszystkie te operacje są wykonywane na ciągach, nie można sprawdzić, czy wyniki są prawidłowe we wszystkich scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="470bc-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="470bc-137">Na przykład <xref:System.IO.Path.GetExtension%2A> Metoda analizuje przekazany ciąg i zwraca rozszerzenie z tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="470bc-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="470bc-138">Nie oznacza to jednak, że plik z tym rozszerzeniem istnieje na dysku.</span><span class="sxs-lookup"><span data-stu-id="470bc-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="470bc-139">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="470bc-140">Poniższy przykład demonstruje niektóre główne elementy członkowskie `Path` klasy.</span><span class="sxs-lookup"><span data-stu-id="470bc-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-141">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-142">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-143">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="470bc-144">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</span><span class="sxs-lookup"><span data-stu-id="470bc-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-145">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="470bc-146">Zapewnia alternatywny znak specyficzny dla platformy używany do oddzielania poziomów katalogów w ciągu ścieżki, który odzwierciedla hierarchiczną organizację systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="470bc-147">To pole może mieć taką samą wartość jak <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="470bc-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="470bc-148">`AltDirectorySeparatorChar`i <xref:System.IO.Path.DirectorySeparatorChar> są prawidłowe w celu oddzielenia poziomów katalogów w ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="470bc-149">Wartość tego pola jest ukośnikiem ("/") w systemach operacyjnych Windows i UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="470bc-150">Poniższy przykład wyświetla <xref:System.IO.Path> wartości pól w systemie Windows i w systemach UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="470bc-151">Należy pamiętać, że system Windows obsługuje ukośnik (zwracany przez <xref:System.IO.Path.AltDirectorySeparatorChar> pole) lub ukośnik odwrotny (który jest zwracany <xref:System.IO.Path.DirectorySeparatorChar> przez pole) jako znaki separatora ścieżki, natomiast systemy z systemem UNIX obsługują tylko ukośnik.</span><span class="sxs-lookup"><span data-stu-id="470bc-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-152">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-153">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-154">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-155">Informacje o ścieżce do zmodyfikowania.</span><span class="sxs-lookup"><span data-stu-id="470bc-155">The path information to modify.</span></span> <span data-ttu-id="470bc-156">Ścieżka nie może zawierać żadnych znaków zdefiniowanych w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="470bc-157">Nowe rozszerzenie (z kropką lub bez niego).</span><span class="sxs-lookup"><span data-stu-id="470bc-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="470bc-158">Określ <see langword="null" /> , aby usunąć istniejące rozszerzenie z <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="470bc-159">Zmienia rozszerzenie ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="470bc-160">Informacje o zmodyfikowanej ścieżce.</span><span class="sxs-lookup"><span data-stu-id="470bc-160">The modified path information.</span></span>  
  
<span data-ttu-id="470bc-161">W przypadku platform klasycznych opartych na <paramref name="path" /> systemie <see langword="null" /> Windows, jeśli jest lub jest pustym ciągiem (""), informacje o ścieżce są zwracane niemodyfikowane.</span><span class="sxs-lookup"><span data-stu-id="470bc-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="470bc-162">Jeśli <paramref name="extension" /> jest<see langword="null" />, zwracany ciąg zawiera określoną ścieżkę z usuniętym rozszerzeniem.</span><span class="sxs-lookup"><span data-stu-id="470bc-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="470bc-163">Jeśli <paramref name="path" /> nie ma rozszerzenia i <paramref name="extension" /> nie <see langword="null" />jest, zwracany <paramref name="path" />ciąg ścieżki zawiera <paramref name="extension" /> dołączenie na końcu.</span><span class="sxs-lookup"><span data-stu-id="470bc-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-164">Jeśli ani nie `ChangeExtension` zawiera kropki (.), program dodaje okres. `extension` `path`</span><span class="sxs-lookup"><span data-stu-id="470bc-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="470bc-165">`extension` Parametr może zawierać wiele okresów i wszystkie prawidłowe ścieżki oraz może mieć dowolną długość.</span><span class="sxs-lookup"><span data-stu-id="470bc-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="470bc-166">Jeśli `extension` jest `null`, zwracany`path` ciąg zawiera zawartość z ostatnim kropką i wszystkie znaki po usunięciu.</span><span class="sxs-lookup"><span data-stu-id="470bc-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="470bc-167">Jeśli `extension` jest pustym ciągiem, zwracany ciąg ścieżki zawiera `path` zawartość z dowolnymi znakami po ostatnim okresie.</span><span class="sxs-lookup"><span data-stu-id="470bc-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="470bc-168">Jeśli `path` nie ma rozszerzenia i `extension` nie `null`jest, zwracany ciąg zawiera `path`. `extension`</span><span class="sxs-lookup"><span data-stu-id="470bc-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="470bc-169">Jeśli `extension` nie`null` jest i nie zawiera kropki wiodącej, zostanie dodany okres.</span><span class="sxs-lookup"><span data-stu-id="470bc-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="470bc-170">Jeśli `path` zawiera wiele rozszerzeń rozdzielonych przez wiele okresów, zwracany ciąg zawiera `path` zawartość z ostatnim kropką i wszystkie znaki po zastąpieniu przez `extension`.</span><span class="sxs-lookup"><span data-stu-id="470bc-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="470bc-171">Na przykład jeśli `path` jest "\Dir1\examples\pathtests.CSX.txt" i `extension` jest "CS", modyfikowaną ścieżką jest "\Dir1\examples\pathtests.CSX.cs".</span><span class="sxs-lookup"><span data-stu-id="470bc-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="470bc-172">Nie można sprawdzić, czy zwracane wyniki są prawidłowe we wszystkich scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="470bc-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="470bc-173">Na przykład, jeśli `path` jest pusty, `extension` jest dołączony.</span><span class="sxs-lookup"><span data-stu-id="470bc-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="470bc-174">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-175">Poniższy przykład ilustruje użycie `ChangeExtension` metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-176"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-177">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-178">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-179">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-180">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="470bc-181">Łączy ciągi w ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="470bc-182">Ta metoda jest przeznaczona do łączenia poszczególnych ciągów w jeden ciąg, który reprezentuje ścieżkę pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="470bc-183">Jeśli jednak argument inny niż pierwszy zawiera ścieżkę do katalogu głównego, wszystkie poprzednie składniki ścieżki są ignorowane, a zwrócony ciąg rozpoczyna się od tego składnika ścieżki root.</span><span class="sxs-lookup"><span data-stu-id="470bc-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="470bc-184">Jako alternatywę dla `Combine` metody należy rozważyć <xref:System.IO.Path.Join%2A> użycie metod lub <xref:System.IO.Path.TryJoin%2A> .</span><span class="sxs-lookup"><span data-stu-id="470bc-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="470bc-185">Ta metoda zakłada, że pierwszy argument jest ścieżką bezwzględną i że następujący argument lub argumenty są ścieżkami względnymi.</span><span class="sxs-lookup"><span data-stu-id="470bc-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="470bc-186">Jeśli tak się nie dzieje, a zwłaszcza jeśli wszystkie kolejne argumenty są ciągami wejściowymi przez użytkownika, wywołaj <xref:System.IO.Path.Join%2A> metodę <xref:System.IO.Path.TryJoin%2A> or.</span><span class="sxs-lookup"><span data-stu-id="470bc-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="470bc-187">Tablica części ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="470bc-188">Łączy tablicę ciągów w ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="470bc-189">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="470bc-190">`paths`powinna być tablicą części ścieżki do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="470bc-191">Jeśli jedna z kolejnych ścieżek jest ścieżką bezwzględną, wówczas Operacja łączenia resetuje się, rozpoczynając od tej ścieżki bezwzględnej, odrzucając wszystkie poprzednie ścieżki połączone.</span><span class="sxs-lookup"><span data-stu-id="470bc-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="470bc-192">Jeśli którykolwiek element w `paths` , ale nie jest dyskiem i nie kończy się <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar> znakiem `Combine` lub, Metoda dodaje <xref:System.IO.Path.DirectorySeparatorChar> znak między tym elementem a następną.</span><span class="sxs-lookup"><span data-stu-id="470bc-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="470bc-193">Należy pamiętać, że jeśli element zostanie zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, `Combine` metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwaną wartość.</span><span class="sxs-lookup"><span data-stu-id="470bc-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="470bc-194">Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="470bc-195">Ciągi o zerowej długości są pomijane w połączonej ścieżce.</span><span class="sxs-lookup"><span data-stu-id="470bc-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="470bc-196">Parametry nie są analizowane, jeśli mają biały znak.</span><span class="sxs-lookup"><span data-stu-id="470bc-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="470bc-197">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-198">Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="470bc-199">Z `Combine` tego względu pomyślnie interpretuje metodę.</span><span class="sxs-lookup"><span data-stu-id="470bc-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="470bc-200">Poniższy przykład łączy tablicę ciągów w ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-201">Jeden z ciągów w tablicy zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-202">Jeden z ciągów w tablicy jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-203">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-204">Pierwsza ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-205">Druga ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="470bc-206">Łączy dwa ciągi w ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="470bc-207">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-207">The combined paths.</span></span> <span data-ttu-id="470bc-208">Jeśli jedna z określonych ścieżek jest ciągiem o zerowej długości, Metoda ta zwraca drugą ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="470bc-209">Jeśli <paramref name="path2" /> zawiera ścieżkę bezwzględną, ta metoda <paramref name="path2" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="470bc-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-210">Jeśli `path1` nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy z prawidłowym znakiem separatora, jak zdefiniowano <xref:System.IO.Path.AltDirectorySeparatorChar>w <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> lub, jest dołączony `path1` do przed połączeniem.</span><span class="sxs-lookup"><span data-stu-id="470bc-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="470bc-211">Należy pamiętać, `path1` że jeśli program zostanie zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla `Combine` platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="470bc-212">Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="470bc-213">Jeśli `path2` nie zawiera elementu głównego (na przykład jeśli `path2` nie zaczyna się od znaku separatora lub specyfikacji dysku), wynikiem jest połączenie dwóch ścieżek z pozostałym znakiem separatora.</span><span class="sxs-lookup"><span data-stu-id="470bc-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="470bc-214">Jeśli `path2` zawiera element główny, `path2` jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="470bc-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="470bc-215">Parametry nie są analizowane, jeśli mają biały znak.</span><span class="sxs-lookup"><span data-stu-id="470bc-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="470bc-216">W związku z `path2` tym, jeśli zawiera biały znak (na przykład "\file.txt") <xref:System.IO.Path.Combine%2A> , metoda dołącza `path1` `path2` do zamiast tylko `path2`zwracanego.</span><span class="sxs-lookup"><span data-stu-id="470bc-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="470bc-217">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-218">Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="470bc-219">Z `Combine` tego względu pomyślnie interpretuje metodę.</span><span class="sxs-lookup"><span data-stu-id="470bc-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="470bc-220">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-221">Poniższy przykład ilustruje użycie `Combine` metody na platformie komputerowej opartej na systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-222"><paramref name="path1" />lub <paramref name="path2" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-223"><paramref name="path1" />lub <paramref name="path2" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-224">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-225">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-226">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-227">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-228">Pierwsza ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-229">Druga ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-230">Trzecia ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="470bc-231">Łączy trzy ciągi w ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="470bc-232">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-233">`path1`powinna być ścieżką bezwzględną (na przykład "d:\archives" lub\\"\archives\public").</span><span class="sxs-lookup"><span data-stu-id="470bc-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="470bc-234">Jeśli `path2` lub`path3` jest również ścieżką bezwzględną, Operacja łączenia odrzuca wszystkie wcześniej połączone ścieżki i przywraca tę ścieżkę bezwzględną.</span><span class="sxs-lookup"><span data-stu-id="470bc-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="470bc-235">Ciągi o zerowej długości są pomijane w połączonej ścieżce.</span><span class="sxs-lookup"><span data-stu-id="470bc-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="470bc-236">Jeśli `path1` lub <xref:System.IO.Path.AltDirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> `path1` <xref:System.IO.Path.VolumeSeparatorChar>nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy prawidłowym znakiem separatora, jak zdefiniowano w,, lub, jest dołączany do lub `path2` `path2` przed połączeniem.</span><span class="sxs-lookup"><span data-stu-id="470bc-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="470bc-237">Należy zauważyć, `path1` że `path2` Jeśli lub kończący się znakiem separatora ścieżki, który nie jest odpowiedni dla `Combine` platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="470bc-238">Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="470bc-239">Jeśli `path2` nie zawiera elementu głównego (na przykład jeśli `path2` nie zaczyna się od znaku separatora lub specyfikacji dysku), wynikiem jest połączenie dwóch ścieżek z pozostałym znakiem separatora.</span><span class="sxs-lookup"><span data-stu-id="470bc-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="470bc-240">Jeśli `path2` zawiera element główny, `path2` jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="470bc-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="470bc-241">Parametry nie są analizowane, jeśli mają biały znak.</span><span class="sxs-lookup"><span data-stu-id="470bc-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="470bc-242">W `path2` `path2` `path1`związku z tym, jeśli zawiera biały znak (na przykład "\file.txt"), Metoda dodaje do. <xref:System.IO.Path.Combine%2A></span><span class="sxs-lookup"><span data-stu-id="470bc-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="470bc-243">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-244">Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="470bc-245">Z `Combine` tego względu pomyślnie interpretuje metodę.</span><span class="sxs-lookup"><span data-stu-id="470bc-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-246">Poniższy przykład łączy trzy ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-247"><paramref name="path1" />, <paramref name="path2" /> <see cref="M:System.IO.Path.GetInvalidPathChars" />lub <paramref name="path3" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w.</span><span class="sxs-lookup"><span data-stu-id="470bc-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-248"><paramref name="path1" />, <paramref name="path2" />, lub <paramref name="path3" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-249">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-250">Pierwsza ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-251">Druga ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-252">Trzecia ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="470bc-253">Czwarta ścieżka do połączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="470bc-254">Łączy cztery ciągi w ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="470bc-255">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-256">`path1`powinna być ścieżką bezwzględną (na przykład "d:\archives" lub\\"\archives\public"). Jeśli jedna z kolejnych ścieżek jest również ścieżką bezwzględną, Operacja łączenia odrzuca wszystkie wcześniej połączone ścieżki i resetuje do tej ścieżki bezwzględnej.</span><span class="sxs-lookup"><span data-stu-id="470bc-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="470bc-257">Ciągi o zerowej długości są pomijane w połączonej ścieżce.</span><span class="sxs-lookup"><span data-stu-id="470bc-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="470bc-258">Jeśli `path1`, <xref:System.IO.Path.AltDirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.VolumeSeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> lub nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy z prawidłowym znakiem separatora określonym w,, lub, jest do niego dołączony `path3` `path2` przed połączeniem.</span><span class="sxs-lookup"><span data-stu-id="470bc-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="470bc-259">Należy pamiętać, `path1`że `path2`Jeśli, `path3` lub kończące się znakiem separatora ścieżki, który `Combine` nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="470bc-260">Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="470bc-261">Jeśli `path2` nie zawiera elementu głównego (na przykład jeśli `path2` nie zaczyna się od znaku separatora lub specyfikacji dysku), wynikiem jest połączenie dwóch ścieżek z pozostałym znakiem separatora.</span><span class="sxs-lookup"><span data-stu-id="470bc-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="470bc-262">Jeśli `path2` zawiera element główny, `path2` jest zwracany.</span><span class="sxs-lookup"><span data-stu-id="470bc-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="470bc-263">Parametry nie są analizowane, jeśli mają biały znak.</span><span class="sxs-lookup"><span data-stu-id="470bc-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="470bc-264">W `path2` `path2` `path1`związku z tym, jeśli zawiera biały znak (na przykład "\file.txt"), Metoda dodaje do. <xref:System.IO.Path.Combine%2A></span><span class="sxs-lookup"><span data-stu-id="470bc-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="470bc-265">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-266">Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="470bc-267">Z `Combine` tego względu pomyślnie interpretuje metodę.</span><span class="sxs-lookup"><span data-stu-id="470bc-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-268">Poniższy przykład łączy cztery ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> <see cref="M:System.IO.Path.GetInvalidPathChars" />lub zawieraconajmniejjedennieprawidłowyznakzdefiniowanyw<paramref name="path4" /> .</span><span class="sxs-lookup"><span data-stu-id="470bc-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, lub <paramref name="path4" /> jest .<see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="470bc-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-271">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="470bc-272">Zawiera znak specyficzny dla platformy używany do oddzielania poziomów katalogów w ciągu ścieżki, który odzwierciedla hierarchiczną organizację systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="470bc-273"><xref:System.IO.Path.AltDirectorySeparatorChar>i `DirectorySeparatorChar` są prawidłowe w celu oddzielenia poziomów katalogów w ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="470bc-274">W przypadku korzystania z platformy .NET Core do tworzenia aplikacji uruchamianych na wielu platformach:</span><span class="sxs-lookup"><span data-stu-id="470bc-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="470bc-275">Jeśli wolisz pokodować znak separatora katalogu, należy użyć znaku ukośnika (`/`).</span><span class="sxs-lookup"><span data-stu-id="470bc-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="470bc-276">Jest to jedyny rozpoznany znak separatora katalogu w systemach UNIX, ponieważ dane wyjściowe z przykładu są wyświetlane i są <xref:System.IO.Path.AltDirectorySeparatorChar> w systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="470bc-277">Użyj łączenia ciągów, aby dynamicznie pobrać znak separatora ścieżki w czasie wykonywania i dołączyć go do ścieżek systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="470bc-278">Na przykład</span><span class="sxs-lookup"><span data-stu-id="470bc-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="470bc-279">Możesz również pobrać wartość z <xref:System.IO.Path.AltDirectorySeparatorChar> właściwości, ponieważ jest ona taka sama w systemach Windows i UNX.</span><span class="sxs-lookup"><span data-stu-id="470bc-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="470bc-280"><xref:System.IO.Path.AltDirectorySeparatorChar> Pobierz właściwość</span><span class="sxs-lookup"><span data-stu-id="470bc-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="470bc-281">Jeśli aplikacja nie jest międzyplatformowa, można użyć separatora odpowiednie dla danego systemu.</span><span class="sxs-lookup"><span data-stu-id="470bc-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="470bc-282">Poniższy przykład wyświetla <xref:System.IO.Path> wartości pól w systemie Windows i w systemach UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="470bc-283">Należy pamiętać, że system Windows obsługuje ukośnik (zwracany przez <xref:System.IO.Path.AltDirectorySeparatorChar> pole) lub ukośnik odwrotny (który jest zwracany <xref:System.IO.Path.DirectorySeparatorChar> przez pole) jako znaki separatora ścieżki, natomiast systemy z systemem UNIX obsługują tylko ukośnik.</span><span class="sxs-lookup"><span data-stu-id="470bc-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-284">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-285">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-286">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-287">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-288">Ścieżka do analizy.</span><span class="sxs-lookup"><span data-stu-id="470bc-288">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="470bc-289">Zwraca wartość wskazującą, czy ścieżka, określona jako zakres tylko do odczytu, zostaje zakończona w separatorze katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-289">Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="470bc-290"><see langword="true" />Jeśli ścieżka zostanie zakończona w separatorze katalogu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="470bc-290"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-291">Ścieżka do analizy.</span><span class="sxs-lookup"><span data-stu-id="470bc-291">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="470bc-292">Zwraca wartość wskazującą, czy określona ścieżka zostanie zakończona w separatorze katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-292">Returns a value that indicates whether the specified path ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="470bc-293"><see langword="true" />Jeśli ścieżka zostanie zakończona w separatorze katalogu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="470bc-293"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-294">Ścieżka, z której mają zostać pobrane informacje o katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-294">The path to retrieve the directory information from.</span></span></param>
        <summary><span data-ttu-id="470bc-295">Zwraca informacje o katalogu dla określonej ścieżki reprezentowanej przez zakres znaków.</span><span class="sxs-lookup"><span data-stu-id="470bc-295">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="470bc-296">Informacje o katalogu <paramref name="path" />dla lub pustego zakresu, <paramref name="path" /> Jeśli <see langword="null" />jest, pusty \, zakres lub główny (na przykład C:, lub \\server\share).</span><span class="sxs-lookup"><span data-stu-id="470bc-296">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-297">W przeciwieństwie do przeciążenia ciągów ta metoda nie normalizuje separatorów katalogów.</span><span class="sxs-lookup"><span data-stu-id="470bc-297">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-298">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-298">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-299">Ścieżka pliku lub katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-299">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="470bc-300">Zwraca informacje o katalogu dla podanego ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-300">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="470bc-301">Informacje o katalogu <paramref name="path" />dla <paramref name="path" /> lub <see langword="null" /> wskazuje katalog główny lub ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="470bc-301">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="470bc-302">Zwraca <see cref="F:System.String.Empty" /> wartość <paramref name="path" /> , jeśli nie zawiera informacji o katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-302">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-303">W większości przypadków ciąg zwracany przez tę metodę składa się ze wszystkich znaków w ścieżce do, ale nie do ostatniego <xref:System.IO.Path.DirectorySeparatorChar> lub. <xref:System.IO.Path.AltDirectorySeparatorChar></span><span class="sxs-lookup"><span data-stu-id="470bc-303">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="470bc-304">Jeśli ścieżka składa się z katalogu głównego, na przykład "c:\\", zwracana jest wartość null.</span><span class="sxs-lookup"><span data-stu-id="470bc-304">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="470bc-305">Należy zauważyć, że ta metoda nie obsługuje ścieżek przy użyciu "File:".</span><span class="sxs-lookup"><span data-stu-id="470bc-305">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="470bc-306">Ponieważ zwracana ścieżka nie zawiera <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, przekazanie <xref:System.IO.Path.GetDirectoryName%2A> zwróconej ścieżki z powrotem do metody spowoduje obcinanie jednego poziomu folderu dla każdego kolejnego wywołania w ciągu wynikowym.</span><span class="sxs-lookup"><span data-stu-id="470bc-306">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="470bc-307">Na przykład przekazanie ścieżki "C:\Directory\SubDirectory\test.txt" do <xref:System.IO.Path.GetDirectoryName%2A> metody zwróci wartość "C:\Directory\SubDirectory".</span><span class="sxs-lookup"><span data-stu-id="470bc-307">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="470bc-308">Przekazanie ciągu "C:\Directory\SubDirectory" do <xref:System.IO.Path.GetDirectoryName%2A> spowoduje "C:\Directory".</span><span class="sxs-lookup"><span data-stu-id="470bc-308">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="470bc-309">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-309">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-310">Poniższy przykład ilustruje użycie `GetDirectoryName` metody na platformie komputerowej opartej na systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-310">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-311"><paramref name="path" /> Parametr zawiera nieprawidłowe znaki, jest pusty lub zawiera tylko znaki odstępu.</span><span class="sxs-lookup"><span data-stu-id="470bc-311">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="470bc-312">W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.IO.IOException" />klasy bazowej, zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="470bc-312">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="470bc-313"><paramref name="path" /> Parametr jest dłuższy niż zdefiniowana w systemie długość maksymalna.</span><span class="sxs-lookup"><span data-stu-id="470bc-313">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-314">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-314">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-315">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-315">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-316">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-316">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-317">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-317">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-318">Ścieżka pliku, z której ma zostać pobrane rozszerzenie.</span><span class="sxs-lookup"><span data-stu-id="470bc-318">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="470bc-319">Zwraca rozszerzenie ścieżki pliku reprezentowanej przez zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="470bc-319">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="470bc-320">Rozszerzenie określonej ścieżki (łącznie z kropką, ".") lub <see cref="P:System.ReadOnlySpan`1.Empty" /> Jeśli <paramref name="path" /> nie ma informacji o rozszerzeniu.</span><span class="sxs-lookup"><span data-stu-id="470bc-320">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="470bc-321">Ta metoda uzyskuje rozszerzenie `path` , wyszukując `path` kropkę ("."), rozpoczynając od ostatniego znaku w zakresie tylko do odczytu i kontynuując do pierwszego znaku.</span><span class="sxs-lookup"><span data-stu-id="470bc-321">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="470bc-322">Jeśli okres zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar> znakiem lub <xref:System.IO.Path.AltDirectorySeparatorChar> , zwracany zakres tylko do odczytu zawiera kropkę i znaki <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> po nim; w przeciwnym razie zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="470bc-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-323">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-323">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-324">Ciąg ścieżki, z którego ma zostać pobrane rozszerzenie.</span><span class="sxs-lookup"><span data-stu-id="470bc-324">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="470bc-325">Zwraca rozszerzenie (łącznie z kropką ".") określonego ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-325">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="470bc-326">Rozszerzenie określonej ścieżki (łącznie z kropką "."), lub <see langword="null" />lub. <see cref="F:System.String.Empty" /></span><span class="sxs-lookup"><span data-stu-id="470bc-326">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="470bc-327">Jeśli <paramref name="path" /> jest <see langword="null" />, zwraca<see cref="M:System.IO.Path.GetExtension(System.String)" /> . <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="470bc-327">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="470bc-328">Jeśli <paramref name="path" /> nie ma informacji o rozszerzeniu <see cref="M:System.IO.Path.GetExtension(System.String)" /> , <see cref="F:System.String.Empty" />zwraca.</span><span class="sxs-lookup"><span data-stu-id="470bc-328">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="470bc-329">Ta metoda uzyskuje rozszerzenie `path` , wyszukując `path` kropkę (.), rozpoczynając od ostatniego znaku w `path` i kontynuując do pierwszego znaku.</span><span class="sxs-lookup"><span data-stu-id="470bc-329">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="470bc-330">Jeśli okres zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar> znakiem lub <xref:System.IO.Path.AltDirectorySeparatorChar> , zwracany ciąg zawiera kropkę i znaki <xref:System.String.Empty?displayProperty=nameWithType> po nim; w przeciwnym razie zwraca wartość.</span><span class="sxs-lookup"><span data-stu-id="470bc-330">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="470bc-331">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-331">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="470bc-332">Poniższy przykład ilustruje użycie `GetExtension` metody na platformie komputerowej opartej na systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-332">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-333"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-333"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-334">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-334">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-335">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-335">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-336">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-336">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-337">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-337">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-338">Zakres tylko do odczytu, który zawiera ścieżkę, z której ma zostać uzyskana nazwa i rozszerzenie pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-338">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="470bc-339">Zwraca nazwę pliku i rozszerzenie ścieżki pliku reprezentowanej przez zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="470bc-339">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="470bc-340">Znaki po ostatnim znaku separatora katalogu w <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-340">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="470bc-341">Zwrócony zakres tylko do odczytu zawiera znaki ścieżki, które obserwują ostatni separator w `path`.</span><span class="sxs-lookup"><span data-stu-id="470bc-341">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="470bc-342">Jeśli ostatni znak w `path` jest woluminem lub znakiem separatora katalogu, metoda zwraca. <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="470bc-342">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="470bc-343">Jeśli `path` nie zawiera znaku separatora, metoda zwraca `path`.</span><span class="sxs-lookup"><span data-stu-id="470bc-343">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-344">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-344">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-345">Ciąg ścieżki, z którego ma zostać uzyskana nazwa i rozszerzenie pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-345">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="470bc-346">Zwraca nazwę pliku i rozszerzenie określonego ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-346">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="470bc-347">Znaki po ostatnim znaku separatora katalogu w <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-347">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="470bc-348">Jeśli ostatni znak <paramref name="path" /> jest znakiem separatora katalogu lub woluminu, ta metoda zwraca <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-348">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="470bc-349">Jeśli <paramref name="path" /> <see langword="null" />jest <see langword="null" />, ta metoda zwraca.</span><span class="sxs-lookup"><span data-stu-id="470bc-349">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="470bc-350">Zwracana wartość jest `null` , jeśli ścieżka pliku to `null`.</span><span class="sxs-lookup"><span data-stu-id="470bc-350">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="470bc-351">Znaki separatora używane do określenia początku nazwy pliku to <xref:System.IO.Path.DirectorySeparatorChar> i. <xref:System.IO.Path.AltDirectorySeparatorChar></span><span class="sxs-lookup"><span data-stu-id="470bc-351">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="470bc-352">Ponieważ *\\* jest to legalna nazwa pliku w systemie `GetFileName` UNIX, działające w ramach platform opartych na systemie UNIX nie może prawidłowo zwrócić nazwy pliku z ścieżki opartej na systemie Windows, takiej jak `GetFileName` *C:\\\\mydir. ext*, ale Uruchamianie w ramach platform opartych na systemie Windows może prawidłowo zwrócić nazwę pliku z ścieżki opartej na systemie UNIX, takiej jak */tmp/myfile.ext*, `GetFileName` więc zachowanie metody nie jest ściśle takie samo na platformach opartych na systemie UNIX i Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-352">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="470bc-353">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-353">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-354">Poniższy przykład ilustruje zachowanie `GetFileName` metody na platformie pulpitu opartej na systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-354">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-355"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-355"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-356">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-356">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-357">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-357">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-358">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-358">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-359">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-359">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-360">Zakres tylko do odczytu, który zawiera ścieżkę, z której ma zostać uzyskana nazwa pliku bez rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-360">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="470bc-361">Zwraca nazwę pliku bez rozszerzenia ścieżki pliku reprezentowanego przez zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="470bc-361">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="470bc-362">Znaki w zakresie tylko do odczytu zwrócone przez <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus ostatni kropka (.) i wszystkie znaki po nim.</span><span class="sxs-lookup"><span data-stu-id="470bc-362">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-363">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-363">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-364">Ścieżka pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-364">The path of the file.</span></span></param>
        <summary><span data-ttu-id="470bc-365">Zwraca nazwę pliku określonego ciągu ścieżki bez rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-365">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="470bc-366">Ciąg zwracany przez <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus ostatni kropka (.) i wszystkie znaki po nim.</span><span class="sxs-lookup"><span data-stu-id="470bc-366">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-367">Ta metoda nie sprawdza, czy ścieżka lub nazwa pliku istnieje.</span><span class="sxs-lookup"><span data-stu-id="470bc-367">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="470bc-368">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-368">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-369">Poniższy przykład ilustruje użycie `GetFileNameWithoutExtension` metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-369">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-370"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-370"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-371">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-371">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-372">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-372">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-373">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-373">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-374">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-374">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-375">Plik lub katalog, dla którego mają zostać uzyskane informacje o ścieżce bezwzględnej.</span><span class="sxs-lookup"><span data-stu-id="470bc-375">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="470bc-376">Zwraca ścieżkę bezwzględną dla podanego ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-376">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="470bc-377">W pełni kwalifikowana lokalizacja <paramref name="path" />, taka jak "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="470bc-377">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="470bc-378">Ścieżka bezwzględna zawiera wszystkie informacje wymagane do zlokalizowania pliku lub katalogu w systemie.</span><span class="sxs-lookup"><span data-stu-id="470bc-378">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="470bc-379">Plik lub katalog określony przez `path` nie musi istnieć.</span><span class="sxs-lookup"><span data-stu-id="470bc-379">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="470bc-380">Na przykład jeśli *c:\temp\newdir* jest bieżącym katalogiem, wywoływanie `GetFullPath` nazwy pliku, takiej jak *test. txt* zwraca *c:\temp\newdir\test.txt*.</span><span class="sxs-lookup"><span data-stu-id="470bc-380">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="470bc-381">Plik nie musi istnieć.</span><span class="sxs-lookup"><span data-stu-id="470bc-381">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="470bc-382">Jeśli `path` jest ścieżką względną, to Przeciążenie zwraca w pełni kwalifikowaną ścieżkę, która może opierać się na bieżącym dysku i bieżącym katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-382">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="470bc-383">Bieżący dysk i bieżący katalog można zmienić w dowolnym momencie, gdy aplikacja jest uruchamiana.</span><span class="sxs-lookup"><span data-stu-id="470bc-383">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="470bc-384">W związku z tym nie można określić z góry ścieżki zwróconej przez to przeciążenie.</span><span class="sxs-lookup"><span data-stu-id="470bc-384">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="470bc-385">Aby zwrócić deterministyczną ścieżkę, wywołaj <xref:System.IO.Path.GetFullPath(System.String,System.String)> Przeciążenie.</span><span class="sxs-lookup"><span data-stu-id="470bc-385">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="470bc-386">Możesz również wywołać metodę, <xref:System.IO.Path.IsPathFullyQualified%2A> aby określić, czy ścieżka jest w pełni kwalifikowana lub względna i czy `GetFullPath` jest to wymagane.</span><span class="sxs-lookup"><span data-stu-id="470bc-386">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="470bc-387">Jeśli `path` jednak istnieje, obiekt wywołujący musi mieć uprawnienie do uzyskiwania informacji o ścieżce dla `path`.</span><span class="sxs-lookup"><span data-stu-id="470bc-387">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="470bc-388">Należy zauważyć, że w przeciwieństwie do <xref:System.IO.Path> większości elementów członkowskich klasy, ta metoda uzyskuje dostęp do systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-388">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="470bc-389">Ta metoda używa bieżącego katalogu i informacji o bieżącym woluminie do pełnej `path`kwalifikacji.</span><span class="sxs-lookup"><span data-stu-id="470bc-389">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="470bc-390">W przypadku określenia nazwy pliku tylko w programie `path` `GetFullPath` funkcja zwraca w pełni kwalifikowaną ścieżkę bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-390">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="470bc-391">Jeśli przekażesz krótką nazwę pliku, zostanie ona rozszerzona na długą nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-391">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="470bc-392">Jeśli ścieżka nie zawiera żadnych znaków znaczących, jest nieprawidłowa, chyba że zawiera jeden lub więcej znaków ".", po których następuje dowolna liczba spacji; następnie zostanie on przeanalizowany jako "." lub "..".</span><span class="sxs-lookup"><span data-stu-id="470bc-392">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="470bc-393">Program .NET Core 1,1 i jego nowsze wersje oraz .NET Framework 4.6.2 i nowsze wersje obsługują również ścieżki zawierające nazwy urządzeń, takie jak\\"? \c\":.</span><span class="sxs-lookup"><span data-stu-id="470bc-393">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="470bc-394">Aby uzyskać więcej informacji na temat formatów ścieżki plików w systemie Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-394">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="470bc-395">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-395">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="470bc-396">Poniższy przykład ilustruje `GetFullPath` metodę na platformie pulpitu opartej na systemie Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-396">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-397"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-397"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="470bc-398">—lub—</span><span class="sxs-lookup"><span data-stu-id="470bc-398">-or-</span></span> 
<span data-ttu-id="470bc-399">System nie może pobrać ścieżki bezwzględnej.</span><span class="sxs-lookup"><span data-stu-id="470bc-399">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="470bc-400">Obiekt wywołujący nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="470bc-400">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-401"><paramref name="path" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-401"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="470bc-402"><paramref name="path" />zawiera dwukropek (":"), który nie jest częścią identyfikatora woluminu (na przykład "c:\\").</span><span class="sxs-lookup"><span data-stu-id="470bc-402"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="470bc-403">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</span><span class="sxs-lookup"><span data-stu-id="470bc-403">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="470bc-404">w celu uzyskania dostępu do ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-404">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-405">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-405">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-406">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-407">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-408">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-409">Ścieżka względna do łączenia <paramref name="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-409">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="470bc-410">Początek w pełni kwalifikowanej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-410">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="470bc-411">Zwraca ścieżkę bezwzględną z w pełni kwalifikowanej ścieżki podstawowej i ścieżki względnej.</span><span class="sxs-lookup"><span data-stu-id="470bc-411">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="470bc-412">Ścieżka bezwzględna.</span><span class="sxs-lookup"><span data-stu-id="470bc-412">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="470bc-413">Jeśli `path` jest pustą ścieżką, metoda zwraca `basePath`.</span><span class="sxs-lookup"><span data-stu-id="470bc-413">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="470bc-414">Jeśli `path` jest w pełni kwalifikowaną ścieżką, Metoda przechodzi `path` do <xref:System.IO.Path.GetFullPath(System.String)> metody i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="470bc-414">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="470bc-415">Użyj tej metody, aby zwrócić deterministyczną ścieżkę na podstawie określonego woluminu i katalogu głównego, gdy używasz ścieżek względnych.</span><span class="sxs-lookup"><span data-stu-id="470bc-415">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="470bc-416">Użycie wstępnie zdefiniowanego `basePath` , a nie jednego w oparciu o bieżące osłony katalogu dysków przed niechcianymi ścieżkami plików spowodowane nieoczekiwanymi zmianami w bieżącym dysku i katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-416">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="470bc-417">Przykład</span><span class="sxs-lookup"><span data-stu-id="470bc-417">Example</span></span>

<span data-ttu-id="470bc-418">W poniższym przykładzie zdefiniowano zmienną, `basePath`która reprezentuje bieżący katalog aplikacji.</span><span class="sxs-lookup"><span data-stu-id="470bc-418">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="470bc-419">Następnie przekazuje go do `GetFullPath` metody, aby uzyskać w pełni kwalifikowaną ścieżkę do katalogu danych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="470bc-419">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-420"><paramref name="path" />lub <paramref name="basePath" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-420"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-421"><paramref name="basePath" />nie jest w pełni kwalifikowaną ścieżką.</span><span class="sxs-lookup"><span data-stu-id="470bc-421"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="470bc-422">—lub—</span><span class="sxs-lookup"><span data-stu-id="470bc-422">-or-</span></span>

<span data-ttu-id="470bc-423"><paramref name="path" />lub <paramref name="basePath" /> zawiera nieprawidłowe znaki ścieżki, takie jak U + 0000.</span><span class="sxs-lookup"><span data-stu-id="470bc-423"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="470bc-424">Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-424">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="470bc-425">Tablica zawierająca znaki, które nie są dozwolone w nazwach plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-425">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-426">Tablica zwracana z tej metody nie powinna zawierać pełnego zestawu znaków, które są nieprawidłowe w nazwach plików i katalogów.</span><span class="sxs-lookup"><span data-stu-id="470bc-426">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="470bc-427">Pełny zestaw nieprawidłowych znaków może różnić się w zależności od systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-427">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="470bc-428">Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać znaki ASCII/Unicode od 1 do 31, a także cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i Tab (\t).</span><span class="sxs-lookup"><span data-stu-id="470bc-428">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-429">Poniższy przykład ilustruje <xref:System.IO.Path.GetInvalidFileNameChars%2A> metodę <xref:System.IO.Path.GetInvalidPathChars%2A> i metodę pobierania nieprawidłowych znaków.</span><span class="sxs-lookup"><span data-stu-id="470bc-429">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="470bc-430">Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach ścieżek.</span><span class="sxs-lookup"><span data-stu-id="470bc-430">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="470bc-431">Tablica zawierająca znaki, które nie są dozwolone w nazwach ścieżek.</span><span class="sxs-lookup"><span data-stu-id="470bc-431">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-432">Tablica zwracana z tej metody nie powinna zawierać pełnego zestawu znaków, które są nieprawidłowe w nazwach plików i katalogów.</span><span class="sxs-lookup"><span data-stu-id="470bc-432">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="470bc-433">Pełny zestaw nieprawidłowych znaków może różnić się w zależności od systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-433">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="470bc-434">Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać znaki ASCII/Unicode od 1 do 31, a także cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i Tab (\t).</span><span class="sxs-lookup"><span data-stu-id="470bc-434">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-435">Poniższy przykład ilustruje <xref:System.IO.Path.GetInvalidFileNameChars%2A> metodę <xref:System.IO.Path.GetInvalidPathChars%2A> i metodę pobierania nieprawidłowych znaków.</span><span class="sxs-lookup"><span data-stu-id="470bc-435">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-436">Ścieżka, z której mają zostać uzyskane informacje o katalogu głównym.</span><span class="sxs-lookup"><span data-stu-id="470bc-436">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="470bc-437">Pobiera informacje z katalogu głównego ze ścieżki zawartej w określonym zakresie znaków.</span><span class="sxs-lookup"><span data-stu-id="470bc-437">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="470bc-438">Zakres znaków zawierający katalog `path`główny.</span><span class="sxs-lookup"><span data-stu-id="470bc-438">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-439">W przeciwieństwie do przeciążenia ciągów ta metoda nie normalizuje separatorów katalogów.</span><span class="sxs-lookup"><span data-stu-id="470bc-439">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-440">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-440">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-441">Ścieżka, z której mają zostać uzyskane informacje o katalogu głównym.</span><span class="sxs-lookup"><span data-stu-id="470bc-441">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="470bc-442">Pobiera informacje o katalogu głównym określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-442">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="470bc-443"><paramref name="path" />Katalog główny, lub <see langword="null" /> Jeśli <paramref name="path" /> jest <see langword="null" />lub pusty ciąg, jeśli <paramref name="path" /> nie zawiera informacji o katalogu głównym.</span><span class="sxs-lookup"><span data-stu-id="470bc-443">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-444">Ta metoda nie sprawdza, czy ścieżka lub nazwa pliku istnieje.</span><span class="sxs-lookup"><span data-stu-id="470bc-444">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="470bc-445">Możliwe wzorce dla ciągu zwracanego przez tę metodę są następujące:</span><span class="sxs-lookup"><span data-stu-id="470bc-445">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="470bc-446">Pusty ciąg (`path` określa ścieżkę względną na bieżącym dysku lub woluminie).</span><span class="sxs-lookup"><span data-stu-id="470bc-446">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="470bc-447">"\" (`path` określona ścieżka bezwzględna na bieżącym dysku).</span><span class="sxs-lookup"><span data-stu-id="470bc-447">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="470bc-448">"X:" (`path` określona ścieżka względna na dysku, gdzie X reprezentuje literę dysku lub woluminu).</span><span class="sxs-lookup"><span data-stu-id="470bc-448">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="470bc-449">"X:\" (`path` określona ścieżka bezwzględna dla danego dysku).</span><span class="sxs-lookup"><span data-stu-id="470bc-449">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="470bc-450">"\\\ComputerName\SharedFolder" (ścieżka UNC).</span><span class="sxs-lookup"><span data-stu-id="470bc-450">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="470bc-451">"\\\C:"\?(ścieżka urządzenia DOS obsługiwana w programie .NET Core 1,1 i nowszych wersjach oraz w .NET Framework 4.6.2 i nowszych wersjach)\\</span><span class="sxs-lookup"><span data-stu-id="470bc-451">"\\\\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="470bc-452">Aby uzyskać więcej informacji na temat ścieżek plików w systemie Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-452">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="470bc-453">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-453">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="470bc-454">Poniższy przykład ilustruje użycie `GetPathRoot` metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-454">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-455"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-455"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="470bc-456">—lub—</span><span class="sxs-lookup"><span data-stu-id="470bc-456">-or-</span></span> 
 <span data-ttu-id="470bc-457"><see cref="F:System.String.Empty" />zostało przesłane do <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-457"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-458">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-458">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-459">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-459">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-460">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-460">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-461">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-461">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="470bc-462">Zwraca losową nazwę folderu lub nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-462">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="470bc-463">Losowa nazwa folderu lub nazwa pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-463">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-464"><xref:System.IO.Path.GetRandomFileName%2A> Metoda zwraca kryptograficznie silnie losowy ciąg, który może być używany jako nazwa folderu lub nazwa pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-464">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="470bc-465">W przeciwieństwie <xref:System.IO.Path.GetRandomFileName%2A> do <xref:System.IO.Path.GetTempFileName%2A>, nie tworzy pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-465">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="470bc-466">Jeśli zabezpieczenia systemu plików są najważniejsze, ta metoda powinna być używana zamiast <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="470bc-466">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-467">Poniższy przykład przedstawia dane wyjściowe z <xref:System.IO.Path.GetRandomFileName%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-467">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="470bc-468">Ścieżka źródłowa, względem której powinien być powiązany wynik.</span><span class="sxs-lookup"><span data-stu-id="470bc-468">The source path the result should be relative to.</span></span> <span data-ttu-id="470bc-469">Ta ścieżka jest zawsze traktowana jako katalog.</span><span class="sxs-lookup"><span data-stu-id="470bc-469">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="470bc-470">Ścieżka docelowa.</span><span class="sxs-lookup"><span data-stu-id="470bc-470">The destination path.</span></span></param>
        <summary><span data-ttu-id="470bc-471">Zwraca ścieżkę względną z jednej ścieżki do innej.</span><span class="sxs-lookup"><span data-stu-id="470bc-471">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="470bc-472">Ścieżka względna lub <paramref name="path" /> Jeśli ścieżki nie mają tego samego katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="470bc-472">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="470bc-473">Ścieżki są rozwiązywane przez wywołanie <xref:System.IO.Path.GetFullPath%2A> metody przed obliczeniem różnicy.</span><span class="sxs-lookup"><span data-stu-id="470bc-473">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="470bc-474">Metoda używa domyślnego porównania ścieżki plików dla bieżącej platformy (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> dla systemów Windows i MacOS, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> dla systemu Linux.</span><span class="sxs-lookup"><span data-stu-id="470bc-474">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-475"><paramref name="relativeTo" />lub <paramref name="path" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-475"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-476">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-476">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="470bc-477">Tworzy plik tymczasowy o unikatowych nazwach o zerowej liczbie bajtów na dysku i zwraca pełną ścieżkę do tego pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-477">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="470bc-478">Pełna ścieżka pliku tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="470bc-478">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-479">Ta metoda tworzy plik tymczasowy z. Rozszerzenie pliku TMP.</span><span class="sxs-lookup"><span data-stu-id="470bc-479">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="470bc-480">Plik tymczasowy jest tworzony w folderze tymczasowym użytkownika, który jest ścieżką zwróconą przez <xref:System.IO.Path.GetTempPath%2A> metodę.</span><span class="sxs-lookup"><span data-stu-id="470bc-480">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="470bc-481"><xref:System.IO.Path.GetTempFileName%2A> Metoda zostanie <xref:System.IO.IOException> utworzona, jeśli zostanie użyta do utworzenia więcej niż 65535 plików bez usuwania poprzednich plików tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="470bc-481">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="470bc-482">Metoda zostanie wywoływać, <xref:System.IO.IOException> Jeśli nie jest dostępna żadna unikatowa nazwa <xref:System.IO.Path.GetTempFileName%2A> pliku tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="470bc-482">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="470bc-483">Aby rozwiązać ten problem, Usuń wszystkie zbędne pliki tymczasowe.</span><span class="sxs-lookup"><span data-stu-id="470bc-483">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="470bc-484">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-484">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="470bc-485">Wystąpił błąd we/wy, taki jak brak dostępnej unikatowej nazwy pliku tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="470bc-485">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="470bc-486">—lub—</span><span class="sxs-lookup"><span data-stu-id="470bc-486">-or-</span></span>
  
 <span data-ttu-id="470bc-487">Ta metoda nie może utworzyć pliku tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="470bc-487">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="470bc-488">do zapisu w katalogu tymczasowym.</span><span class="sxs-lookup"><span data-stu-id="470bc-488">for writing to the temporary directory.</span></span> <span data-ttu-id="470bc-489">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="470bc-489">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-490">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-490">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-491">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-491">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-492">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-492">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="470bc-493">Zwraca ścieżkę folderu tymczasowego bieżącego użytkownika.</span><span class="sxs-lookup"><span data-stu-id="470bc-493">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="470bc-494">Ścieżka do folderu tymczasowego, kończąca się ukośnikiem odwrotnym.</span><span class="sxs-lookup"><span data-stu-id="470bc-494">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-495">Ta metoda sprawdza istnienie zmiennych środowiskowych w następującej kolejności i używa pierwszej znalezionej ścieżki:</span><span class="sxs-lookup"><span data-stu-id="470bc-495">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="470bc-496">Ścieżka określona przez zmienną środowiskową TMP.</span><span class="sxs-lookup"><span data-stu-id="470bc-496">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="470bc-497">Ścieżka określona przez zmienną środowiskową TEMP.</span><span class="sxs-lookup"><span data-stu-id="470bc-497">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="470bc-498">Ścieżka określona przez zmienną środowiskową profilu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="470bc-498">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="470bc-499">Katalog systemu Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-499">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-500">Poniższy kod ilustruje sposób wywoływania <xref:System.IO.Path.GetTempPath%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-500">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="470bc-501">Ten przykład generuje dane wyjściowe podobne do poniższych.</span><span class="sxs-lookup"><span data-stu-id="470bc-501">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="470bc-502">Obiekt wywołujący nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="470bc-502">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="470bc-503">w przypadku nieograniczonego dostępu do zmiennych środowiskowych.</span><span class="sxs-lookup"><span data-stu-id="470bc-503">for unrestricted access to environment variables.</span></span> <span data-ttu-id="470bc-504">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="470bc-504">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-505">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-505">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-506">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-506">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-507">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-507">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-508">Ścieżka do wyszukiwania rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-508">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="470bc-509">Określa, czy ścieżka reprezentowana przez określony zakres znaków zawiera rozszerzenie nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-509">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="470bc-510"><see langword="true" />Jeśli znaki znajdujące się po ostatnim znaku separatora katalogu lub separator woluminu w ścieżce obejmują kropkę ("."), po której następuje jeden lub więcej znaków; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="470bc-510"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="470bc-511">Końcowy okres w `path` nie jest uważany za rozszerzenie.</span><span class="sxs-lookup"><span data-stu-id="470bc-511">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-512">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-512">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-513">Ścieżka do wyszukiwania rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-513">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="470bc-514">Określa, czy ścieżka zawiera rozszerzenie nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-514">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="470bc-515"><see langword="true" />Jeśli znaki, które są zgodne z ostatnim separatorem\\katalogu (\ lub/) lub separatorem woluminu (:) ścieżka zawiera kropkę (.), po której następuje jeden lub więcej znaków; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="470bc-515"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-516">Począwszy od końca `path`, ta metoda wyszukuje kropkę (.), po którym następuje co najmniej jeden znak.</span><span class="sxs-lookup"><span data-stu-id="470bc-516">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="470bc-517">Jeśli ten wzorzec <xref:System.IO.Path.DirectorySeparatorChar>zostanie znaleziony przed znakiem, <xref:System.IO.Path.AltDirectorySeparatorChar>, <xref:System.IO.Path.VolumeSeparatorChar> lub zostanie napotkany, ta metoda `true`zwraca.</span><span class="sxs-lookup"><span data-stu-id="470bc-517">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="470bc-518">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-518">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-519">Poniższy przykład demonstruje użycie `HasExtension` metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-519">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-520"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-520"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-521">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-521">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-522">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-522">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-523">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-523">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-524">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-524">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="470bc-525">Dostarcza tablicę znaków specyficznych dla platformy, których nie można określić w argumentach ciągu ścieżki przekazane do elementów <see cref="T:System.IO.Path" /> członkowskich klasy.</span><span class="sxs-lookup"><span data-stu-id="470bc-525">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-526">Tablica zwracana z tej metody nie powinna zawierać pełnego zestawu znaków, które są nieprawidłowe w nazwach plików i katalogów.</span><span class="sxs-lookup"><span data-stu-id="470bc-526">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="470bc-527">Pełny zestaw nieprawidłowych znaków może różnić się w zależności od systemu plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-527">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="470bc-528">Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać znaki ASCII/Unicode od 1 do 31, a także cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i Tab (\t).</span><span class="sxs-lookup"><span data-stu-id="470bc-528">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="470bc-529">Nie należy używać <xref:System.IO.Path.InvalidPathChars> , jeśli uważasz, że kod może być wykonywany w tej samej domenie aplikacji co kod niezaufany.</span><span class="sxs-lookup"><span data-stu-id="470bc-529">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="470bc-530"><xref:System.IO.Path.InvalidPathChars>jest tablicą, więc jego elementy mogą być zastępowane.</span><span class="sxs-lookup"><span data-stu-id="470bc-530"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="470bc-531">Jeśli niezaufany kod zastąpi elementy <xref:System.IO.Path.InvalidPathChars>, może dojść do nieprawidłowego kodu w sposób, który mógłby być wykorzystany.</span><span class="sxs-lookup"><span data-stu-id="470bc-531">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-532">Poniższy przykład demonstruje użycie `InvalidPathChars` właściwości.</span><span class="sxs-lookup"><span data-stu-id="470bc-532">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-533">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-533">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-534">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-534">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-535">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-535">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="470bc-536">Zwraca wartość wskazującą, czy ścieżka pliku jest w pełni kwalifikowana.</span><span class="sxs-lookup"><span data-stu-id="470bc-536">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="470bc-537">Przeciążenia `IsPathFullyQualified` metody obsługują ścieżki, które używają <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar> znaków i.</span><span class="sxs-lookup"><span data-stu-id="470bc-537">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="470bc-538">Nie wykonuje żadnych walidacji ścieżki, która jest przenoszona do niej jako argument.</span><span class="sxs-lookup"><span data-stu-id="470bc-538">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="470bc-539">W związku z tym identyfikatory URI są interpretowane jako ścieżki względne i zwracane `false`.</span><span class="sxs-lookup"><span data-stu-id="470bc-539">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="470bc-540">Istnieje różnica między w pełni kwalifikowaną ścieżką (wskazywanym przez `IsPathFullyQualified` metodę) a ścieżką główną (jak wskazano <xref:System.IO.Path.IsPathRooted%2A> w metodzie).</span><span class="sxs-lookup"><span data-stu-id="470bc-540">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="470bc-541">W *pełni kwalifikowana ścieżka* lub *bezwzględna ścieżka* zawsze definiuje dokładną ścieżkę z określonego dysku lub urządzenia do pliku lub katalogu docelowego i nie zależy od bieżącego dysku lub bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-541">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="470bc-542">Na przykład w systemach Windows, *C:/Users/Użytkownik1/Documents/Reports/2019/styczeń/wyróżnienis. PDF* definiuje ścieżkę bezwzględną z katalogu głównego dysku C: do pliku docelowego, *Podświetl. PDF*.</span><span class="sxs-lookup"><span data-stu-id="470bc-542">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="470bc-543">*Ścieżka* z odblokowanym dostępem określa dysk startowy lub katalog główny, ale zależy od bieżącego katalogu (jeśli jest on odblokowany przez określony dysk) lub bieżącego dysku (jeśli jest on odblokowany przez katalog główny).</span><span class="sxs-lookup"><span data-stu-id="470bc-543">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="470bc-544">Poniższy przykład ilustruje różnicę między w pełni kwalifikowanymi ścieżkami i ścieżkami głównymi.</span><span class="sxs-lookup"><span data-stu-id="470bc-544">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-545">Ścieżka pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-545">A file path.</span></span></param>
        <summary><span data-ttu-id="470bc-546">Zwraca wartość wskazującą, czy ścieżka pliku reprezentowana przez określony zakres znaków jest ustalona dla określonego dysku lub ścieżki UNC.</span><span class="sxs-lookup"><span data-stu-id="470bc-546">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="470bc-547"><see langword="true" />Jeśli ścieżka jest stała dla określonego dysku lub ścieżki UNC; <see langword="false" /> Jeśli ścieżka jest określana względem bieżącego dysku lub katalogu roboczego.</span><span class="sxs-lookup"><span data-stu-id="470bc-547"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-548">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-548">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-549">Ścieżka pliku.</span><span class="sxs-lookup"><span data-stu-id="470bc-549">A file path.</span></span></param>
        <summary><span data-ttu-id="470bc-550">Zwraca wartość wskazującą, czy określona ścieżka pliku jest stała dla określonego dysku lub ścieżki UNC.</span><span class="sxs-lookup"><span data-stu-id="470bc-550">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="470bc-551"><see langword="true" />Jeśli ścieżka jest stała dla określonego dysku lub ścieżki UNC; <see langword="false" /> Jeśli ścieżka jest określana względem bieżącego dysku lub katalogu roboczego.</span><span class="sxs-lookup"><span data-stu-id="470bc-551"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-552">Ta metoda obsługuje ścieżki, które używają alternatywnego separatora katalogów.</span><span class="sxs-lookup"><span data-stu-id="470bc-552">This method handles paths that use the alternate directory separator.</span></span> <span data-ttu-id="470bc-553">Jest to częste pomyłka przy założeniu, że ścieżki root<xref:System.IO.Path.IsPathRooted(System.String)>() nie są względne.</span><span class="sxs-lookup"><span data-stu-id="470bc-553">It's a frequent mistake to assume that rooted paths (<xref:System.IO.Path.IsPathRooted(System.String)>) aren't relative.</span></span> <span data-ttu-id="470bc-554">Na przykład "C:a" jest ścieżką względną, czyli jest rozpoznawana względem bieżącego katalogu dla C: (root, ale względna).</span><span class="sxs-lookup"><span data-stu-id="470bc-554">For example, "C:a" is drive relative, that is, it's resolved against the current directory for C: (rooted, but relative).</span></span> <span data-ttu-id="470bc-555">"C:\a" jest odblokowany, a nie względny, to oznacza, że bieżący katalog nie jest używany do modyfikacji ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-555">"C:\a" is rooted and not relative, that is, the current directory isn't used to modify the path.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="470bc-556"><paramref name="path" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-556"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-557">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-557">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="470bc-558">Zwraca wartość wskazującą, czy ścieżka pliku zawiera element główny.</span><span class="sxs-lookup"><span data-stu-id="470bc-558">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="470bc-559">**Ścieżka** z odblokowanym dostępem do ścieżki pliku, który jest ustalony dla konkretnego dysku lub ścieżki. jest to kontrast ze ścieżką względną względem bieżącego dysku lub katalogu roboczego.</span><span class="sxs-lookup"><span data-stu-id="470bc-559">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="470bc-560">Na przykład w systemach Windows ścieżką główną zaczyna się od ukośnika odwrotnego (na przykład "\Documents") lub litery dysku i dwukropek (na przykład "C:Documents").</span><span class="sxs-lookup"><span data-stu-id="470bc-560">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="470bc-561">Należy pamiętać, że ścieżki z odblokowanym dostępem mogą być bezwzględne (czyli w pełni kwalifikowana) lub względne.</span><span class="sxs-lookup"><span data-stu-id="470bc-561">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="470bc-562">Ścieżka bezwzględna jest w pełni kwalifikowana ścieżka z katalogu głównego dysku do określonego katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-562">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="470bc-563">Względna ścieżka do ścieżki źródłowej określa dysk, ale jego w pełni kwalifikowana ścieżka jest rozpoznawana w bieżącym katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-563">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="470bc-564">Poniższy przykład ilustruje różnicę.</span><span class="sxs-lookup"><span data-stu-id="470bc-564">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-565">Ścieżka do przetestowania.</span><span class="sxs-lookup"><span data-stu-id="470bc-565">The path to test.</span></span></param>
        <summary><span data-ttu-id="470bc-566">Zwraca wartość wskazującą, czy określony zakres znaków reprezentujący ścieżkę pliku zawiera element główny.</span><span class="sxs-lookup"><span data-stu-id="470bc-566">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="470bc-567"><see langword="true" />Jeśli <paramref name="path" /> zawiera element główny; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="470bc-567"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-568">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-568">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-569">Ścieżka do przetestowania.</span><span class="sxs-lookup"><span data-stu-id="470bc-569">The path to test.</span></span></param>
        <summary><span data-ttu-id="470bc-570">Zwraca wartość wskazującą, czy określony ciąg ścieżki zawiera element główny.</span><span class="sxs-lookup"><span data-stu-id="470bc-570">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="470bc-571"><see langword="true" />Jeśli <paramref name="path" /> zawiera element główny; w przeciwnym <see langword="false" />razie,.</span><span class="sxs-lookup"><span data-stu-id="470bc-571"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-572">Metoda zwraca wartość `true` , jeśli pierwszy znak jest znakiem separatora katalogu, takim\\jak "", lub jeśli ścieżka rozpoczyna się od litery dysku i dwukropka (:). <xref:System.IO.Path.IsPathRooted%2A></span><span class="sxs-lookup"><span data-stu-id="470bc-572">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="470bc-573">Na `true` przykład zwraca\\dla `path` ciągów, takich jak "\\\mydir\\\MyFile.txt", "C: \mydir" lub "C:mydir".</span><span class="sxs-lookup"><span data-stu-id="470bc-573">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="470bc-574">Zwraca `false` dla`path` ciągów, takich jak "Mydir".</span><span class="sxs-lookup"><span data-stu-id="470bc-574">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="470bc-575">Ta metoda nie sprawdza, czy ścieżka lub nazwa pliku istnieje.</span><span class="sxs-lookup"><span data-stu-id="470bc-575">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="470bc-576">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="470bc-576">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="470bc-577">W poniższym przykładzie pokazano, `IsPathRooted` jak można użyć metody do testowania trzech ciągów.</span><span class="sxs-lookup"><span data-stu-id="470bc-577">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="470bc-578"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="470bc-578"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-579">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-579">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-580">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-580">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-581">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-581">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-582">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-582">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="470bc-583">Tablica ścieżek.</span><span class="sxs-lookup"><span data-stu-id="470bc-583">An array of paths.</span></span></param>
        <summary><span data-ttu-id="470bc-584">Łączy tablicę ścieżek w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-584">Concatenates an array of paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-585">Łączona ścieżka.</span><span class="sxs-lookup"><span data-stu-id="470bc-585">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-586">Ta metoda po prostu łączy wszystkie ciągi w `paths` i dodaje znak separatora katalogu między wszystkimi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny.</span><span class="sxs-lookup"><span data-stu-id="470bc-586">This method simply concatenates all the strings in `paths` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="470bc-587">Jeśli którakolwiek z ścieżek w `paths` jest równa zero, Metoda łączy pozostałe argumenty. <xref:System.String.Length></span><span class="sxs-lookup"><span data-stu-id="470bc-587">If the <xref:System.String.Length> of any of the paths in `paths` is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="470bc-588">Jeśli wynikowa długość połączonego ciągu wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="470bc-588">If the resulting concatenated string's length is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="470bc-589">Jeśli dowolna ze ścieżek w `paths`, z wyjątkiem ostatniego, kończą się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Join` , metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-589">If any of the paths in `paths`, except for the last one, ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-590">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-590">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-591">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-591">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-592">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-592">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-593">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-593">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-594">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-594">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="470bc-595">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-595">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-596">(Oznacza to, że jeśli którakolwiek z ścieżek w `paths`, z wyjątkiem ostatniego, jest ścieżką bezwzględną `Join` , metoda nie odrzuci poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-596">(That is, if any of the paths in `paths`, except for the last one, is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="470bc-597">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-597">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-598">Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-598">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-599">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-599">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-600">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-600">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-601">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-601">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="470bc-602">Łączy dwa składniki ścieżki w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-602">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-603">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-603">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="470bc-604">Ta metoda po prostu łączy `path` i `path2` dodaje znak separatora katalogu między dwoma składnikami ścieżki, jeśli jeden nie jest jeszcze `path1` obecny na końcu lub początku `path2`.</span><span class="sxs-lookup"><span data-stu-id="470bc-604">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="470bc-605">Jeśli wartość lub`path2`jest równa zero, metoda zwraca inną ścieżkę. `path1` <xref:System.ReadOnlySpan%601.Length></span><span class="sxs-lookup"><span data-stu-id="470bc-605">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="470bc-606"><xref:System.String.Empty?displayProperty=nameWithType>Jeśli oba `path1` i`path2` są zerami, metoda zwraca. <xref:System.ReadOnlySpan%601.Length></span><span class="sxs-lookup"><span data-stu-id="470bc-606">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="470bc-607">Jeśli `path1` zostanie zakończona literałem ścieżki, która nie jest odpowiednia dla platformy docelowej `Join` , metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-607">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-608">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-608">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-609">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-609">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-610">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-610">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-611">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-611">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-612">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-612">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="470bc-613">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-613">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-614">(Oznacza to, że `path2` jeśli jest ścieżką bezwzględną `Join` , metoda nie `path1` <xref:System.IO.Path.Combine%2A> odrzuca i `path2` zwraca jako metoda.) Poniższy przykład ilustruje różnicę w ścieżkach zwracanych przez dwie metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-614">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="470bc-615">Jeśli źródłem `path2` jest dane wejściowe użytkownika <xref:System.IO.Path.Combine%2A> , Metoda umożliwia użytkownikowi uzyskanie dostępu do zasobu systemu plików (takiego jak *C:/Users/Użytkownik1/Documents/Financial/* w przypadku przykładu), którego aplikacja nie zamierza wprowadzić pul.</span><span class="sxs-lookup"><span data-stu-id="470bc-615">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="470bc-616">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-616">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-617">Na przykład podczas `Path.Join("c:\\", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-617">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-618">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-618">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="470bc-619">Przykład</span><span class="sxs-lookup"><span data-stu-id="470bc-619">Example</span></span>

<span data-ttu-id="470bc-620">Poniższy przykład ilustruje różnicę w ścieżkach zwracanych przez <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> metody i. <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="470bc-620">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="470bc-621">Gdy pierwszy ciąg jest w pełni kwalifikowaną ścieżką obejmującą dysk i katalog główny, a drugi jest ścieżką względną od pierwszej ścieżki, dwie metody dają identyczne wyniki.</span><span class="sxs-lookup"><span data-stu-id="470bc-621">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="470bc-622">W drugim i trzecim wywołaniach `ShowPathInformation` metody, ciągi zwracane przez dwie metody rozbieżność.</span><span class="sxs-lookup"><span data-stu-id="470bc-622">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="470bc-623">W drugim wywołaniu metody pierwszy argument ciągu jest dysk, a drugi jest katalogiem głównym.</span><span class="sxs-lookup"><span data-stu-id="470bc-623">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="470bc-624">`Join` Metoda łączy dwa ciągi i zachowuje duplikaty separatorów ścieżek.</span><span class="sxs-lookup"><span data-stu-id="470bc-624">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="470bc-625">`Combine` Metoda porzuca dysk i zwraca katalog główny na bieżącym dysku.</span><span class="sxs-lookup"><span data-stu-id="470bc-625">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="470bc-626">Jeśli bieżącym dyskiem aplikacji jest C:\ a ciąg jest używany w celu uzyskania dostępu do pliku lub plików w katalogu, będzie miał dostęp do C: zamiast D:.</span><span class="sxs-lookup"><span data-stu-id="470bc-626">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="470bc-627">Na koniec, ponieważ oba argumenty w trzecim wywołaniu `ShowPathInformation` są odblokowane `Join` , metoda po prostu dołącza je do utworzenia ścieżki `Combine` pliku bezsensownie, podczas gdy metoda odrzuca pierwszy ciąg i zwraca sekundę.</span><span class="sxs-lookup"><span data-stu-id="470bc-627">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="470bc-628">Użycie tego ciągu na potrzeby dostępu do plików może dać aplikacji niezamierzony dostęp do poufnych plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-628">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-629">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-629">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-630">Pierwsza ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-630">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-631">Druga ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-631">The second path to join.</span></span></param>
        <summary><span data-ttu-id="470bc-632">Łączy dwie ścieżki w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-632">Concatenates two paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-633">Łączona ścieżka.</span><span class="sxs-lookup"><span data-stu-id="470bc-633">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-634">Ta metoda po prostu łączy `path` i `path2` dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny.</span><span class="sxs-lookup"><span data-stu-id="470bc-634">This method simply concatenates `path` and `path2` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="470bc-635">Jeśli długość `path1` lub `path2` jest równa zero, Metoda łączy pozostałe argumenty.</span><span class="sxs-lookup"><span data-stu-id="470bc-635">If the length of either `path1` or `path2` is zero, the method concatenates the remaining argument.</span></span> <span data-ttu-id="470bc-636">Jeśli długość wynikowego ciągu połączonego wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="470bc-636">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="470bc-637">Jeśli `path1` zostanie zakończona literałem ścieżki, która nie jest odpowiednia dla platformy docelowej `Join` , metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-637">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-638">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-638">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-639">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-639">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-640">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-640">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-641">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-641">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-642">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-642">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="470bc-643">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-643">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-644">(Oznacza to, że `path2` jeśli jest ścieżką bezwzględną `Join` , metoda nie odrzuci poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-644">(That is, if `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="470bc-645">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-645">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-646">Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-646">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-647">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-647">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-648">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-648">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-649">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-649">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-650">Zakres znaków, który zawiera trzecią ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-650">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="470bc-651">Łączy trzy składniki ścieżki w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-651">Concatenates three path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-652">Łączona ścieżka.</span><span class="sxs-lookup"><span data-stu-id="470bc-652">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="470bc-653">Ta metoda po prostu łączy `path`, `path2`i `path3` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny.</span><span class="sxs-lookup"><span data-stu-id="470bc-653">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="470bc-654">`path1` Jeśliktórykolwiek`path2`z argumentówmawartośćzero,Metodałączypozostałeargumenty`path3`. <xref:System.ReadOnlySpan%601.Length></span><span class="sxs-lookup"><span data-stu-id="470bc-654">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` arguments is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="470bc-655">Jeśli wartość wszystkich składników jest równa zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="470bc-655">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="470bc-656">Jeśli `path1` `Join` lub `path2` kończący się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-656">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-657">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-657">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-658">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-658">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-659">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-659">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-660">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-660">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-661">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-661">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="470bc-662">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-662">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-663">(Oznacza to, że `path2` Jeśli `path2` lub jest ścieżką bezwzględną, `Join` Metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-663">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>
  
<span data-ttu-id="470bc-664">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-664">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-665">Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-665">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-666">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-666">The `Join` method therefore successfully interprets it.</span></span>

## <a name="example"></a><span data-ttu-id="470bc-667">Przykład</span><span class="sxs-lookup"><span data-stu-id="470bc-667">Example</span></span>

<span data-ttu-id="470bc-668">Poniższy przykład ilustruje różnicę w ścieżkach zwracanych przez <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> metody i. <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="470bc-668">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="470bc-669">Gdy pierwszy ciąg jest w pełni kwalifikowaną ścieżką obejmującą dysk i katalog główny, a drugi jest ścieżką względną od pierwszej ścieżki, dwie metody generują identyczne wyniki.</span><span class="sxs-lookup"><span data-stu-id="470bc-669">When the first string is a fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="470bc-670">W drugim i trzecim wywołaniach `ShowPathInformation` metody, ciągi zwracane przez dwie metody rozbieżność.</span><span class="sxs-lookup"><span data-stu-id="470bc-670">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="470bc-671">W drugim wywołaniu metody pierwszy argument ciągu jest dysk, a drugi jest katalogiem głównym.</span><span class="sxs-lookup"><span data-stu-id="470bc-671">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="470bc-672">`Join` Metoda łączy dwa ciągi i zachowuje duplikaty separatorów ścieżek.</span><span class="sxs-lookup"><span data-stu-id="470bc-672">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="470bc-673">Wywołanie <xref:System.IO.Path.GetFullPath%2A> metody eliminuje duplikowanie.</span><span class="sxs-lookup"><span data-stu-id="470bc-673">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="470bc-674">`Combine` Metoda porzuca dysk i zwraca katalog główny na bieżącym dysku.</span><span class="sxs-lookup"><span data-stu-id="470bc-674">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="470bc-675">Jeśli bieżącym dyskiem aplikacji jest C:\ a ciąg jest używany w celu uzyskania dostępu do pliku lub plików w katalogu, będzie miał dostęp do C: zamiast D:.</span><span class="sxs-lookup"><span data-stu-id="470bc-675">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="470bc-676">Na koniec, ponieważ końcowy argument w trzecim wywołaniu `ShowPathInformation` jest odblokowany `Join` , metoda po prostu dołącza ją do pierwszych dwóch argumentów w celu utworzenia ścieżki `Combine` pliku bezsensownie, podczas gdy metoda odrzuca pierwsze dwa ciągi i zwraca trzecia.</span><span class="sxs-lookup"><span data-stu-id="470bc-676">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="470bc-677">Użycie tego ciągu na potrzeby dostępu do plików może dać aplikacji niezamierzony dostęp do poufnych plików.</span><span class="sxs-lookup"><span data-stu-id="470bc-677">Using this string for file access could give the application unintended access to sensitive files.</span></span>

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-678">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-678">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-679">Pierwsza ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-679">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-680">Druga ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-680">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-681">Trzecia ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-681">The third path to join.</span></span></param>
        <summary><span data-ttu-id="470bc-682">Łączy trzy ścieżki w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-682">Concatenates three paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-683">Łączona ścieżka.</span><span class="sxs-lookup"><span data-stu-id="470bc-683">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-684">Ta metoda po prostu łączy `path`, `path2`i `path3` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny.</span><span class="sxs-lookup"><span data-stu-id="470bc-684">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="470bc-685">Jeśli długość któregokolwiek `path1` `path2` lub `path3` argumentu jest równa zero, Metoda łączy pozostałe argumenty.</span><span class="sxs-lookup"><span data-stu-id="470bc-685">If the length of any of `path1`, `path2` or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="470bc-686">Jeśli długość wynikowego ciągu połączonego wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="470bc-686">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="470bc-687">Jeśli `path1` `Join` lub `path2` kończący się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="470bc-687">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-688">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-688">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-689">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-689">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-690">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-690">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-691">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-691">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-692">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-692">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="470bc-693">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-693">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-694">(Oznacza to, że `path2` Jeśli `path2` lub jest ścieżką bezwzględną, `Join` Metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-694">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="470bc-695">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-695">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-696">Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-696">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-697">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-697">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-698">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-698">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-699">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-699">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-700">Zakres znaków, który zawiera trzecią ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-700">A character span that contains the third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="470bc-701">Zakres znaków, który zawiera czwartą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-701">A character span that contains the fourth path to join.</span></span></param>
        <summary><span data-ttu-id="470bc-702">Łączy cztery składniki ścieżki w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-702">Concatenates four path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-703">Łączona ścieżka.</span><span class="sxs-lookup"><span data-stu-id="470bc-703">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-704">Ta metoda po prostu łączy `path` `path3` , `path2`i `path4` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny.</span><span class="sxs-lookup"><span data-stu-id="470bc-704">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="470bc-705">Jeśliktórykolwiek`path2`z `path1` argumentów`path3`ma wartość zero, Metoda łączy pozostałe argumenty. <xref:System.ReadOnlySpan%601.Length> `path4`</span><span class="sxs-lookup"><span data-stu-id="470bc-705">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="470bc-706">Jeśli wartość wszystkich składników jest równa zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="470bc-706">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="470bc-707">Jeśli `path1` lub `path2` lub `Join` zostaje zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. `path3`</span><span class="sxs-lookup"><span data-stu-id="470bc-707">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-708">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-708">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-709">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-709">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-710">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-710">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-711">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-711">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-712">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-712">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="470bc-713">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-713">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-714">(Oznacza to, że `path2` Jeśli `path2` `path3` lub jest ścieżką bezwzględną `Join` , metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-714">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="470bc-715">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-715">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-716">Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-716">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-717">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-717">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-718">Pierwsza ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-718">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-719">Druga ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-719">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-720">Trzecia ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-720">The third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="470bc-721">Czwarta ścieżka do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-721">The fourth path to join.</span></span></param>
        <summary><span data-ttu-id="470bc-722">Łączy cztery ścieżki w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="470bc-722">Concatenates four paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="470bc-723">Łączona ścieżka.</span><span class="sxs-lookup"><span data-stu-id="470bc-723">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="470bc-724">Ta metoda po prostu łączy `path` `path3` , `path2`i `path4` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny.</span><span class="sxs-lookup"><span data-stu-id="470bc-724">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="470bc-725">Jeśli długość `path1`któregokolwiek z argumentów `path3` , `path2`lub `path4` jest równa zero, Metoda łączy pozostałe argumenty.</span><span class="sxs-lookup"><span data-stu-id="470bc-725">If the length of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="470bc-726">Jeśli długość wynikowego ciągu połączonego wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="470bc-726">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="470bc-727">Jeśli `path1` lub `path2` lub `Join` zostaje zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. `path3`</span><span class="sxs-lookup"><span data-stu-id="470bc-727">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="470bc-728">Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-728">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="470bc-729">Aby obejść ten problem, możesz:</span><span class="sxs-lookup"><span data-stu-id="470bc-729">To work around this issue, you can:</span></span>

- <span data-ttu-id="470bc-730">Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-730">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="470bc-731">Użyj ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="470bc-731">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="470bc-732">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="470bc-732">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="470bc-733">W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-733">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="470bc-734">(Oznacza to, że `path2` Jeśli `path2` `path3` lub jest ścieżką bezwzględną `Join` , metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="470bc-734">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="470bc-735">Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="470bc-735">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="470bc-736">Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="470bc-736">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="470bc-737">Dlatego `Join` metoda pomyślnie interpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="470bc-737">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="470bc-738">Znak separatora specyficzny dla platformy używany do oddzielania ciągów ścieżki w zmiennych środowiskowych.</span><span class="sxs-lookup"><span data-stu-id="470bc-738">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-739">W przypadku platform komputerowych opartych na systemie Windows wartość tego pola jest średnikiem (;) Domyślnie, ale mogą się różnić w zależności od innych platform.</span><span class="sxs-lookup"><span data-stu-id="470bc-739">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-740">Poniższy przykład demonstruje użycie `PathSeparator` pola.</span><span class="sxs-lookup"><span data-stu-id="470bc-740">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-741">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-741">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-742">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-742">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-743">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-743">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-744">Ścieżka do przycinania.</span><span class="sxs-lookup"><span data-stu-id="470bc-744">The path to trim.</span></span></param>
        <summary><span data-ttu-id="470bc-745">Przycina jeden końcowy separator katalogów poza katalogiem głównym określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-745">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="470bc-746"><paramref name="path" /> Bez żadnych separatorów katalogu końcowego.</span><span class="sxs-lookup"><span data-stu-id="470bc-746">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="470bc-747">Ścieżka do przycinania.</span><span class="sxs-lookup"><span data-stu-id="470bc-747">The path to trim.</span></span></param>
        <summary><span data-ttu-id="470bc-748">Przycina jeden końcowy separator katalogów poza katalogiem głównym określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-748">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="470bc-749"><paramref name="path" /> Bez żadnych separatorów katalogu końcowego.</span><span class="sxs-lookup"><span data-stu-id="470bc-749">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="470bc-750">Próbuje połączyć poszczególne składniki ścieżki ze wstępnie przydzielonym zakresem znaków i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="470bc-750">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="470bc-751">Docelowy zakres znaków musi być wystarczająco duży, aby pomieścić połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-751">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="470bc-752">Następnie można pobrać połączone ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metodę, jak pokazano w poniższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="470bc-752">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-753">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-753">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-754">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-754">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="470bc-755">Zakres znaków do przechowywania połączonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-755">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="470bc-756">Gdy metoda zwraca, wartość, która wskazuje liczbę znaków, które są <paramref name="destination" />zapisywane w.</span><span class="sxs-lookup"><span data-stu-id="470bc-756">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="470bc-757">Próbuje połączyć dwa składniki ścieżki z pojedynczym wstępnie przydzielonym zakresem znaków i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="470bc-757">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="470bc-758"><see langword="true" />Jeśli operacja łączenia się powiedzie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="470bc-758"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="470bc-759">`destination`musi być wystarczająco duży, aby pomieścić połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-759">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="470bc-760">Następnie można pobrać połączone ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metodę, jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="470bc-760">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-761">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-761">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="470bc-762">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-762">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="470bc-763">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-763">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="470bc-764">Zakres znaków, który zawiera trzecią ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="470bc-764">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="470bc-765">Zakres znaków do przechowywania połączonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-765">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="470bc-766">Gdy metoda zwraca, wartość, która wskazuje liczbę znaków, które są <paramref name="destination" />zapisywane w.</span><span class="sxs-lookup"><span data-stu-id="470bc-766">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="470bc-767">Próbuje połączyć dwa składniki ścieżki z pojedynczym wstępnie przydzielonym zakresem znaków i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="470bc-767">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="470bc-768"><see langword="true" />Jeśli operacja łączenia się powiedzie; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="470bc-768"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="470bc-769">`destination`musi być wystarczająco duży, aby pomieścić połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="470bc-769">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="470bc-770">Następnie można pobrać połączone ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metodę, jak pokazano w przykładzie.</span><span class="sxs-lookup"><span data-stu-id="470bc-770">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="470bc-771">Formaty ścieżek plików w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="470bc-771">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="470bc-772">Zawiera znak separatora woluminu specyficzny dla platformy.</span><span class="sxs-lookup"><span data-stu-id="470bc-772">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="470bc-773">Wartość tego pola jest dwukropek (:) w systemie Windows i komputerach Macintosh oraz ukośnik (/) w systemach operacyjnych UNIX.</span><span class="sxs-lookup"><span data-stu-id="470bc-773">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="470bc-774">Jest to najbardziej przydatne w przypadku analizowania ścieżek, takich jak "c:\Windows" lub "MacVolume: system folder".</span><span class="sxs-lookup"><span data-stu-id="470bc-774">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="470bc-775">Poniższy przykład demonstruje użycie `VolumeSeparatorChar` pola.</span><span class="sxs-lookup"><span data-stu-id="470bc-775">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="470bc-776">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="470bc-776">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="470bc-777">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-777">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="470bc-778">Instrukcje: Zapisywanie tekstu w pliku</span><span class="sxs-lookup"><span data-stu-id="470bc-778">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>

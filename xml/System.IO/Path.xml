<Type Name="Path" FullName="System.IO.Path">
  <TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wykonuje operacje na <see cref="T:System.String" /> wystąpieniach, które zawierają informacje o ścieżce pliku lub katalogu. Te operacje są wykonywane w sposób Międzyplatformowy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ścieżka to ciąg, który zawiera lokalizację pliku lub katalogu. Ścieżka nie musi wskazywać lokalizacji na dysku; na przykład ścieżka może być mapowana na lokalizację w pamięci lub na urządzeniu. Dokładny Format ścieżki jest określany przez bieżącą platformę. Na przykład w niektórych systemach ścieżka może rozpoczynać się od litery dysku lub woluminu, podczas gdy ten element nie jest obecny w innych systemach. W niektórych systemach ścieżki plików mogą zawierać rozszerzenia, które wskazują typ informacji przechowywanych w pliku. Format rozszerzenia nazwy pliku zależy od platformy; na przykład niektóre systemy ograniczają rozszerzenia do trzech znaków, a inne nie. Bieżąca platforma określa również zestaw znaków użytych do oddzielenia elementów ścieżki oraz zestaw znaków, które nie mogą być używane podczas określania ścieżek. Ze względu na te różnice pola `Path` klasy oraz dokładne zachowanie niektórych elementów członkowskich `Path` klasy są zależne od platformy.  
  
 Ścieżka może zawierać bezwzględne lub względne informacje o lokalizacji. Ścieżki bezwzględne w pełni określają lokalizację: plik lub katalog można jednoznacznie zidentyfikować, niezależnie od bieżącej lokalizacji. Ścieżki względne określają lokalizację częściową: bieżąca lokalizacja jest używana jako punkt początkowy podczas lokalizowania pliku określonego ze ścieżką względną. Aby określić bieżący katalog, wywołaj <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.  

 Program .NET Core 1,1 i jego nowsze wersje oraz .NET Framework 4.6.2 i nowsze wersje obsługują również dostęp do obiektów systemu plików, które są nazwami urządzeń\\, na przykład\""? \c:.

Aby uzyskać więcej informacji na temat formatów ścieżki plików w systemie Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).

 Większość elementów członkowskich `Path` klasy nie współdziała z systemem plików i nie weryfikuje istnienia pliku określonego przez ciąg ścieżki. `Path`elementy członkowskie klasy, które modyfikują ciąg ścieżki, <xref:System.IO.Path.ChangeExtension%2A>takie jak, nie mają wpływu na nazwy plików w systemie plików. `Path`Członkowie mogą jednak sprawdzić zawartość określonego ciągu ścieżki i zgłosić <xref:System.ArgumentException> wyjątek, jeśli ciąg zawiera znaki, które nie są prawidłowe w ciągach ścieżki, jak zdefiniowano w znakach zwracanych <xref:System.IO.Path.GetInvalidPathChars%2A> przez metodę. Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i znaki Unicode od 16 do 18 i 20 do 25.  
  
 Członkowie `Path` klasy umożliwiają szybkie i łatwe wykonywanie typowych operacji, takich jak określenie, czy rozszerzenie nazwy pliku jest częścią ścieżki, i połączenie dwóch ciągów w jedną nazwę ścieżki.  
  
 Wszystkie elementy członkowskie `Path` klasy są statyczne i dlatego mogą być wywoływane bez wystąpienia ścieżki.  
  
> [!NOTE]
>  W elementach członkowskich, które akceptują ścieżkę jako ciąg wejściowy, ta ścieżka musi być poprawnie sformułowana lub występuje wyjątek. Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale zaczyna się od spacji, ścieżka nie jest przycięta w metodach klasy. W związku z tym ścieżka jest źle sformułowana i zgłaszany jest wyjątek. Podobnie ścieżka lub kombinacja ścieżek nie mogą być w pełni kwalifikowane dwukrotnie. Na przykład "c:\Temp c:\Windows" wywołuje również wyjątek w większości przypadków. Upewnij się, że ścieżki są poprawnie sformułowane podczas korzystania z metod, które akceptują ciąg ścieżki.  
  
 W elementach członkowskich, które akceptują ścieżkę, ścieżka może odwoływać się do pliku lub tylko katalogu. Określona ścieżka może również odwoływać się do ścieżki względnej lub ścieżki Universal Naming Convention (UNC) dla serwera i nazwy udziału. Na przykład wszystkie następujące są dopuszczalne ścieżki:  
  
-   "c:\\\mydir\\\MyFile.txt" in C#lub "c:\MyDir\MyFile.txt" w Visual Basic.  
  
-   "c:\\\mydir" in C#lub "c:\mydir" w Visual Basic.  
  
-   "Mydir\\\MySubdir" in C#lub "MyDir\MySubDir" w Visual Basic.  
  
-   "\\\\ C#\MyServer \MyShare" in lub"\\\MyServer\MyShare" w Visual Basic.\\\\  
  
 Ponieważ wszystkie te operacje są wykonywane na ciągach, nie można sprawdzić, czy wyniki są prawidłowe we wszystkich scenariuszach. Na przykład <xref:System.IO.Path.GetExtension%2A> Metoda analizuje przekazany ciąg i zwraca rozszerzenie z tego ciągu. Nie oznacza to jednak, że plik z tym rozszerzeniem istnieje na dysku.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).   
  
## Examples  
 Poniższy przykład demonstruje niektóre główne elementy członkowskie `Path` klasy.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Instrukcje: Odczyt i zapis we właśnie utworzonym pliku danych</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia alternatywny znak specyficzny dla platformy używany do oddzielania poziomów katalogów w ciągu ścieżki, który odzwierciedla hierarchiczną organizację systemu plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
To pole może mieć taką samą wartość jak <xref:System.IO.Path.DirectorySeparatorChar>. `AltDirectorySeparatorChar`i <xref:System.IO.Path.DirectorySeparatorChar> są prawidłowe w celu oddzielenia poziomów katalogów w ciągu ścieżki.  
  
Wartość tego pola jest ukośnikiem ("/") w systemach operacyjnych Windows i UNIX.  
  
## Examples  

Poniższy przykład wyświetla <xref:System.IO.Path> wartości pól w systemie Windows i w systemach UNIX. Należy pamiętać, że system Windows obsługuje ukośnik (zwracany przez <xref:System.IO.Path.AltDirectorySeparatorChar> pole) lub ukośnik odwrotny (który jest zwracany <xref:System.IO.Path.DirectorySeparatorChar> przez pole) jako znaki separatora ścieżki, natomiast systemy z systemem UNIX obsługują tylko ukośnik.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Informacje o ścieżce do zmodyfikowania. Ścieżka nie może zawierać żadnych znaków zdefiniowanych w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</param>
        <param name="extension">Nowe rozszerzenie (z kropką lub bez niego). Określ <see langword="null" /> , aby usunąć istniejące rozszerzenie z <paramref name="path" />.</param>
        <summary>Zmienia rozszerzenie ciągu ścieżki.</summary>
        <returns>Informacje o zmodyfikowanej ścieżce.  
  
W przypadku platform klasycznych opartych na <paramref name="path" /> systemie <see langword="null" /> Windows, jeśli jest lub jest pustym ciągiem (""), informacje o ścieżce są zwracane niemodyfikowane. Jeśli <paramref name="extension" /> jest<see langword="null" />, zwracany ciąg zawiera określoną ścieżkę z usuniętym rozszerzeniem. Jeśli <paramref name="path" /> nie ma rozszerzenia i <paramref name="extension" /> nie <see langword="null" />jest, zwracany <paramref name="path" />ciąg ścieżki zawiera <paramref name="extension" /> dołączenie na końcu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ani nie `ChangeExtension` zawiera kropki (.), program dodaje okres. `extension` `path`  
  
 `extension` Parametr może zawierać wiele okresów i wszystkie prawidłowe ścieżki oraz może mieć dowolną długość. Jeśli `extension` jest `null`, zwracany`path` ciąg zawiera zawartość z ostatnim kropką i wszystkie znaki po usunięciu.  
  
 Jeśli `extension` jest pustym ciągiem, zwracany ciąg ścieżki zawiera `path` zawartość z dowolnymi znakami po ostatnim okresie.  
  
 Jeśli `path` nie ma rozszerzenia i `extension` nie `null`jest, zwracany ciąg zawiera `path`. `extension`  
  
 Jeśli `extension` nie`null` jest i nie zawiera kropki wiodącej, zostanie dodany okres.  
  
 Jeśli `path` zawiera wiele rozszerzeń rozdzielonych przez wiele okresów, zwracany ciąg zawiera `path` zawartość z ostatnim kropką i wszystkie znaki po zastąpieniu przez `extension`. Na przykład jeśli `path` jest "\Dir1\examples\pathtests.CSX.txt" i `extension` jest "CS", modyfikowaną ścieżką jest "\Dir1\examples\pathtests.CSX.cs".  
  
 Nie można sprawdzić, czy zwracane wyniki są prawidłowe we wszystkich scenariuszach. Na przykład, jeśli `path` jest pusty, `extension` jest dołączony.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `ChangeExtension` metody.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Łączy ciągi w ścieżkę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Ta metoda jest przeznaczona do łączenia poszczególnych ciągów w jeden ciąg, który reprezentuje ścieżkę pliku. Jeśli jednak argument inny niż pierwszy zawiera ścieżkę do katalogu głównego, wszystkie poprzednie składniki ścieżki są ignorowane, a zwrócony ciąg rozpoczyna się od tego składnika ścieżki root. Jako alternatywę dla `Combine` metody należy rozważyć <xref:System.IO.Path.Join%2A> użycie metod lub <xref:System.IO.Path.TryJoin%2A> .

> [!IMPORTANT]
> Ta metoda zakłada, że pierwszy argument jest ścieżką bezwzględną i że następujący argument lub argumenty są ścieżkami względnymi. Jeśli tak się nie dzieje, a zwłaszcza jeśli wszystkie kolejne argumenty są ciągami wejściowymi przez użytkownika, wywołaj <xref:System.IO.Path.Join%2A> metodę <xref:System.IO.Path.TryJoin%2A> or.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Tablica części ścieżki.</param>
        <summary>Łączy tablicę ciągów w ścieżkę.</summary>
        <returns>Połączone ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths`powinna być tablicą części ścieżki do połączenia. Jeśli jedna z kolejnych ścieżek jest ścieżką bezwzględną, wówczas Operacja łączenia resetuje się, rozpoczynając od tej ścieżki bezwzględnej, odrzucając wszystkie poprzednie ścieżki połączone.  

Jeśli którykolwiek element w `paths` , ale nie jest dyskiem i nie kończy się <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar> znakiem `Combine` lub, Metoda dodaje <xref:System.IO.Path.DirectorySeparatorChar> znak między tym elementem a następną. Należy pamiętać, że jeśli element zostanie zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, `Combine` metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwaną wartość. Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 Ciągi o zerowej długości są pomijane w połączonej ścieżce.  
  
 Parametry nie są analizowane, jeśli mają biały znak.  
  
 Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania. Z `Combine` tego względu pomyślnie interpretuje metodę.  
  
## Examples  
 Poniższy przykład łączy tablicę ciągów w ścieżkę.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeden z ciągów w tablicy zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Jeden z ciągów w tablicy jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Pierwsza ścieżka do połączenia.</param>
        <param name="path2">Druga ścieżka do połączenia.</param>
        <summary>Łączy dwa ciągi w ścieżkę.</summary>
        <returns>Połączone ścieżki. Jeśli jedna z określonych ścieżek jest ciągiem o zerowej długości, Metoda ta zwraca drugą ścieżkę. Jeśli <paramref name="path2" /> zawiera ścieżkę bezwzględną, ta metoda <paramref name="path2" />zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `path1` nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy z prawidłowym znakiem separatora, jak zdefiniowano <xref:System.IO.Path.AltDirectorySeparatorChar>w <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> lub, jest dołączony `path1` do przed połączeniem. Należy pamiętać, `path1` że jeśli program zostanie zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla `Combine` platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 Jeśli `path2` nie zawiera elementu głównego (na przykład jeśli `path2` nie zaczyna się od znaku separatora lub specyfikacji dysku), wynikiem jest połączenie dwóch ścieżek z pozostałym znakiem separatora. Jeśli `path2` zawiera element główny, `path2` jest zwracany.  
  
 Parametry nie są analizowane, jeśli mają biały znak. W związku z `path2` tym, jeśli zawiera biały znak (na przykład "\file.txt") <xref:System.IO.Path.Combine%2A> , metoda dołącza `path1` `path2` do zamiast tylko `path2`zwracanego.  
  
 Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania. Z `Combine` tego względu pomyślnie interpretuje metodę.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `Combine` metody na platformie komputerowej opartej na systemie Windows.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />lub <paramref name="path2" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />lub <paramref name="path2" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Pierwsza ścieżka do połączenia.</param>
        <param name="path2">Druga ścieżka do połączenia.</param>
        <param name="path3">Trzecia ścieżka do połączenia.</param>
        <summary>Łączy trzy ciągi w ścieżkę.</summary>
        <returns>Połączone ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1`powinna być ścieżką bezwzględną (na przykład "d:\archives" lub\\"\archives\public"). Jeśli `path2` lub`path3` jest również ścieżką bezwzględną, Operacja łączenia odrzuca wszystkie wcześniej połączone ścieżki i przywraca tę ścieżkę bezwzględną.  
  
 Ciągi o zerowej długości są pomijane w połączonej ścieżce.  
  
 Jeśli `path1` lub <xref:System.IO.Path.AltDirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> `path1` <xref:System.IO.Path.VolumeSeparatorChar>nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy prawidłowym znakiem separatora, jak zdefiniowano w,, lub, jest dołączany do lub `path2` `path2` przed połączeniem. Należy zauważyć, `path1` że `path2` Jeśli lub kończący się znakiem separatora ścieżki, który nie jest odpowiedni dla `Combine` platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 Jeśli `path2` nie zawiera elementu głównego (na przykład jeśli `path2` nie zaczyna się od znaku separatora lub specyfikacji dysku), wynikiem jest połączenie dwóch ścieżek z pozostałym znakiem separatora. Jeśli `path2` zawiera element główny, `path2` jest zwracany.  
  
 Parametry nie są analizowane, jeśli mają biały znak. W `path2` `path2` `path1`związku z tym, jeśli zawiera biały znak (na przykład "\file.txt"), Metoda dodaje do. <xref:System.IO.Path.Combine%2A>  
  
 Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania. Z `Combine` tego względu pomyślnie interpretuje metodę.  
  
   
  
## Examples  
 Poniższy przykład łączy trzy ścieżki.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" /> <see cref="M:System.IO.Path.GetInvalidPathChars" />lub <paramref name="path3" /> zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, lub <paramref name="path3" /> jest <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Pierwsza ścieżka do połączenia.</param>
        <param name="path2">Druga ścieżka do połączenia.</param>
        <param name="path3">Trzecia ścieżka do połączenia.</param>
        <param name="path4">Czwarta ścieżka do połączenia.</param>
        <summary>Łączy cztery ciągi w ścieżkę.</summary>
        <returns>Połączone ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1`powinna być ścieżką bezwzględną (na przykład "d:\archives" lub\\"\archives\public"). Jeśli jedna z kolejnych ścieżek jest również ścieżką bezwzględną, Operacja łączenia odrzuca wszystkie wcześniej połączone ścieżki i resetuje do tej ścieżki bezwzględnej.  
  
 Ciągi o zerowej długości są pomijane w połączonej ścieżce.  
  
 Jeśli `path1`, <xref:System.IO.Path.AltDirectorySeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.VolumeSeparatorChar> <xref:System.IO.Path.DirectorySeparatorChar> lub nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy z prawidłowym znakiem separatora określonym w,, lub, jest do niego dołączony `path3` `path2` przed połączeniem. Należy pamiętać, `path1`że `path2`Jeśli, `path3` lub kończące się znakiem separatora ścieżki, który `Combine` nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Poniższy przykład porównuje wynik w systemach Windows i UNIX, gdy ukośnik odwrotny jest używany jako znak separatora ścieżki. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 Jeśli `path2` nie zawiera elementu głównego (na przykład jeśli `path2` nie zaczyna się od znaku separatora lub specyfikacji dysku), wynikiem jest połączenie dwóch ścieżek z pozostałym znakiem separatora. Jeśli `path2` zawiera element główny, `path2` jest zwracany.  
  
 Parametry nie są analizowane, jeśli mają biały znak. W `path2` `path2` `path1`związku z tym, jeśli zawiera biały znak (na przykład "\file.txt"), Metoda dodaje do. <xref:System.IO.Path.Combine%2A>  
  
 Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Combine` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład w przypadku `Path.Combine("c:\\", "*.txt")` , gdy użytkownik utworzył plik z tego pliku, może być nieprawidłowy ciąg wyszukiwania. Z `Combine` tego względu pomyślnie interpretuje metodę.  
  
   
  
## Examples  
 Poniższy przykład łączy cztery ścieżki.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> <see cref="M:System.IO.Path.GetInvalidPathChars" />lub zawieraconajmniejjedennieprawidłowyznakzdefiniowanyw<paramref name="path4" /> .</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, lub <paramref name="path4" /> jest .<see langword="null" /></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera znak specyficzny dla platformy używany do oddzielania poziomów katalogów w ciągu ścieżki, który odzwierciedla hierarchiczną organizację systemu plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar>i `DirectorySeparatorChar` są prawidłowe w celu oddzielenia poziomów katalogów w ciągu ścieżki.  
  
W przypadku korzystania z platformy .NET Core do tworzenia aplikacji uruchamianych na wielu platformach:

- Jeśli wolisz pokodować znak separatora katalogu, należy użyć znaku ukośnika (`/`). Jest to jedyny rozpoznany znak separatora katalogu w systemach UNIX, ponieważ dane wyjściowe z przykładu są wyświetlane i są <xref:System.IO.Path.AltDirectorySeparatorChar> w systemie Windows.

- Użyj łączenia ciągów, aby dynamicznie pobrać znak separatora ścieżki w czasie wykonywania i dołączyć go do ścieżek systemu plików. Na przykład 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   Możesz również pobrać wartość z <xref:System.IO.Path.AltDirectorySeparatorChar> właściwości, ponieważ jest ona taka sama w systemach Windows i UNX.

- <xref:System.IO.Path.AltDirectorySeparatorChar> Pobierz właściwość

Jeśli aplikacja nie jest międzyplatformowa, można użyć separatora odpowiednie dla danego systemu.

## Examples  

Poniższy przykład wyświetla <xref:System.IO.Path> wartości pól w systemie Windows i w systemach UNIX. Należy pamiętać, że system Windows obsługuje ukośnik (zwracany przez <xref:System.IO.Path.AltDirectorySeparatorChar> pole) lub ukośnik odwrotny (który jest zwracany <xref:System.IO.Path.DirectorySeparatorChar> przez pole) jako znaki separatora ścieżki, natomiast systemy z systemem UNIX obsługują tylko ukośnik.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>Zwraca informacje o katalogu dla określonej ścieżki reprezentowanej przez zakres znaków.</summary>
        <returns>Informacje o katalogu <paramref name="path" />dla lub pustego zakresu, <paramref name="path" /> Jeśli <see langword="null" />jest, pusty \, zakres lub główny (na przykład C:, lub \\server\share).</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku lub katalogu.</param>
        <summary>Zwraca informacje o katalogu dla podanego ciągu ścieżki.</summary>
        <returns>Informacje o katalogu <paramref name="path" />dla <paramref name="path" /> lub <see langword="null" /> wskazuje katalog główny lub ma wartość null. Zwraca <see cref="F:System.String.Empty" /> wartość <paramref name="path" /> , jeśli nie zawiera informacji o katalogu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W większości przypadków ciąg zwracany przez tę metodę składa się ze wszystkich znaków w ścieżce do, ale nie do ostatniego <xref:System.IO.Path.DirectorySeparatorChar> lub. <xref:System.IO.Path.AltDirectorySeparatorChar> Jeśli ścieżka składa się z katalogu głównego, na przykład "c:\\", zwracana jest wartość null. Należy zauważyć, że ta metoda nie obsługuje ścieżek przy użyciu "File:". Ponieważ zwracana ścieżka nie zawiera <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, przekazanie <xref:System.IO.Path.GetDirectoryName%2A> zwróconej ścieżki z powrotem do metody spowoduje obcinanie jednego poziomu folderu dla każdego kolejnego wywołania w ciągu wynikowym. Na przykład przekazanie ścieżki "C:\Directory\SubDirectory\test.txt" do <xref:System.IO.Path.GetDirectoryName%2A> metody zwróci wartość "C:\Directory\SubDirectory". Przekazanie ciągu "C:\Directory\SubDirectory" do <xref:System.IO.Path.GetDirectoryName%2A> spowoduje "C:\Directory".  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `GetDirectoryName` metody na platformie komputerowej opartej na systemie Windows.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> Parametr zawiera nieprawidłowe znaki, jest pusty lub zawiera tylko znaki odstępu.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.IO.IOException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 <paramref name="path" /> Parametr jest dłuższy niż zdefiniowana w systemie długość maksymalna.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku, z której ma zostać pobrane rozszerzenie.</param>
        <summary>Zwraca rozszerzenie ścieżki pliku reprezentowanej przez zakres znaków tylko do odczytu.</summary>
        <returns>Rozszerzenie określonej ścieżki (łącznie z kropką, ".") lub <see cref="P:System.ReadOnlySpan`1.Empty" /> Jeśli <paramref name="path" /> nie ma informacji o rozszerzeniu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Ta metoda uzyskuje rozszerzenie `path` , wyszukując `path` kropkę ("."), rozpoczynając od ostatniego znaku w zakresie tylko do odczytu i kontynuując do pierwszego znaku. Jeśli okres zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar> znakiem lub <xref:System.IO.Path.AltDirectorySeparatorChar> , zwracany zakres tylko do odczytu zawiera kropkę i znaki <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> po nim; w przeciwnym razie zwraca wartość.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ciąg ścieżki, z którego ma zostać pobrane rozszerzenie.</param>
        <summary>Zwraca rozszerzenie (łącznie z kropką ".") określonego ciągu ścieżki.</summary>
        <returns>Rozszerzenie określonej ścieżki (łącznie z kropką "."), lub <see langword="null" />lub. <see cref="F:System.String.Empty" /> Jeśli <paramref name="path" /> jest <see langword="null" />, zwraca<see cref="M:System.IO.Path.GetExtension(System.String)" /> . <see langword="null" /> Jeśli <paramref name="path" /> nie ma informacji o rozszerzeniu <see cref="M:System.IO.Path.GetExtension(System.String)" /> , <see cref="F:System.String.Empty" />zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Ta metoda uzyskuje rozszerzenie `path` , wyszukując `path` kropkę (.), rozpoczynając od ostatniego znaku w `path` i kontynuując do pierwszego znaku. Jeśli okres zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar> znakiem lub <xref:System.IO.Path.AltDirectorySeparatorChar> , zwracany ciąg zawiera kropkę i znaki <xref:System.String.Empty?displayProperty=nameWithType> po nim; w przeciwnym razie zwraca wartość.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).
 
## Examples  
 Poniższy przykład ilustruje użycie `GetExtension` metody na platformie komputerowej opartej na systemie Windows.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Zakres tylko do odczytu, który zawiera ścieżkę, z której ma zostać uzyskana nazwa i rozszerzenie pliku.</param>
        <summary>Zwraca nazwę pliku i rozszerzenie ścieżki pliku reprezentowanej przez zakres znaków tylko do odczytu.</summary>
        <returns>Znaki po ostatnim znaku separatora katalogu w <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Zwrócony zakres tylko do odczytu zawiera znaki ścieżki, które obserwują ostatni separator w `path`. Jeśli ostatni znak w `path` jest woluminem lub znakiem separatora katalogu, metoda zwraca. <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> Jeśli `path` nie zawiera znaku separatora, metoda zwraca `path`.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ciąg ścieżki, z którego ma zostać uzyskana nazwa i rozszerzenie pliku.</param>
        <summary>Zwraca nazwę pliku i rozszerzenie określonego ciągu ścieżki.</summary>
        <returns>Znaki po ostatnim znaku separatora katalogu w <paramref name="path" />. Jeśli ostatni znak <paramref name="path" /> jest znakiem separatora katalogu lub woluminu, ta metoda zwraca <see cref="F:System.String.Empty" />. Jeśli <paramref name="path" /> <see langword="null" />jest <see langword="null" />, ta metoda zwraca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Zwracana wartość jest `null` , jeśli ścieżka pliku to `null`.  
  
Znaki separatora używane do określenia początku nazwy pliku to <xref:System.IO.Path.DirectorySeparatorChar> i. <xref:System.IO.Path.AltDirectorySeparatorChar>  

Ponieważ *\\* jest to legalna nazwa pliku w systemie `GetFileName` UNIX, działające w ramach platform opartych na systemie UNIX nie może prawidłowo zwrócić nazwy pliku z ścieżki opartej na systemie Windows, takiej jak `GetFileName` *C:\\\\mydir. ext*, ale Uruchamianie w ramach platform opartych na systemie Windows może prawidłowo zwrócić nazwę pliku z ścieżki opartej na systemie UNIX, takiej jak */tmp/myfile.ext*, `GetFileName` więc zachowanie metody nie jest ściśle takie samo na platformach opartych na systemie UNIX i Windows.

Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje zachowanie `GetFileName` metody na platformie pulpitu opartej na systemie Windows.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Zakres tylko do odczytu, który zawiera ścieżkę, z której ma zostać uzyskana nazwa pliku bez rozszerzenia.</param>
        <summary>Zwraca nazwę pliku bez rozszerzenia ścieżki pliku reprezentowanego przez zakres znaków tylko do odczytu.</summary>
        <returns>Znaki w zakresie tylko do odczytu zwrócone przez <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus ostatni kropka (.) i wszystkie znaki po nim.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku.</param>
        <summary>Zwraca nazwę pliku określonego ciągu ścieżki bez rozszerzenia.</summary>
        <returns>Ciąg zwracany przez <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus ostatni kropka (.) i wszystkie znaki po nim.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie sprawdza, czy ścieżka lub nazwa pliku istnieje.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie `GetFileNameWithoutExtension` metody.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Plik lub katalog, dla którego mają zostać uzyskane informacje o ścieżce bezwzględnej.</param>
        <summary>Zwraca ścieżkę bezwzględną dla podanego ciągu ścieżki.</summary>
        <returns>W pełni kwalifikowana lokalizacja <paramref name="path" />, taka jak "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ścieżka bezwzględna zawiera wszystkie informacje wymagane do zlokalizowania pliku lub katalogu w systemie.  
  
 Plik lub katalog określony przez `path` nie musi istnieć. Na przykład jeśli *c:\temp\newdir* jest bieżącym katalogiem, wywoływanie `GetFullPath` nazwy pliku, takiej jak *test. txt* zwraca *c:\temp\newdir\test.txt*. Plik nie musi istnieć.  

> [!IMPORTANT]
> Jeśli `path` jest ścieżką względną, to Przeciążenie zwraca w pełni kwalifikowaną ścieżkę, która może opierać się na bieżącym dysku i bieżącym katalogu. Bieżący dysk i bieżący katalog można zmienić w dowolnym momencie, gdy aplikacja jest uruchamiana. W związku z tym nie można określić z góry ścieżki zwróconej przez to przeciążenie. Aby zwrócić deterministyczną ścieżkę, wywołaj <xref:System.IO.Path.GetFullPath(System.String,System.String)> Przeciążenie. Możesz również wywołać metodę, <xref:System.IO.Path.IsPathFullyQualified%2A> aby określić, czy ścieżka jest w pełni kwalifikowana lub względna i czy `GetFullPath` jest to wymagane.

 Jeśli `path` jednak istnieje, obiekt wywołujący musi mieć uprawnienie do uzyskiwania informacji o ścieżce dla `path`. Należy zauważyć, że w przeciwieństwie do <xref:System.IO.Path> większości elementów członkowskich klasy, ta metoda uzyskuje dostęp do systemu plików.  
  
 Ta metoda używa bieżącego katalogu i informacji o bieżącym woluminie do pełnej `path`kwalifikacji. W przypadku określenia nazwy pliku tylko w programie `path` `GetFullPath` funkcja zwraca w pełni kwalifikowaną ścieżkę bieżącego katalogu.  
  
 Jeśli przekażesz krótką nazwę pliku, zostanie ona rozszerzona na długą nazwę pliku.  
  
 Jeśli ścieżka nie zawiera żadnych znaków znaczących, jest nieprawidłowa, chyba że zawiera jeden lub więcej znaków ".", po których następuje dowolna liczba spacji; następnie zostanie on przeanalizowany jako "." lub "..".  

Program .NET Core 1,1 i jego nowsze wersje oraz .NET Framework 4.6.2 i nowsze wersje obsługują również ścieżki zawierające nazwy urządzeń, takie jak\\"? \c\":.

Aby uzyskać więcej informacji na temat formatów ścieżki plików w systemie Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md). Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).
  
## Examples  
 Poniższy przykład ilustruje `GetFullPath` metodę na platformie pulpitu opartej na systemie Windows.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
—lub— 
System nie może pobrać ścieżki bezwzględnej.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" />zawiera dwukropek (":"), który nie jest częścią identyfikatora woluminu (na przykład "c:\\").</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania dostępu do ścieżki.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna do łączenia <paramref name="basePath" />.</param>
        <param name="basePath">Początek w pełni kwalifikowanej ścieżki.</param>
        <summary>Zwraca ścieżkę bezwzględną z w pełni kwalifikowanej ścieżki podstawowej i ścieżki względnej.</summary>
        <returns>Ścieżka bezwzględna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Jeśli `path` jest pustą ścieżką, metoda zwraca `basePath`. Jeśli `path` jest w pełni kwalifikowaną ścieżką, Metoda przechodzi `path` do <xref:System.IO.Path.GetFullPath(System.String)> metody i zwraca wynik.

Użyj tej metody, aby zwrócić deterministyczną ścieżkę na podstawie określonego woluminu i katalogu głównego, gdy używasz ścieżek względnych. Użycie wstępnie zdefiniowanego `basePath` , a nie jednego w oparciu o bieżące osłony katalogu dysków przed niechcianymi ścieżkami plików spowodowane nieoczekiwanymi zmianami w bieżącym dysku i katalogu. 

## <a name="example"></a>Przykład

W poniższym przykładzie zdefiniowano zmienną, `basePath`która reprezentuje bieżący katalog aplikacji. Następnie przekazuje go do `GetFullPath` metody, aby uzyskać w pełni kwalifikowaną ścieżkę do katalogu danych aplikacji.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />lub <paramref name="basePath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" />nie jest w pełni kwalifikowaną ścieżką.

—lub—

<paramref name="path" />lub <paramref name="basePath" /> zawiera nieprawidłowe znaki ścieżki, takie jak U + 0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach plików.</summary>
        <returns>Tablica zawierająca znaki, które nie są dozwolone w nazwach plików.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica zwracana z tej metody nie powinna zawierać pełnego zestawu znaków, które są nieprawidłowe w nazwach plików i katalogów. Pełny zestaw nieprawidłowych znaków może różnić się w zależności od systemu plików. Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać znaki ASCII/Unicode od 1 do 31, a także cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i Tab (\t).  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.IO.Path.GetInvalidFileNameChars%2A> metodę <xref:System.IO.Path.GetInvalidPathChars%2A> i metodę pobierania nieprawidłowych znaków.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach ścieżek.</summary>
        <returns>Tablica zawierająca znaki, które nie są dozwolone w nazwach ścieżek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica zwracana z tej metody nie powinna zawierać pełnego zestawu znaków, które są nieprawidłowe w nazwach plików i katalogów. Pełny zestaw nieprawidłowych znaków może różnić się w zależności od systemu plików. Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać znaki ASCII/Unicode od 1 do 31, a także cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i Tab (\t).  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.IO.Path.GetInvalidFileNameChars%2A> metodę <xref:System.IO.Path.GetInvalidPathChars%2A> i metodę pobierania nieprawidłowych znaków.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, z której mają zostać uzyskane informacje o katalogu głównym.</param>
        <summary>Pobiera informacje z katalogu głównego ze ścieżki zawartej w określonym zakresie znaków.</summary>
        <returns>Zakres znaków zawierający katalog `path`główny.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka, z której mają zostać uzyskane informacje o katalogu głównym.</param>
        <summary>Pobiera informacje o katalogu głównym określonej ścieżki.</summary>
        <returns><paramref name="path" />Katalog główny, lub <see langword="null" /> Jeśli <paramref name="path" /> jest <see langword="null" />lub pusty ciąg, jeśli <paramref name="path" /> nie zawiera informacji o katalogu głównym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie sprawdza, czy ścieżka lub nazwa pliku istnieje.  
  
 Możliwe wzorce dla ciągu zwracanego przez tę metodę są następujące:  
  
- Pusty ciąg (`path` określa ścieżkę względną na bieżącym dysku lub woluminie).  
  
- "\" (`path` określona ścieżka bezwzględna na bieżącym dysku).  
  
- "X:" (`path` określona ścieżka względna na dysku, gdzie X reprezentuje literę dysku lub woluminu).  
  
- "X:\" (`path` określona ścieżka bezwzględna dla danego dysku).  
  
- "\\\ComputerName\SharedFolder" (ścieżka UNC).  
  
- "\\\C:"\?(ścieżka urządzenia DOS obsługiwana w programie .NET Core 1,1 i nowszych wersjach oraz w .NET Framework 4.6.2 i nowszych wersjach)\\
   
 Aby uzyskać więcej informacji na temat ścieżek plików w systemie Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md). Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
## Examples  
 Poniższy przykład ilustruje użycie `GetPathRoot` metody.  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
—lub— 
 <see cref="F:System.String.Empty" />zostało przesłane do <paramref name="path" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca losową nazwę folderu lub nazwę pliku.</summary>
        <returns>Losowa nazwa folderu lub nazwa pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.GetRandomFileName%2A> Metoda zwraca kryptograficznie silnie losowy ciąg, który może być używany jako nazwa folderu lub nazwa pliku. W przeciwieństwie <xref:System.IO.Path.GetRandomFileName%2A> do <xref:System.IO.Path.GetTempFileName%2A>, nie tworzy pliku. Jeśli zabezpieczenia systemu plików są najważniejsze, ta metoda powinna być używana zamiast <xref:System.IO.Path.GetTempFileName%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dane wyjściowe z <xref:System.IO.Path.GetRandomFileName%2A> metody.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Ścieżka źródłowa, względem której powinien być powiązany wynik. Ta ścieżka jest zawsze traktowana jako katalog.</param>
        <param name="path">Ścieżka docelowa.</param>
        <summary>Zwraca ścieżkę względną z jednej ścieżki do innej.</summary>
        <returns>Ścieżka względna lub <paramref name="path" /> Jeśli ścieżki nie mają tego samego katalogu głównego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Ścieżki są rozwiązywane przez wywołanie <xref:System.IO.Path.GetFullPath%2A> metody przed obliczeniem różnicy. Metoda używa domyślnego porównania ścieżki plików dla bieżącej platformy (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> dla systemów Windows i MacOS, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> dla systemu Linux. 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" />lub <paramref name="path" /> jest <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy plik tymczasowy o unikatowych nazwach o zerowej liczbie bajtów na dysku i zwraca pełną ścieżkę do tego pliku.</summary>
        <returns>Pełna ścieżka pliku tymczasowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy plik tymczasowy z. Rozszerzenie pliku TMP. Plik tymczasowy jest tworzony w folderze tymczasowym użytkownika, który jest ścieżką zwróconą przez <xref:System.IO.Path.GetTempPath%2A> metodę.  
  
 <xref:System.IO.Path.GetTempFileName%2A> Metoda zostanie <xref:System.IO.IOException> utworzona, jeśli zostanie użyta do utworzenia więcej niż 65535 plików bez usuwania poprzednich plików tymczasowych.  
  
 Metoda zostanie wywoływać, <xref:System.IO.IOException> Jeśli nie jest dostępna żadna unikatowa nazwa <xref:System.IO.Path.GetTempFileName%2A> pliku tymczasowego. Aby rozwiązać ten problem, Usuń wszystkie zbędne pliki tymczasowe.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd we/wy, taki jak brak dostępnej unikatowej nazwy pliku tymczasowego.  
  
—lub—
  
 Ta metoda nie może utworzyć pliku tymczasowego.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do zapisu w katalogu tymczasowym. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ścieżkę folderu tymczasowego bieżącego użytkownika.</summary>
        <returns>Ścieżka do folderu tymczasowego, kończąca się ukośnikiem odwrotnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza istnienie zmiennych środowiskowych w następującej kolejności i używa pierwszej znalezionej ścieżki:  
  
1.  Ścieżka określona przez zmienną środowiskową TMP.  
  
2.  Ścieżka określona przez zmienną środowiskową TEMP.  
  
3.  Ścieżka określona przez zmienną środowiskową profilu użytkownika.  
  
4.  Katalog systemu Windows.  
  
   
  
## Examples  
 Poniższy kod ilustruje sposób wywoływania <xref:System.IO.Path.GetTempPath%2A> metody.  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 Ten przykład generuje dane wyjściowe podobne do poniższych.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma wymaganych uprawnień.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">w przypadku nieograniczonego dostępu do zmiennych środowiskowych. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do wyszukiwania rozszerzenia.</param>
        <summary>Określa, czy ścieżka reprezentowana przez określony zakres znaków zawiera rozszerzenie nazwy pliku.</summary>
        <returns><see langword="true" />Jeśli znaki znajdujące się po ostatnim znaku separatora katalogu lub separator woluminu w ścieżce obejmują kropkę ("."), po której następuje jeden lub więcej znaków; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Końcowy okres w `path` nie jest uważany za rozszerzenie.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do wyszukiwania rozszerzenia.</param>
        <summary>Określa, czy ścieżka zawiera rozszerzenie nazwy pliku.</summary>
        <returns><see langword="true" />Jeśli znaki, które są zgodne z ostatnim separatorem\\katalogu (\ lub/) lub separatorem woluminu (:) ścieżka zawiera kropkę (.), po której następuje jeden lub więcej znaków; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Począwszy od końca `path`, ta metoda wyszukuje kropkę (.), po którym następuje co najmniej jeden znak. Jeśli ten wzorzec <xref:System.IO.Path.DirectorySeparatorChar>zostanie znaleziony przed znakiem, <xref:System.IO.Path.AltDirectorySeparatorChar>, <xref:System.IO.Path.VolumeSeparatorChar> lub zostanie napotkany, ta metoda `true`zwraca.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `HasExtension` metody.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dostarcza tablicę znaków specyficznych dla platformy, których nie można określić w argumentach ciągu ścieżki przekazane do elementów <see cref="T:System.IO.Path" /> członkowskich klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica zwracana z tej metody nie powinna zawierać pełnego zestawu znaków, które są nieprawidłowe w nazwach plików i katalogów. Pełny zestaw nieprawidłowych znaków może różnić się w zależności od systemu plików. Na przykład na platformach klasycznych opartych na systemie Windows nieprawidłowe znaki ścieżki mogą zawierać znaki ASCII/Unicode od 1 do 31, a także cudzysłowy ("), mniejsze\<niż (), większe niż (>),&#124;potok (), Backspace (\b), null (\ 0) i Tab (\t).  
  
> [!CAUTION]
>  Nie należy używać <xref:System.IO.Path.InvalidPathChars> , jeśli uważasz, że kod może być wykonywany w tej samej domenie aplikacji co kod niezaufany. <xref:System.IO.Path.InvalidPathChars>jest tablicą, więc jego elementy mogą być zastępowane. Jeśli niezaufany kod zastąpi elementy <xref:System.IO.Path.InvalidPathChars>, może dojść do nieprawidłowego kodu w sposób, który mógłby być wykorzystany.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `InvalidPathChars` właściwości.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Zwraca wartość wskazującą, czy ścieżka pliku jest w pełni kwalifikowana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Przeciążenia `IsPathFullyQualified` metody obsługują ścieżki, które używają <xref:System.IO.Path.DirectorySeparatorChar> <xref:System.IO.Path.AltDirectorySeparatorChar> znaków i. Nie wykonuje żadnych walidacji ścieżki, która jest przenoszona do niej jako argument. W związku z tym identyfikatory URI są interpretowane jako ścieżki względne i zwracane `false`. 

Istnieje różnica między w pełni kwalifikowaną ścieżką (wskazywanym przez `IsPathFullyQualified` metodę) a ścieżką główną (jak wskazano <xref:System.IO.Path.IsPathRooted%2A> w metodzie). W *pełni kwalifikowana ścieżka* lub *bezwzględna ścieżka* zawsze definiuje dokładną ścieżkę z określonego dysku lub urządzenia do pliku lub katalogu docelowego i nie zależy od bieżącego dysku lub bieżącego katalogu. Na przykład w systemach Windows, *C:/Users/Użytkownik1/Documents/Reports/2019/styczeń/wyróżnienis. PDF* definiuje ścieżkę bezwzględną z katalogu głównego dysku C: do pliku docelowego, *Podświetl. PDF*. *Ścieżka* z odblokowanym dostępem określa dysk startowy lub katalog główny, ale zależy od bieżącego katalogu (jeśli jest on odblokowany przez określony dysk) lub bieżącego dysku (jeśli jest on odblokowany przez katalog główny). Poniższy przykład ilustruje różnicę między w pełni kwalifikowanymi ścieżkami i ścieżkami głównymi.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku.</param>
        <summary>Zwraca wartość wskazującą, czy ścieżka pliku reprezentowana przez określony zakres znaków jest ustalona dla określonego dysku lub ścieżki UNC.</summary>
        <returns><see langword="true" />Jeśli ścieżka jest stała dla określonego dysku lub ścieżki UNC; <see langword="false" /> Jeśli ścieżka jest określana względem bieżącego dysku lub katalogu roboczego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka pliku.</param>
        <summary>Zwraca wartość wskazującą, czy określona ścieżka pliku jest stała dla określonego dysku lub ścieżki UNC.</summary>
        <returns><see langword="true" />Jeśli ścieżka jest stała dla określonego dysku lub ścieżki UNC; <see langword="false" /> Jeśli ścieżka jest określana względem bieżącego dysku lub katalogu roboczego.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" />jest <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Zwraca wartość wskazującą, czy ścieżka pliku zawiera element główny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

**Ścieżka** z odblokowanym dostępem do ścieżki pliku, który jest ustalony dla konkretnego dysku lub ścieżki. jest to kontrast ze ścieżką względną względem bieżącego dysku lub katalogu roboczego. Na przykład w systemach Windows ścieżką główną zaczyna się od ukośnika odwrotnego (na przykład "\Documents") lub litery dysku i dwukropek (na przykład "C:Documents"). 

Należy pamiętać, że ścieżki z odblokowanym dostępem mogą być bezwzględne (czyli w pełni kwalifikowana) lub względne. Ścieżka bezwzględna jest w pełni kwalifikowana ścieżka z katalogu głównego dysku do określonego katalogu. Względna ścieżka do ścieżki źródłowej określa dysk, ale jego w pełni kwalifikowana ścieżka jest rozpoznawana w bieżącym katalogu. Poniższy przykład ilustruje różnicę.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do przetestowania.</param>
        <summary>Zwraca wartość wskazującą, czy określony zakres znaków reprezentujący ścieżkę pliku zawiera element główny.</summary>
        <returns><see langword="true" />Jeśli <paramref name="path" /> zawiera element główny; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do przetestowania.</param>
        <summary>Zwraca wartość wskazującą, czy określony ciąg ścieżki zawiera element główny.</summary>
        <returns><see langword="true" />Jeśli <paramref name="path" /> zawiera element główny; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca wartość `true` , jeśli pierwszy znak jest znakiem separatora katalogu, takim\\jak "", lub jeśli ścieżka rozpoczyna się od litery dysku i dwukropka (:). <xref:System.IO.Path.IsPathRooted%2A> Na `true` przykład zwraca\\dla `path` ciągów, takich jak "\\\mydir\\\MyFile.txt", "C: \mydir" lub "C:mydir". Zwraca `false` dla`path` ciągów, takich jak "Mydir".  
  
 Ta metoda nie sprawdza, czy ścieżka lub nazwa pliku istnieje.  
  
 Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).  

## Examples  
 W poniższym przykładzie pokazano, `IsPathRooted` jak można użyć metody do testowania trzech ciągów.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" />zawiera co najmniej jeden nieprawidłowy znak zdefiniowany w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Tablica ścieżek.</param>
        <summary>Łączy tablicę ścieżek w jedną ścieżkę.</summary>
        <returns>Łączona ścieżka.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Ta metoda po prostu łączy wszystkie ciągi w `paths` i dodaje znak separatora katalogu między wszystkimi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny. Jeśli którakolwiek z ścieżek w `paths` jest równa zero, Metoda łączy pozostałe argumenty. <xref:System.String.Length> Jeśli wynikowa długość połączonego ciągu wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.

Jeśli dowolna ze ścieżek w `paths`, z wyjątkiem ostatniego, kończą się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Join` , metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że jeśli którakolwiek z ścieżek w `paths`, z wyjątkiem ostatniego, jest ścieżką bezwzględną `Join` , metoda nie odrzuci poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.

Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją.

             </format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</param>
        <param name="path2">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</param>
        <summary>Łączy dwa składniki ścieżki w jedną ścieżkę.</summary>
        <returns>Połączone ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Ta metoda po prostu łączy `path` i `path2` dodaje znak separatora katalogu między dwoma składnikami ścieżki, jeśli jeden nie jest jeszcze `path1` obecny na końcu lub początku `path2`. Jeśli wartość lub`path2`jest równa zero, metoda zwraca inną ścieżkę. `path1` <xref:System.ReadOnlySpan%601.Length> <xref:System.String.Empty?displayProperty=nameWithType>Jeśli oba `path1` i`path2` są zerami, metoda zwraca. <xref:System.ReadOnlySpan%601.Length> 

Jeśli `path1` zostanie zakończona literałem ścieżki, która nie jest odpowiednia dla platformy docelowej `Join` , metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows. 

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że `path2` jeśli jest ścieżką bezwzględną `Join` , metoda nie `path1` <xref:System.IO.Path.Combine%2A> odrzuca i `path2` zwraca jako metoda.) Poniższy przykład ilustruje różnicę w ścieżkach zwracanych przez dwie metody. Jeśli źródłem `path2` jest dane wejściowe użytkownika <xref:System.IO.Path.Combine%2A> , Metoda umożliwia użytkownikowi uzyskanie dostępu do zasobu systemu plików (takiego jak *C:/Users/Użytkownik1/Documents/Financial/* w przypadku przykładu), którego aplikacja nie zamierza wprowadzić pul.  

Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją. 

## <a name="example"></a>Przykład

Poniższy przykład ilustruje różnicę w ścieżkach zwracanych przez <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> metody i. <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> Gdy pierwszy ciąg jest w pełni kwalifikowaną ścieżką obejmującą dysk i katalog główny, a drugi jest ścieżką względną od pierwszej ścieżki, dwie metody dają identyczne wyniki. W drugim i trzecim wywołaniach `ShowPathInformation` metody, ciągi zwracane przez dwie metody rozbieżność. W drugim wywołaniu metody pierwszy argument ciągu jest dysk, a drugi jest katalogiem głównym. `Join` Metoda łączy dwa ciągi i zachowuje duplikaty separatorów ścieżek. `Combine` Metoda porzuca dysk i zwraca katalog główny na bieżącym dysku. Jeśli bieżącym dyskiem aplikacji jest C:\ a ciąg jest używany w celu uzyskania dostępu do pliku lub plików w katalogu, będzie miał dostęp do C: zamiast D:. Na koniec, ponieważ oba argumenty w trzecim wywołaniu `ShowPathInformation` są odblokowane `Join` , metoda po prostu dołącza je do utworzenia ścieżki `Combine` pliku bezsensownie, podczas gdy metoda odrzuca pierwszy ciąg i zwraca sekundę. Użycie tego ciągu na potrzeby dostępu do plików może dać aplikacji niezamierzony dostęp do poufnych plików.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Pierwsza ścieżka do przyłączenia.</param>
        <param name="path2">Druga ścieżka do przyłączenia.</param>
        <summary>Łączy dwie ścieżki w jedną ścieżkę.</summary>
        <returns>Łączona ścieżka.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Ta metoda po prostu łączy `path` i `path2` dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny. Jeśli długość `path1` lub `path2` jest równa zero, Metoda łączy pozostałe argumenty. Jeśli długość wynikowego ciągu połączonego wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.

Jeśli `path1` zostanie zakończona literałem ścieżki, która nie jest odpowiednia dla platformy docelowej `Join` , metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że `path2` jeśli jest ścieżką bezwzględną `Join` , metoda nie odrzuci poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.

Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją.

             </format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</param>
        <param name="path2">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</param>
        <param name="path3">Zakres znaków, który zawiera trzecią ścieżkę do przyłączenia.</param>
        <summary>Łączy trzy składniki ścieżki w jedną ścieżkę.</summary>
        <returns>Łączona ścieżka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Ta metoda po prostu łączy `path`, `path2`i `path3` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny. `path1` Jeśliktórykolwiek`path2`z argumentówmawartośćzero,Metodałączypozostałeargumenty`path3`. <xref:System.ReadOnlySpan%601.Length> Jeśli wartość wszystkich składników jest równa zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType>

Jeśli `path1` `Join` lub `path2` kończący się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że `path2` Jeśli `path2` lub jest ścieżką bezwzględną, `Join` Metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.
  
Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją.

## <a name="example"></a>Przykład

Poniższy przykład ilustruje różnicę w ścieżkach zwracanych przez <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> metody i. <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> Gdy pierwszy ciąg jest w pełni kwalifikowaną ścieżką obejmującą dysk i katalog główny, a drugi jest ścieżką względną od pierwszej ścieżki, dwie metody generują identyczne wyniki. W drugim i trzecim wywołaniach `ShowPathInformation` metody, ciągi zwracane przez dwie metody rozbieżność. W drugim wywołaniu metody pierwszy argument ciągu jest dysk, a drugi jest katalogiem głównym. `Join` Metoda łączy dwa ciągi i zachowuje duplikaty separatorów ścieżek. Wywołanie <xref:System.IO.Path.GetFullPath%2A> metody eliminuje duplikowanie. `Combine` Metoda porzuca dysk i zwraca katalog główny na bieżącym dysku. Jeśli bieżącym dyskiem aplikacji jest C:\ a ciąg jest używany w celu uzyskania dostępu do pliku lub plików w katalogu, będzie miał dostęp do C: zamiast D:. Na koniec, ponieważ końcowy argument w trzecim wywołaniu `ShowPathInformation` jest odblokowany `Join` , metoda po prostu dołącza ją do pierwszych dwóch argumentów w celu utworzenia ścieżki `Combine` pliku bezsensownie, podczas gdy metoda odrzuca pierwsze dwa ciągi i zwraca trzecia. Użycie tego ciągu na potrzeby dostępu do plików może dać aplikacji niezamierzony dostęp do poufnych plików.

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Pierwsza ścieżka do przyłączenia.</param>
        <param name="path2">Druga ścieżka do przyłączenia.</param>
        <param name="path3">Trzecia ścieżka do przyłączenia.</param>
        <summary>Łączy trzy ścieżki w jedną ścieżkę.</summary>
        <returns>Łączona ścieżka.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Ta metoda po prostu łączy `path`, `path2`i `path3` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny. Jeśli długość któregokolwiek `path1` `path2` lub `path3` argumentu jest równa zero, Metoda łączy pozostałe argumenty. Jeśli długość wynikowego ciągu połączonego wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.

Jeśli `path1` `Join` lub `path2` kończący się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że `path2` Jeśli `path2` lub jest ścieżką bezwzględną, `Join` Metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.

Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją.

             </format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</param>
        <param name="path2">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</param>
        <param name="path3">Zakres znaków, który zawiera trzecią ścieżkę do przyłączenia.</param>
        <param name="path4">Zakres znaków, który zawiera czwartą ścieżkę do przyłączenia.</param>
        <summary>Łączy cztery składniki ścieżki w jedną ścieżkę.</summary>
        <returns>Łączona ścieżka.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Ta metoda po prostu łączy `path` `path3` , `path2`i `path4` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny. Jeśliktórykolwiek`path2`z `path1` argumentów`path3`ma wartość zero, Metoda łączy pozostałe argumenty. <xref:System.ReadOnlySpan%601.Length> `path4` Jeśli wartość wszystkich składników jest równa zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>. <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType>

Jeśli `path1` lub `path2` lub `Join` zostaje zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. `path3` Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że `path2` Jeśli `path2` `path3` lub jest ścieżką bezwzględną `Join` , metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.

Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Pierwsza ścieżka do przyłączenia.</param>
        <param name="path2">Druga ścieżka do przyłączenia.</param>
        <param name="path3">Trzecia ścieżka do przyłączenia.</param>
        <param name="path4">Czwarta ścieżka do przyłączenia.</param>
        <summary>Łączy cztery ścieżki w jedną ścieżkę.</summary>
        <returns>Łączona ścieżka.</returns>
        <remarks>
          <format type="text/markdown">
        

## Remarks

Ta metoda po prostu łączy `path` `path3` , `path2`i `path4` i dodaje znak separatora katalogu między dowolnymi składnikami ścieżki, jeśli jeden z nich nie jest jeszcze obecny. Jeśli długość `path1`któregokolwiek z argumentów `path3` , `path2`lub `path4` jest równa zero, Metoda łączy pozostałe argumenty. Jeśli długość wynikowego ciągu połączonego wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.

Jeśli `path1` lub `path2` lub `Join` zostaje zakończony znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej, metoda zachowuje oryginalny znak separatora ścieżki i dołącza obsługiwane. `path3` Ten problem występuje w ścieżkach twardych, które używają znaku ukośnika odwrotnego ("\") systemu Windows, który nie jest rozpoznawany jako separator ścieżki w systemach z systemem UNIX. Aby obejść ten problem, możesz:

- Pobierz wartość właściwości, <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> a nie kodowanie twarde znaku separatora katalogu.

- Użyj ukośnika ("/") jako znaku separatora katalogu. Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach UNIX i <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> przez właściwość w systemach Windows.

W przeciwieństwie <xref:System.IO.Path.Combine%2A> do metody <xref:System.IO.Path.Join%2A> , metoda nie próbuje uzyskać dostępu do głównej zwróconej ścieżki. (Oznacza to, że `path2` Jeśli `path2` `path3` lub jest ścieżką bezwzględną `Join` , metoda nie odrzuca poprzednich ścieżek jako <xref:System.IO.Path.Combine%2A> metody.

Nie wszystkie nieprawidłowe znaki dla katalogów i nazw plików są interpretowane jako nieakceptowalne przez `Join` metodę, ponieważ można użyć tych znaków do wyszukiwania symboli wieloznacznych. Na przykład podczas `Path.Join("c:\\", "temp", "*.txt")` tworzenia pliku może być nieprawidłowy, jest on prawidłowy jako ciąg wyszukiwania. Dlatego `Join` metoda pomyślnie interpretuje ją.

             </format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Znak separatora specyficzny dla platformy używany do oddzielania ciągów ścieżki w zmiennych środowiskowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku platform komputerowych opartych na systemie Windows wartość tego pola jest średnikiem (;) Domyślnie, ale mogą się różnić w zależności od innych platform.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `PathSeparator` pola.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Próbuje połączyć poszczególne składniki ścieżki ze wstępnie przydzielonym zakresem znaków i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Docelowy zakres znaków musi być wystarczająco duży, aby pomieścić połączone ścieżki. Następnie można pobrać połączone ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metodę, jak pokazano w poniższym przykładzie.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</param>
        <param name="path2">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</param>
        <param name="destination">Zakres znaków do przechowywania połączonej ścieżki.</param>
        <param name="charsWritten">Gdy metoda zwraca, wartość, która wskazuje liczbę znaków, które są <paramref name="destination" />zapisywane w.</param>
        <summary>Próbuje połączyć dwa składniki ścieżki z pojedynczym wstępnie przydzielonym zakresem znaków i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli operacja łączenia się powiedzie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination`musi być wystarczająco duży, aby pomieścić połączone ścieżki. Następnie można pobrać połączone ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metodę, jak pokazano w przykładzie.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Zakres znaków, który zawiera pierwszą ścieżkę do przyłączenia.</param>
        <param name="path2">Zakres znaków, który zawiera drugą ścieżkę do przyłączenia.</param>
        <param name="path3">Zakres znaków, który zawiera trzecią ścieżkę do przyłączenia.</param>
        <param name="destination">Zakres znaków do przechowywania połączonej ścieżki.</param>
        <param name="charsWritten">Gdy metoda zwraca, wartość, która wskazuje liczbę znaków, które są <paramref name="destination" />zapisywane w.</param>
        <summary>Próbuje połączyć dwa składniki ścieżki z pojedynczym wstępnie przydzielonym zakresem znaków i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli operacja łączenia się powiedzie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination`musi być wystarczająco duży, aby pomieścić połączone ścieżki. Następnie można pobrać połączone ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metodę, jak pokazano w przykładzie.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formaty ścieżek plików w systemie Windows</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera znak separatora woluminu specyficzny dla platformy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest dwukropek (:) w systemie Windows i komputerach Macintosh oraz ukośnik (/) w systemach operacyjnych UNIX. Jest to najbardziej przydatne w przypadku analizowania ścieżek, takich jak "c:\Windows" lub "MacVolume: system folder".  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie `VolumeSeparatorChar` pola.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">We/Wy plików i strumieni</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Instrukcje: Odczytywanie tekstu z pliku</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Instrukcje: Zapisywanie tekstu w pliku</related>
      </Docs>
    </Member>
  </Members>
</Type>
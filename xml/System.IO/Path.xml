<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1eaca2d8dfd9fc38261f9fb7664ea9a4126f45f4" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56763525" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b9bf6-101">Wykonuje operacje na <see cref="T:System.String" /> wystąpień, które zawierają informacje o ścieżce pliku lub katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="b9bf6-102">Te operacje są wykonywane w sposób dla wielu platform.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="b9bf6-103">Ścieżka to ciąg, który określa lokalizację pliku lub katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="b9bf6-104">Nie musi być ścieżką do lokalizacji na dysku na przykład ścieżki mogą być mapowane do lokalizacji w pamięci lub na urządzeniu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="b9bf6-105">Dokładny format ścieżki jest ustalana bieżącej platformy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="b9bf6-106">Na przykład w niektórych systemach ścieżki można uruchomić za pomocą litery dysku lub woluminie, podczas gdy ten element nie znajduje się w innych systemach.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="b9bf6-107">W niektórych systemach ścieżki plików mogą zawierać rozszerzenia, które wskazują na typ informacji przechowywanych w pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="b9bf6-108">Format rozszerzenia nazwy pliku jest zależny od platformy; na przykład niektóre systemy ograniczyć rozszerzenia do trzech znaków, a inne nie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="b9bf6-109">Bieżąca platforma określa również zestaw znaków używany do oddzielania elementów ścieżki, a zestaw znaków, których nie można używać podczas określania ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="b9bf6-110">Ze względu na różnice te pola `Path` klasy, a także dokładne zachowanie niektórzy członkowie `Path` klasy są zależne od platformy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="b9bf6-111">Ścieżka może zawierać informacje o lokalizacji bezwzględny lub względny.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="b9bf6-112">Ścieżki bezwzględne w pełni określić lokalizację: plik lub katalog może być identyfikowane niezależnie od bieżącej lokalizacji.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="b9bf6-113">Ścieżki względne lokalizację, do częściowego: Bieżąca lokalizacja jest używana jako punktu wyjścia podczas lokalizowania określony plik ze ścieżką względną.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="b9bf6-114">Aby określić bieżący katalog, należy wywołać <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="b9bf6-115">.NET core 1.1 i nowszych wersjach i .NET Framework 4.6.2 i nowsze wersje obsługują także dostęp do obiektów systemu plików, które są nazwy urządzenia, na przykład "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="b9bf6-116">Aby uzyskać więcej informacji na temat formatów ścieżki plików w Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="b9bf6-117">Większość członkowie `Path` klasy nie wchodź w interakcję z systemem plików i nie sprawdzał, czy określona przez ciąg ścieżki pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="b9bf6-118">`Path` elementy członkowskie, które modyfikują ciąg ścieżki, takich jak klasy <xref:System.IO.Path.ChangeExtension%2A>, nie mają wpływu na nazwy plików w systemie plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="b9bf6-119">`Path` elementy członkowskie, jednak sprawdzić zawartość ciągu na określonej ścieżce i zgłosić <xref:System.ArgumentException> wyjątek, jeśli ciąg zawiera znaki, które nie są prawidłowe w ciągach ścieżki, zgodnie z definicją w znakach zwrócone w wyniku <xref:System.IO.Path.GetInvalidPathChars%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="b9bf6-120">Na przykład na platformach opartych na Windows pulpitu, znaki nieprawidłowe dla ścieżki może zawierać cudzysłowu ("), mniej niż (\<), większe niż (>), kreski pionowej (&#124;), backspace (\b), o wartości null (\0) i znaki Unicode 16 do 18 i 20 do 25.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="b9bf6-121">Elementy członkowskie `Path` klasy umożliwiają łatwe i szybkie wykonywania typowych operacji, takich jak określanie, czy rozszerzenie jest częścią ścieżki i łączenie dwóch ciągów w jedną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="b9bf6-122">Wszystkie elementy członkowskie `Path` klasy są statyczne i w związku z tym może być wywołana bez konieczności wystąpienia ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b9bf6-123">W przypadku elementów członkowskich, które akceptują ścieżka jako ciąg wejściowy ta ścieżka musi być poprawnie sformułowany lub zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="b9bf6-124">Na przykład jeśli ścieżka jest w pełni kwalifikowany, ale zaczyna się od spacji, ścieżki nie są spacje w metody klasy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="b9bf6-125">W związku z tym ścieżka jest źle sformułowany i zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="b9bf6-126">Podobnie ścieżki lub kombinacji ścieżki nie może być w pełni kwalifikowana dwa razy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="b9bf6-127">Na przykład "c:\temp c:\windows" zgłasza również wyjątek w większości przypadków.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="b9bf6-128">Upewnij się, Twoje ścieżki są poprawnie sformułowane, korzystając z metod, które akceptują ciąg ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="b9bf6-129">W przypadku elementów członkowskich, które akceptują ścieżki ścieżki mogą odwoływać się do pliku lub po prostu katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="b9bf6-130">Określona ścieżka może również dotyczyć ścieżką względną lub ścieżką Universal Naming Convention (UNC) dla nazwy serwera i udziału.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="b9bf6-131">Na przykład następujące warunki są dopuszczalne ścieżki:</span><span class="sxs-lookup"><span data-stu-id="b9bf6-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="b9bf6-132">"c:\\\MyDir\\\MyFile.txt" w języku C# lub "c:\MyDir\MyFile.txt" w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="b9bf6-133">"c:\\\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="b9bf6-134">"MyDir\\\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="b9bf6-135">"\\\\\\\MyServer\\\MyShare" w języku C# lub "\\\MyServer\MyShare" w języku Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="b9bf6-136">Ponieważ te operacje są wykonywane na ciągi, jest niemożliwe sprawdzić, czy wyniki są prawidłowe we wszystkich scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="b9bf6-137">Na przykład <xref:System.IO.Path.GetExtension%2A> metoda analizuje ciąg, który zostanie przekazany do niego i zwraca numer wewnętrzny z tego ciągu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="b9bf6-138">Jednak oznacza to, że plik za pomocą tego rozszerzenia istnieje na dysku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="b9bf6-139">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="b9bf6-140">W poniższym przykładzie pokazano niektóre z głównych elementów członkowskich `Path` klasy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-141">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-142">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-143">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="b9bf6-144">Instrukcje: Odczyt i zapis w nowo utworzonym pliku danych</span><span class="sxs-lookup"><span data-stu-id="b9bf6-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-145">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9bf6-146">Dostarcza specyficzne dla platformy znak alternatywne, używany do rozdzielania poziomów katalogów w ciąg ścieżki, który odzwierciedla organizacje systemu plików hierarchiczne.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="b9bf6-147">To pole może mieć taką samą wartość jak <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="b9bf6-148">`AltDirectorySeparatorChar` i <xref:System.IO.Path.DirectorySeparatorChar> są prawidłowe dla oddzielenie poziomów katalogów w ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="b9bf6-149">Wartość tego pola jest ukośnikiem ("/") w systemach operacyjnych Unix i Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="b9bf6-150">Poniższy przykład wyświetla <xref:System.IO.Path> pole wartości na Windows i na komputerach z systemem Unix.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="b9bf6-151">Należy pamiętać, że Windows obsługuje znakiem kreski ułamkowej (zwracany przez <xref:System.IO.Path.AltDirectorySeparatorChar> pola) lub ukośnik odwrotny (który jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar> pola) jako znaki separatora ścieżki, komputerach z systemem Unix obsługują tylko ukośnika.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-152">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-153">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-154">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-155">Informacje o ścieżce do zmodyfikowania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-155">The path information to modify.</span></span> <span data-ttu-id="b9bf6-156">Ścieżka nie może zawierać żadnego ze znaków zdefiniowanych w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="b9bf6-157">Nowe rozszerzenie (z lub bez poprzedzającej go kropki).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="b9bf6-158">Określ <see langword="null" /> Aby usunąć istniejące rozszerzenie z <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="b9bf6-159">Powoduje zmianę rozszerzenia ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-160">Informacje o ścieżce zmodyfikowane.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-160">The modified path information.</span></span>  
  
<span data-ttu-id="b9bf6-161">Na platformach opartych na Windows pulpitu Jeśli <paramref name="path" /> jest <see langword="null" /> ani być pustym ciągiem (""), informacje o ścieżce jest zwracany niemodyfikowany.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="b9bf6-162">Jeśli <paramref name="extension" /> jest <see langword="null" />, zwrócony ciąg zawiera określona ścieżka z rozszerzeniem usunięte.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="b9bf6-163">Jeśli <paramref name="path" /> nie ma rozszerzenia, a <paramref name="extension" /> nie <see langword="null" />, zawiera ciąg zwracany ścieżki <paramref name="extension" /> dołączany na końcu <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-164">Jeśli żadna `path` ani `extension` zawiera kropkę (.), `ChangeExtension` dodaje okresu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="b9bf6-165">`extension` Parametr może zawierać wiele kropek i wszystkie znaki prawidłową ścieżkę i może być dowolnej długości.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="b9bf6-166">Jeśli `extension` jest `null`, zwrócony ciąg zawiera zawartość `path` z poprzednim okres i wszystkie znaki po jej usunąć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="b9bf6-167">Jeśli `extension` jest pusty ciąg, ciąg ścieżki zwrócony z zawartością `path` znakami po ostatnim okresie usunięte.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="b9bf6-168">Jeśli `path` nie ma rozszerzenia i `extension` nie `null`, zwrócony ciąg zawiera `path` następuje `extension`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="b9bf6-169">Jeśli `extension` nie `null` i nie może zawierać kropki na początku, okres zostanie dodany.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="b9bf6-170">Jeśli `path` zawiera wiele rozszerzeń, oddzielone kropkami wielu zwracanego ciągu z zawartością `path` z poprzednim okresie i wszystkie znaki po jego zastępuje `extension`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="b9bf6-171">Na przykład jeśli `path` jest "\Dir1\examples\pathtests.csx.txt" i `extension` "cs", ścieżka modyfikacji "\Dir1\examples\pathtests.csx.cs".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="b9bf6-172">Nie jest możliwe sprawdzić, czy zwracane wyniki są prawidłowe we wszystkich scenariuszach.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="b9bf6-173">Na przykład jeśli `path` jest pusta, `extension` jest dołączany.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="b9bf6-174">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-175">W poniższym przykładzie pokazano użycie `ChangeExtension` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-176"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-177">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-178">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-179">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-180">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9bf6-181">Łączy ciągi w ścieżce.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="b9bf6-182">Ta metoda jest przeznaczona dla poszczególnych ciągów w jeden ciąg, który reprezentuje ścieżkę do pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="b9bf6-183">Jednak jeśli argument innych niż pierwszy zawiera ścieżki do katalogu głównego, wszystkie poprzednie składników ścieżki są ignorowane i zwracanego ciągu, który rozpoczyna się od danego składnika ścieżki do katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="b9bf6-184">Jako alternatywę dla `Combine` metody, należy rozważyć użycie <xref:System.IO.Path.Join%2A> lub <xref:System.IO.Path.TryJoin%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b9bf6-185">Ta metoda założono, że pierwszy argument jest ścieżką bezwzględną i następujący argument lub argumenty ścieżek względnych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="b9bf6-186">Jeśli tak nie jest, a szczególnie, jeśli wszystkie pozostałe argumenty są ciągami wprowadzane przez użytkownika, wywołaj <xref:System.IO.Path.Join%2A> lub <xref:System.IO.Path.TryJoin%2A> metody zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="b9bf6-187">Tablica części ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="b9bf6-188">Łączy tablicę ciągów w ścieżce.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-189">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="b9bf6-190">`paths` powinna być tablica części ścieżki, aby połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="b9bf6-191">Jeśli z jednym z kolejnych ścieżki jest ścieżką bezwzględną, operację łączenia resetuje, począwszy od tej ścieżki bezwzględnej odrzucanie wszystkich poprzednich połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="b9bf6-192">Jeśli dowolny element w `paths` , ale ostatni z nich nie jest dyskiem i nie kończy się albo <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar> znak `Combine` metoda dodaje <xref:System.IO.Path.DirectorySeparatorChar> znaków między tym elementem i kolejny.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="b9bf6-193">Należy zauważyć, że jeśli element kończy się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Combine` metody zachowuje oryginalne znakiem separatora ścieżki i dołącza obsługiwanym elementem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="b9bf6-194">Poniższy przykład porównuje wynik dla systemów Unix i Windows w przypadku użycia ukośnik odwrotny jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="b9bf6-195">Ciągi o zerowej długości zostały pominięte w złożonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="b9bf6-196">Parametry nie są parsowane, jeśli biały znak.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="b9bf6-197">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku są interpretowane jako nie do przyjęcia przez `Combine` metody, ponieważ te znaki mogą używać do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="b9bf6-198">Na przykład `Path.Combine("c:\\", "*.txt")` może być nieprawidłowy w przypadku utworzenia pliku z jego jest prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="b9bf6-199">W związku z tym jest pomyślnie interpretowany przez `Combine` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="b9bf6-200">Poniższy przykład łączy tablicę ciągów w ścieżce.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-201">Jeden z ciągów w tablicy zawiera jeden lub więcej nieprawidłowych znaków zdefiniowanych w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-202">Jeden z ciągów w tablicy jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-203">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-204">Pierwsza ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-205">Drugi ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="b9bf6-206">Łączy dwa ciągi na ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-207">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-207">The combined paths.</span></span> <span data-ttu-id="b9bf6-208">Jeśli jeden z określonych ścieżek jest ciągiem o zerowej długości, Metoda ta zwraca innej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="b9bf6-209">Jeśli <paramref name="path2" /> zawiera ścieżkę bezwzględną, Metoda ta zwraca <paramref name="path2" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-210">Jeśli `path1` nie jest odwołaniem do dysku (tj. "C:" lub "D:") i nie może kończyć prawidłowego znaku separatora zgodnie z definicją w <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, lub <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> jest dołączany do `path1` przed łączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="b9bf6-211">Należy pamiętać, że jeśli `path1` kończy się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Combine` metody zachowuje oryginalne znakiem separatora ścieżki i dołącza obsługiwanym elementem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="b9bf6-212">Poniższy przykład porównuje wynik dla systemów Unix i Windows w przypadku użycia ukośnik odwrotny jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="b9bf6-213">Jeśli `path2` nie obejmuje głównego (na przykład, jeśli `path2` nie rozpoczyna się od znaku separatora lub specyfikację dysku), wynik jest składa się z dwóch ścieżek, pośredniczące znaku separatora.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="b9bf6-214">Jeśli `path2` zawiera katalog główny `path2` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="b9bf6-215">Parametry nie są parsowane, jeśli biały znak.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="b9bf6-216">W związku z tym jeśli `path2` zawiera białe miejsca (na przykład "\file.txt"), <xref:System.IO.Path.Combine%2A> metoda dołącza `path2` do `path1` zamiast zwracać tylko `path2`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="b9bf6-217">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku są interpretowane jako nie do przyjęcia przez `Combine` metody, ponieważ te znaki mogą używać do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="b9bf6-218">Na przykład `Path.Combine("c:\\", "*.txt")` może być nieprawidłowy w przypadku utworzenia pliku z jego jest prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="b9bf6-219">W związku z tym jest pomyślnie interpretowany przez `Combine` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="b9bf6-220">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-221">Poniższy przykład demonstruje użycie `Combine` metody na platformie pulpitu Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-222"><paramref name="path1" /> lub <paramref name="path2" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-223"><paramref name="path1" /> lub <paramref name="path2" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-224">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-225">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-226">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-227">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-228">Pierwsza ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-229">Drugi ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="b9bf6-230">Trzeci ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="b9bf6-231">Łączy trzy ciągi na ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-232">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-233">`path1` powinna być ścieżką bezwzględną (na przykład "d:\archives" lub "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="b9bf6-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="b9bf6-234">Jeśli `path2` lub `path3` również jest ścieżką bezwzględną, ścieżki odrzuca wszystkie uprzednio połączone operacji łączenia i resetuje do tej ścieżki bezwzględnej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="b9bf6-235">Ciągi o zerowej długości zostały pominięte w złożonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="b9bf6-236">Jeśli `path1` lub `path2` nie jest odwołaniem do dysku (tj. "C:" lub "D:") i nie może kończyć prawidłowego znaku separatora zgodnie z definicją w <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, lub <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> jest dołączany do `path1` lub `path2` przed łączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="b9bf6-237">Należy pamiętać, że jeśli `path1` lub `path2` kończy się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Combine` metody zachowuje oryginalne znakiem separatora ścieżki i dołącza obsługiwanym elementem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="b9bf6-238">Poniższy przykład porównuje wynik dla systemów Unix i Windows w przypadku użycia ukośnik odwrotny jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="b9bf6-239">Jeśli `path2` nie obejmuje głównego (na przykład, jeśli `path2` nie rozpoczyna się od znaku separatora lub specyfikację dysku), wynik jest składa się z dwóch ścieżek, pośredniczące znaku separatora.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="b9bf6-240">Jeśli `path2` zawiera katalog główny `path2` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="b9bf6-241">Parametry nie są parsowane, jeśli biały znak.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="b9bf6-242">W związku z tym jeśli `path2` zawiera białe miejsca (na przykład "\file.txt"), <xref:System.IO.Path.Combine%2A> metoda dołącza `path2` do `path1`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="b9bf6-243">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku są interpretowane jako nie do przyjęcia przez `Combine` metody, ponieważ te znaki mogą używać do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="b9bf6-244">Na przykład `Path.Combine("c:\\", "*.txt")` może być nieprawidłowy w przypadku utworzenia pliku z jego jest prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="b9bf6-245">W związku z tym jest pomyślnie interpretowany przez `Combine` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-246">Poniższy przykład łączy trzy ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-247"><paramref name="path1" />, <paramref name="path2" />, lub <paramref name="path3" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-248"><paramref name="path1" />, <paramref name="path2" />, lub <paramref name="path3" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-249">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
        <Parameter Name="path4" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-250">Pierwsza ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-251">Drugi ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="b9bf6-252">Trzeci ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="b9bf6-253">Czwarty ścieżka połączyć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="b9bf6-254">Połączenie czterech ciągów w ścieżce.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-255">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-256">`path1` powinna być ścieżką bezwzględną (na przykład "d:\archives" lub "\\\archives\public"). Jeśli jedna ze ścieżek kolejnych również jest ścieżką bezwzględną, operację łączenia odrzuca wszystkie wcześniej połączone ścieżki, a ponadto resetuje do tej ścieżki bezwzględnej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="b9bf6-257">Ciągi o zerowej długości zostały pominięte w złożonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="b9bf6-258">Jeśli `path1`, `path2`, lub `path3` nie jest odwołaniem do dysku (tj. "C:" lub "D:") i nie może kończyć prawidłowego znaku separatora zgodnie z definicją w <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, lub <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> jest dołączany do niego przed łączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="b9bf6-259">Należy pamiętać, że jeśli `path1`, `path2`, lub `path3` kończy się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Combine` metody zachowuje oryginalne znakiem separatora ścieżki i dołącza obsługiwanym elementem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="b9bf6-260">Poniższy przykład porównuje wynik dla systemów Unix i Windows w przypadku użycia ukośnik odwrotny jako znak separatora ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="b9bf6-261">Jeśli `path2` nie obejmuje głównego (na przykład, jeśli `path2` nie rozpoczyna się od znaku separatora lub specyfikację dysku), wynik jest składa się z dwóch ścieżek, pośredniczące znaku separatora.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="b9bf6-262">Jeśli `path2` zawiera katalog główny `path2` jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="b9bf6-263">Parametry nie są parsowane, jeśli biały znak.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="b9bf6-264">W związku z tym jeśli `path2` zawiera białe miejsca (na przykład "\file.txt"), <xref:System.IO.Path.Combine%2A> metoda dołącza `path2` do `path1`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="b9bf6-265">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku są interpretowane jako nie do przyjęcia przez `Combine` metody, ponieważ te znaki mogą używać do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="b9bf6-266">Na przykład `Path.Combine("c:\\", "*.txt")` może być nieprawidłowy w przypadku utworzenia pliku z jego jest prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="b9bf6-267">W związku z tym jest pomyślnie interpretowany przez `Combine` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-268">Poniższy przykład łączy cztery ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, lub <paramref name="path4" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, lub <paramref name="path4" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-271">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9bf6-272">Dostarcza specyficzne dla platformy znak używany do rozdzielania poziomów katalogów w ciąg ścieżki, który odzwierciedla organizacje systemu plików hierarchiczne.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="b9bf6-273"><xref:System.IO.Path.AltDirectorySeparatorChar> i `DirectorySeparatorChar` są prawidłowe dla oddzielenie poziomów katalogów w ciągu ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="b9bf6-274">Jeśli korzystasz z platformy .NET Core do tworzenia aplikacji działających na wielu platformach:</span><span class="sxs-lookup"><span data-stu-id="b9bf6-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="b9bf6-275">Jeśli chcesz trwale kodować znakiem separatora katalogu, należy użyć ukośnika (`/`) znaków.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="b9bf6-276">Jest znakiem separatora katalogu rozpoznawanym tylko w systemach Unix jako dane wyjściowe w przykładzie pokazano i <xref:System.IO.Path.AltDirectorySeparatorChar> na Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="b9bf6-277">Użyj ciągów, aby dynamicznie pobrać znakiem separatora ścieżki w czasie wykonywania i dołączyć go do ścieżki systemu plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="b9bf6-278">Na przykład</span><span class="sxs-lookup"><span data-stu-id="b9bf6-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="b9bf6-279">Możesz również pobrać wartość z <xref:System.IO.Path.AltDirectorySeparatorChar> właściwość, ponieważ jest taki sam dla systemów Unx i Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="b9bf6-280">Pobieranie <xref:System.IO.Path.AltDirectorySeparatorChar> właściwości</span><span class="sxs-lookup"><span data-stu-id="b9bf6-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="b9bf6-281">Jeśli aplikacja nie jest dla wielu platform, używając separatora odpowiedni dla używanego systemu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="b9bf6-282">Poniższy przykład wyświetla <xref:System.IO.Path> pole wartości na Windows i na komputerach z systemem Unix.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="b9bf6-283">Należy pamiętać, że Windows obsługuje znakiem kreski ułamkowej (zwracany przez <xref:System.IO.Path.AltDirectorySeparatorChar> pola) lub ukośnik odwrotny (który jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar> pola) jako znaki separatora ścieżki, komputerach z systemem Unix obsługują tylko ukośnika.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-284">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-285">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-286">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-287">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="b9bf6-288">Zwraca wartość informacji katalogu dla określonej ścieżki, które są reprezentowane przez zakres znaków.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-289">Informacje katalogu dla <paramref name="path" />, lub pustego zakresu <paramref name="path" /> jest <see langword="null" />, pusty zakres lub elementem głównym (takich jak \, C:, lub \\server\share).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-290">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-291">Ścieżka pliku lub katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="b9bf6-292">Zwraca wartość informacji katalogu w ciągu określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-293">Informacje o katalogu dla <paramref name="path" />, lub <see langword="null" /> Jeśli <paramref name="path" /> wskazuje katalog główny lub ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="b9bf6-294">Zwraca <see cref="F:System.String.Empty" /> Jeśli <paramref name="path" /> nie zawiera informacji o katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-295">W większości przypadków ciąg zwracanego przez tę metodę zawiera wszystkie znaki w ścieżce maksymalnie z wyjątkiem ostatnich <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="b9bf6-296">Jeśli ścieżka składa się z katalogiem głównym, takie jak "c:\\", zwracana jest wartość null.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="b9bf6-297">Należy pamiętać, że ta metoda nie obsługuje ścieżek przy użyciu "pliku:".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="b9bf6-298">Zwrócone ścieżka zawiera <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar>, przekazanie ścieżki zwracany z powrotem do <xref:System.IO.Path.GetDirectoryName%2A> metoda spowoduje obcięcie jeden poziom folderów na kolejnych wywołań w ciągu wynikowym.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="b9bf6-299">Na przykład, przekazując ścieżkę "C:\Directory\SubDirectory\test.txt" do <xref:System.IO.Path.GetDirectoryName%2A> metoda zwróci "C:\Directory\SubDirectory".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="b9bf6-300">Przekazanie tego ciągu "C:\Directory\SubDirectory" do <xref:System.IO.Path.GetDirectoryName%2A> wynikiem będzie "C:\Directory".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="b9bf6-301">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-302">Poniższy przykład demonstruje użycie `GetDirectoryName` metody na platformie pulpitu Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-303"><paramref name="path" /> Parametru zawiera nieprawidłowe znaki, jest pusta lub zawiera tylko białe miejsca do magazynowania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="b9bf6-304">W <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, przechwycić wyjątek klasy bazowej <see cref="T:System.IO.IOException" />, a zamiast tego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="b9bf6-305"><paramref name="path" /> Parametr jest większa niż zdefiniowana w systemie długość maksymalna.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-306">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-307">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-308">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-309">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-310">Ścieżka pliku, z którego można pobrać rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-311">Zwraca numer wewnętrzny ścieżki pliku, który jest reprezentowany przez zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-312">Rozszerzenie określonej ścieżki (łącznie z okresem "."), lub <see cref="P:System.ReadOnlySpan`1.Empty" /> Jeśli <paramref name="path" /> nie ma informacji o rozszerzeniu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="b9bf6-313">Ta metoda uzyskuje rozszerzenia `path` , wyszukując `path` w danym okresie ("."), zaczynając od ostatniego znaku w zakresie tylko do odczytu i kontynuowanie kierunku jej pierwszym znakiem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="b9bf6-314">Jeśli okres zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar> znak zwrócone zakres tylko do odczytu zawiera kropkę i znaki po nim; w przeciwnym razie <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-315">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-316">Ciąg ścieżki, z którego można pobrać rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-317">Zwraca numer wewnętrzny w ciągu określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-317">Returns the extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-318">Rozszerzenie określonej ścieżki (w tym okresie "."), lub <see langword="null" />, lub <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="b9bf6-319">Jeśli <paramref name="path" /> jest <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> zwraca <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="b9bf6-320">Jeśli <paramref name="path" /> nie ma informacji o rozszerzeniu, <see cref="M:System.IO.Path.GetExtension(System.String)" /> zwraca <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="b9bf6-321">Ta metoda uzyskuje rozszerzenia `path` , wyszukując `path` dla kropki (.), począwszy od ostatniego znaku w `path` i przechodzić do pierwszego znaku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="b9bf6-322">Jeśli okres zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar> lub <xref:System.IO.Path.AltDirectorySeparatorChar> znaku, w zwracanym ciągu zawiera kropki i znaki po nim; w przeciwnym razie <xref:System.String.Empty?displayProperty=nameWithType> jest zwracana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="b9bf6-323">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="b9bf6-324">Poniższy przykład demonstruje użycie `GetExtension` metody na platformie pulpitu Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-325"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-326">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-327">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-328">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-329">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-330">Zakres tylko do odczytu, który zawiera ścieżkę, z którego można uzyskać nazwę pliku i rozszerzenie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-331">Zwraca nazwę pliku i rozszerzenie ścieżki pliku, który jest reprezentowany przez zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-332">Po ostatnim znakiem separatora katalogu w znaki <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="b9bf6-333">Zwrócone zakres tylko do odczytu zawiera znaki ścieżki, która postępuj zgodnie z ostatnich separator w `path`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="b9bf6-334">Jeśli ostatni znak w `path` jest znakiem separatora woluminu lub katalogu, metoda zwraca <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithtype>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithtype>.</span></span> <span data-ttu-id="b9bf6-335">Jeśli `path` zawiera nie znaku separatora, metoda zwraca `path`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-336">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-337">Ciąg ścieżki, z którego można uzyskać nazwę pliku i rozszerzenie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-338">Zwraca nazwę pliku i rozszerzenie, w ciągu określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-339">Po ostatnim znakiem separatora katalogu w znaki <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="b9bf6-340">Jeśli ostatni znak <paramref name="path" /> jest znak separatora katalogu lub woluminu, Metoda ta zwraca <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="b9bf6-341">Jeśli <paramref name="path" /> jest <see langword="null" />, Metoda ta zwraca <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="b9bf6-342">Zwrócona wartość jest `null` Jeśli ścieżka pliku jest `null`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="b9bf6-343">Znaki separatora, używana do określenia początku nazwa pliku są <xref:System.IO.Path.DirectorySeparatorChar> i <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="b9bf6-344">Ponieważ *\\* to nazwa pliku prawne w systemie Unix, `GetFileName` uruchomiona w ramach platformy z opartych na systemie Unix poprawnie nie można zwrócić nazwę pliku z Windows = oparte na ścieżkę, taką jak *C:\\mydir\\myfile.ext*, ale `GetFileName` uruchomiona w ramach platformy Windows poprawnie może zwrócić nazwę pliku z systemem UNIX ścieżkę, taką jak */tmp/myfile.ext*, więc zachowanie `GetFileName` Metoda nie jest ściśle taki sam dla platform Unix i Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows=based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="b9bf6-345">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-346">Poniższy przykład demonstruje działanie `GetFileName` metody na platformie pulpitu Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-347"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-348">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-349">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-350">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-351">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-352">Zakres tylko do odczytu, który zawiera ścieżkę, z którego można uzyskać nazwę pliku bez rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-353">Zwraca nazwę pliku bez rozszerzenia ścieżki pliku, który jest reprezentowany przez zakres znaków tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-354">Znaki w zakresie tylko do odczytu, zwracany przez <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus ostatniego kropki (.) i wszystkie znaki po jej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-355">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-356">Ścieżka pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="b9bf6-357">Zwraca nazwę pliku bez rozszerzenia, w ciągu określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-358">Ciąg zwracany przez <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus ostatniego kropki (.) i wszystkie znaki po jej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-359">Ta metoda nie sprawdza, czy istnieje Nazwa pliku lub ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="b9bf6-360">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-361">W poniższym przykładzie pokazano użycie `GetFileNameWithoutExtension` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-362"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-363">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-364">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-365">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-366">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-367">Plik lub katalog, dla którego można uzyskać informacji o ścieżkę bezwzględną.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="b9bf6-368">Zwraca ścieżkę bezwzględną do ciągu w określonej ścieżce.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-369">W pełni kwalifikowanej lokalizacji <paramref name="path" />, takie jak "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="b9bf6-370">Ścieżka bezwzględna zawiera wszystkie informacje wymagane do zlokalizowania pliku lub katalogu w systemie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="b9bf6-371">Pliku lub katalogu określonym przez `path` nie musi istnieć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="b9bf6-372">Na przykład jeśli *c:\temp\newdir* jest bieżący katalog wywoływania `GetFullPath` na nazwę pliku, taką jak *jako* zwraca *c:\temp\newdir\test.txt*.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="b9bf6-373">Plik nie musi istnieć.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="b9bf6-374">Jeśli `path` jest ścieżką względną tego przeciążenia zwraca w pełni kwalifikowanej ścieżki, która może opierać się na bieżącym dysku i bieżący katalog.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="b9bf6-375">Bieżący dysk i bieżący katalog można zmienić w dowolnym momencie, gdy aplikacja jest wykonywana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="b9bf6-376">W rezultacie ścieżka zwrócona przez element tego przeciążenia nie można ustalić wcześniej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="b9bf6-377">Zwraca ścieżkę deterministyczna, należy wywołać <xref:System.IO.Path.GetFullPath(System.String,System.String)> przeciążenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="b9bf6-378">Można również wywołać <xref:System.IO.Path.IsPathFullyQualified%2A> metodę, aby określić, czy jest w pełni kwalifikowana ścieżka względna lub i w związku z tym czy wywołanie `GetFullPath` jest konieczne.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="b9bf6-379">Jednak jeśli `path` istnieje, obiekt wywołujący musi mieć uprawnienia, aby uzyskać informacje o ścieżce dla `path`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="b9bf6-380">Należy pamiętać, że w przeciwieństwie do większości członków <xref:System.IO.Path> klasy, ta metoda uzyskuje dostęp do systemu plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="b9bf6-381">Ta metoda korzysta z bieżącego katalogu i bieżących informacji woluminu do pełnej kwalifikacji `path`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="b9bf6-382">Jeśli określisz plik nazwy tylko w `path`, `GetFullPath` zwraca w pełni kwalifikowaną ścieżkę bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="b9bf6-383">Jeśli przekażesz w krótkiej nazwy pliku, podzielonego długiej nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="b9bf6-384">Jeśli ścieżka nie zawiera żadnych znaków znaczących, jest on nieprawidłowy chyba że zawiera on co najmniej jeden "." znaków, a następnie przez dowolną liczbę miejsc do magazynowania; następnie będzie analizowany jako "."lub"..".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="b9bf6-385">.NET core 1.1 i nowszych wersjach i .NET Framework 4.6.2 i nowsze wersje obsługują także ścieżek, które obejmują nazwy urządzenia, takie jak "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="b9bf6-386">Aby uzyskać więcej informacji na temat formatów ścieżki plików w Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="b9bf6-387">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="b9bf6-388">W poniższym przykładzie pokazano `GetFullPath` metody na platformie pulpitu Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-389"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="b9bf6-390">—lub—</span><span class="sxs-lookup"><span data-stu-id="b9bf6-390">-or-</span></span> 
<span data-ttu-id="b9bf6-391">System nie może pobrać ścieżki bezwzględnej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b9bf6-392">Obiekt wywołujący nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-393"><paramref name="path" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b9bf6-394"><paramref name="path" /> zawiera dwukropek (":") oznacza to nie jest częścią identyfikator woluminu (na przykład "c:\\").</span><span class="sxs-lookup"><span data-stu-id="b9bf6-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="b9bf6-395">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="b9bf6-396">Aby uzyskać dostęp do ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-397">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-398">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-399">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-400">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="basePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-401">Ścieżka względna do łączenia się <see paramref="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-401">A relative path to concatenate to <see paramref="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="b9bf6-402">Początek w pełni kwalifikowaną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="b9bf6-403">Zwraca ścieżkę bezwzględną z w pełni kwalifikowanej ścieżki podstawowej i ścieżki względnej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-404">Ścieżka bezwzględna.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="b9bf6-405">Jeśli `path` jest pustą ścieżkę, metoda zwraca `basePath`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="b9bf6-406">Jeśli `path` jest w pełni kwalifikowaną ścieżką, przebiegów metoda `path` do <xref:System.IO.Path.GetFullPath(System.String)> metodę i zwraca wynik.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="b9bf6-407">Użyj tej metody, aby zwrócić deterministyczne ścieżki oparte na określony wolumin i dostęp do konta root katalogu podczas korzystania z ścieżek względnych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="b9bf6-408">Przy użyciu wstępnie zdefiniowanej `basePath` zamiast oparty na bieżącej osłony dysku w katalogu, względem ścieżki do plików niechciane spowodowane nieoczekiwanych zmian na bieżącym dysku i katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="b9bf6-409">Przykład</span><span class="sxs-lookup"><span data-stu-id="b9bf6-409">Example</span></span>

<span data-ttu-id="b9bf6-410">W poniższym przykładzie zdefiniowano zmienną, `basePath`, do reprezentowania aplikacji w bieżącym katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="b9bf6-411">Następnie przekazuje go do `GetFullPath` metodę, aby uzyskać pełną ścieżkę do katalogu danych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-412"><paramref name="path" /> lub <paramref name="basePath" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-413"><paramref name="basePath" /> nie jest w pełni kwalifikowaną ścieżkę.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>
<span data-ttu-id="b9bf6-414">- lub - <paramref name="path" /> lub <paramref name="basePath" /> zawiera nieprawidłowe znaki ścieżki, np. U + 0000.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-414">-or- <paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9bf6-415">Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-415">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-416">Tablica zawiera znaki, które nie są dozwolone w nazwach plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-416">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-417">Tablica zwrócona przez tę metodę nie jest gwarantowana zawiera pełny zestaw znaków, które są nieprawidłowe w nazwach plików i katalogów.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-417">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="b9bf6-418">Pełny zestaw nieprawidłowych znaków może być różna w systemie plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-418">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="b9bf6-419">Na przykład na platformach opartych na Windows pulpitu, znaki nieprawidłowe dla ścieżki może zawierać znaki ASCII/Unicode 1 do 31, a także cudzysłowu ("), mniej niż (\<), większe niż (>), kreski pionowej (&#124;), backspace (\b), o wartości null (\0) i kartę (\t).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-419">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-420">W poniższym przykładzie pokazano <xref:System.IO.Path.GetInvalidFileNameChars%2A> metody i <xref:System.IO.Path.GetInvalidPathChars%2A> metodę, która pobierze nieprawidłowe znaki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-420">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9bf6-421">Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-421">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-422">Tablica zawierający znaki, które nie są dozwolone w nazwach ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-422">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-423">Tablica zwrócona przez tę metodę nie jest gwarantowana zawiera pełny zestaw znaków, które są nieprawidłowe w nazwach plików i katalogów.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-423">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="b9bf6-424">Pełny zestaw nieprawidłowych znaków może być różna w systemie plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-424">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="b9bf6-425">Na przykład na platformach opartych na Windows pulpitu, znaki nieprawidłowe dla ścieżki może zawierać znaki ASCII/Unicode 1 do 31, a także cudzysłowu ("), mniej niż (\<), większe niż (>), kreski pionowej (&#124;), backspace (\b), o wartości null (\0) i kartę (\t).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-425">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-426">W poniższym przykładzie pokazano <xref:System.IO.Path.GetInvalidFileNameChars%2A> metody i <xref:System.IO.Path.GetInvalidPathChars%2A> metodę, która pobierze nieprawidłowe znaki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-426">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-427">Ścieżka, z którego można uzyskać informacji o katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-427">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="b9bf6-428">Pobiera informacje o katalogu głównym ze ścieżki znajdujących się w zakresie określonego znaku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-428">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-429">Znak span zawierającą katalog główny `path`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-429">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-430">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-430">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-431">Ścieżka, z którego można uzyskać informacji o katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-431">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="b9bf6-432">Pobiera informacje o katalogu głównym określonej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-432">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-433">Katalog główny <paramref name="path" />, lub <see langword="null" /> Jeśli <paramref name="path" /> jest <see langword="null" />, lub pustego ciągu, jeśli <paramref name="path" /> nie zawiera informacji o katalogu głównego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-433">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-434">Ta metoda nie sprawdza, czy istnieje Nazwa pliku lub ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-434">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="b9bf6-435">Możliwe wzorce dla ciągu zwracanego przez tę metodę, są następujące:</span><span class="sxs-lookup"><span data-stu-id="b9bf6-435">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="b9bf6-436">Ciąg pusty (`path` określonej ścieżki względnej na bieżący dysk lub wolumin).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-436">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="b9bf6-437">"\" (`path` określona ścieżką bezwzględną na bieżącym dysku).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-437">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="b9bf6-438">"X" (`path` określona względna ścieżka na dysku, gdzie X oznacza literę dysku lub woluminie).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-438">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="b9bf6-439">"X:\" (`path` określona ścieżką bezwzględną na danym dysku).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-439">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="b9bf6-440">"\\\ComputerName\SharedFolder" (ścieżka UNC).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-440">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="b9bf6-441">"\\? \C:" (DOS ścieżką do urządzenia, obsługiwane w programie .NET Core 1.1 i nowszych wersjach i .NET Framework 4.6.2 lub nowszy)</span><span class="sxs-lookup"><span data-stu-id="b9bf6-441">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="b9bf6-442">Aby uzyskać więcej informacji na temat ścieżek plików w Windows, zobacz [formaty ścieżki plików w systemach Windows](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-442">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="b9bf6-443">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-443">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="b9bf6-444">W poniższym przykładzie pokazano użycie `GetPathRoot` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-444">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-445"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-445"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="b9bf6-446">—lub—</span><span class="sxs-lookup"><span data-stu-id="b9bf6-446">-or-</span></span> 
 <span data-ttu-id="b9bf6-447"><see cref="F:System.String.Empty" /> został przekazany do <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-447"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-448">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-448">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-449">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-449">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-450">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-450">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-451">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-451">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9bf6-452">Zwraca nazwę folderu losowych lub nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-452">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-453">Losowe nazwy folderu lub pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-453">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-454"><xref:System.IO.Path.GetRandomFileName%2A> Metoda zwraca ciąg kryptograficznie silnych, losowych, który może służyć jako nazwa folderu lub nazwę pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-454">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="b9bf6-455">W odróżnieniu od <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> nie tworzy pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-455">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="b9bf6-456">Gdy zabezpieczenia systemu plików jest najważniejsza, ta metoda powinna służyć zamiast <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-456">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-457">Poniższy przykład Pokaż dane wyjściowe z <xref:System.IO.Path.GetRandomFileName%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-457">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="b9bf6-458">Ścieżka źródłowa wynik powinien być względem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-458">The source path the result should be relative to.</span></span> <span data-ttu-id="b9bf6-459">Ta ścieżka zawsze jest uważana za katalog.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-459">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="b9bf6-460">Ścieżka docelowa.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-460">The destination path.</span></span></param>
        <summary><span data-ttu-id="b9bf6-461">Zwraca ścieżkę względną z jedną ścieżkę do innego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-461">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-462">Ścieżka względna lub <paramref name="path" /> ścieżki nie udostępniono takim samym certyfikatem głównym.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-462">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="b9bf6-463">Ścieżki są rozpoznawane przez wywołanie metody <xref:System.IO.Path.GetFullPath%2A> metody przed obliczenie różnicy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-463">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="b9bf6-464">Metoda używa domyślnym porównaniem ścieżkę pliku dla bieżącej platformy (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> dla Windows i MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> dla systemu Linux.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-464">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-465"><paramref name="relativeTo" /> lub <paramref name="path" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-465"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-466">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-466">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9bf6-467">Tworzy plik o unikatowej nazwie, zero bajtów tymczasowy na dysku i zwraca pełną ścieżkę pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-467">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-468">Pełna ścieżka pliku tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-468">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-469">Ta metoda tworzy plik tymczasowy z. Rozszerzenie pliku TMP.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-469">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="b9bf6-470">Plik tymczasowy zostanie utworzony w ramach folder tymczasowy użytkownika, który jest ścieżką zwrócony przez <xref:System.IO.Path.GetTempPath%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-470">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="b9bf6-471"><xref:System.IO.Path.GetTempFileName%2A> Metoda zgłosi <xref:System.IO.IOException> Jeśli jest używany do tworzenia plików więcej niż 65535 bez usuwania poprzedniego plików tymczasowych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-471">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="b9bf6-472"><xref:System.IO.Path.GetTempFileName%2A> Metoda zgłosi <xref:System.IO.IOException> Jeśli nie unikatowa nazwa pliku tymczasowego jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="b9bf6-473">Aby rozwiązać ten problem, należy usunąć wszystkie zbędne pliki tymczasowe.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-473">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="b9bf6-474">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-474">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b9bf6-475">Wystąpi błąd We/Wy, takich jak nie unikatowa nazwa pliku tymczasowego jest dostępna.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-475">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="b9bf6-476">—lub—</span><span class="sxs-lookup"><span data-stu-id="b9bf6-476">-or-</span></span> 
<span data-ttu-id="b9bf6-477">Ta metoda nie może utworzyć pliku tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-477">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="b9bf6-478">dla zapisu do katalogu tymczasowego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-478">for writing to the temporary directory.</span></span> <span data-ttu-id="b9bf6-479">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="b9bf6-479">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-480">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-480">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-481">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-481">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-482">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-482">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9bf6-483">Zwraca ścieżkę folderu tymczasowego bieżącego użytkownika.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-483">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-484">Ścieżka do folderu tymczasowego program kończy się znakiem kreski ułamkowej odwróconej.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-484">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-485">Ta metoda sprawdza istnienie zmiennych środowiskowych w następującej kolejności i używa pierwszego znaleziono ścieżki:</span><span class="sxs-lookup"><span data-stu-id="b9bf6-485">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="b9bf6-486">Ścieżka określona przez zmienną środowiskową TMP.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-486">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="b9bf6-487">Ścieżka określona przez zmienną środowiskową TEMP.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-487">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="b9bf6-488">Ścieżka określona przez zmienną środowiskową profilu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-488">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="b9bf6-489">Katalog Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-489">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-490">Poniższy kod przedstawia sposób wywołania <xref:System.IO.Path.GetTempPath%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-490">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="b9bf6-491">Ten przykład generuje dane wyjściowe podobne do następujących.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-491">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b9bf6-492">Obiekt wywołujący nie ma wymaganych uprawnień.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-492">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="b9bf6-493">Aby uzyskać nieograniczony dostęp do zmiennych środowiskowych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-493">for unrestricted access to environment variables.</span></span> <span data-ttu-id="b9bf6-494">Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="b9bf6-494">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-495">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-495">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-496">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-496">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-497">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-497">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-498">Ścieżka wyszukiwania dla rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-498">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-499">Określa, czy ścieżka reprezentowanego przez zakres określony znak zawiera rozszerzenie nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-499">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-500"><see langword="true" /> Jeśli znaki, które należy wykonać ostatni separatora znak lub woluminu separatorem katalogu w ścieżce zawierają kropką (".") następuje jeden lub więcej znaków; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-500"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="b9bf6-501">Kropki w `path` nie jest uważany za rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-501">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-502">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-502">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-503">Ścieżka wyszukiwania dla rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-503">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="b9bf6-504">Określa, czy ścieżka zawiera rozszerzenie nazwy pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-504">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-505"><see langword="true" /> Jeśli znaki, które postępuj zgodnie z ostatnich separatorem katalogu (\\\ lub /) lub woluminu separatora (:) w ścieżce zawiera znak kropki (.), następuje jeden lub więcej znaków; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-505"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-506">Począwszy od końca `path`, Metoda ta wyszukuje następuje co najmniej jeden znak kropki (.).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-506">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="b9bf6-507">Jeśli ten wzorzec zostanie znaleziony przed <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, lub <xref:System.IO.Path.VolumeSeparatorChar> występuje znak, Metoda ta zwraca `true`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-507">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="b9bf6-508">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-508">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-509">W poniższym przykładzie pokazano użycie `HasExtension` metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-509">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-510"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-510"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-511">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-511">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-512">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-512">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-513">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-513">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-514">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-514">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9bf6-515">Dostarcza specyficzne dla platformy tablicę znaków, które nie może być określone w argumenty typu string ścieżki przekazane do elementów członkowskich <see cref="T:System.IO.Path" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-515">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-516">Tablica zwrócona przez tę metodę nie jest gwarantowana zawiera pełny zestaw znaków, które są nieprawidłowe w nazwach plików i katalogów.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-516">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="b9bf6-517">Pełny zestaw nieprawidłowych znaków może być różna w systemie plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-517">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="b9bf6-518">Na przykład na platformach opartych na Windows pulpitu, znaki nieprawidłowe dla ścieżki może zawierać znaki ASCII/Unicode 1 do 31, a także cudzysłowu ("), mniej niż (\<), większe niż (>), kreski pionowej (&#124;), backspace (\b), o wartości null (\0) i kartę (\t).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-518">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="b9bf6-519">Nie używaj <xref:System.IO.Path.InvalidPathChars> Jeśli uważasz, że Twój kod może być wykonywany w tej samej domenie aplikacji niezaufanego kodu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-519">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="b9bf6-520"><xref:System.IO.Path.InvalidPathChars> jest tablicą, dzięki czemu jego elementy, które mogą zostać zastąpione.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-520"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="b9bf6-521">Jeśli niezaufanego kodu zastępuje elementy <xref:System.IO.Path.InvalidPathChars>, może spowodować, że swój kod, aby działać poprawnie w sposób, który może zostać wykorzystana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-521">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-522">W poniższym przykładzie pokazano użycie `InvalidPathChars` właściwości.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-522">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-523">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-523">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-524">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-524">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-525">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-525">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="b9bf6-526">Zwraca wartość wskazującą, czy ścieżka pliku jest w pełni kwalifikowany.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-526">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="b9bf6-527">Przeciążenia `IsPathFullyQualified` metoda uchwyt ścieżek, które korzystać zarówno <xref:System.IO.Path.DirectorySeparatorChar> i <xref:System.IO.Path.AltDirectorySeparatorChar> znaków.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-527">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="b9bf6-528">Nie wykonuje żadnych sprawdzania poprawności w ścieżce, który jest przekazywany do niej jako argument.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-528">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="b9bf6-529">W rezultacie, identyfikatory URI są interpretowane jako ścieżki względne i zwracać `false`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-529">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="b9bf6-530">Istnieje następująca różnica między pełną ścieżkę (wskazane przez `IsPathFullyQualified` metoda) i ścieżki do katalogu głównego (wskazane przez <xref:System.IO.Path.IsPathRooted%2A> metody).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-530">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="b9bf6-531">A *w pełni kwalifikowana ścieżka* lub *ścieżka bezwzględna* zawsze definiuje dokładną ścieżkę danego dysku lub urządzenia do docelowego pliku lub katalogu, a nie zależy od bieżącego dysku lub bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-531">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="b9bf6-532">Na przykład w systemach Windows *C:/users/user1/documents/reports/2019/january/highlights.pdf* definiuje ścieżkę bezwzględną w katalogu głównym dysku C: do pliku docelowego *highlights.pdf*.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-532">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="b9bf6-533">A *ścieżki prowadzącej* Określa początkowy dysku lub katalogu głównego, ale zależy od bieżącego katalogu (jeśli osadzonego przez określony dysk) lub bieżącego dysku (jeśli osadzonego w katalogu głównym).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-533">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="b9bf6-534">Poniższy przykład ilustruje różnicę w pełni kwalifikowanej ścieżki i ścieżek odblokowanym dostępem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-534">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-535">Ścieżka pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-535">A file path.</span></span></param>
        <summary><span data-ttu-id="b9bf6-536">Zwraca wartość wskazującą, czy ścieżka pliku reprezentowanego przez zakres określony znak jest rozwiązany na określonym dysku ani ścieżki UNC.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-536">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-537"><see langword="true" /> Jeśli ścieżka jest ustalona określony dysk lub ścieżkę UNC; <see langword="false" /> Jeśli ścieżka jest określana względem bieżącego dysku i katalogu roboczego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-537"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-538">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-538">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-539">Ścieżka pliku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-539">A file path.</span></span></param>
        <summary><span data-ttu-id="b9bf6-540">Zwraca wartość wskazującą, czy podana ścieżka pliku zostanie usunięty z dysku ani ścieżki UNC.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-540">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-541"><see langword="true" /> Jeśli ścieżka jest ustalona określony dysk lub ścieżkę UNC; <see langword="false" /> Jeśli ścieżka jest określana względem bieżącego dysku i katalogu roboczego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-541"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b9bf6-542"><paramref name="path" /> jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-542"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-543">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-543">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="b9bf6-544">Zwraca wartość wskazującą, czy ścieżka pliku zawiera katalog główny.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-544">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="b9bf6-545">A **ścieżki prowadzącej** jest ścieżka do pliku, zostanie usunięty z dysku lub ścieżki UNIC; go różni się znacząco ze ścieżką względną wobec bieżącego dysku i katalogu roboczego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-545">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="b9bf6-546">Na przykład w systemach Windows, ścieżki do katalogu głównego zaczyna się od ukośnika odwrotnego (na przykład "\Documents") lub literę dysku i dwukropek (na przykład "C:Documents").</span><span class="sxs-lookup"><span data-stu-id="b9bf6-546">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="b9bf6-547">Należy pamiętać, że ścieżki odblokowanym dostępem mogą być bezwzględna (co oznacza, że w pełni kwalifikowana) lub względna.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-547">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="b9bf6-548">Ścieżka bezwzględna odblokowanym dostępem jest w pełni kwalifikowaną ścieżkę w katalogu głównym na dysku do określonego katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-548">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="b9bf6-549">Względne ścieżki do katalogu głównego Określa dysk, ale jego w pełni kwalifikowana ścieżka nie zostanie rozwiązany względem bieżącego katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-549">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="b9bf6-550">Poniższy przykład ilustruje tę różnicę.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-550">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-551">Ścieżka do testowania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-551">The path to test.</span></span></param>
        <summary><span data-ttu-id="b9bf6-552">Zwraca wartość wskazującą, czy zakres określony znak, który reprezentuje ścieżkę do pliku zawiera katalog główny.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-552">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-553"><see langword="true" /> Jeśli <paramref name="path" /> zawiera katalog główny; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-553"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-554">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-554">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="b9bf6-555">Ścieżka do testowania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-555">The path to test.</span></span></param>
        <summary><span data-ttu-id="b9bf6-556">Zwraca wartość wskazującą, czy ciąg określona ścieżka zawiera katalog główny.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-556">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-557"><see langword="true" /> Jeśli <paramref name="path" /> zawiera katalog główny; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-557"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-558"><xref:System.IO.Path.IsPathRooted%2A> Metoda zwraca `true` jeśli pierwszym znakiem jest znak separatora katalogu takich jak "\\", lub jeśli ścieżka zaczyna się od litery dysku i dwukropek (:).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-558">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="b9bf6-559">Na przykład zwraca `true` dla `path` ciągi, takie jak "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", lub "C:MyDir".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-559">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="b9bf6-560">Zwraca `false` dla `path` ciągów, takich jak "MyDir".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-560">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="b9bf6-561">Ta metoda nie sprawdza, czy istnieje Nazwa pliku lub ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-561">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="b9bf6-562">Aby uzyskać listę typowych zadań we/wy, zobacz [typowe zadania we/wy](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="b9bf6-562">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="b9bf6-563">W poniższym przykładzie pokazano sposób, w jaki `IsPathRooted` metoda może służyć do testowania trzy ciągi.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-563">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b9bf6-564"><paramref name="path" /> zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-564"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-565">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-565">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-566">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-566">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-567">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-567">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-568">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-568">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-569">Zakres znaków, zawierający pierwszy ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-569">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-570">Zakres znaków, zawierający ścieżkę drugiego do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-570">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="b9bf6-571">Łączy dwa składniki ścieżki do pojedynczej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-571">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-572">Połączone ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-572">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="b9bf6-573">Ta metoda po prostu łączy `path` i `path2` i dodaje znak separatora katalogu między składnikami dwie ścieżki, jeśli nie jest już obecny na końcu `path1` lub na początku `path2`.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-573">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="b9bf6-574">Jeśli <xref:System.ReadOnlySpan%601.Length> albo `path1` lub `path2` wynosi zero, metoda zwraca innej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-574">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="b9bf6-575">Jeśli <xref:System.ReadOnlySpan%601.Length> obu `path1` i `path2` wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-575">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="b9bf6-576">Jeśli `path1` kończy się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Join` metody zachowuje oryginalne znakiem separatora ścieżki i dołącza obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-576">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="b9bf6-577">Ten problem pojawia się w zakodowanych ścieżek, korzystających z Windows kreski ułamkowej odwróconej ("\") znak, który nie został rozpoznany jako separatora ścieżki na komputerach z systemem Unix.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-577">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="b9bf6-578">Aby obejść ten problem, możesz wykonywać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="b9bf6-578">To work around this issue, you can:</span></span>

- <span data-ttu-id="b9bf6-579">Pobieranie wartości <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwości zamiast kodować znakiem separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-579">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="b9bf6-580">Należy używać ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-580">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="b9bf6-581">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwości na komputerach z systemem Unix i przy <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-581">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="b9bf6-582">W odróżnieniu od <xref:System.IO.Path.Combine%2A> metody <xref:System.IO.Path.Join%2A> methhod nie jest podejmowana próba główna ścieżka zwracanego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-582">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> methhod does not attempt to root the returned path.</span></span> <span data-ttu-id="b9bf6-583">(To znaczy, jeśli `path2` jest ścieżką bezwzględną `Join` metody nie odrzuca `path1` i zwracają `path2` jako <xref:System.IO.Path.Combine%2A> metody.) Poniższy przykład ilustruje tę różnicę w ścieżkach zwrócone przez te dwie metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-583">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="b9bf6-584">Jeśli źródło `path2` danych wejściowych użytkownika jest <xref:System.IO.Path.Combine%2A> metoda pozwala użytkownikowi na dostęp do zasobów systemu plików (takich jak *C:/użytkowników/Użytkownik1/dokumenty/finansowych/* w przypadku przykładu) czy aplikacji Zamierzasz udostępnić.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-584">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of hte example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="b9bf6-585">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku są interpretowane jako nie do przyjęcia przez `Join` metody, ponieważ te znaki mogą używać do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-585">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="b9bf6-586">Na przykład `Path.Join("c:\\", "*.txt")` może być nieprawidłowy, gdy tworzenie pliku, jest prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-586">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="b9bf6-587">`Join` Metody w związku z tym pomyślnie zinterpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-587">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="b9bf6-588">Przykład</span><span class="sxs-lookup"><span data-stu-id="b9bf6-588">Example</span></span>

<span data-ttu-id="b9bf6-589">Poniższy przykład ilustruje różnicę w ścieżkach zwrócony przez <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> i <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-589">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="b9bf6-590">Jeśli pierwszy ciąg jest w pełni kwalifikowanej ścieżki, która zawiera dysk i katalog główny katalog, a drugą jest ścieżką względną z pierwszej ścieżki, te dwie metody utworzyć takie same wyniki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-590">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="b9bf6-591">W wywołaniach drugi i trzeci `ShowPathInformation` rozdzielić ciągi zwrócone przez te dwie metody metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-591">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="b9bf6-592">W drugim wywołaniu metody ciągu pierwszego argumentu jest to dysk, a drugi jest katalogiem odblokowanym dostępem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-592">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="b9bf6-593">`Join` Metoda łączy dwa ciągi i zachowuje zduplikowanych separatorami ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-593">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="b9bf6-594">`Combine` Metoda porzuca dysku i zwraca odblokowanym dostępem katalogu na bieżącym dysku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-594">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="b9bf6-595">W przypadku aplikacji bieżący dysk C:\ Ten ciąg jest używany do uzyskania dostępu do pliku lub plików w katalogu, jego dostęp do C: zamiast D:.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-595">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="b9bf6-596">Na koniec ponieważ oba argumenty w trzecim wywołaniu `ShowPathInformation` są zakorzenione `Join` metoda po prostu dołącza je utworzyć ścieżkę do pliku pozbawiona sensu, podczas gdy `Combine` metoda odrzuca pierwszy ciąg anmd Zwraca sekundy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-596">Finally, becasue both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string anmd returns the second.</span></span> <span data-ttu-id="b9bf6-597">Przy użyciu tych parametrów do uzyskiwania dostępu do plików może przyznać aplikacji niekontrolowanego dostępu do poufnych plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-597">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-598">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-598">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-599">Zakres znaków, zawierający pierwszy ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-599">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-600">Zakres znaków, zawierający ścieżkę drugiego do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-600">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="b9bf6-601">Zakres znaków, zawierający trzeci ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-601">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="b9bf6-602">Łączy trzy składniki ścieżki do pojedynczej ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-602">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="b9bf6-603">Ta metoda po prostu łączy `path`, `path2`, i `path3` i dodaje znak separatora katalogu między dowolnymi składników ścieżki, jeśli nie jest już dostępny.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-603">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="b9bf6-604">Jeśli <xref:System.ReadOnlySpan%601.Length> któregokolwiek z `path1`, `path2`, lub `path3` argument wynosi zero, metoda contatenates pozostałe argumenty.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-604">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method contatenates the remaining arguments.</span></span> <span data-ttu-id="b9bf6-605">Jeśli <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> wszystkich składników wynosi zero, metoda zwraca <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-605">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="b9bf6-606">Jeśli `path1` lub `path2` kończy się znakiem separatora ścieżki, który nie jest odpowiedni dla platformy docelowej `Join` metody zachowuje oryginalne znakiem separatora ścieżki i dołącza obsługiwana.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-606">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="b9bf6-607">Ten problem pojawia się w zakodowanych ścieżek, korzystających z Windows kreski ułamkowej odwróconej ("\") znak, który nie został rozpoznany jako separatora ścieżki na komputerach z systemem Unix.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-607">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="b9bf6-608">Aby obejść ten problem, możesz wykonywać następujące czynności:</span><span class="sxs-lookup"><span data-stu-id="b9bf6-608">To work around this issue, you can:</span></span>

- <span data-ttu-id="b9bf6-609">Pobieranie wartości <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwości zamiast kodować znakiem separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-609">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="b9bf6-610">Należy używać ukośnika ("/") jako znaku separatora katalogu.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-610">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="b9bf6-611">Ten znak jest zwracany przez <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> właściwości na komputerach z systemem Unix i przy <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> właściwość w systemach Windows.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-611">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="b9bf6-612">W odróżnieniu od <xref:System.IO.Path.Combine%2A> metody <xref:System.IO.Path.Join%2A> methhod nie jest podejmowana próba główna ścieżka zwracanego.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-612">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> methhod does not attempt to root the returned path.</span></span> <span data-ttu-id="b9bf6-613">(To znaczy, jeśli `path2` lub `path2` jest ścieżką bezwzględną `Join` metody nie odrzuca poprzedniej ścieżki jako <xref:System.IO.Path.Combine%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-613">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="b9bf6-614">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku są interpretowane jako nie do przyjęcia przez `Join` metody, ponieważ te znaki mogą używać do wyszukiwania symboli wieloznacznych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-614">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="b9bf6-615">Na przykład `Path.Join("c:\\", "temp", "*.txt")` może być nieprawidłowy, gdy tworzenie pliku, jest prawidłowy jako ciąg wyszukiwania.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-615">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="b9bf6-616">`Join` Metody w związku z tym pomyślnie zinterpretuje ją.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-616">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="b9bf6-617">Przykład</span><span class="sxs-lookup"><span data-stu-id="b9bf6-617">Example</span></span>

<span data-ttu-id="b9bf6-618">Poniższy przykład ilustruje różnicę w ścieżkach zwrócony przez <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> i <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-618">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="b9bf6-619">Jeśli pierwszy ciąg jest w pełni kwalifikowanej ścieżki, która zawiera dysk i katalog główny katalog, a drugą jest ścieżką względną z pierwszej ścieżki, te dwie metody utworzyć takie same wyniki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-619">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="b9bf6-620">W wywołaniach drugi i trzeci `ShowPathInformation` rozdzielić ciągi zwrócone przez te dwie metody metody.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-620">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="b9bf6-621">W drugim wywołaniu metody ciągu pierwszego argumentu jest to dysk, a drugi jest katalogiem odblokowanym dostępem.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-621">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="b9bf6-622">`Join` Metoda łączy dwa ciągi i zachowuje zduplikowanych separatorami ścieżki.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-622">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="b9bf6-623">Wywołanie <xref:System.IO.Path.GetFullPath%2A> metoda może wyeliminować duplikaty.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-623">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="b9bf6-624">`Combine` Metoda porzuca dysku i zwraca odblokowanym dostępem katalogu na bieżącym dysku.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-624">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="b9bf6-625">W przypadku aplikacji bieżący dysk C:\ Ten ciąg jest używany do uzyskania dostępu do pliku lub plików w katalogu, jego dostęp do C: zamiast D:.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-625">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="b9bf6-626">Na koniec ponieważ ostatni argument w trzecim wywołaniu `ShowPathInformation` są zakorzenione `Join` metoda po prostu dołącza je do pierwszych dwóch argumentów, aby utworzyć ścieżkę pliku pozbawiona sensu podczas `Combine` metoda odrzuca pierwsze dwa ciągi, które zwraca anmd trzeci.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-626">Finally, becasue the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings anmd returns the third.</span></span> <span data-ttu-id="b9bf6-627">Przy użyciu tych parametrów do uzyskiwania dostępu do plików może przyznać aplikacji niekontrolowanego dostępu do poufnych plików.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-627">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-628">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-628">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9bf6-629">Znak separatora specyficzne dla platformy, używany do oddzielania parametrów path w zmiennych środowiskowych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-629">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-630">Na platformach opartych na Windows pulpitu, wartość tego pola jest średnika (;) domyślnie, ale mogą się różnić na innych platformach.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-630">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-631">W poniższym przykładzie pokazano użycie `PathSeparator` pola.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-631">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-632">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-632">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-633">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-633">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-634">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-634">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="b9bf6-635">Podejmuje próbę łączenia składników ścieżki poszczególnych jak zakres przydzielony wstępnie znaku i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-635">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="b9bf6-636">Docelowy zakres znaków musi być wystarczająco duży, aby pomieścić ścieżki concatentated.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-636">The destination character span must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="b9bf6-637">Można później odzyskać połączonych ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metody, w poniższym przykładzie pokazano.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-637">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-638">Zakres znaków, zawierający pierwszy ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-638">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-639">Zakres znaków, zawierający ścieżkę drugiego do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-639">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="b9bf6-640">Zakres znaków, zawierającą ścieżkę połączonych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-640">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="b9bf6-641">Gdy metoda zwraca, wartość, która wskazuje liczbę znaków napisanych na <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-641">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="b9bf6-642">Podejmuje próbę łączenia dwóch składników ścieżki, jak zakres pojedynczy znak przydzielony wstępnie i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-642">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-643"><see langword="true" /> Jeśli concatentation operaton się powiedzie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-643"><see langword="true" /> if the concatentation operaton is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b9bf6-644">`destination` musi być wystarczająco duży, aby pomieścić ścieżki concatentated.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-644">`destination` must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="b9bf6-645">Można później odzyskać połączonych ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metody, jak pokazano na przykładzie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-645">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-646">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-646">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="b9bf6-647">Zakres znaków, zawierający pierwszy ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-647">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="b9bf6-648">Zakres znaków, zawierający ścieżkę drugiego do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-648">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="b9bf6-649">Zakres znaków, zawierający trzeci ścieżkę do przyłączenia.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-649">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="b9bf6-650">Zakres znaków, zawierającą ścieżkę połączonych.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-650">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="b9bf6-651">Gdy metoda zwraca, wartość, która wskazuje liczbę znaków napisanych na <paramref name="destination" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-651">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="b9bf6-652">Podejmuje próbę łączenia dwóch składników ścieżki, jak zakres pojedynczy znak przydzielony wstępnie i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-652">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="b9bf6-653"><see langword="true" /> Jeśli concatentation operaton się powiedzie; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-653"><see langword="true" /> if the concatentation operaton is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b9bf6-654">`destination` musi być wystarczająco duży, aby pomieścić ścieżki concatentated.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-654">`destination` must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="b9bf6-655">Można później odzyskać połączonych ścieżki, wywołując <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> metody, jak pokazano na przykładzie.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-655">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="b9bf6-656">Formaty ścieżki plików w systemach Windows</span><span class="sxs-lookup"><span data-stu-id="b9bf6-656">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9bf6-657">Zawiera znaku separatora woluminów specyficznych dla platformy.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-657">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9bf6-658">Wartość tego pola jest dwukropek (:) na Windows i dla komputerów Macintosh i ukośnika (/) w systemach operacyjnych UNIX.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-658">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="b9bf6-659">Jest to najbardziej przydatne podczas analizowania ścieżki, takie jak "c:\windows" lub "MacVolume:System Folder".</span><span class="sxs-lookup"><span data-stu-id="b9bf6-659">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9bf6-660">W poniższym przykładzie pokazano użycie `VolumeSeparatorChar` pola.</span><span class="sxs-lookup"><span data-stu-id="b9bf6-660">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b9bf6-661">We/Wy plików i strumieni</span><span class="sxs-lookup"><span data-stu-id="b9bf6-661">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b9bf6-662">Instrukcje: Odczytywanie tekstu z pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-662">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b9bf6-663">Instrukcje: Zapisywanie tekstu do pliku</span><span class="sxs-lookup"><span data-stu-id="b9bf6-663">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
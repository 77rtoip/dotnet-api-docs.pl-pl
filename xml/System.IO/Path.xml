<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Path.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c0ef473bd6615db5908afedacb6564d0e78685953.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0ef473bd6615db5908afedacb6564d0e78685953</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Performs operations on <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> instances that contain file or directory path information.</source>
          <target state="translated">Wykonuje operacje na <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> wystąpień, które zawierają informacje o ścieżce pliku lub katalogu.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>These operations are performed in a cross-platform manner.</source>
          <target state="translated">Te operacje są wykonywane w sposób między platformami.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path is a string that provides the location of a file or directory.</source>
          <target state="translated">Ścieżka jest ciągiem, który określa lokalizację pliku lub katalogu.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</source>
          <target state="translated">Nie zawsze ścieżką do lokalizacji na dysku; na przykład ścieżki mogą być mapowane do lokalizacji w pamięci lub na urządzeniu.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The exact format of a path is determined by the current platform.</source>
          <target state="translated">Dokładnego formatu ścieżki zależy od bieżącej platformie.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</source>
          <target state="translated">Na przykład w niektórych systemach ścieżkę można uruchomić z litery dysku lub woluminie, podczas gdy ten element nie jest obecny w innych systemach.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</source>
          <target state="translated">W niektórych systemach ścieżki do pliku może zawierać rozszerzenia, które wskazują na typ informacji przechowywanych w pliku.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</source>
          <target state="translated">Format rozszerzenie nazwy pliku jest zależny od platformy; na przykład niektóre systemy Ogranicz rozszerzeń trzy znaki, a innych nie.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</source>
          <target state="translated">Bieżąca platforma określa również zestaw znaków używany do oddzielania elementów ścieżki i zestawu znaków, których nie można używać podczas określania ścieżki.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because of these differences, the fields of the <ph id="ph1">`Path`</ph> class as well as the exact behavior of some members of the <ph id="ph2">`Path`</ph> class are platform-dependent.</source>
          <target state="translated">Z powodu różnic, pola <ph id="ph1">`Path`</ph> klasy, a także dokładnie zachowanie niektórzy członkowie <ph id="ph2">`Path`</ph> klasy są zależne od platformy.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path can contain absolute or relative location information.</source>
          <target state="translated">Ścieżki może zawierać informacje o lokalizacji bezwzględny lub względny.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</source>
          <target state="translated">Ścieżki bezwzględne pełni określić lokalizację: plik lub katalog może być identyfikowane niezależnie od bieżącej lokalizacji.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</source>
          <target state="translated">Ścieżki względne określić lokalizację częściowe: Bieżąca lokalizacja jest używana jako punktu wyjścia podczas lokalizowania określony plik ze ścieżką względną.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>To determine the current directory, call <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Aby określić bieżącego katalogu, należy wywołać <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Most members of the <ph id="ph1">`Path`</ph> class do not interact with the file system and do not verify the existence of the file specified by a path string.</source>
          <target state="translated">Większość członkami <ph id="ph1">`Path`</ph> klasy nie wykonuj żadnych działań w systemie plików i weryfikuje istnienie określonego przez ciąg ścieżki pliku.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> class members that modify a path string, such as <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, have no effect on names of files in the file system.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> klasy elementów członkowskich, które modyfikują ciąg ścieżki, takie jak <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, nie mają wpływu na nazwy plików w systemie plików.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> members do, however, validate the contents of a specified path string, and throw an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> elementy członkowskie, jednak weryfikacji zawartości ciągu określona ścieżka i throw <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> wyjątek, jeśli ciąg zawiera znaki, które nie są prawidłowe w ciągach ścieżki, zgodnie z definicją w znaki zwrócone z <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</source>
          <target state="translated">Na przykład na platformach opartych na systemie Windows desktop, nieprawidłowe znaki ścieżki może zawierać cudzysłowu ("), poniżej (<ph id="ph1">\&lt;</ph>), większości (&gt;), kreski pionowej (&amp;#124;), backspace (\b), wartości null (\0) i znaki Unicode 16 za pośrednictwem 18 i 20 do 25.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The members of the <ph id="ph1">`Path`</ph> class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</source>
          <target state="translated">Elementy członkowskie <ph id="ph1">`Path`</ph> klasy umożliwiają szybkie i łatwe wykonywanie typowych operacji, takich jak ustalania, czy rozszerzenie nazwy pliku jest częścią ścieżki i łączenia dwóch ciągów w nazwie jedną ścieżkę.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>All members of the <ph id="ph1">`Path`</ph> class are static and can therefore be called without having an instance of a path.</source>
          <target state="translated">Wszystkie elementy członkowskie <ph id="ph1">`Path`</ph> klasy statyczne i w związku z tym można wywołać bez konieczności wystąpienia ścieżki.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path as an input string, that path must be well-formed or an exception is raised.</source>
          <target state="translated">W elementach członkowskich, które akceptują ścieżki jako ciąg wejściowy że ścieżka musi być poprawnie sformułowany lub zgłoszony wyjątek.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</source>
          <target state="translated">Na przykład jeśli ścieżka jest w pełni kwalifikowana, ale rozpoczyna się od spacji, ścieżka nie jest usuwane w metody klasy.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Therefore, the path is malformed and an exception is raised.</source>
          <target state="translated">W związku z tym ścieżka jest nieprawidłowo sformułowany i zgłoszony wyjątek.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Similarly, a path or a combination of paths cannot be fully qualified twice.</source>
          <target state="translated">Podobnie ścieżkę lub kombinację ścieżki nie może być w pełni kwalifikowana dwa razy.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, "c:\temp c:\windows" also raises an exception in most cases.</source>
          <target state="translated">Na przykład "c:\temp c:\windows" również zgłasza wyjątek w większości przypadków.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Ensure that your paths are well-formed when using methods that accept a path string.</source>
          <target state="translated">Upewnij się, czy z ścieżki są poprawnie sformułowany, gdy przy użyciu metod, które przyjmują ciąg ścieżki.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path, the path can refer to a file or just a directory.</source>
          <target state="translated">W elementach członkowskich, które akceptują ścieżką ścieżka może odwoływać się do pliku lub po prostu katalogu.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</source>
          <target state="translated">Określona ścieżka znajdują się ścieżką względną lub ścieżką Universal Naming Convention (UNC) dla nazwy serwera i udziału.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, all the following are acceptable paths:</source>
          <target state="translated">Na przykład następujące są dopuszczalne ścieżki:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</source>
          <target state="translated">"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" w języku C# lub "c:\MyDir\MyFile.txt" w języku Visual Basic.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir" in C#, or "c:\MyDir" in Visual Basic.</source>
          <target state="translated">"c:<ph id="ph1">\\</ph>\MyDir" w języku C# lub "c:\MyDir" w języku Visual Basic.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"MyDir<ph id="ph1">\\</ph>\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</source>
          <target state="translated">"MyDir<ph id="ph1">\\</ph>\MySubdir" w języku C# lub "MyDir\MySubDir" w języku Visual Basic.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#, or "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</source>
          <target state="translated">"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" w języku C# lub "<ph id="ph5">\\</ph>\MyServer\MyShare" w języku Visual Basic.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</source>
          <target state="translated">Ponieważ te operacje są wykonywane na ciągach, jest niemożliwe zweryfikować, że wyniki są prawidłowe we wszystkich scenariuszach.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, the <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> method parses a string that you pass to it and returns the extension from that string.</source>
          <target state="translated">Na przykład <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> metody analizuje ciąg, który przekazywania do niej i zwraca rozszerzenie z tego ciągu.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>However, this does not mean that a file with that extension exists on the disk.</source>
          <target state="translated">Jednak nie oznacza to, że plik z danym rozszerzeniem istnieje na dysku.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The following code example demonstrates some of the main members of the <ph id="ph1">`Path`</ph> class.</source>
          <target state="translated">W poniższym przykładzie kodu przedstawiono niektóre główne członków <ph id="ph1">`Path`</ph> klasy.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Zawiera znak alternatywny specyficzne dla platformy służący do oddzielania poziomów katalogu w ciągu ścieżki, które odzwierciedla organizacje systemu plików hierarchicznej.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">Znak, przechowywanego w polu nie może być w <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>This field can be set to the same value as <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">To pole może mieć ustawioną taką samą wartość jak <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source><ph id="ph1">`AltDirectorySeparatorChar`</ph> and <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">`AltDirectorySeparatorChar`</ph> i <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> są prawidłowe dla oddzielenie poziomów katalogów w ciągu ścieżki.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</source>
          <target state="translated">Wartość tego pola jest ukośnika ("/") w systemach operacyjnych Windows, UNIX i Macintosh.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The following code example demonstrates a use of the <ph id="ph1">`AltDirectorySeparatorChar`</ph> field.</source>
          <target state="translated">Poniższy przykład kodu pokazuje korzystanie z <ph id="ph1">`AltDirectorySeparatorChar`</ph> pola.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path information to modify.</source>
          <target state="translated">Informacje o ścieżce do zmodyfikowania.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path cannot contain any of the characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Ścieżka nie może zawierać znaków określonych w <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The new extension (with or without a leading period).</source>
          <target state="translated">Nowe rozszerzenie (z lub bez poprzedzającej go kropki).</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> to remove an existing extension from <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Określ <ph id="ph1">&lt;see langword="null" /&gt;</ph> usunąć istniejące rozszerzenie z <bpt id="p1">&lt;c&gt;</bpt>ścieżki<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Changes the extension of a path string.</source>
          <target state="translated">Powoduje zmianę rozszerzenia ciągu ścieżki.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The modified path information.</source>
          <target state="translated">Informacje o ścieżce zmodyfikowane.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>On Windows-based desktop platforms, if <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string (""), the path information is returned unmodified.</source>
          <target state="translated">Na platformach opartych na systemie Windows desktop Jeśli <ph id="ph1">&lt;paramref name="path" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph> lub ciąg pusty (""), informacje o ścieżce jest zwracana bez modyfikacji.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the returned string contains the specified path with its extension removed.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, zwracany ciąg zawiera określona ścieżka z rozszerzeniem usunięte.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> has no extension, and <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the returned path string contains <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> appended to the end of <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="path" /&gt;</ph> nie ma rozszerzenia, a <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> nie jest <ph id="ph3">&lt;see langword="null" /&gt;</ph>, zawiera ciąg ścieżki zwrócony <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> dołączany na końcu <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If neither <ph id="ph1">`path`</ph> nor <ph id="ph2">`extension`</ph> contains a period (.), <ph id="ph3">`ChangeExtension`</ph> adds the period.</source>
          <target state="translated">Jeśli żadna <ph id="ph1">`path`</ph> ani <ph id="ph2">`extension`</ph> zawiera kropkę (.), <ph id="ph3">`ChangeExtension`</ph> dodaje okresu.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The <ph id="ph1">`extension`</ph> parameter can contain multiple periods and any valid path characters, and can be any length.</source>
          <target state="translated"><ph id="ph1">`extension`</ph> Parametr może zawierać wielu kropek i znaków prawidłową ścieżkę i może być dowolnej długości.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is <ph id="ph2">`null`</ph>, the returned string contains the contents of <ph id="ph3">`path`</ph> with the last period and all characters following it removed.</source>
          <target state="translated">Jeśli <ph id="ph1">`extension`</ph> jest <ph id="ph2">`null`</ph>, zwracany ciąg zawiera zawartość <ph id="ph3">`path`</ph> z ostatniego okresu i wszystkie znaki po jej usunąć.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is an empty string, the returned path string contains the contents of <ph id="ph2">`path`</ph> with any characters following the last period removed.</source>
          <target state="translated">Jeśli <ph id="ph1">`extension`</ph> to ciąg pusty ciąg ścieżki zwrócony z zawartością <ph id="ph2">`path`</ph> znakami po ostatnim okresie usunięte.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> does not have an extension and <ph id="ph2">`extension`</ph> is not <ph id="ph3">`null`</ph>, the returned string contains <ph id="ph4">`path`</ph> followed by <ph id="ph5">`extension`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`path`</ph> nie ma rozszerzenia i <ph id="ph2">`extension`</ph> nie jest <ph id="ph3">`null`</ph>, zwrócony ciąg zawiera <ph id="ph4">`path`</ph> następuje <ph id="ph5">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is not <ph id="ph2">`null`</ph> and does not contain a leading period, the period is added.</source>
          <target state="translated">Jeśli <ph id="ph1">`extension`</ph> nie jest <ph id="ph2">`null`</ph> i nie zawierać kropki na początku, okres został dodany.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> contains a multiple extension separated by multiple periods, the returned string contains the contents of <ph id="ph2">`path`</ph> with the last period and all characters following it replaced by <ph id="ph3">`extension`</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">`path`</ph> zawiera wiele rozszerzeń, oddzielone kropkami wielu zwrócony ciąg zawiera zawartość <ph id="ph2">`path`</ph> z ostatniego okresu i wszystkie znaki po jego zastępuje <ph id="ph3">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is "\Dir1\examples\pathtests.csx.txt" and <ph id="ph2">`extension`</ph> is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</source>
          <target state="translated">Na przykład jeśli <ph id="ph1">`path`</ph> jest "\Dir1\examples\pathtests.csx.txt" i <ph id="ph2">`extension`</ph> jest "cs", "\Dir1\examples\pathtests.csx.cs" to zmodyfikowana ścieżka.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>It is not possible to verify that the returned results are valid in all scenarios.</source>
          <target state="translated">Nie jest możliwe sprawdzić, czy zwrócone wyniki są prawidłowe we wszystkich scenariuszach.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is empty, <ph id="ph2">`extension`</ph> is appended.</source>
          <target state="translated">Na przykład jeśli <ph id="ph1">`path`</ph> jest pusta, <ph id="ph2">`extension`</ph> jest dołączony.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`ChangeExtension`</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje korzystanie z <ph id="ph1">`ChangeExtension`</ph> metody.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Combines strings into a path.</source>
          <target state="translated">Połączenie ciągów w ścieżce.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>An array of parts of the path.</source>
          <target state="translated">Tablica części ścieżki.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Combines an array of strings into a path.</source>
          <target state="translated">Łączy tablica ciągów w ścieżce.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The combined paths.</source>
          <target state="translated">Połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source><ph id="ph1">`paths`</ph> should be an array of the parts of the path to combine.</source>
          <target state="translated"><ph id="ph1">`paths`</ph> powinien być tablicą części ścieżki do połączenia.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</source>
          <target state="translated">Jeśli jedna z kolejnych ścieżki jest ścieżką bezwzględną, operację łączenia resetuje, począwszy od tej ścieżki bezwzględnej odrzuca wszystkie poprzednie połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Ciągi o zerowej długości są pominięte połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Parametry nie są parsowane, jeśli biały znak.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku będą interpretowane przez niedopuszczalne <ph id="ph1">`Combine`</ph> metody, ponieważ dla wyszukiwania symboli wieloznacznych można używać następujących znaków.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Na przykład <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> może być nieprawidłowy w przypadku tworzenia pliku z jego jest nieprawidłowy jako ciąg wyszukiwania.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">W związku z tym jest pomyślnie interpretowany przez <ph id="ph1">`Combine`</ph> metody.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The following example combines an array of strings into a path.</source>
          <target state="translated">Poniższy przykład łączy tablica ciągów w ścieżce.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array contains one or more of the invalid characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Jeden z parametrów w tablicy zawiera jeden lub więcej nieprawidłowych znaków zdefiniowana w <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Jeden z parametrów w tablicy jest <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Pierwszy ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Drugi ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Combines two strings into a path.</source>
          <target state="translated">Łączy dwa ciągi na ścieżki.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If one of the specified paths is a zero-length string, this method returns the other path.</source>
          <target state="translated">Jeśli jedna z określonych ścieżek jest ciągiem o zerowej długości, ta metoda zwraca innej ścieżki.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contains an absolute path, this method returns <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> zawiera ścieżkę bezwzględną, ta metoda zwraca <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Jeśli <ph id="ph1">`path1`</ph> nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy się znak separatora prawidłowy zgodnie z definicją w <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, lub <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> jest dołączany do <ph id="ph6">`path1`</ph> przed łączenia.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> nie ma głównego (na przykład, jeśli <ph id="ph2">`path2`</ph> nie rozpoczyna się znak separatora lub specyfikację dysku), wynik jest złączeniem tych dwóch ścieżek, pośredniczące znaku separatora.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> zawiera katalog główny <ph id="ph2">`path2`</ph> jest zwracany.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Parametry nie są parsowane, jeśli biały znak.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph> instead of returning only <ph id="ph5">`path2`</ph>.</source>
          <target state="translated">W związku z tym jeśli <ph id="ph1">`path2`</ph> zawiera biały znak (na przykład "\file.txt"), <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> dołącza metody <ph id="ph3">`path2`</ph> do <ph id="ph4">`path1`</ph> zamiast zwracać tylko <ph id="ph5">`path2`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku będą interpretowane przez niedopuszczalne <ph id="ph1">`Combine`</ph> metody, ponieważ dla wyszukiwania symboli wieloznacznych można używać następujących znaków.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Na przykład <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> może być nieprawidłowy w przypadku tworzenia pliku z jego jest nieprawidłowy jako ciąg wyszukiwania.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">W związku z tym jest pomyślnie interpretowany przez <ph id="ph1">`Combine`</ph> metody.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`Combine`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, przy użyciu <ph id="ph1">`Combine`</ph> metody na platformie pulpitu systemu Windows.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> lub <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> jest <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Pierwszy ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Drugi ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Trzeci ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Combines three strings into a path.</source>
          <target state="translated">Łączy trzy ciągi na ścieżki.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").</source>
          <target state="translated"><ph id="ph1">`path1`</ph> powinno być ścieżką bezwzględną (na przykład "d:\archives" lub "<ph id="ph2">\\</ph>\archives\public").</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> or <ph id="ph2">`path3`</ph> is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> lub <ph id="ph2">`path3`</ph> również jest ścieżką bezwzględną, ścieżki usunięcie wszystkich uprzednio łączyć operacji łączenia i przywraca tego ścieżkę bezwzględną.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Ciągi o zerowej długości są pominięte połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Jeśli <ph id="ph1">`path1`</ph> nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy się znak separatora prawidłowy zgodnie z definicją w <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, lub <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> jest dołączany do <ph id="ph6">`path1`</ph> przed łączenia.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> nie ma głównego (na przykład, jeśli <ph id="ph2">`path2`</ph> nie rozpoczyna się znak separatora lub specyfikację dysku), wynik jest złączeniem tych dwóch ścieżek, pośredniczące znaku separatora.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> zawiera katalog główny <ph id="ph2">`path2`</ph> jest zwracany.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Parametry nie są parsowane, jeśli biały znak.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">W związku z tym jeśli <ph id="ph1">`path2`</ph> zawiera biały znak (na przykład "\file.txt"), <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> dołącza metody <ph id="ph3">`path2`</ph> do <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku będą interpretowane przez niedopuszczalne <ph id="ph1">`Combine`</ph> metody, ponieważ dla wyszukiwania symboli wieloznacznych można używać następujących znaków.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Na przykład <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> może być nieprawidłowy w przypadku tworzenia pliku z jego jest nieprawidłowy jako ciąg wyszukiwania.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">W związku z tym jest pomyślnie interpretowany przez <ph id="ph1">`Combine`</ph> metody.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The following example combines three paths.</source>
          <target state="translated">Poniższy przykład łączy trzy ścieżki.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, lub <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, lub <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> jest <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Pierwszy ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Drugi ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Trzeci ścieżka do połączenia.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The fourth path to combine.</source>
          <target state="translated">Ścieżka czwarty połączyć.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Combines four strings into a path.</source>
          <target state="translated">Łączy cztery ciągów w ścieżce.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated"><ph id="ph1">`path1`</ph> powinno być ścieżką bezwzględną (na przykład "d:\archives" lub "<ph id="ph2">\\</ph>\archives\public"). Jeśli jedna ze ścieżek kolejnych również jest ścieżką bezwzględną, operację łączenia odrzuca wszystkie wcześniej połączone ścieżki, a ponadto resetuje do tej ścieżki bezwzględnej.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Ciągi o zerowej długości są pominięte połączone ścieżki.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Jeśli <ph id="ph1">`path1`</ph> nie jest odwołaniem do dysku (czyli "C:" lub "D:") i nie kończy się znak separatora prawidłowy zgodnie z definicją w <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, lub <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> jest dołączany do <ph id="ph6">`path1`</ph> przed łączenia.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> nie ma głównego (na przykład, jeśli <ph id="ph2">`path2`</ph> nie rozpoczyna się znak separatora lub specyfikację dysku), wynik jest złączeniem tych dwóch ścieżek, pośredniczące znaku separatora.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Jeśli <ph id="ph1">`path2`</ph> zawiera katalog główny <ph id="ph2">`path2`</ph> jest zwracany.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Parametry nie są parsowane, jeśli biały znak.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">W związku z tym jeśli <ph id="ph1">`path2`</ph> zawiera biały znak (na przykład "\file.txt"), <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> dołącza metody <ph id="ph3">`path2`</ph> do <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nie wszystkie nieprawidłowe znaki dla nazwy katalogu i pliku będą interpretowane przez niedopuszczalne <ph id="ph1">`Combine`</ph> metody, ponieważ dla wyszukiwania symboli wieloznacznych można używać następujących znaków.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Na przykład <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> może być nieprawidłowy w przypadku tworzenia pliku z jego jest nieprawidłowy jako ciąg wyszukiwania.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">W związku z tym jest pomyślnie interpretowany przez <ph id="ph1">`Combine`</ph> metody.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The following example combines four paths.</source>
          <target state="translated">Poniższy przykład łączy cztery ścieżki.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, lub <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, lub <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> jest <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Udostępnia specyficzne dla platformy znak używany do rozdzielania poziomów katalogów w ciągu ścieżki, które odzwierciedla organizacje systemu plików hierarchicznej.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">Znak, przechowywanego w polu nie może być w <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> and <ph id="ph2">`DirectorySeparatorChar`</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> i <ph id="ph2">`DirectorySeparatorChar`</ph> są prawidłowe dla oddzielenie poziomów katalogów w ciągu ścieżki.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`DirectorySeparatorChar`</ph> field.</source>
          <target state="translated">Poniższy przykład kodu pokazuje użycie <ph id="ph1">`DirectorySeparatorChar`</ph> pola.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The path of a file or directory.</source>
          <target state="translated">Ścieżka pliku lub katalogu.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns the directory information for the specified path string.</source>
          <target state="translated">Zwraca informacje o katalogu dla ciągu określonej ścieżki.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Directory information for <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if <ph id="ph3">&lt;paramref name="path" /&gt;</ph> denotes a root directory or is null.</source>
          <target state="translated">Informacje o katalogu dla <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, lub <ph id="ph2">&lt;see langword="null" /&gt;</ph> Jeśli <ph id="ph3">&lt;paramref name="path" /&gt;</ph> oznacza katalogiem głównym lub ma wartość null.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> does not contain directory information.</source>
          <target state="translated">Zwraca <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> Jeśli <ph id="ph2">&lt;paramref name="path" /&gt;</ph> nie zawiera informacji o katalogu.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In most cases, the string returned by this method consists of all characters in the path up to but not including the last <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">W większości przypadków długość ciągu zwróconego przez tę metodę składa się z wszystkie znaki w ścieżce do z wyjątkiem ostatniego <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> lub <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>If the path consists of a root directory, such as "c:<ph id="ph1">\\</ph>", null is returned.</source>
          <target state="translated">Jeśli ścieżka składa się z katalogiem głównym, takich jak "c:<ph id="ph1">\\</ph>", zwracana jest wartość null.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Note that this method does not support paths using "file:".</source>
          <target state="translated">Należy pamiętać, że ta metoda nie obsługuje ścieżek przy użyciu "pliku:".</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Because the returned path does not include the <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, passing the returned path back into the <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will result in the truncation of one folder level per subsequent call on the result string.</source>
          <target state="translated">Ponieważ zwrócony ścieżka nie zawiera <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> lub <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, przekazywanie zwrócony ścieżki z powrotem do <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> metody spowoduje obcięcie poziom jeden folder na kolejne wywołanie ciąg wyniku.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will return "C:\Directory\SubDirectory".</source>
          <target state="translated">Na przykład, przekazywanie do ścieżki "C:\Directory\SubDirectory\test.txt" <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> metoda zwróci "C:\Directory\SubDirectory".</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Passing that string, "C:\Directory\SubDirectory", into <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> will result in "C:\Directory".</source>
          <target state="translated">Przekazywanie tego ciągu "C:\Directory\SubDirectory", do <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> spowoduje "C:\Directory".</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetDirectoryName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, przy użyciu <ph id="ph1">`GetDirectoryName`</ph> metody na platformie pulpitu systemu Windows.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter contains invalid characters, is empty, or contains only white spaces.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> Parametru zawiera nieprawidłowe znaki, jest pusta lub zawiera tylko białe znaki.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">W <bpt id="p1">[</bpt>.NET dla Sklepu Windows apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> lub <bpt id="p2">[</bpt>przenośnej biblioteki klas<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch wyjątku klasy podstawowej <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, zamiast tego.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is longer than the system-defined maximum length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> Parametr jest dłuższa niż zdefiniowana w systemie długość maksymalna.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The path string from which to get the extension.</source>
          <target state="translated">Ciąg ścieżki, z którego można pobrać rozszerzenia.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>Returns the extension of the specified path string.</source>
          <target state="translated">Zwraca rozszerzenia w ciągu określonej ścieżki.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of the specified path (including the period "."), or <ph id="ph1">&lt;see langword="null" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Rozszerzenie określonej ścieżki (w tym okresie "."), lub <ph id="ph1">&lt;see langword="null" /&gt;</ph>, lub <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="path" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> zwraca <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not have extension information, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="path" /&gt;</ph> nie ma informacji o rozszerzeniu, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> zwraca <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of <ph id="ph1">`path`</ph> is obtained by searching <ph id="ph2">`path`</ph> for a period (.), starting with the last character in path and continuing toward the start of path.</source>
          <target state="translated">Rozszerzenie <ph id="ph1">`path`</ph> są uzyskiwane przez wyszukiwanie <ph id="ph2">`path`</ph> w okresie (.), zaczynając od ostatni znak w ścieżce i kontynuowanie do początku ścieżki.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If a period is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> character, the returned string contains the period and the characters after it; otherwise, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> is returned.</source>
          <target state="translated">Jeśli okres znajduje się przed <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> lub <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> znak zwracany ciąg zawiera okresu i znaki po nim; w przeciwnym razie <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> jest zwracany.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetExtension`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Poniższy przykład kodu pokazuje, przy użyciu <ph id="ph1">`GetExtension`</ph> metody na platformie pulpitu systemu Windows.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The path string from which to obtain the file name and extension.</source>
          <target state="translated">Ciąg ścieżki, z którego można uzyskać nazwy pliku i rozszerzenia.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>Returns the file name and extension of the specified path string.</source>
          <target state="translated">Zwraca nazwę pliku i rozszerzenie ciągu określonej ścieżki.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The characters after the last directory character in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Znaki po ostatnim znaku katalogu w <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If the last character of <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a directory or volume separator character, this method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Jeśli ostatni znak <ph id="ph1">&lt;paramref name="path" /&gt;</ph> jest znak separatora katalogu lub woluminu, ta metoda zwraca <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Jeśli <ph id="ph1">&lt;paramref name="path" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>, ta metoda zwraca <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The returned value is <ph id="ph1">`null`</ph> if the file path is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Zwrócona wartość jest <ph id="ph1">`null`</ph> Jeśli ścieżka pliku jest <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The separator characters used to determine the start of the file name are <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Separatory używany w celu określenia początku nazwa pliku są <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> i <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The following code example demonstrates the behavior of the <ph id="ph1">`GetFileName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">W poniższym przykładzie kodu pokazano zachowanie <ph id="ph1">`GetFileName`</ph> metody na platformie pulpitu systemu Windows.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The path of the file.</source>
          <target state="translated">Ścieżka pliku.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>Returns the file name of the specified path string without the extension.</source>
          <target state="translated">Zwraca nazwę pliku w ciągu określonej ścieżki bez rozszerzenia.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The string returned by <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, minus the last period (.) and all characters following it.</source>
          <target state="translated">Długość ciągu zwróconego przez <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, minus ostatniego kropki (.) i wszystkie znaki po jej.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Ta metoda nie sprawdza, czy nazwa pliku lub ścieżka istnieje.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetFileNameWithoutExtension`</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje korzystanie z <ph id="ph1">`GetFileNameWithoutExtension`</ph> metody.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory for which to obtain absolute path information.</source>
          <target state="translated">Plik lub katalog, do których chcesz uzyskać informacje o ścieżce bezwzględnej.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Returns the absolute path for the specified path string.</source>
          <target state="translated">Zwraca ścieżkę bezwzględną do ciągu określonej ścieżki.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The fully qualified location of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:\MyFile.txt".</source>
          <target state="translated">Lokalizacja pełną <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, takie jak "C:\MyFile.txt".</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The absolute path includes all information required to locate a file or directory on a system.</source>
          <target state="translated">Bezwzględna ścieżka zawiera wszystkie informacje wymagane do zlokalizowania pliku lub katalogu w systemie.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory specified by <ph id="ph1">`path`</ph> is not required to exist.</source>
          <target state="translated">Plik lub katalog określony przez <ph id="ph1">`path`</ph> istnieje nie jest wymagane.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, if c:\temp\newdir is the current directory, calling <ph id="ph1">`GetFullPath`</ph> on a file name such as test.txt returns c:\temp\newdir\test.txt.</source>
          <target state="translated">Na przykład, jeśli c:\temp\newdir jest bieżącym katalogiem, wywoływania <ph id="ph1">`GetFullPath`</ph> pliku nazwy, takie jak test.txt zwraca c:\temp\newdir\test.txt.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file need not exist.</source>
          <target state="translated">Plik musi nie istnieje.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>However, if <ph id="ph1">`path`</ph> does exist, the caller must have permission to obtain path information for <ph id="ph2">`path`</ph>.</source>
          <target state="translated">Jednak jeśli <ph id="ph1">`path`</ph> istnieje, wywołujący musi mieć uprawnienia, aby uzyskać informacje dotyczące ścieżki <ph id="ph2">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Note that unlike most members of the <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> class, this method accesses the file system.</source>
          <target state="translated">Należy pamiętać, że w przeciwieństwie do większości członków <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> klasy, ta metoda uzyskuje dostęp do systemu plików.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>This method uses current directory and current volume information to fully qualify <ph id="ph1">`path`</ph>.</source>
          <target state="translated">Ta metoda używa bieżącego katalogu i informacji o bieżącym woluminu do pełnej kwalifikacji <ph id="ph1">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you specify a file name only in <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> returns the fully qualified path of the current directory.</source>
          <target state="translated">Jeśli plik jest określony tylko w nazwie <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> zwraca w pełni kwalifikowaną ścieżkę bieżącego katalogu.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you pass in a short file name, it is expanded to a long file name.</source>
          <target state="translated">W przypadku przekazania w krótkiej nazwy pliku jest rozwinięty długiej nazwy pliku.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</source>
          <target state="translated">Jeśli ścieżka nie zawiera żadnych znaczących znaków jest nieprawidłowy, o ile zawiera ona co najmniej jeden "."znaki następuje dowolną liczbę spacji, a następnie będzie analizowany jako"."lub"..".</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The following code example demonstrates the <ph id="ph1">`GetFullPath`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">`GetFullPath`</ph> metody na platformie pulpitu systemu Windows.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> jest ciągiem o zerowej długości, zawiera tylko biały znak lub zawiera jeden lub więcej nieprawidłowych znaków, które są zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The system could not retrieve the absolute path.</source>
          <target state="translated">System nie może pobrać ścieżki bezwzględnej.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Obiekt wywołujący nie ma wymaganych uprawnień.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> jest <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon (":") that is not part of a volume identifier (for example, "c:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera dwukropek (":") oznacza to nie jest częścią identyfikator woluminu (na przykład "c:<ph id="ph2">\\</ph>").</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Na przykład na platformach opartych na systemie Windows, ścieżki muszą być mniejsze niż 248 znaków, a nazwy plików muszą być krótsze niż 260 znaków.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>for access to the path.</source>
          <target state="translated">Aby uzyskać dostęp do ścieżki.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>Gets an array containing the characters that are not allowed in file names.</source>
          <target state="translated">Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach plików.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>An array containing the characters that are not allowed in file names.</source>
          <target state="translated">Tablica zawiera znaki, które nie są dozwolone w nazwach plików.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Tablica zwrócona z tej metody nie jest gwarantowana zawierają pełny zestaw znaków, które nie są prawidłowe w nazwach plików i katalogów.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Pełny zestaw nieprawidłowe znaki może się różnić przez system plików.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Na przykład na platformach opartych na systemie Windows desktop, nieprawidłowe znaki ścieżki może zawierać znaki ASCII/Unicode 1 do 31, a także oferta ("), poniżej (<ph id="ph1">\&lt;</ph>), większości (&gt;), kreski pionowej (&amp;#124;), backspace (\b), wartości null (\0) i kartę (\t).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> — metoda i <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> metoda pobierania nieprawidłowe znaki.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>Gets an array containing the characters that are not allowed in path names.</source>
          <target state="translated">Pobiera tablicę zawierającą znaki, które nie są dozwolone w nazwach ścieżki.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>An array containing the characters that are not allowed in path names.</source>
          <target state="translated">Tablica zawiera znaki, które nie są dozwolone w nazwach ścieżki.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Tablica zwrócona z tej metody nie jest gwarantowana zawierają pełny zestaw znaków, które nie są prawidłowe w nazwach plików i katalogów.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Pełny zestaw nieprawidłowe znaki może się różnić przez system plików.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Na przykład na platformach opartych na systemie Windows desktop, nieprawidłowe znaki ścieżki może zawierać znaki ASCII/Unicode 1 do 31, a także oferta ("), poniżej (<ph id="ph1">\&lt;</ph>), większości (&gt;), kreski pionowej (&amp;#124;), backspace (\b), wartości null (\0) i kartę (\t).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">Poniższy przykład kodu pokazuje <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> — metoda i <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> metoda pobierania nieprawidłowe znaki.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The path from which to obtain root directory information.</source>
          <target state="translated">Ścieżka, z którego można uzyskać informacji o katalogu głównego.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Gets the root directory information of the specified path.</source>
          <target state="translated">Pobiera informacje o katalogu głównym określonej ścieżki.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The root directory of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:<ph id="ph2">\\</ph>", or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if <ph id="ph4">&lt;paramref name="path" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>, or an empty string if <ph id="ph6">&lt;paramref name="path" /&gt;</ph> does not contain root directory information.</source>
          <target state="translated">Katalog główny <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, takich jak "C:<ph id="ph2">\\</ph>", lub <ph id="ph3">&lt;see langword="null" /&gt;</ph> Jeśli <ph id="ph4">&lt;paramref name="path" /&gt;</ph> jest <ph id="ph5">&lt;see langword="null" /&gt;</ph>, lub pusty string, jeśli <ph id="ph6">&lt;paramref name="path" /&gt;</ph> nie zawiera informacji o katalogu głównego.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Ta metoda nie sprawdza, czy nazwa pliku lub ścieżka istnieje.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Possible patterns for the string returned by this method are as follows:</source>
          <target state="translated">Możliwe wzorce dla ciąg zwrócony przez tę metodę, są następujące:</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>An empty string (<ph id="ph1">`path`</ph> specified a relative path on the current drive or volume).</source>
          <target state="translated">Ciąg pusty (<ph id="ph1">`path`</ph> określona ścieżka względna na bieżącym dysku lub woluminie).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"/" (<ph id="ph1">`path`</ph> specified an absolute path on the current drive).</source>
          <target state="translated">"/" (<ph id="ph1">`path`</ph> określona ścieżką bezwzględną na bieżącym dysku).</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:" (<ph id="ph1">`path`</ph> specified a relative path on a drive, where X represents a drive or volume letter).</source>
          <target state="translated">"X" (<ph id="ph1">`path`</ph> określona względna ścieżka na dysku, gdzie X oznacza literę dysku lub woluminie).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:/" (<ph id="ph1">`path`</ph> specified an absolute path on a given drive).</source>
          <target state="translated">"X: /" (<ph id="ph1">`path`</ph> określona ścieżką bezwzględną na danym dysku).</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (a UNC path).</source>
          <target state="translated">"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (ścieżka UNC).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework nie obsługuje bezpośredniego dostępu do dysków fizycznych za pomocą ścieżek, które są nazwy urządzenia, takie jak "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetPathRoot`</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje korzystanie z <ph id="ph1">`GetPathRoot`</ph> metody.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>-or-</source>
          <target state="translated">—lub—</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> was passed to <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> został przekazany do <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>Returns a random folder name or file name.</source>
          <target state="translated">Zwraca nazwę folderu losowych lub nazwę pliku.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>A random folder name or file name.</source>
          <target state="translated">Losowe nazwa folderu lub pliku.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> Metoda zwraca silną kryptograficznie losowe ciąg używany jako nazwa folderu lub nazwę pliku.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>Unlike <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> does not create a file.</source>
          <target state="translated">W odróżnieniu od <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> nie tworzy pliku.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>When the security of your file system is paramount, this method should be used instead of <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</source>
          <target state="translated">Gdy bezpieczeństwo systemu plików jest podstawowym, ta metoda powinna być używana zamiast <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The following example show output from the <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method.</source>
          <target state="translated">Poniższy przykład Pokaż dane wyjściowe z <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</source>
          <target state="translated">Tworzy plik o unikatowej nazwie, zero bajtów tymczasowy na dysku i zwraca pełną ścieżkę pliku.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>The full path of the temporary file.</source>
          <target state="translated">Pełna ścieżka pliku tymczasowego.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>This method creates a temporary file with a .TMP file extension.</source>
          <target state="translated">Ta metoda tworzy plik tymczasowy z. Rozszerzenie pliku TMP.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The temporary file is created within the user’s temporary folder, which is the path returned by the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Plik tymczasowy zostanie utworzony w ramach folderu tymczasowego użytkownika, który jest ścieżka zwrócona przez <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if it is used to create more than 65535 files without deleting previous temporary files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> Metoda zgłosi <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> Jeśli jest on używany do tworzenia plików więcej niż 65535 bez usuwania poprzedniego plików tymczasowych.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if no unique temporary file name is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> Metoda zgłosi <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> Jeśli dostępny jest nie unikatowa nazwa pliku tymczasowego.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>To resolve this error, delete all unneeded temporary files.</source>
          <target state="translated">Aby rozwiązać ten problem, należy usunąć wszystkie zbędne plików tymczasowych.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>An I/O error occurs, such as no unique temporary file name is available.</source>
          <target state="translated">Występuje błąd We/Wy, takich jak nie unikatowa nazwa pliku tymczasowego jest dostępna.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> lub -</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>This method was unable to create a temporary file.</source>
          <target state="translated">Ta metoda nie może utworzyć pliku tymczasowego.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>for writing to the temporary directory.</source>
          <target state="translated">dla zapisu do katalogu tymczasowego.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>Returns the path of the current user's temporary folder.</source>
          <target state="translated">Zwraca ścieżkę folderu tymczasowego bieżącego użytkownika.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The path to the temporary folder, ending with a backslash.</source>
          <target state="translated">Ścieżka do folderu tymczasowego, kończąc ukośnik odwrotny.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This method checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">Ta metoda sprawdza istnienie zmienne środowiskowe w następującej kolejności i używa pierwszego znaleziono ścieżki:</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TMP environment variable.</source>
          <target state="translated">Ścieżka określona przez zmienną środowiskową TMP.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TEMP environment variable.</source>
          <target state="translated">Ścieżka określona przez zmienną środowiskową TEMP.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the USERPROFILE environment variable.</source>
          <target state="translated">Ścieżka określona przez zmienną środowiskową USERPROFILE.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The Windows directory.</source>
          <target state="translated">Katalog systemu Windows.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The following code shows how to call the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Poniższy kod przedstawia sposób wywołania <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This example produces output similar to the following.</source>
          <target state="translated">W tym przykładzie generuje dane wyjściowe podobne do następującego.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Obiekt wywołujący nie ma wymaganych uprawnień.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>for unrestricted access to environment variables.</source>
          <target state="translated">Aby uzyskać nieograniczony dostęp do zmiennych środowiskowych.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></source>
          <target state="translated">Wyliczenie skojarzone: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The path to search for an extension.</source>
          <target state="translated">Ścieżka wyszukiwania dla rozszerzenia.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Determines whether a path includes a file name extension.</source>
          <target state="translated">Określa, czy ścieżka zawiera rozszerzenie nazwy pliku.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the characters that follow the last directory separator (<ph id="ph2">\\</ph>\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli znaki, które należy wykonać ostatniego separatora katalogu (<ph id="ph2">\\</ph>\ lub /) lub wolumin separatora (:) w ścieżce zawierać kropki (.), a następnie co najmniej jeden znak; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Starting from the end of <ph id="ph1">`path`</ph>, this method searches for a period (.) followed by at least one character.</source>
          <target state="translated">Począwszy od końca <ph id="ph1">`path`</ph>, ta metoda szuka następuje co najmniej jeden znak kropki (.).</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>If this pattern is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> character is encountered, this method returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Jeśli ten wzorzec zostanie znaleziony przed <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, lub <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> napotkano znak, ta metoda zwraca <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The following code example demonstrates the use of the <ph id="ph1">`HasExtension`</ph> method.</source>
          <target state="translated">Poniższy przykład kodu pokazuje użycie <ph id="ph1">`HasExtension`</ph> metody.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.IO.Path.InvalidPathChars">
          <source>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> class.</source>
          <target state="translated">Udostępnia specyficzne dla platformy tablicę znaków, które w ścieżce argumentów ciągów przekazana do elementów członkowskich nie można określić <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> klasy.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Tablica zwrócona z tej metody nie jest gwarantowana zawierają pełny zestaw znaków, które nie są prawidłowe w nazwach plików i katalogów.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Pełny zestaw nieprawidłowe znaki może się różnić przez system plików.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Na przykład na platformach opartych na systemie Windows desktop, nieprawidłowe znaki ścieżki może zawierać znaki ASCII/Unicode 1 do 31, a także oferta ("), poniżej (<ph id="ph1">\&lt;</ph>), większości (&gt;), kreski pionowej (&amp;#124;), backspace (\b), wartości null (\0) i kartę (\t).</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>Do not use <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> if you think your code might execute in the same application domain as untrusted code.</source>
          <target state="translated">Nie używaj <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> Jeśli uważasz, że kod może wykonać w tej samej domenie aplikacji kodzie niezaufanym.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> is an array, so its elements can be overwritten.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> jest tablicą, więc jego elementy mogą zostać zastąpione.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>If untrusted code overwrites elements of <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, it might cause your code to malfunction in ways that could be exploited.</source>
          <target state="translated">Jeśli w kodzie niezaufanym zastępuje elementy <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, może spowodować nieprawidłowe działanie w sposób, który może zostać wykorzystana swój kod.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The following code example demonstrates the use of the <ph id="ph1">`InvalidPathChars`</ph> property.</source>
          <target state="translated">Poniższy przykład kodu pokazuje użycie <ph id="ph1">`InvalidPathChars`</ph> właściwości.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The path to test.</source>
          <target state="translated">Ścieżka do testowania.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>Gets a value indicating whether the specified path string contains a root.</source>
          <target state="translated">Pobiera wartość wskazującą, czy ciąg określona ścieżka zawiera katalog główny.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contains a root; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Jeśli <ph id="ph2">&lt;paramref name="path" /&gt;</ph> zawiera główny; w przeciwnym razie <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the first character is a directory separator character such as "<ph id="ph3">\\</ph>", or if the path starts with a drive letter and colon (:).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> Metoda zwraca <ph id="ph2">`true`</ph> Jeśli pierwszego znaku jest znakiem separatora katalogu takich jak "<ph id="ph3">\\</ph>", lub jeśli ścieżka rozpoczyna się od litery dysku i dwukropka (:).</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For example, it returns <ph id="ph1">`true`</ph> for <ph id="ph2">`path`</ph> strings such as "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "C:<ph id="ph5">\\</ph>\MyDir", or "C:MyDir".</source>
          <target state="translated">Na przykład zwraca <ph id="ph1">`true`</ph> dla <ph id="ph2">`path`</ph> ciągi, takie jak "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "C:<ph id="ph5">\\</ph>\MyDir", lub "C:MyDir".</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>It returns <ph id="ph1">`false`</ph> for <ph id="ph2">`path`</ph> strings such as "MyDir".</source>
          <target state="translated">Zwraca <ph id="ph1">`false`</ph> dla <ph id="ph2">`path`</ph> ciągów, takich jak "MyDir".</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Ta metoda nie sprawdza, czy nazwa pliku lub ścieżka istnieje.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Aby uzyskać listę typowe zadania we/wy, zobacz <bpt id="p1">[</bpt>typowe zadania we/wy<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The following code example demonstrates how the <ph id="ph1">`IsPathRooted`</ph> method can be used to test three strings.</source>
          <target state="translated">Poniższy przykład kodu pokazuje sposób <ph id="ph1">`IsPathRooted`</ph> metody można użyć do testowania trzy ciągi.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> zawiera co najmniej jeden nieprawidłowy znak zdefiniowane w <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="F:System.IO.Path.PathSeparator">
          <source>A platform-specific separator character used to separate path strings in environment variables.</source>
          <target state="translated">Znak separatora specyficzne dla platformy, używany do rozdzielania ciągów path w zmiennych środowiskowych.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</source>
          <target state="translated">Na platformach opartych na systemie Windows desktop, wartość tego pola jest średnika (;) domyślnie, ale mogą się różnić na innych platformach.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>The following code example demonstrates the use of the <ph id="ph1">`PathSeparator`</ph> field.</source>
          <target state="translated">Poniższy przykład kodu pokazuje użycie <ph id="ph1">`PathSeparator`</ph> pola.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>Provides a platform-specific volume separator character.</source>
          <target state="translated">Zawiera znak separatora woluminu specyficzne dla platformy.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</source>
          <target state="translated">Wartość tego pola jest dwukropkiem (:) w systemach Windows i Macintosh i ukośnika (/) w systemach operacyjnych UNIX.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</source>
          <target state="translated">Jest to najbardziej przydatne podczas analizowania ścieżki, takie jak "c:\windows" lub "MacVolume:System Folder".</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`VolumeSeparatorChar`</ph> field.</source>
          <target state="translated">Poniższy przykład kodu pokazuje użycie <ph id="ph1">`VolumeSeparatorChar`</ph> pola.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
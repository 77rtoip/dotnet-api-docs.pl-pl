<Type Name="RoutingConfiguration" FullName="System.ServiceModel.Routing.RoutingConfiguration">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e3c12e85823f9ad96a1a3b93a735cf24c9674c9a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69235255" /></Metadata><TypeSignature Language="C#" Value="public sealed class RoutingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RoutingConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Routing.RoutingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RoutingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutingConfiguration sealed" />
  <TypeSignature Language="F#" Value="type RoutingConfiguration = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Routing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiuje informacje o konfiguracji używane przez <see cref="T:System.ServiceModel.Routing.RoutingExtension" />program.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.ServiceModel.Routing.RoutingConfiguration" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutingConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Routing.RoutingConfiguration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutingConfiguration();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.ServiceModel.Routing.RoutingConfiguration" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutingConfiguration (System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt; filterTable, bool routeOnHeadersOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ServiceModel.Dispatcher.MessageFilterTable`1&lt;class System.Collections.Generic.IEnumerable`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt;&gt; filterTable, bool routeOnHeadersOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Routing.RoutingConfiguration.#ctor(System.ServiceModel.Dispatcher.MessageFilterTable{System.Collections.Generic.IEnumerable{System.ServiceModel.Description.ServiceEndpoint}},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filterTable As MessageFilterTable(Of IEnumerable(Of ServiceEndpoint)), routeOnHeadersOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutingConfiguration(System::ServiceModel::Dispatcher::MessageFilterTable&lt;System::Collections::Generic::IEnumerable&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^&gt; ^ filterTable, bool routeOnHeadersOnly);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Routing.RoutingConfiguration : System.ServiceModel.Dispatcher.MessageFilterTable&lt;seq&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt; * bool -&gt; System.ServiceModel.Routing.RoutingConfiguration" Usage="new System.ServiceModel.Routing.RoutingConfiguration (filterTable, routeOnHeadersOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filterTable" Type="System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt;" />
        <Parameter Name="routeOnHeadersOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filterTable">Tabela filtru komunikatów, która ma być używana dla tej konfiguracji.</param>
        <param name="routeOnHeadersOnly"><see langword="true" />Jeśli może jedynie przeanalizować nagłówki wiadomości; <see langword="false" />w przeciwnym razie. <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> Wartość domyślna to <see langword="true" />.</param>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.ServiceModel.Routing.RoutingConfiguration" /> klasy za pomocą podanego <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> parametru i RouteOnHeadersOnly.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.Routing.RoutingConfiguration.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy komunikaty mają być wysyłane w kolejności, w jakiej zostały wysłane.</summary>
        <value><see langword="true" />Jeśli komunikaty mają być wysyłane w kolejności, w jakiej zostały wysłane; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTable">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt; FilterTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.MessageFilterTable`1&lt;class System.Collections.Generic.IEnumerable`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt;&gt; FilterTable" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.FilterTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilterTable As MessageFilterTable(Of IEnumerable(Of ServiceEndpoint))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::MessageFilterTable&lt;System::Collections::Generic::IEnumerable&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^&gt; ^ FilterTable { System::ServiceModel::Dispatcher::MessageFilterTable&lt;System::Collections::Generic::IEnumerable&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilterTable : System.ServiceModel.Dispatcher.MessageFilterTable&lt;seq&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt;" Usage="System.ServiceModel.Routing.RoutingConfiguration.FilterTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.MessageFilterTable&lt;System.Collections.Generic.IEnumerable&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ServiceModel.Dispatcher.MessageFilterTable`1" /> używany przez tę konfigurację.</summary>
        <value>Tabela filtru komunikatów.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteOnHeadersOnly">
      <MemberSignature Language="C#" Value="public bool RouteOnHeadersOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteOnHeadersOnly" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteOnHeadersOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteOnHeadersOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteOnHeadersOnly : bool with get, set" Usage="System.ServiceModel.Routing.RoutingConfiguration.RouteOnHeadersOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy filtr może przeanalizować treść wiadomości.</summary>
        <value><see langword="true" />Jeśli filtr może jedynie przeanalizować nagłówki wiadomości; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoapProcessingEnabled">
      <MemberSignature Language="C#" Value="public bool SoapProcessingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SoapProcessingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property SoapProcessingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SoapProcessingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SoapProcessingEnabled : bool with get, set" Usage="System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Routing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy komunikaty mają być przetwarzane między SOAP <see cref="T:System.ServiceModel.Channels.MessageVersion" />s.</summary>
        <value><see langword="true" />Jeśli komunikaty powinny być przetwarzane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przetwarzanie protokołu SOAP jest procesem, w którym komunikaty są konwertowane <xref:System.ServiceModel.Channels.MessageVersion>między SOAP s.  
  
 Ustawienie tej wartości `false` wskazuje <xref:System.ServiceModel.Routing.RoutingBehavior> , że nie należy instalować <xref:System.ServiceModel.Routing.SoapProcessingBehavior> na punktach końcowych klienta. Jeśli jest ustawiona `false`na, należy dodać własnego inspektora komunikatów lub innego kodu do obsługi niektórych aspektów komunikatów przed ich wysłaniem. Istnieje również możliwość wyłączenia przetwarzania protokołu SOAP na każdym punkcie końcowym. Aby uzyskać więcej informacji, zobacz <xref:System.ServiceModel.Routing.SoapProcessingBehavior> Klasa.  
  
 Domyślnie program <xref:System.ServiceModel.Routing.RoutingBehavior> tworzy i dołącza nowy <xref:System.ServiceModel.Routing.SoapProcessingBehavior> z <xref:System.ServiceModel.Routing.SoapProcessingBehavior.ProcessMessages%2A> ustawionym `true` na dla każdego punktu końcowego klienta. Jeśli nie chcesz używać <xref:System.ServiceModel.Routing.SoapProcessingBehavior> w określonym punkcie końcowym, Utwórz nową <xref:System.ServiceModel.Routing.SoapProcessingBehavior> z tą wartością ustawioną na `false` , a następnie Dołącz ją do punktu końcowego, na którym nie ma się odbywać przetwarzanie. Jeśli klient ma już program, nie podejmie próby dołączenia kolejnego. <xref:System.ServiceModel.Routing.SoapProcessingBehavior> <xref:System.ServiceModel.Routing.RoutingBehavior>  
  
 Aby wyłączyć aplikację <xref:System.ServiceModel.Routing.SoapProcessingBehavior> w dowolnym punkcie końcowym, wyłącz przetwarzanie protokołu SOAP <xref:System.ServiceModel.Routing.RoutingBehavior> na i <xref:System.ServiceModel.Routing.RoutingConfiguration>.  
  
 Jeśli <xref:System.ServiceModel.Routing.RoutingConfiguration.SoapProcessingEnabled%2A> jest `true` <xref:System.ServiceModel.Description.ServiceEndpoint.Behaviors%2A> , jestdodawanydokolekcjipunktówkońcowychklienta<xref:System.ServiceModel.Routing.SoapProcessingBehavior> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

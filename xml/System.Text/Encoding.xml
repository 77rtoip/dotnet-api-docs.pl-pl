<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a39b38507f408edbec59ee4906a6ca9bc4b314fb" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69099847" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowanie znaków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode w sekwencję bajtów. Natomiast dekodowanie jest procesem przekształcania sekwencji zakodowanych bajtów na zestaw znaków Unicode. Aby uzyskać informacje na temat formatów transformacji Unicode (UTFs) i innych kodowań obsługiwanych przez <xref:System.Text.Encoding>program, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Należy pamiętać <xref:System.Text.Encoding> , że jest przeznaczony do działania na znaki Unicode zamiast dowolnych danych binarnych, takich jak tablice bajtowe. Jeśli musisz zakodować dowolne dane binarne do tekstu, Użyj protokołu takiego jak UUENCODE, który jest implementowany przez metody takie jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Platforma .NET udostępnia następujące implementacje <xref:System.Text.Encoding> klasy do obsługi bieżących kodowań Unicode i innych kodowań:  
  
-   <xref:System.Text.ASCIIEncoding>koduje znaki Unicode jako pojedyncze 7-bitowe znaki ASCII. To kodowanie obsługuje tylko wartości znakowe między literami U + 0000 i U + 007F. Strona kodowa 20127. Dostępne również za pomocą <xref:System.Text.Encoding.ASCII%2A> właściwości.  
  
-   <xref:System.Text.UTF7Encoding>koduje znaki Unicode przy użyciu kodowania UTF-7. To kodowanie obsługuje wszystkie wartości znaków Unicode. Strona kodowa 65000. Dostępne również za pomocą <xref:System.Text.Encoding.UTF7%2A> właściwości.  
  
-   <xref:System.Text.UTF8Encoding>koduje znaki Unicode przy użyciu kodowania UTF-8. To kodowanie obsługuje wszystkie wartości znaków Unicode. Strona kodowa 65001. Dostępne również za pomocą <xref:System.Text.Encoding.UTF8%2A> właściwości.  
  
-   <xref:System.Text.UnicodeEncoding>koduje znaki Unicode przy użyciu kodowania UTF-16. Obsługiwane są zarówno zamówienia little endian, jak i big endian bajty. Dostępne również za pomocą <xref:System.Text.Encoding.Unicode%2A> właściwości <xref:System.Text.Encoding.BigEndianUnicode%2A> i właściwości.  
  
-   <xref:System.Text.UTF32Encoding>koduje znaki Unicode przy użyciu kodowania UTF-32. Obsługiwane są zarówno little endian (strona kodowa 12000), jak i big endian (strona kodowa 12001) kolejność bajtów. Dostępne również za pomocą <xref:System.Text.Encoding.UTF32%2A> właściwości.  
  
 <xref:System.Text.Encoding> Klasa jest przeznaczona głównie do konwersji między różnymi kodowania i Unicode. Często jedną z pochodnych klas Unicode jest właściwy wybór dla aplikacji.  
  
 Użyj metody, aby uzyskać inne kodowania, i <xref:System.Text.Encoding.GetEncodings%2A> Wywołaj metodę, aby uzyskać listę wszystkich kodowań. <xref:System.Text.Encoding.GetEncoding%2A>  
  
 W poniższej tabeli przedstawiono kodowanie obsługiwane przez .NET Framework i .NET Core. Zawiera on listę numerów stron kodowych i wartości kodowania <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> oraz <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> właściwości. Znacznik wyboru w kolumnach **obsługa .NET Framework** i **Obsługa platformy .NET Core** wskazuje, że strona kodowa jest natywnie obsługiwana przez implementację platformy .NET, niezależnie od podstawowej platformy. W przypadku .NET Framework dostępność innych kodowań wymienionych w tabeli zależy od systemu operacyjnego. W przypadku platformy .NET Core inne kodowania są dostępne za pomocą <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> klasy lub przez pochodną <xref:System.Text.EncodingProvider?displayProperty=nameWithType> klasy.  

> [!NOTE]
> Strony kodowe <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> , których właściwość odnosi się do normy międzynarodowej, niekoniecznie są zgodne z tym standardem. 

|Strona kodowa|Nazwa|Nazwa wyświetlana|Obsługa .NET Framework| Obsługa platformy .NET Core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (US-Canada)|||  
|437|IBM437|Stany Zjednoczone OEM|||  
|500|IBM500|IBM EBCDIC (międzynarodowy)|||  
|708|ASMO-708|Arabski (ASMO 708)|||  
|720|DOS-720|Arabski (DOS)|||  
|737|ibm737|Grecki (DOS)|||  
|775|ibm775|Bałtycki (DOS)|||  
|850|ibm850|Europa Zachodnia (DOS)|||  
|852|ibm852|Europa Środkowa (DOS)|||  
|855|IBM855|OEM Cyrillic|||  
|857|ibm857|Turecki (DOS)|||  
|858|IBM00858|OEM — wielojęzyczny Latin I|||  
|860|IBM860|Portugalski (DOS)|||  
|861|ibm861|Islandzki (DOS)|||  
|862|DOS-862|Hebrajski (DOS)|||  
|863|IBM863|Francuski kanadyjski (DOS)|||  
|864|IBM864|Arabski (864)|||  
|865|IBM865|Nordyckie (DOS)|||  
|866|cp866|Cyrylica (DOS)|||  
|869|ibm869|Grecki, nowoczesny (DOS)|||  
|870|IBM870|IBM EBCDIC (wielojęzyczny Latin-2)|||  
|874|windows-874|Tajski (Windows)|||  
|875|cp875|IBM EBCDIC (grecki współczesny)|||  
|932|shift_jis|Japoński (Shift-JIS)|||  
|936|gb2312|Chiński uproszczony (GB2312)|✓||  
|949|ks_c_5601-1987|koreański|||  
|950|big5|Chiński tradycyjny (BIG5)|||  
|1026|IBM1026|IBM EBCDIC (turecki Latin-5)|||  
|1047|IBM01047|IBM Latin-1|||  
|1140|IBM01140|IBM EBCDIC (USA-Kanada-euro)|||  
|1141|IBM01141|IBM EBCDIC (Niemcy-euro)|||  
|1142|IBM01142|IBM EBCDIC (Dania-Norwegia-Euro)|||  
|1143|IBM01143|IBM EBCDIC (Finlandia-Szwecja-euro)|||  
|1144|IBM01144|IBM EBCDIC (Włochy-euro)|||  
|1145|IBM01145|IBM EBCDIC (Hiszpania-euro)|||  
|1146|IBM01146|IBM EBCDIC (UK-euro)|||  
|1147|IBM01147|IBM EBCDIC (Francja-euro)|||  
|1148|IBM01148|IBM EBCDIC (Międzynarodowy-euro)|||  
|1149|IBM01149|IBM EBCDIC (islandzki-Euro)|||  
|1200|UTF-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (big endian)|✓|✓|  
|1250|windows-1250|Europa Środkowa (Windows)|||  
|1251|windows-1251|Cyrylica (Windows)|||  
|1252|Windows-1252|Europa Zachodnia (system Windows)|✓||  
|1253|windows-1253|Grecki (Windows)|||  
|1254|windows-1254|Turecki (Windows)|||  
|1255|windows-1255|Hebrajski (Windows)|||  
|1256|windows-1256|Arabski (Windows)|||  
|1257|windows-1257|Bałtycki (Windows)|||  
|1258|windows-1258|Wietnamski (Windows)|||  
|1361|Johab|Koreański (Johab)|||  
|10 000|Mac|Europa Zachodnia (Mac)|||  
|10001|x-Mac — japoński|Japoński (Mac)|||  
|10002|x-mac-chinesetrad|Chiński tradycyjny (Mac)|||  
|10003|x-mac-korean|Koreański (Mac)|✓||  
|10004|x-mac-arabic|Arabski (Mac)|||  
|10005|x-mac-hebrew|Hebrajski (Mac)|||  
|10006|x-Mac — grecki|Grecki (Mac)|||  
|10007|x-mac-cyrillic|Cyrylica (Mac)|||  
|10008|x-mac-chinesesimp|Chiński uproszczony (Mac)|✓||  
|10010|x-Mac — rumuński|Rumuński (Mac)|||  
|10017|x-mac-ukrainian|Ukraiński (Mac)|||  
|10021|x-Mac — tajski|Tajski (Mac)|||  
|10029|x-Mac-CE|Europa Środkowa (Mac)|||  
|10079|x-mac-icelandic|Islandzki (Mac)|||  
|10081|x-mac-turkish|Turecki (Mac)|||  
|10082|x-Mac-chorwacki|Chorwacki (Mac)|||  
|12000|UTF-32|Unicode (UTF-32)|✓|✓|  
|12001|utf-32BE|Unicode (big endian UTF-32)|✓|✓|  
|20000|x-Chinese-CNS|Chiński tradycyjny (CNS)|||  
|20001|x-cp20001|TCA Tajwan|||  
|20002|x-Chinese-Eten|Chiński tradycyjny (eTEN)|||  
|20003|x-cp20003|IBM5550 Tajwan|||  
|20004|x-cp20004|Teletekst — Tajwan|||  
|20005|x-cp20005|Wang Tajwan|||  
|20105|x-IA5|Europa Zachodnia (IA5)|||  
|20106|x-IA5-niemiecki|Niemiecki (IA5)|||  
|20107|x-IA5-szwedzki|Szwedzki (IA5)|||  
|20108|x-IA5-Norwegian|Norweski (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T. 61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Niemcy)|||  
|20277|IBM277|IBM EBCDIC (Dania-Norwegia)|||  
|20278|IBM278|IBM EBCDIC (Finlandia-Szwecja)|||  
|20280|IBM280|IBM EBCDIC (Włochy)|||  
|20284|IBM284|IBM EBCDIC (Hiszpania)|||  
|20285|IBM285|IBM EBCDIC (UK)|||  
|20290|IBM290|IBM EBCDIC (japoński katakana)|||  
|20297|IBM297|IBM EBCDIC (Francja)|||  
|20420|IBM420|IBM EBCDIC (arabski)|||  
|20423|IBM423|IBM EBCDIC (grecki)|||  
|20424|IBM424|IBM EBCDIC (hebrajski)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (koreański rozszerzony)|||  
|20838|IBM — tajski|IBM EBCDIC (tajski)|||  
|20866|KOI8-r|Cyrylica (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (islandzki)|||  
|20880|IBM880|IBM EBCDIC (cyrylica rosyjski)|||  
|20905|IBM905|IBM EBCDIC (turecki)|||  
|20924|IBM00924|IBM Latin-1|||  
|20932|EUC-JP|Japoński (JIS 0208-1990 i 0212-1990)|||  
|20936|x-cp20936|Chiński uproszczony (GB2312-80)|✓||  
|20949|x-cp20949|Wansung koreański|✓||  
|21025|cp1025|IBM EBCDIC (Serbski Cyrylica — bułgarski)|||  
|21866|KOI8-u|Cyrylica (KOI8-U)|||  
|28591|ISO-8859-1|Europa Zachodnia (ISO)|✓|✓|  
|28592|ISO-8859-2|Europa Środkowa (ISO)|||  
|28593|ISO-8859-3|Łaciński 3 (ISO)|||  
|28594|ISO-8859-4|Bałtycki (ISO)|||  
|28595|ISO-8859-5|Cyrylica (ISO)|||  
|28596|ISO-8859-6|Arabski (ISO)|||  
|28597|ISO-8859-7|Grecki (ISO)|||  
|28598|ISO-8859-8|Hebrajski (ISO-Visual)|✓||  
|28599|ISO-8859-9|Turecki (ISO)|||  
|28603|ISO-8859-13|Estoński (ISO)|||  
|28605|ISO-8859-15|Latin 9 (ISO)|||  
|29001|x-Europa|Stronie|||  
|38598|iso-8859-8-i|Hebrajski (ISO-Logical)|✓||  
|50220|iso-2022-jp|Japoński (JIS)|✓||  
|50221|csISO2022JP|Japoński (JIS-dozwolone 1-bajtowe znaki kana)|✓||  
|50222|iso-2022-jp|Japoński (JIS-dozwolone 1-bajtowe znaki kana-SO/SI)|✓||  
|50225|ISO-2022-KR|Koreański (ISO)|✓||  
|50227|x-cp50227|Chiński uproszczony (ISO-2022)|✓||  
|51932|euc-jp|Japoński (EUC)|✓||  
|51936|EUC-CN|Chiński uproszczony (EUC)|✓||  
|51949|euc-kr|Koreański (EUC)|✓||  
|52936|hz-gb-2312|Chiński uproszczony (HZ)|✓||  
|54936|GB18030|Chiński uproszczony (GB18030)|✓||  
|57002|x-iscii-de|ISCII dewanagari|✓||  
|57003|x-iscii-be|ISCII Bengali|✓||  
|57004|x-ISCII-ta|ISCII tamilski|✓||  
|57005|x-ISCII-te|ISCII telugu|✓||  
|57006|x-iscii-as|ISCII assamski|✓||  
|57007|x-ISCII lub|ISCII orija|✓||  
|57008|x-iscii-ka|ISCII Kannada|✓||  
|57009|x-iscii-ma|ISCII Malayalam|✓||  
|57010|x-iscii-gu|ISCII Gujarati|✓||  
|57011|x-iscii-pa|ISCII Punjabi|✓||  
|65000|UTF-7|Unicode (UTF-7)|✓|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|✓|  
  
 Poniższy przykład wywołuje <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> metody i <xref:System.Text.Encoding.GetEncoding%28System.String%29> , aby uzyskać greckie kodowanie strony kodowej (Windows). Porównuje <xref:System.Text.Encoding> obiekty zwracane przez wywołania metody, aby pokazać, że są równe, a następnie Maps wyświetla punkt kodu Unicode i odpowiednią wartość strony kodowej dla każdego znaku w alfabecie greckim.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Kodery UTF-16 i UTF-32 mogą używać kolejności bajtów w big endian (najpierw najbardziej znaczący bajt) lub kolejności bajtów little endian (najpierw należy użyć co najmniej znaczącego bajtu). Na przykład Wielka litera A (U + 0041) jest serializowana w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów w formacie UTF-16 big endian: 00 41  
  
-   Kolejność bajtów w formacie UTF-16 little endian: 41 00  
  
-   Kolejność bajtów w formacie UTF-32 big endian: 00 00 00 41  
  
-   Kolejność bajtów w formacie UTF-32 little endian: 41 00 00 00  
  
 Zwykle bardziej wydajne jest przechowywanie znaków Unicode przy użyciu kolejności bajtów natywnych. Na przykład lepiej jest używać kolejności bajtów little endian na platformach little endian, takich jak komputery Intel.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> Metoda pobiera tablicę bajtów, która zawiera znacznik kolejności bajtów (BOM). Jeśli ta tablica bajtowa jest poprzedzona zakodowanym strumieniem, pomaga dekoderowi identyfikować używany format kodowania.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, zobacz Standard Unicode na [stronie głównej Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Należy zauważyć, że klasy kodowania umożliwiają błędy:  
  
-   Przejdź w tryb dyskretny do znaku "?".  
  
-   Użyj znaku "Najlepsza dopasowanie".  
  
-   Zmień zachowanie <xref:System.Text.EncoderFallback> specyficzne dla aplikacji, korzystając z klas i i <xref:System.Text.DecoderFallback> znaku zastępczego Unicode U + FFFD.  
  
 W przypadku błędu strumienia danych należy zgłosić wyjątek. Aplikacja używa flagi "parametr throwOnError", jeśli ma zastosowanie lub używa <xref:System.Text.EncoderExceptionFallback> klas i. <xref:System.Text.DecoderExceptionFallback> Opcja Najlepsza dopasowanie jest często niezalecana, ponieważ może spowodować utratę lub pomyłkę danych i jest wolniejsza niż proste zamiany znaków. W przypadku kodowań ANSI najlepszym zachowaniem jest ustawienie domyślne.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z jednego kodowania na inny.  
  
> [!NOTE]
>  Tablica Byte [] jest jedynym typem w tym przykładzie, który zawiera zakodowane dane. Typy znaków i ciągów programu .NET są same w formacie Unicode, <xref:System.Text.Encoding.GetChars%2A> więc wywołanie dekoduje dane z powrotem do formatu Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne przesłaniają ten Konstruktor.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Identyfikator strony kodowej preferowanego kodowania.  
  
 —lub—  
  
 0, aby użyć domyślnego kodowania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.Encoding" /> klasy, które odnosi się do określonej strony kodowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne przesłaniają ten Konstruktor.  
  
 Wywołania tego konstruktora z klasy pochodnej tworzą <xref:System.Text.Encoding> obiekt, który używa najlepszego dopasowania dla operacji kodowania i dekodowania. Właściwości i <xref:System.Text.Encoding.DecoderFallback%2A> <xref:System.Text.Encoding.EncoderFallback%2A> są tylko do odczytu i nie można ich modyfikować. Aby kontrolować strategię powrotu klasy pochodnej z <xref:System.Text.Encoding>, <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> Wywołaj konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" />jest mniejsza od zera.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Identyfikator strony kodowej kodowania.</param>
        <param name="encoderFallback">Obiekt, który dostarcza procedurę obsługi błędów, gdy nie można zakodować znaku przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który dostarcza procedurę obsługi błędów, gdy nie można zdekodować sekwencji bajtów z bieżącym kodowaniem.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.Encoding" /> klasy, które odnosi się do określonej strony kodowej z określonymi strategiami rezerwy kodera i dekodera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor to `protected`; klasy pochodne przesłaniają je.  
  
 Ten konstruktor jest wywoływany z klasy pochodnej, aby kontrolować rezerwowe strategie kodowania i dekodowania. Konstruktory <xref:System.Text.Encoding> klas tworzą obiekty kodowania tylko do odczytu, które nie zezwalają na ustawienie powrotu dekodera lub dekodera po utworzeniu obiektu.  
  
 `encoderFallback` Jeśli lub `decoderFallback` ma wartość null, najlepszym dopasowaniem jest użycie jako odpowiedniej strategii rezerwowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" />jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla zestawu znaków ASCII (7-bitowy).</summary>
        <value>Kodowanie zestawu znaków ASCII (7-bitowy).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ASCII są ograniczone do najmniejszych 128 znaków Unicode, od U + 0000 do U + 007F.  
  
 Wybierając kodowanie ASCII dla aplikacji, weź pod uwagę następujące kwestie:  
  
-   Kodowanie ASCII jest zwykle odpowiednie dla protokołów, które wymagają ASCII.  
  
-   Jeśli jest wymagane kodowanie 8-bitowe (które jest czasami niewłaściwie określane jako "ASCII"), kodowanie UTF-8 jest zalecane w porównaniu z kodowaniem ASCII. W przypadku znaków 0-7F wyniki są identyczne, ale użycie UTF-8 pozwala uniknąć utraty danych, umożliwiając reprezentację wszystkich znaków Unicode, które są możliwe do przedstawienia. Należy zauważyć, że kodowanie ASCII ma 8-bitową niejednoznaczność, która może pozwolić na złośliwe użycie, ale kodowanie UTF-8 usuwa niejednoznaczność dla ósmego bitu.  
  
-   Przed .NET Framework w wersji 2,0 .NET Framework dozwolone fałszowanie poprzez ignorowanie ósmego bitu. Począwszy od .NET Framework 2,0, punkty kodów inne niż ASCII powracają podczas dekodowania.  
  
 <xref:System.Text.ASCIIEncoding> Obiekt, który jest zwracany przez tę właściwość, może nie mieć odpowiednich zachowań dla aplikacji. Używa powrotu zamiennej, aby zastąpić każdy ciąg, którego nie można kodować, i każdego bajtu, którego nie można zdekodować ze znakiem zapytania ("?"). <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> Zamiast tego można wywołać metodę, aby <xref:System.Text.ASCIIEncoding> utworzyć wystąpienie obiektu, <xref:System.Text.EncoderFallbackException> którego rezerwa jest albo a <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje efekt kodowania ASCII dla znaków, które znajdują się poza zakresem ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-16, który używa kolejności bajtów big endian.</summary>
        <value>Obiekt kodowania dla formatu UTF-16, który używa kolejności bajtów big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiekt, który jest zwracany przez tę właściwość, może nie mieć odpowiednich zachowań dla aplikacji. Używa powrotu zamiennej, aby zastąpić każdy ciąg, którego nie można kodować, i każdego bajtu, którego nie można zdekodować ze znakiem zapytania ("?"). Zamiast tego można <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> wywołać konstruktora, aby utworzyć wystąpienie obiektu big endian <xref:System.Text.UnicodeEncoding> , <xref:System.Text.EncoderFallbackException> którego rezerwa jest albo a <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Zwrócony <xref:System.Text.UnicodeEncoding> obiekt <xref:System.Text.Encoding.BodyName%2A> <xref:System.Text.Encoding.WebName%2A> ma właściwości,, i, które dają nazwę "unicodeFFFE". <xref:System.Text.Encoding.HeaderName%2A> Mimo że znacznik kolejności bajtów UTF-16 big endian ma wartość szesnastkową FEFF, została wybrana nazwa "unicodeFFFE", ponieważ znacznik kolejności bajtów pojawia się jako szesnastkowy FFFE na komputerach z systemem little endian Windows.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik tekstowy z kodowaniem UTF-16 przy użyciu kolejności bajtów big endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera nazwę bieżącego kodowania, który może być używany z tagami treści agenta poczty.</summary>
        <value>Nazwa bieżącego <see cref="T:System.Text.Encoding" /> , który może być używany z tagami treści agenta poczty.  
  
—lub— 
Pusty ciąg (""), jeśli nie można użyć <see cref="T:System.Text.Encoding" /> bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli potrzebujesz kodowania dla nazwy treści, należy wywołać <xref:System.Text.Encoding.GetEncoding%2A> <xref:System.Text.Encoding.BodyName%2A> z właściwością. Często Metoda pobiera inne kodowanie z kodowania testowego dostarczonego w wywołaniu. Ogólnie tylko aplikacje poczty e-mail muszą pobierać takie kodowanie; Większość innych aplikacji, które muszą opisać kodowanie, powinna używać jego <xref:System.Text.Encoding.WebName%2A>.  
  
 W niektórych przypadkach wartość <xref:System.Text.Encoding.BodyName%2A> właściwości odnosi się do normy międzynarodowej, która definiuje to kodowanie. Nie oznacza to, że implementacja jest zgodna z tym standardem.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z co najmniej jedną nazwą, która różni się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Jest on <xref:System.Text.Encoding.EncodingName%2A> wyświetlany, ale nie jest porównywany z nim.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, tworzy skróconą kopię bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <returns>Kopia bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klon jest zapisywalny, nawet jeśli oryginalny <xref:System.Text.Encoding> obiekt jest tylko do odczytu. W związku z tym właściwości klonu można modyfikować.  
  
 Płytki kopia obiektu jest kopią tylko obiektu. Jeśli obiekt zawiera odwołania do innych obiektów, płytki kopia nie tworzy kopii określonych obiektów. Odwołuje się do oryginalnych obiektów. Z kolei Szczegółowa kopia obiektu tworzy kopię obiektu i kopię wszystkiego bezpośrednio lub pośrednio, do którego odwołuje się ten obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera identyfikator strony kodowej bieżącego <see cref="T:System.Text.Encoding" />.</summary>
        <value>Identyfikator strony kodowej bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z co najmniej jedną nazwą, która różni się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Jest on <xref:System.Text.Encoding.EncodingName%2A> wyświetlany, ale nie jest porównywany z nim.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje tablicę bajtową z jednego kodowania na inną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Format <paramref name="bytes" />kodowania.</param>
        <param name="dstEncoding">Docelowy format kodowania.</param>
        <param name="bytes">Bajty do przekonwertowania.</param>
        <summary>Konwertuje całą tablicę bajtową z jednego kodowania na inną.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierającego wyniki konwersji <paramref name="bytes" /> z <paramref name="srcEncoding" /> do <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje ciąg zakodowany w formacie Unicode na ciąg zakodowany w formacie ASCII. Ponieważ obiekt kodowania ASCII zwrócony przez <xref:System.Text.Encoding.ASCII%2A> właściwość używa rezerwy zastępczej, a znak pi nie jest częścią zestawu znaków ASCII, znak Pi jest zastępowany znakiem zapytania, ponieważ dane wyjściowe z przykładu są wyświetlane.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="dstEncoding" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Kodowanie tablicy <paramref name="bytes" />źródłowej.</param>
        <param name="dstEncoding">Kodowanie tablicy wyjściowej.</param>
        <param name="bytes">Tablica bajtów do przekonwertowania.</param>
        <param name="index">Indeks pierwszego elementu <paramref name="bytes" /> do przekonwertowania.</param>
        <param name="count">Liczba bajtów do przekonwertowania.</param>
        <summary>Konwertuje zakres bajtów w tablicy bajtów z jednego kodowania na inny.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierającego wynik konwersji zakresu bajtów w <paramref name="bytes" /> z <paramref name="srcEncoding" /> do <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="dstEncoding" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />i <paramref name="count" /> nie określaj prawidłowego zakresu w tablicy bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.DecoderFallback" /> obiekt dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <value>Obiekt rezerwowy dekodera dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Obiekt reprezentuje procedurę obsługi błędów, która jest wywoływana, gdy nie można zdekodować zakodowanej sekwencji bajtów do znaku. Obsługiwany jest dowolny z następujących typów obsługi:  
  
-   Optymalna obsługa powrotu, która zastępuje bajty, których nie można zdekodować przy użyciu odpowiedniego znaku zastępczego.  
  
-   Zastępcza procedura obsługi rezerwowej, która zastępuje bajty, których nie można zdekodować przy użyciu dowolnego dowolnego znaku zastępczego. Platforma .NET zawiera jedną alternatywną procedurę <xref:System.Text.DecoderFallback>obsługi rezerwowej, która domyślnie zastępuje bajty, których nie można zdekodować przy użyciu znaku zapytania ("?").  
  
-   Procedura obsługi powrotu wyjątku, która zgłasza wyjątek, gdy nie można zdekodować bajtów. Platforma .NET zawiera jedną procedurę obsługi <xref:System.Text.DecoderExceptionFallback>rezerwy wyjątku, która <xref:System.Text.DecoderFallbackException> zgłasza, kiedy nie można zdekodować bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji zestawu wynosi <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można przypisać wartości w operacji zestawu, ponieważ bieżący <see cref="T:System.Text.Encoding" /> obiekt jest tylko do odczytu.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne kodowanie dla tej implementacji platformy .NET.</summary>
        <value>Domyślne kodowanie dla tej implementacji platformy .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Różne komputery mogą używać różnych kodowań jako domyślnych, a domyślne kodowanie można zmienić na pojedynczym komputerze. W przypadku użycia <xref:System.Text.Encoding.Default%2A> kodowania do kodowania i dekodowania danych przesyłanych między komputerami lub pobieranych w różnym czasie na tym samym komputerze, dane te mogą być nieprawidłowo przekonwertowane. Ponadto kodowanie zwracane przez <xref:System.Text.Encoding.Default%2A> właściwość używa najlepiej pasującej rezerwy do mapowania nieobsługiwanych znaków na znaki obsługiwane przez stronę kodową. Z tego względu nie zaleca się używania domyślnego kodowania. Aby upewnić się, że zakodowane bajty są poprawnie zdekodowane, należy użyć kodowania Unicode, <xref:System.Text.UTF8Encoding> takiego <xref:System.Text.UnicodeEncoding>jak lub. Można również użyć protokołu wyższego poziomu, aby upewnić się, że ten sam format jest używany do kodowania i dekodowania.  

### <a name="the-default-property-in-the-net-framework"></a>Właściwość domyślna w .NET Framework

W .NET Framework na pulpicie <xref:System.Text.Encoding.Default%2A> systemu Windows właściwość zawsze pobiera aktywną stronę kodową systemu i <xref:System.Text.Encoding> tworzy obiekt, który odpowiada. Aktywna strona kodowa może być stroną kodową ANSI, która zawiera zestaw znaków ASCII wraz z dodatkowymi znakami, które różnią się w zależności od strony kodowej. Ponieważ wszystkie <xref:System.Text.Encoding.Default%2A> kodowania na podstawie stron kodowych ANSI utraciły dane, rozważ <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> użycie kodowania zamiast tego. UTF-8 jest często identyczny w zakresie od U + 00 do a + 7F, ale może kodować znaki poza zakresem ASCII bez utraty.

## <a name="the-default-property-on-net-core"></a>Właściwość domyślna na platformie .NET Core

W przypadku <xref:System.Text.Encoding.Default%2A> platformy .NET Core Właściwość zawsze <xref:System.Text.UTF8Encoding>zwraca wartość. Kodowanie UTF-8 jest obsługiwane we wszystkich systemach operacyjnych (Windows, Linux i Max OS X), na których działają aplikacje .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.EncoderFallback" /> obiekt dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <value>Obiekt rezerwowy kodera dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Obiekt reprezentuje procedurę obsługi błędów, która jest wywoływana, gdy nie można przekonwertować znaku na zakodowaną sekwencję bajtów. Obsługiwany jest dowolny z następujących typów obsługi:  
  
-   Optymalna obsługa powrotu, która zastępuje znaki, których nie można zakodować przy użyciu odpowiedniego znaku zastępczego.  
  
-   Zastępcza procedura obsługi rezerwowej, która zastępuje znaki, których nie można zakodować przy użyciu dowolnego dowolnego znaku zastępczego. Platforma .NET zawiera jedną alternatywną procedurę <xref:System.Text.EncoderFallback>obsługi rezerwowej, która domyślnie zastępuje znaki, których nie można zakodować znakiem zapytania ("?").  
  
-   Procedura obsługi powrotu wyjątku, która zgłasza wyjątek, gdy nie można zakodować znaków. Platforma .NET zawiera jedną procedurę obsługi <xref:System.Text.EncoderExceptionFallback>rezerwy wyjątku, która zgłasza, że <xref:System.Text.EncoderFallbackException> nie można zdekodować znaków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji zestawu wynosi <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można przypisać wartości w operacji zestawu, ponieważ bieżący <see cref="T:System.Text.Encoding" /> obiekt jest tylko do odczytu.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, Pobiera opis bieżącego kodowania przez człowieka.</summary>
        <value>Czytelny dla człowieka Opis bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> Właściwość jest przeznaczona do wyświetlania. Aby znaleźć nazwę, którą można przesłać do <xref:System.Text.Encoding.GetEncoding%2A> metody, <xref:System.Text.Encoding.WebName%2A> Użyj właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z co najmniej jedną nazwą, która różni się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Jest on <xref:System.Text.Encoding.EncodingName%2A> wyświetlany, ale nie jest porównywany z nim.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> element jest równy bieżącemu wystąpieniu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest <see langword="false" />wystąpieniem i jest równe bieżącemu wystąpieniu; w przeciwnym razie,. <see cref="T:System.Text.Encoding" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa wystąpienia <xref:System.Text.Encoding> są uważane za równe, jeśli są zgodne z tą samą stroną kodową `DecoderFallback` , a ich `EncoderFallback` obiekty i są równe. W szczególności wszystkie pochodne strony kodowe mają stronę kodową 0, a ich powrotu są zwykle `null` (`Nothing` w Visual Basic .NET). Dlatego wszystkie są uważane za równorzędne. Jedną z postanowień jest <xref:System.Text.Encoding.Equals%2A> to, że gdy jest używany do wypełniania tabeli skrótów, wszystkie pochodne kodowania porównują się równo i mieszczą się w tym samym gnieździe tabeli skrótów.  
  
   
  
## Examples  
 Poniższy przykład pobiera dwa wystąpienia tego samego kodowania (po jednym przez stronę kodową i inne według nazwy) i sprawdza ich równość.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca znaki do kodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę bajtów generowanych przez kodowanie wszystkich znaków w określonej tablicy znaków.</summary>
        <returns>Liczba bajtów wygenerowanych przez kodowanie wszystkich znaków w określonej tablicy znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetBytes%2A> program do przechowywania wyników, <xref:System.Text.Encoding.GetByteCount%2A> Wywołaj metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A> typu String metody.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków do kodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę bajtów wytwarzanych przez zakodowanie znaków w określonym ciągu.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetBytes%2A> program do przechowywania wyników, <xref:System.Text.Encoding.GetByteCount%2A> Wywołaj metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, zalecana <xref:System.Text.Encoding.GetBytes%2A> jest wersja ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania ciągu lub zakresu w ciągu, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków, zaczynając od określonego wskaźnika znakowego.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.Encoding.GetBytes%2A> jest wymagany do przechowywania powstających bajtów, należy <xref:System.Text.Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia dotyczące korzystania z tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A> ciągu metody.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%2A> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków z określonej tablicy znaków.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetBytes%2A> program do przechowywania wyników, <xref:System.Text.Encoding.GetByteCount%2A> Wywołaj metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, zalecana <xref:System.Text.Encoding.GetBytes%2A> jest wersja ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania trzech znaków z tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje zestaw znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca znaki do kodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje wszystkie znaki w określonej tablicy znaków w sekwencji bajtów.</summary>
        <returns>Tablica bajtowa zawierająca wyniki kodowania określonego zestawu znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt. (Na przykład sekwencja znaków obejmująca pary zastępcze może kończyć się dużym surogatem. <xref:System.Text.Encoder> Będzie pamiętać, że duży Surogat, aby można było łączyć się z małą częścią, na początku następującego wywołania. <xref:System.Text.Encoding>nie będzie można zachować stanu, więc znak zostanie wysłany do <xref:System.Text.EncoderFallback>.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy wywołać wersję <xref:System.Text.Encoding.GetBytes%2A> ciągu metody.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający znaki do kodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje wszystkie znaki w określonym ciągu do sekwencji bajtów.</summary>
        <returns>Tablica bajtowa zawierająca wyniki kodowania określonego zestawu znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt. (Na przykład sekwencja znaków obejmująca pary zastępcze może kończyć się dużym surogatem. <xref:System.Text.Encoder> Będzie pamiętać, że duży Surogat, aby można było łączyć się z małą częścią, na początku następującego wywołania. <xref:System.Text.Encoding>nie będzie można zachować stanu, więc znak zostanie wysłany do <xref:System.Text.EncoderFallback>.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A>ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania ciągu lub zakresu w ciągu, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje zestaw znaków z określonej tablicy znaków w sekwencji bajtów.</summary>
        <returns>Tablica bajtowa zawierająca wyniki kodowania określonego zestawu znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt. (Na przykład sekwencja znaków obejmująca pary zastępcze może kończyć się dużym surogatem. <xref:System.Text.Encoder> Będzie pamiętać, że duży Surogat, aby można było łączyć się z małą częścią, na początku następującego wywołania. <xref:System.Text.Encoding>nie będzie można zachować stanu, więc znak zostanie wysłany do <xref:System.Text.EncoderFallback>.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A>ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania trzech znaków z tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której ma zostać rozpoczęte pisanie sekwencji bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje zestaw znaków, zaczynając od określonego wskaźnika znakowego do sekwencji bajtów, które są przechowywane Zaczynając od określonego wskaźnika Byte.</summary>
        <returns>Rzeczywista liczba bajtów zapisywana w lokalizacji wskazywanej przez <paramref name="bytes" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.Encoding.GetBytes%2A> jest wymagany do przechowywania powstających bajtów, <xref:System.Text.Encoding.GetByteCount%2A> Wywołaj metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Jeśli dane do konwersji są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że trzeba ją podzielić na mniejsze bloki, należy użyć podanego obiektu <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> odpowiednio przez metodę <xref:System.Text.Encoding.GetDecoder%2A> lub <xref:System.Text.Encoding.GetEncoder%2A> klasy pochodnej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt. (Na przykład sekwencja znaków obejmująca pary zastępcze może kończyć się dużym surogatem. <xref:System.Text.Encoder> Będzie pamiętać, że duży Surogat, aby można było łączyć się z małą częścią, na początku następującego wywołania. <xref:System.Text.Encoding>nie będzie można zachować stanu, więc znak zostanie wysłany do <xref:System.Text.EncoderFallback>.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A>ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" />jest mniejsza niż liczba bajtów będących wynikiem.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów, która zawiera wyniki sekwencji bajtów.</param>
        <param name="byteIndex">Indeks, od którego ma zostać rozpoczęte zapisywanie wyniku sekwencji bajtów.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje zestaw znaków z określonej tablicy znaków do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów do <paramref name="bytes" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt. (Na przykład sekwencja znaków obejmująca pary zastępcze może kończyć się dużym surogatem. <xref:System.Text.Encoder> Będzie pamiętać, że duży Surogat, aby można było łączyć się z małą częścią, na początku następującego wywołania. <xref:System.Text.Encoding>nie będzie można zachować stanu, więc znak zostanie wysłany do <xref:System.Text.EncoderFallback>.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A>ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania trzech znaków z tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />lub <paramref name="charCount" />jestmniejszaod zera.<paramref name="byteIndex" />  
  
—lub— 
 <paramref name="charIndex" />i <paramref name="charCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" />nie jest prawidłowym indeksem <paramref name="bytes" />w.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" />nie ma wystarczającej pojemności od <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków do kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów, która zawiera wyniki sekwencji bajtów.</param>
        <param name="byteIndex">Indeks, od którego ma zostać rozpoczęte zapisywanie wyniku sekwencji bajtów.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, koduje zestaw znaków z określonego ciągu w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów do <paramref name="bytes" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.Encoding.GetMaxByteCount%2A> metodę. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.Encoding.GetByteCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> do metody, która obsługuje wiele konwersji w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetByteCount%2A> wersje <xref:System.Text.Encoding.GetBytes%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać zakodowania wielu znaków wejściowych na stronie kodowej i przetworzyć znaki przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, biorąc pod uwagę stan, który jest utrwalony przez <xref:System.Text.Encoder> używany obiekt. (Na przykład sekwencja znaków obejmująca pary zastępcze może kończyć się dużym surogatem. <xref:System.Text.Encoder> Będzie pamiętać, że duży Surogat, aby można było łączyć się z małą częścią, na początku następującego wywołania. <xref:System.Text.Encoding>nie będzie można zachować stanu, więc znak zostanie wysłany do <xref:System.Text.EncoderFallback>.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciągu, należy użyć wersji <xref:System.Text.Encoding.GetBytes%2A>ciągu.  
  
-   Wersja buforu znaków Unicode programu <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami <xref:System.Text.Encoder> przy użyciu obiektu lub wstawianie do istniejących buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest wersja obsługująca tablice bajtowe.  
  
-   Rozważ użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetByteCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego kodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania ciągu lub zakresu w ciągu, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />lub <paramref name="charCount" />jestmniejszaod zera.<paramref name="byteIndex" />  
  
—lub— 
 <paramref name="charIndex" />i <paramref name="charCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" />nie jest prawidłowym indeksem <paramref name="bytes" />w.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" />nie ma wystarczającej pojemności od <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę znaków wytworzonych przez odkodowanie wszystkich bajtów w określonej tablicy bajtów.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> metody. Metoda <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxCharCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami.  
  
-   Jeśli aplikacja obsługuje dane wyjściowe ciągu, należy użyć <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje bajty do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów, zaczynając od określonego wskaźnika Byte.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.Encoding.GetChars%2A> jest wymagany do przechowywania wyników, należy <xref:System.Text.Encoding.GetCharCount%2A> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. Metoda <xref:System.Text.Encoding.GetCharCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxCharCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%2A> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami.  
  
-   Jeśli aplikacja obsługuje wyprowadzanie ciągów, zaleca się użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetChars%2A> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetCharCount%2A> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. Metoda <xref:System.Text.Encoding.GetCharCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxCharCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%2A> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami.  
  
-   Jeśli aplikacja obsługuje wyprowadzanie ciągów, zaleca się użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z jednego kodowania na inny.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje zakres bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje wszystkie bajty w określonej tablicy bajtów do zestawu znaków.</summary>
        <returns>Tablica znaków zawierająca wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Pobiera znaki z sekwencji bajtów wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>jest inna niż <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , <xref:System.Text.Encoding> ponieważ oczekuje konwersji dyskretnych, <xref:System.Text.Decoder> natomiast jest przeznaczona dla wielu przebiegów w pojedynczym strumieniu wejściowym.  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 **Uwaga** Ta metoda jest przeznaczona do działania na znaki Unicode, a nie w dowolnych danych binarnych, takich jak tablice bajtowe. Jeśli zachodzi potrzeba zakodowania dowolnych danych binarnych do tekstu, należy użyć protokołu takiego jak UUENCODE, który jest implementowany przez <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>metody takie jak.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%2A> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, ponieważ sekwencje bajtów mogą być przerywane podczas przetwarzania w partiach. (Na przykład część sekwencji ISO-2022 może zakończyć jedno <xref:System.Text.Encoding.GetChars%2A> wywołanie i kontynuować na początku następnego <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>spowoduje wywołanie powrotu dla tych niekompletnych sekwencji, <xref:System.Text.Decoder> ale zapamiętaje te sekwencje dla następnego wywołania.)  
  
-   Jeśli aplikacja obsługuje wyprowadzanie ciągów, zaleca się użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje bajty do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje sekwencję bajtów z określonej tablicy bajtów do zestawu znaków.</summary>
        <returns>Tablica znaków zawierająca wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Pobiera znaki z sekwencji bajtów wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>jest inna niż <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , <xref:System.Text.Encoding> ponieważ oczekuje konwersji dyskretnych, <xref:System.Text.Decoder> natomiast jest przeznaczona dla wielu przebiegów w pojedynczym strumieniu wejściowym.  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 **Uwaga** Ta metoda jest przeznaczona do działania na znaki Unicode, a nie w dowolnych danych binarnych, takich jak tablice bajtowe. Jeśli zachodzi potrzeba zakodowania dowolnych danych binarnych do tekstu, należy użyć protokołu takiego jak UUENCODE, który jest implementowany przez <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>metody takie jak.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%2A> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, ponieważ sekwencje bajtów mogą być przerywane podczas przetwarzania w partiach. (Na przykład część sekwencji ISO-2022 może zakończyć jedno <xref:System.Text.Encoding.GetChars%2A> wywołanie i kontynuować na początku następnego <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>spowoduje wywołanie powrotu dla tych niekompletnych sekwencji, <xref:System.Text.Decoder> ale zapamiętaje te sekwencje dla następnego wywołania.)  
  
-   Jeśli aplikacja obsługuje wyprowadzanie ciągów, zaleca się użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje zakres bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do zdekodowania.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której ma zostać rozpoczęte pisanie zestawu znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje sekwencję bajtów, zaczynając od określonego wskaźnika Byte do zestawu znaków, które są przechowywane, zaczynając od określonego wskaźnika znakowego.</summary>
        <returns>Rzeczywista liczba znaków zapisywana w lokalizacji wskazywanej przez <paramref name="chars" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.Encoding.GetChars%2A> jest wymagany do przechowywania wyników, należy <xref:System.Text.Encoding.GetCharCount%2A> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. Metoda <xref:System.Text.Encoding.GetCharCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxCharCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Pobiera znaki z sekwencji bajtów wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>jest inna niż <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , <xref:System.Text.Encoding> ponieważ oczekuje konwersji dyskretnych, <xref:System.Text.Decoder> natomiast jest przeznaczona dla wielu przebiegów w pojedynczym strumieniu wejściowym.  
  
 Jeśli dane do konwersji są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że trzeba ją podzielić na mniejsze bloki, należy użyć podanego obiektu <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> odpowiednio przez metodę <xref:System.Text.Encoding.GetDecoder%2A> lub <xref:System.Text.Encoding.GetEncoder%2A> klasy pochodnej.  
  
 **Uwaga** Ta metoda jest przeznaczona do działania na znaki Unicode, a nie w dowolnych danych binarnych, takich jak tablice bajtowe. Jeśli zachodzi potrzeba zakodowania dowolnych danych binarnych do tekstu, należy użyć protokołu takiego jak UUENCODE, który jest implementowany przez <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>metody takie jak.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%2A> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, ponieważ sekwencje bajtów mogą być przerywane podczas przetwarzania w partiach. (Na przykład część sekwencji ISO-2022 może zakończyć jedno <xref:System.Text.Encoding.GetChars%2A> wywołanie i kontynuować na początku następnego <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>spowoduje wywołanie powrotu dla tych niekompletnych sekwencji, <xref:System.Text.Decoder> ale zapamiętaje te sekwencje dla następnego wywołania.)  
  
-   Jeśli aplikacja obsługuje wyprowadzanie ciągów, <xref:System.Text.Encoding.GetString%2A> Metoda jest zalecana. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" />jest mniejsza niż liczba znaków będących wynikiem.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków, która będzie zawierać zestaw znaków.</param>
        <param name="charIndex">Indeks, od którego należy zacząć pisać zestaw znaków.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje sekwencję bajtów z określonej tablicy bajtów do określonej tablicy znaków.</summary>
        <returns>Rzeczywista liczba znaków do <paramref name="chars" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetChars%2A> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetCharCount%2A> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. Metoda <xref:System.Text.Encoding.GetCharCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxCharCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 2a? displayProperty = nameWithType > pobiera znaki z sekwencji bajtów wejściowych. [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 2a? displayProperty = nameWithType > różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> , <xref:System.Text.Encoding> ponieważ oczekuje konwersji dyskretnych, <xref:System.Text.Decoder> gdy jest zaprojektowana dla wiele przebiegów na pojedynczym strumieniu wejściowym.  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 **Uwaga** Ta metoda jest przeznaczona do działania na znaki Unicode, a nie w dowolnych danych binarnych, takich jak tablice bajtowe. Jeśli zachodzi potrzeba zakodowania dowolnych danych binarnych do tekstu, należy użyć protokołu takiego jak UUENCODE, który jest implementowany przez <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>metody takie jak.  
  
 Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.Encoding.GetChars%2A> a metoda wykonuje rzeczywiste dekodowanie. <xref:System.Text.Encoding.GetCharCount%2A> Metoda oczekuje konwersji dyskretnych, w przeciwieństwie <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> do metody, która obsługuje wiele przebiegów w pojedynczym strumieniu wejściowym. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>  
  
 Obsługiwane są różne <xref:System.Text.Encoding.GetCharCount%2A> wersje <xref:System.Text.Encoding.GetChars%2A> systemów i. Poniżej przedstawiono niektóre zagadnienia związane z programowaniem tych metod:  
  
-   Aplikacja może wymagać dekodowania wielu bajtów wejściowych ze strony kodowej i przetworzyć bajty przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba będzie zachować stan między wywołaniami, ponieważ sekwencje bajtów mogą być przerywane podczas przetwarzania w partiach. (Na przykład część sekwencji ISO-2022 Shift\]może kończyć jeden [, Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 2a > wywołanie i kontynuowanie na początku następnego [\], Int32, Int32, char\<linki XREF : System. Text. Encoding. GetChars% 2A > wywołanie. [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 2a? displayProperty = nameWithType > wywoła powrotu dla tych nieukończonych sekwencji, ale <xref:System.Text.Decoder> zapamiętaje te sekwencje dla następnego wywołania.)  
  
-   Jeśli aplikacja obsługuje wyprowadzanie ciągów, <xref:System.Text.Encoding.GetString%2A> Metoda jest zalecana. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić bufor, jest nieco wolniejsza, ale typ otrzymany <xref:System.String> jest preferowany.  
  
-   Wersja bajtowa programu <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia stosowanie niektórych szybkich technik, szczególnie z wieloma wywołaniami dużych buforów. Należy jednak pamiętać, że ta wersja metody jest czasami niebezpieczna, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja wymaga konwersji dużej ilości danych, należy ponownie użyć buforu wyjściowego. W takim przypadku [\], Int32, Int32, char\<linki XREF: System. Text. Encoding. GetChars% 28System. Byte% 5B% 5D% 2CSystem. Int32% 2CSystem. Int32% 2CSystem. Char% 5B% 5D% 2CSystem. Int32% 29 > wersja obsługująca znak wyjścia bufory są najlepszym wyborem.  
  
-   Rozważ użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody <xref:System.Text.Encoding.GetCharCount%2A>zamiast. Metoda konwersji umożliwia konwertowanie możliwie największej ilości danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. W przypadku ciągłego dekodowania strumienia ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z jednego kodowania na inny.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje zakres bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />lub <paramref name="byteCount" />jestmniejszaod zera.<paramref name="charIndex" />  
  
—lub— 
 <paramref name="byteindex" />i <paramref name="byteCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" />nie jest prawidłowym indeksem <paramref name="chars" />w.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" />nie ma wystarczającej pojemności od <paramref name="charIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, uzyskuje dekoder, który konwertuje zakodowaną sekwencję bajtów na sekwencję znaków.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> , który konwertuje zakodowaną sekwencję bajtów na sekwencję znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda konwertuje sekwencyjne bloki bajtów do sekwencyjnych bloków znaków w sposób podobny <xref:System.Text.Encoding.GetChars%2A> do metody tej klasy. <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> <xref:System.Text.Decoder> Jednak utrzymuje informacje o stanie między wywołaniami, aby poprawnie dekodować sekwencje bajtów, które obejmują bloki. Zachowuje <xref:System.Text.Decoder> również końcowe bajty na końcu bloków danych i używa końcowych bajtów w następnej operacji dekodowania. W związku z <xref:System.Text.Encoding.GetEncoder%2A> tym isąprzydatnewprzypadkuoperacjitransmisjiwsieciiplików,ponieważteoperacjeczęstozajmująsięblokamidanych,aniezpełnymstrumieniemdanych.<xref:System.Text.Encoding.GetDecoder%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja zwraca <see cref="T:System.Text.Decoder" /> metodę, która <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> wywołuje metody <see cref="T:System.Text.Encoding" />i <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> . Należy zastąpić tę metodę w celu zwrócenia <see cref="T:System.Text.Decoder" /> jej stanu między wywołaniami.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, uzyskuje koder, który konwertuje sekwencję znaków Unicode na zakodowaną sekwencję bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> , która konwertuje sekwencję znaków Unicode na zakodowaną sekwencję bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda konwertuje sekwencyjne bloki znaków na bloki sekwencyjne bajtów w sposób podobny <xref:System.Text.Encoding.GetBytes%2A> do metody tej klasy. <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> <xref:System.Text.Encoder> Jednak utrzymuje informacje o stanie między wywołaniami, aby poprawnie kodować sekwencje znaków, które obejmują bloki. Zachowuje <xref:System.Text.Encoder> również końcowe znaki na końcu bloków danych i używa znaków końcowych w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowanym surogatem, a zgodny z niską surogatem może znajdować się w następnym bloku danych. W związku z <xref:System.Text.Encoding.GetEncoder%2A> tym isąprzydatnewprzypadkuoperacjitransmisjiwsieciiplików,ponieważteoperacjeczęstozajmująsięblokamidanych,aniezpełnymstrumieniemdanych.<xref:System.Text.Encoding.GetDecoder%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja zwraca <see cref="T:System.Text.Encoder" /> metodę, która <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> wywołuje metody <see cref="T:System.Text.Encoding" />i <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> . Należy zastąpić tę metodę w celu zwrócenia <see cref="T:System.Text.Encoder" /> jej stanu między wywołaniami.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kodowanie dla określonej strony kodowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Identyfikator strony kodowej preferowanego kodowania. Możliwe wartości są wymienione w kolumnie Strona kodowa tabeli, która pojawia się w <see cref="T:System.Text.Encoding" /> temacie Class.  
  
—lub— 
0 (zero), aby użyć domyślnego kodowania.</param>
        <summary>Zwraca kodowanie skojarzone z określonym identyfikatorem strony kodowej.</summary>
        <returns>Kodowanie skojarzone z określoną stroną kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Procedura obsługi rezerwowej zależy od typu `codepage`kodowania. Jeśli `codepage` jest kodowaniem strony kodowej lub zestawu znaków dwubajtowych (DBCS), używana jest obsługa najlepiej pasującej rezerwy. W przeciwnym razie jest używana zastępcza procedura obsługi rezerwowej. Te programy obsługi powrotu mogą nie być odpowiednie dla Twojej aplikacji. Aby określić procedurę obsługi rezerwowej używaną przez kodowanie określone `codepage`przez, można <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> wywołać Przeciążenie.  
  
 W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> Metoda korzysta z podstawowej platformy do obsługi większości stron kodowych. Jednak .NET Framework natywnie obsługuje pewne kodowanie. Aby zapoznać się z listą stron kodowych <xref:System.Text.Encoding> , zapoznaj się z tematem klasy. W programie .NET Core <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca kodowania natywnie obsługiwane przez platformę .NET Core. W obu implementacjach platformy .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać <xref:System.Text.EncodingInfo> tablicę obiektów, które zawierają informacje o wszystkich dostępnych kodowaniach. 

 Oprócz kodowania, które są natywnie dostępne w programie .NET Core lub które są obsługiwane wewnętrznie w określonej wersji platformy .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca wszelkie dodatkowe kodowanie, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiekt. Jeśli takie samo kodowanie zostało zarejestrowane przez wiele <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatnio zarejestrowana.  

Dla `codepage` argumentu można także podać wartość 0. Dokładne zachowanie jest zależne od tego, czy dowolne kodowanie zostało udostępnione przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu:

- Jeśli co najmniej jeden dostawca kodowania został zarejestrowany, zwraca kodowanie ostatniego zarejestrowanego dostawcy, który zdecydował się zwrócić kodowanie, gdy <xref:System.Text.Encoding.GetEncoding%2A> Metoda jest przenoszona jako `codepage` argument 0.     

- Na .NET Framework, jeśli nie zarejestrowano dostawcy kodowania, jeśli <xref:System.Text.CodePagesEncodingProvider> jest to zarejestrowany dostawca kodowania lub jeśli żaden zarejestrowany dostawca kodowania nie `codepage` obsługuje wartości 0, zwraca aktywną stronę kodową systemu operacyjnego. Aby określić aktywną stronę kodową w systemach Windows, wywołaj funkcję [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) systemu windows z .NET Framework na pulpicie systemu Windows.

- W przypadku platformy .NET Core, jeśli żaden dostawca kodowania nie został zarejestrowany lub żaden zarejestrowany dostawca kodowania nie `codepage` obsługuje wartości 0, <xref:System.Text.UTF8Encoding>zwraca.
  
> [!NOTE]
>  Niektóre nieobsługiwane strony kodowe <xref:System.ArgumentException> powodują, że mogą być zgłaszane, a <xref:System.NotSupportedException>inne powodują. W związku z tym kod musi przechwycić wszystkie wyjątki wskazane w sekcji wyjątki.  
  
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i mogą ulec zmianie na pojedynczym komputerze, co prowadzi do uszkodzenia danych. Z tego powodu, jeśli aktywna strona kodowa jest stroną kodową ANSI, dane kodowania i dekodowania przy użyciu domyślnej strony kodowej zwróconej przez `Encoding.GetEncoding(0)` nie są zalecane. Aby uzyskać najbardziej spójne wyniki, należy użyć kodowania Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, zamiast konkretnej strony kodowej.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Aby uzyskać wystąpienie z różnymi ustawieniami, należy użyć konstruktorów klas pochodnych. Na przykład <xref:System.Text.UTF32Encoding> Klasa zawiera konstruktora, który umożliwia włączenie wykrywania błędów.  

   
  
## Examples  
 Poniższy przykład pobiera dwa wystąpienia tego samego kodowania (po jednym przez stronę kodową i inne według nazwy) i sprawdza ich równość.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" />jest mniejsza od zera lub większa niż 65535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" />nie jest obsługiwany przez platformę bazową.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" />nie jest obsługiwany przez platformę bazową.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa strony kodowej preferowanego kodowania. Każda wartość zwrócona przez <see cref="P:System.Text.Encoding.WebName" /> właściwość jest prawidłowa. Możliwe wartości są wymienione w kolumnie Nazwa tabeli, która pojawia się w <see cref="T:System.Text.Encoding" /> temacie klasy.</param>
        <summary>Zwraca kodowanie skojarzone z określoną nazwą strony kodowej.</summary>
        <returns>Kodowanie skojarzone z określoną stroną kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Procedura obsługi rezerwowej zależy od typu `name`kodowania. Jeśli `name` jest kodowaniem strony kodowej lub zestawu znaków dwubajtowych (DBCS), używana jest obsługa najlepiej pasującej rezerwy. W przeciwnym razie jest używana zastępcza procedura obsługi rezerwowej. Te programy obsługi powrotu mogą nie być odpowiednie dla Twojej aplikacji. Aby określić procedurę obsługi rezerwowej używaną przez kodowanie określone `name`przez, można <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> wywołać Przeciążenie.  

W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> Metoda korzysta z podstawowej platformy do obsługi większości stron kodowych. Jednak .NET Framework natywnie obsługuje pewne kodowanie. Aby zapoznać się z listą stron kodowych <xref:System.Text.Encoding> , zapoznaj się z tematem klasy. W programie .NET Core <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca kodowania natywnie obsługiwane przez platformę .NET Core. W obu implementacjach platformy .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać <xref:System.Text.EncodingInfo> tablicę obiektów, które zawierają informacje o wszystkich dostępnych kodowaniach. 

 Oprócz kodowania, które są natywnie dostępne w programie .NET Core lub które są obsługiwane wewnętrznie w określonej wersji platformy .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca wszelkie dodatkowe kodowanie, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiekt. Jeśli takie samo kodowanie zostało zarejestrowane przez wiele <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatnio zarejestrowana.  
   
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach lub mogą być zmieniane dla pojedynczego komputera, co prowadzi do uszkodzenia danych. Aby uzyskać najbardziej spójne wyniki, należy użyć Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, a nie konkretnej strony kodowej.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A>Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Aby uzyskać wystąpienie z różnymi ustawieniami, należy użyć konstruktorów klas pochodnych. Na przykład <xref:System.Text.UTF32Encoding> Klasa zawiera konstruktora, który umożliwia włączenie wykrywania błędów.  
  
## Examples  
 Poniższy przykład pobiera dwa wystąpienia tego samego kodowania (po jednym przez stronę kodową i inne według nazwy) i sprawdza ich równość.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />nie jest prawidłową nazwą strony kodowej.  
  
—lub— 
Strona kodowa wskazywana <paramref name="name" /> przez nie jest obsługiwana przez bazową platformę.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Identyfikator strony kodowej preferowanego kodowania. Możliwe wartości są wymienione w kolumnie Strona kodowa tabeli, która pojawia się w <see cref="T:System.Text.Encoding" /> temacie Class.  
  
—lub— 
0 (zero), aby użyć domyślnego kodowania.</param>
        <param name="encoderFallback">Obiekt, który dostarcza procedurę obsługi błędów, gdy nie można zakodować znaku przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który dostarcza procedurę obsługi błędów, gdy nie można zdekodować sekwencji bajtów z bieżącym kodowaniem.</param>
        <summary>Zwraca kodowanie skojarzone z określonym identyfikatorem strony kodowej. Parametry określają procedurę obsługi błędów dla znaków, które nie mogą być zakodowane i sekwencje bajtów, których nie można zdekodować.</summary>
        <returns>Kodowanie skojarzone z określoną stroną kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Niektóre nieobsługiwane strony kodowe powodują <xref:System.ArgumentException> zgłoszenie wyjątku, podczas gdy inne powodują <xref:System.NotSupportedException>. W związku z tym kod musi przechwycić wszystkie wyjątki wskazane w sekcji wyjątki.  

W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> Metoda korzysta z podstawowej platformy do obsługi większości stron kodowych. Jednak .NET Framework natywnie obsługuje pewne kodowanie. Aby zapoznać się z listą stron kodowych <xref:System.Text.Encoding> , zapoznaj się z tematem klasy. W programie .NET Core <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca kodowania natywnie obsługiwane przez platformę .NET Core. W obu implementacjach platformy .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać <xref:System.Text.EncodingInfo> tablicę obiektów, które zawierają informacje o wszystkich dostępnych kodowaniach. 

 Oprócz kodowania, które są natywnie dostępne w programie .NET Core lub które są obsługiwane wewnętrznie w określonej wersji platformy .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca wszelkie dodatkowe kodowanie, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiekt. Jeśli takie samo kodowanie zostało zarejestrowane przez wiele <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatnio zarejestrowana.  

Dla `codepage` argumentu można także podać wartość 0. Dokładne zachowanie jest zależne od tego, czy dowolne kodowanie zostało udostępnione przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu:

- Jeśli co najmniej jeden dostawca kodowania został zarejestrowany, zwraca kodowanie ostatniego zarejestrowanego dostawcy, który zdecydował się zwrócić kodowanie, gdy <xref:System.Text.Encoding.GetEncoding%2A> Metoda jest przenoszona jako `codepage` argument 0.     

- Na .NET Framework, jeśli nie zarejestrowano dostawcy kodowania, jeśli <xref:System.Text.CodePagesEncodingProvider> jest to zarejestrowany dostawca kodowania lub jeśli żaden zarejestrowany dostawca kodowania nie `codepage` obsługuje wartości 0, zwraca aktywną stronę kodową.

- W przypadku platformy .NET Core, jeśli żaden dostawca kodowania nie został zarejestrowany lub żaden zarejestrowany dostawca kodowania nie `codepage` obsługuje wartości 0, <xref:System.Text.UTF8Encoding> zwraca kodowanie.

> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i mogą ulec zmianie na pojedynczym komputerze, co prowadzi do uszkodzenia danych. Z tego powodu, jeśli aktywna strona kodowa jest stroną kodową ANSI, dane kodowania i dekodowania przy użyciu domyślnej strony kodowej zwróconej przez `Encoding.GetEncoding(0)` nie są zalecane. Aby uzyskać najbardziej spójne wyniki, należy użyć Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, a nie konkretnej strony kodowej. 
  
 Aby uzyskać kodowanie skojarzone z aktywną stroną kodową, można podać wartość 0 dla `codepage` argumentu lub, jeśli kod jest uruchomiony na .NET Framework na pulpicie systemu Windows, pobrać wartość <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> właściwości. Aby określić bieżącą aktywną stronę kodową, wywołaj funkcję [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) systemu windows z .NET Framework na pulpicie systemu Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Aby uzyskać wystąpienie z różnymi ustawieniami, należy użyć konstruktorów klas pochodnych. Na przykład <xref:System.Text.UTF32Encoding> Klasa zawiera konstruktora, który umożliwia włączenie wykrywania błędów.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> metodę.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" />jest mniejsza od zera lub większa niż 65535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" />nie jest obsługiwany przez platformę bazową.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" />nie jest obsługiwany przez platformę bazową.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa strony kodowej preferowanego kodowania. Każda wartość zwrócona przez <see cref="P:System.Text.Encoding.WebName" /> właściwość jest prawidłowa. Możliwe wartości są wymienione w kolumnie Nazwa tabeli, która pojawia się w <see cref="T:System.Text.Encoding" /> temacie klasy.</param>
        <param name="encoderFallback">Obiekt, który dostarcza procedurę obsługi błędów, gdy nie można zakodować znaku przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który dostarcza procedurę obsługi błędów, gdy nie można zdekodować sekwencji bajtów z bieżącym kodowaniem.</param>
        <summary>Zwraca kodowanie skojarzone z określoną nazwą strony kodowej. Parametry określają procedurę obsługi błędów dla znaków, które nie mogą być zakodowane i sekwencje bajtów, których nie można zdekodować.</summary>
        <returns>Kodowanie skojarzone z określoną stroną kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> Metoda korzysta z podstawowej platformy do obsługi większości stron kodowych. Jednak .NET Framework natywnie obsługuje pewne kodowanie. Aby zapoznać się z listą stron kodowych <xref:System.Text.Encoding> , zapoznaj się z tematem klasy. W programie .NET Core <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca kodowania natywnie obsługiwane przez platformę .NET Core. W obu implementacjach platformy .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać <xref:System.Text.EncodingInfo> tablicę obiektów, które zawierają informacje o wszystkich dostępnych kodowaniach. 

 Oprócz kodowania, które są natywnie dostępne w programie .NET Core lub które są obsługiwane wewnętrznie w określonej wersji platformy .NET Framework, <xref:System.Text.Encoding.GetEncoding%2A> Metoda zwraca wszelkie dodatkowe kodowanie, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiekt. Jeśli takie samo kodowanie zostało zarejestrowane przez wiele <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatnio zarejestrowana.  
  
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i mogą ulec zmianie na pojedynczym komputerze, co prowadzi do uszkodzenia danych. Aby uzyskać najbardziej spójne wyniki, należy użyć kodowania Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, zamiast konkretnej strony kodowej.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Aby uzyskać wystąpienie z różnymi ustawieniami, należy użyć konstruktorów klas pochodnych. Na przykład <xref:System.Text.UTF32Encoding> Klasa zawiera konstruktora, który umożliwia włączenie wykrywania błędów.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> metodę.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" />nie jest prawidłową nazwą strony kodowej.  
  
—lub— 
Strona kodowa wskazywana <paramref name="name" /> przez nie jest obsługiwana przez bazową platformę.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę zawierającą wszystkie kodowanie.</summary>
        <returns>Tablica, która zawiera wszystkie kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca listę obsługiwanych kodowań, jednoznacznie wyróżniających przez stronę kodową. Aby zapoznać się z tabelą zawierającą obsługiwane kodowanie, zapoznaj się z <xref:System.Text.Encoding> tematem klasy.  
  
> [!NOTE]
>  Lista obsługiwanych kodowań zwracanych przez <xref:System.Text.Encoding.GetEncodings%2A> metodę nie obejmuje żadnych dodatkowych kodowań, które są dostępne <xref:System.Text.EncodingProvider> w ramach implementacji <xref:System.Text.Encoding.RegisterProvider%2A> zarejestrowanej przez wywołania metody.  
  
 Na .NET Framework kodowania 50220 i 50222 są skojarzone z nazwą "ISO-2022-JP", ale nie są identyczne. Kodowanie 50220 konwertuje znaki katakana połówkowej szerokości na znaki katakana o pełnej szerokości, podczas gdy kodowanie 50222 używa sekwencji Shift-in/Shift w celu zakodowania znaków katakana o połówkowej szerokości. Nazwa wyświetlana kodowania 50222 to "japoński (JIS-Allow 1 bajt kana-SO/SI)", aby odróżnić go od kodowania 50220, który ma nazwę wyświetlaną "japoński (JIS)".  
  
 Jeśli zażądasz nazwy kodowania "ISO-2022-JP", .NET Framework zwraca Kodowanie 50220. Jednak kodowanie odpowiednie dla aplikacji zależy od preferowanego traktowania znaków katakana połówkowej szerokości.  
  
 Aby uzyskać określone kodowanie, należy użyć <xref:System.Text.Encoding.GetEncoding%2A> metody.  
  
 <xref:System.Text.Encoding.GetEncodings%2A>jest czasami używany do prezentowania użytkownikowi listy kodowań w oknie dialogowym **Zapisz jako** . Jednak wiele kodowań niezgodnych ze standardem Unicode jest niekompletnych i tłumaczy wiele znaków na "?" lub ma nieco inne zachowanie na różnych platformach. Rozważ użycie UTF-8 lub UTF-16 jako domyślnej.  
  
   
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logicznych każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego wystąpienia.</summary>
        <returns>Kod skrótu dla bieżącego wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza maksymalną liczbę bajtów wyprodukowanych przez zakodowanie określonej liczby znaków.</summary>
        <returns>Maksymalna liczba bajtów wygenerowanych przez kodowanie określonej liczby znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr `charCount` w rzeczywistości określa <xref:System.Char> liczbę obiektów, które reprezentują znaki Unicode do kodowania, ponieważ platforma .NET wewnętrznie używa kodowania UTF-16 do reprezentowania znaków Unicode. W związku z tym większość znaków Unicode może być reprezentowana przez <xref:System.Char> jeden obiekt, ale znak Unicode reprezentowany przez parę zastępczą, na przykład wymaga dwóch <xref:System.Char> obiektów.  
  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetByteCount%2A> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, użyj <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. Metoda <xref:System.Text.Encoding.GetByteCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxByteCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A>Pobiera najgorszą liczbę przypadków, w tym najgorszy przypadek dla aktualnie wybranego <xref:System.Text.EncoderFallback>elementu. W przypadku wybrania rezerwy z potencjalnie dużym ciągiem <xref:System.Text.Encoding.GetMaxByteCount%2A> pobiera duże wartości, szczególnie w przypadkach, gdy najgorszy przypadek kodowania obejmuje przełączanie trybów dla każdego znaku. Na przykład może się to zdarzyć w przypadku ISO-2022-JP. Aby uzyskać więcej informacji, zobacz wpis w blogu "[co to jest funkcja Encoding. GetMaxByteCount () i Encoding. GetMaxCharCount ()?".](https://go.microsoft.com/fwlink/?LinkId=153702) (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 W większości przypadków ta metoda pobiera rozsądne wartości dla małych ciągów. W przypadku dużych ciągów może zajść potrzeba wyboru między użyciem bardzo dużych buforów i przechwycenia błędów w rzadkich przypadkach, gdy bardziej rozsądny bufor jest zbyt mały. Warto również rozważyć inne podejście przy użyciu <xref:System.Text.Encoding.GetByteCount%2A> lub. <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>  
  
 W przypadku <xref:System.Text.Encoding.GetMaxByteCount%2A>korzystania z programu należy przydzielić bufor wyjściowy na podstawie maksymalnego rozmiaru buforu wejściowego. Jeśli bufor wyjściowy ma ograniczone rozmiary, można użyć <xref:System.Text.Encoding.Convert%2A> metody.  
  
 Należy pamiętać <xref:System.Text.Encoding.GetMaxByteCount%2A> , że traktuje potencjalne częściowe reszty z poprzedniej operacji dekodera. Ze względu na dekoder przekazywanie wartości 1 do metody pobiera 2 w przypadku kodowania jednobajtowego, takiego jak ASCII. Jeśli te informacje są <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> niezbędne, należy użyć właściwości.  
  
> [!NOTE]
>  `GetMaxByteCount(N)`nie musi być taka sama jak `N* GetMaxByteCount(1)`wartość.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Wszystkie <see cref="T:System.Text.Encoding" /> implementacje muszą zagwarantować, że nie występują wyjątki przepełnienia buforu, jeśli rozmiary buforów są zgodne z wynikami obliczeń tej metody.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, oblicza maksymalną liczbę znaków wyprodukowanych przez dekodowanie określonej liczby bajtów.</summary>
        <returns>Maksymalna liczba znaków wytworzonych przez odkodowanie określonej liczby bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.Encoding.GetChars%2A> program do przechowywania wyników, należy <xref:System.Text.Encoding.GetCharCount%2A> użyć metody. Aby obliczyć maksymalny rozmiar tablicy, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. Metoda <xref:System.Text.Encoding.GetCharCount%2A> ogólnie zezwala na przydzielanie mniejszej ilości pamięci, <xref:System.Text.Encoding.GetMaxCharCount%2A> podczas gdy metoda zazwyczaj wykonuje się szybciej.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>Pobiera najgorszą liczbę przypadków, w tym najgorszy przypadek dla aktualnie wybranego <xref:System.Text.DecoderFallback>elementu. W przypadku wybrania rezerwy z potencjalnie dużym ciągiem <xref:System.Text.Encoding.GetMaxCharCount%2A> pobiera duże wartości.  
  
 W większości przypadków ta metoda pobiera rozsądne liczby dla małych ciągów. W przypadku dużych ciągów może zajść potrzeba wyboru między użyciem bardzo dużych buforów i przechwycenia błędów w rzadkich przypadkach, gdy bardziej rozsądny bufor jest zbyt mały. Warto również rozważyć inne podejście przy użyciu <xref:System.Text.Encoding.GetCharCount%2A> lub. <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>nie ma relacji do <xref:System.Text.Encoding.GetBytes%2A>. Jeśli potrzebna jest podobna funkcja do używania z programem <xref:System.Text.Encoding.GetBytes%2A>, należy użyć. <xref:System.Text.Encoding.GetMaxByteCount%2A>  
  
 W przypadku <xref:System.Text.Encoding.GetMaxCharCount%2A>korzystania z programu należy przydzielić bufor wyjściowy na podstawie maksymalnego rozmiaru buforu wejściowego. Jeśli bufor wyjściowy ma ograniczone rozmiary, można użyć <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody.  
  
 Należy zauważyć <xref:System.Text.Encoding.GetMaxCharCount%2A> , że w przypadku pozostałej wielkości w przypadku pozostałej liczby bajtów z poprzedniej operacji kodera zostanie W przypadku większości stron kodowych przekazywanie wartości 0 do tej metody powoduje pobranie wartości większych lub równych 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)`nie musi być taka sama jak `N* GetMaxCharCount(1)`wartość.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje bajty do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Wszystkie <see cref="T:System.Text.Encoding" /> implementacje muszą zagwarantować, że nie występują wyjątki przepełnienia buforu, jeśli rozmiary buforów są zgodne z wynikami obliczeń tej metody.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, zwraca sekwencję bajtów, która określa używane kodowanie.</summary>
        <returns>Tablica bajtowa zawierająca sekwencję bajtów, która określa używane kodowanie.  
  
 —lub—  
  
 Tablica bajtowa o długości zero, jeśli preambuła nie jest wymagana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding> Opcjonalnie obiekt zawiera preambułę, która jest tablicą bajtów, które mogą być poprzedzone sekwencją bajtów w wyniku procesu kodowania. Jeśli Preambuła zawiera znacznik kolejności bajtów (w standardzie Unicode, punkt kodowy U + FEFF), pomaga dekoderowi określić kolejność bajtów i format transformacji lub UTF.  
  
 Znacznik kolejności bajtów (BOM) Unicode jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   UTF-8: EF BBBINDING  
  
-   Kolejność bajtów w formacie UTF-16 big endian: FE FF  
  
-   Kolejność bajtów w formacie UTF-16 little endian: FRF FE  
  
-   Kolejność bajtów w formacie UTF-32 big endian: 00 00 FE FF  
  
-   Kolejność bajtów w formacie UTF-32 little endian: FF FE 00 00  
  
 Należy używać BOM, ponieważ zapewnia niemal pewnej identyfikacji kodowania dla plików, które w przeciwnym razie utraciły odwołanie do <xref:System.Text.Encoding> obiektu, na przykład nieoznakowane lub niewłaściwie oznakowane dane sieci Web lub losowe pliki tekstowe przechowywane, gdy firma nie mają międzynarodowe problemy lub inne dane. Często można uniknąć problemów z użytkownikami, jeśli dane są spójne i właściwie oznakowane, najlepiej w UTF-8 lub UTF-16.  
  
 W przypadku standardów, które zapewniają typ kodowania, BOM jest nieco nadmiarowy. Można go jednak użyć, aby ułatwić serwerowi wysyłanie poprawnego nagłówka kodowania. Alternatywnie, może być używany jako rezerwa w przypadku, gdy kodowanie jest tracone.  
  
 Istnieją pewne wady dotyczące korzystania z BOM. Na przykład poznanie sposobu ograniczania pól bazy danych, które używają BOM, może być trudne. Łączenie plików może być również problemem, na przykład podczas scalania plików w taki sposób, że niezbędny znak może kończyć się w danych. Pomimo tego, że użycie BOM jest zdecydowanie zalecane.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, zobacz Standard Unicode na [stronie głównej Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, należy prefiksować zakodowane bajty z preambuły. Jednak większość kodowań nie udostępnia preambuły. Aby upewnić się, że zakodowane bajty są poprawnie zdekodowane, należy użyć kodowania Unicode, czyli <xref:System.Text.UTF8Encoding> <xref:System.Text.UnicodeEncoding>,, lub <xref:System.Text.UTF32Encoding>, z preambuły.  
  
   
  
## Examples  
 Poniższy przykład określa kolejność bajtów kodowania na podstawie preambuły.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje sekwencję bajtów do ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje wszystkie bajty w określonej tablicy bajtów do ciągu.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi być podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć obiektu zwróconego <xref:System.Text.Encoding.GetDecoder%2A> przez metodę elementu Deri Ved — Klasa.  
  
 Zapoznaj się z sekcją <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> uwagi tematu referencyjnego, aby zapoznać się z omówieniem technik dekodowania i zagadnieniami.  
  
 Należy zauważyć, że precyzyjne zachowanie <xref:System.Text.Encoding.GetString%2A> metody dla określonej <xref:System.Text.Encoding> implementacji zależy od strategii rezerwowej zdefiniowanej dla tego <xref:System.Text.Encoding> obiektu. Aby uzyskać więcej informacji, zobacz sekcję "Wybieranie strategii awaryjnej" [kodowania znaków w temacie .NET](~/docs/standard/base-types/character-encoding.md) .  
  
   
  
## Examples  
 Poniższy przykład odczytuje zakodowany ciąg UTF-8 z pliku binarnego reprezentowanego przez <xref:System.IO.FileStream> obiekt. W przypadku plików mniejszych niż 2 048 bajtów odczytuje zawartość całego pliku do tablicy bajtów i wywołuje <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> metodę, aby wykonać dekodowanie. W przypadku większych plików odczytuje 2 048 bajtów jednocześnie do tablicy bajtów, wywołuje <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu określenia liczby znaków znajdujących się w tablicy, a następnie <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> wywołuje metodę w celu wykonania dekodowania.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 W przykładzie używany jest następujący tekst, który powinien zostać zapisany w pliku zakodowanym w formacie UTF-8 o nazwie Utf8Example. txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica bajtów zawiera nieprawidłowe punkty kodowe Unicode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do tablicy typu Byte.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje określoną liczbę bajtów, zaczynając od określonego adresu do ciągu.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> Metoda została zaprojektowana w celu optymalizacji wydajności, gdy istnieje natywny wskaźnik do tablicy bajtów. Zamiast tworzyć tablicę bajtów zarządzanych, a następnie dekodowanie jej, można wywołać tę metodę bez konieczności tworzenia obiektów pośrednich.  
  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi być podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć obiektu zwróconego <xref:System.Text.Encoding.GetDecoder%2A> przez metodę elementu Deri Ved — Klasa.  
  
 Zapoznaj się z sekcją <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> uwagi tematu referencyjnego, aby zapoznać się z omówieniem technik dekodowania i zagadnieniami.  
  
 Należy zauważyć, że precyzyjne zachowanie <xref:System.Text.Encoding.GetString%2A> metody dla określonej <xref:System.Text.Encoding> implementacji zależy od strategii rezerwowej zdefiniowanej dla tego <xref:System.Text.Encoding> obiektu. Aby uzyskać więcej informacji, zobacz sekcję "Wybieranie strategii awaryjnej" [kodowania znaków w temacie .NET](~/docs/standard/base-types/character-encoding.md) .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest wskaźnikiem o wartości null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, dekoduje sekwencję bajtów z określonej tablicy bajtów do ciągu.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które mają być konwertowane, są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że musi zostać podzielona na mniejsze bloki, należy <xref:System.Text.Decoder> użyć <xref:System.Text.Encoder> lub dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> Metoda, odpowiednio, klasy pochodnej.  
  
 Zapoznaj się z sekcją <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> uwagi tematu referencyjnego, aby zapoznać się z omówieniem technik dekodowania i zagadnieniami.  
  
   
  
## Examples  
 Poniższy przykład odczytuje zakodowany ciąg UTF-8 z pliku binarnego reprezentowanego przez <xref:System.IO.FileStream> obiekt. W przypadku plików mniejszych niż 2 048 bajtów odczytuje zawartość całego pliku do tablicy bajtów i wywołuje <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę, aby wykonać dekodowanie. W przypadku większych plików odczytuje 2 048 bajtów jednocześnie do tablicy bajtów, wywołuje <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu określenia liczby znaków znajdujących się w tablicy, a następnie <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> wywołuje metodę w celu wykonania dekodowania.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 W przykładzie używany jest następujący tekst, który powinien zostać zapisany w pliku zakodowanym w formacie UTF-8 o nazwie Utf8Example. txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica bajtów zawiera nieprawidłowe punkty kodowe Unicode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md) , aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera nazwę bieżącego kodowania, który może być używany z tagami nagłówka agenta poczty.</summary>
        <value>Nazwa bieżącego <see cref="T:System.Text.Encoding" /> do użycia z tagami nagłówka agenta poczty e-mail.  
  
—lub— 
Pusty ciąg (""), jeśli nie można użyć <see cref="T:System.Text.Encoding" /> bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli potrzebujesz kodowania nazwy nagłówka, należy wywołać <xref:System.Text.Encoding.GetEncoding%2A> metodę <xref:System.Text.Encoding.HeaderName%2A> z właściwością. Często Metoda pobiera inne kodowanie z kodowania testowego dostarczonego w wywołaniu. Ogólnie tylko aplikacje poczty e-mail muszą pobierać takie kodowanie.  
  
 W niektórych przypadkach wartość <xref:System.Text.Encoding.BodyName%2A> właściwości odnosi się do normy międzynarodowej, która definiuje to kodowanie. Nie oznacza to, że implementacja jest zgodna z tym standardem.  
  
 Zwróć uwagę <xref:System.Text.Encoding.WebName%2A> , że zwraca nazwę, która ma być używana do opisywania kodowania. <xref:System.Text.Encoding.HeaderName%2A> Właściwość definiuje inne kodowanie, które może być lepszym rozwiązaniem dla aplikacji poczty e-mail, na przykład. Nie zaleca się jednak używania właściwości w celu zdefiniowania kodowania.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z co najmniej jedną nazwą, która różni się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Jest on <xref:System.Text.Encoding.EncodingName%2A> wyświetlany, ale nie jest porównywany z nim.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące kodowanie jest zawsze znormalizowane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżące kodowanie jest zawsze znormalizowane, przy użyciu domyślnego formularza normalizacji.</summary>
        <returns><see langword="true" />Jeśli bieżąca <see cref="T:System.Text.Encoding" /> jest zawsze znormalizowana; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślną formą normalizacji jest <xref:System.Text.NormalizationForm.FormC>, która używa pełnej dekompozycji kanonicznej, a następnie zastąpienia sekwencji przy użyciu ich podstawowych elementów złożonych, jeśli jest to możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form">Jedna z <see cref="T:System.Text.NormalizationForm" /> wartości.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie jest zawsze znormalizowane, przy użyciu podanego formularza normalizacji.</summary>
        <returns><see langword="true" />Jeśli bieżący <see cref="T:System.Text.Encoding" /> obiekt jest zawsze znormalizowany przy użyciu określonej <see cref="T:System.Text.NormalizationForm" /> wartości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślną formą normalizacji jest <xref:System.Text.NormalizationForm.FormC>, która używa pełnej dekompozycji kanonicznej, a następnie zastąpienia sekwencji przy użyciu ich podstawowych elementów złożonych, jeśli jest to możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie może być używane przez klientów przeglądarki do wyświetlania zawartości.</summary>
        <value><see langword="true" />Jeśli bieżące <see cref="T:System.Text.Encoding" /> może być używane przez klientów przeglądarki do wyświetlania zawartości; w przeciwnym razie <see langword="false" />,.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logicznych każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie może być używane przez klientów przeglądarki do zapisywania zawartości.</summary>
        <value><see langword="true" />Jeśli bieżące <see cref="T:System.Text.Encoding" /> może być używane przez klientów przeglądarki do zapisywania zawartości; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logicznych każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie może być używane przez klientów poczty e-mail i wiadomości do wyświetlania zawartości.</summary>
        <value><see langword="true" />Jeśli bieżące <see cref="T:System.Text.Encoding" /> może być używane przez klientów poczty e-mail i wiadomości do wyświetlania zawartości; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logicznych każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie może być używane przez klientów poczty e-mail i wiadomości do zapisywania zawartości.</summary>
        <value><see langword="true" />Jeśli bieżące <see cref="T:System.Text.Encoding" /> może być używane przez klientów poczty e-mail i wiadomości do zapisywania zawartości; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logicznych każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie jest tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli bieżący <see cref="T:System.Text.Encoding" /> element jest tylko do odczytu; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera wartość wskazującą, czy bieżące kodowanie używa jednobajtowych punktów kodowych.</summary>
        <value><see langword="true" />Jeśli bieżąca <see cref="T:System.Text.Encoding" /> używa jednobajtowych punktów kodowych; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na przykład <xref:System.Text.ASCIIEncoding>dla kodowania jednobajtowego, ta właściwość pobiera `true`.  
  
> [!CAUTION]
>  Należy zachować ostrożność w przypadku aplikacji z wartością <xref:System.Text.Encoding.IsSingleByte%2A>. Założenie, w jaki sposób kodowanie będzie kontynuowało, może być nadal błędne. Na przykład system Windows-1252 ma wartość `true` dla <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, ale Encoding. GetMaxByteCount (1) zwraca 2. Wynika to z faktu, że metoda traktuje potencjalną resztę surogatów z poprzedniej operacji dekodera.  
  
   
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logicznych każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Podklasa <see cref="T:System.Text.EncodingProvider" /> , która zapewnia dostęp do dodatkowych kodowań znaków.</param>
        <summary>Rejestruje dostawcę kodowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zarejestrowanie klasy pochodzącej od <xref:System.Text.EncodingProvider> , co sprawia, że kodowanie znaków jest dostępne na platformie, która nie obsługuje ich w inny sposób. <xref:System.Text.Encoding.RegisterProvider%2A> Po zarejestrowaniu dostawcy kodowania można pobrać obsługiwane przez siebie kodowanie, wywołując dowolne <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> przeciążenia. Jeśli istnieje wielu dostawców kodowania, <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> Metoda próbuje pobrać określone kodowanie z każdego dostawcy, rozpoczynając od ostatniego zarejestrowanego.

Zarejestrowanie dostawcy kodowania przy użyciu <xref:System.Text.Encoding.RegisterProvider%2A> metody również modyfikuje zachowanie metody [Encoding. GetEncoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) i [EncodingProvider. GetEncoding (Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) , gdy przeszedł `0`argument:

- W przypadku zarejestrowanego dostawcy <xref:System.Text.CodePagesEncodingProvider>Metoda zwraca kodowanie zgodne ze stroną aktywnego kodu systemowego w przypadku uruchamiania w systemie operacyjnym Windows.

- Niestandardowy dostawca kodowania może wybrać kodowanie, które ma zostać zwrócone, gdy jedno <xref:System.Text.Encoding.GetEncoding%2A> z tych przeciążeń metod przeszedł do `0`argumentu. Dostawca może również zrezygnować z kodowania, <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> zwracając `null`metodę. 
  
Począwszy od .NET Framework 4,6, .NET Framework obejmuje jednego dostawcę kodowania, <xref:System.Text.CodePagesEncodingProvider>który sprawia, że dostępne są kodowania, które znajdują się w pełnym .NET Framework ale nie są dostępne w platforma uniwersalna systemu Windows. Domyślnie platforma uniwersalna systemu Windows obsługuje tylko kodowania Unicode, ASCII i stronę kodową 28591.  
  
 Jeśli ten sam dostawca kodowania jest używany w wielu wywołaniach <xref:System.Text.Encoding.RegisterProvider%2A> metody, tylko pierwsze wywołanie metody rejestruje dostawcę. Kolejne wywołania są ignorowane.  
  
 <xref:System.Text.Encoding.RegisterProvider%2A> Jeśli metoda jest wywoływana w celu zarejestrowania wielu dostawców obsługujących to samo kodowanie, Ostatni zarejestrowany dostawca jest używany dla wszystkich operacji kodowania i dekodowania. Wszyscy wcześniej zarejestrowani dostawcy są pomijani.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-16 przy użyciu kolejności bajtów little endian.</summary>
        <value>Kodowanie w formacie UTF-16 przy użyciu kolejności bajtów little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje na temat kodowania obsługiwanych przez platformę .NET i omówienie tego, które kodowanie Unicode ma być używane, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Obiekt, który jest zwracany przez tę właściwość, może nie mieć odpowiednich zachowań dla aplikacji. Używa powrotu zamiennej, aby zastąpić każdy ciąg, którego nie można kodować, i każdego bajtu, którego nie można zdekodować ze znakiem zapytania ("?"). Zamiast tego można <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> wywołać konstruktora, aby utworzyć wystąpienie obiektu Little Endian <xref:System.Text.UnicodeEncoding> , <xref:System.Text.EncoderFallbackException> którego rezerwa jest albo a <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-32 przy użyciu kolejności bajtów little endian.</summary>
        <value>Obiekt kodowania dla formatu UTF-32 przy użyciu kolejności bajtów little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Obiekt, który jest zwracany przez tę właściwość, może nie mieć odpowiednich zachowań dla aplikacji. Używa powrotu zamiennej, aby zastąpić każdy ciąg, którego nie można kodować, i każdego bajtu, którego nie można zdekodować przy użyciu znaku ZASTĘPCZego Unicode (U + FFFE). <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Zamiast tego można wywołać konstruktora, aby <xref:System.Text.UTF32Encoding> utworzyć wystąpienie obiektu, <xref:System.Text.EncoderFallbackException> którego rezerwa jest albo a <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Omówienie kolejności little endian bajtów można znaleźć w <xref:System.Text.Encoding> temacie dotyczącym klas.  
  
 Aby uzyskać informacje na temat kodowania obsługiwanych przez platformę .NET i omówienie tego, które kodowanie Unicode ma być używane, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-7.</summary>
        <value>Kodowanie formatu UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie UTF-7 jest używane głównie w środowiskach, których historycznie ograniczono do 7 bitów, takich jak NNTP i niektóre aplikacje poczty e-mail. Ze względu na problemy z niezawodnością i zabezpieczeniami nie należy używać kodowania UTF7 w środowiskach 8-bitowych, w których można użyć kodowania UTF-8.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania tablicy znaków, koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-8.</summary>
        <value>Kodowanie w formacie UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Text.UTF8Encoding> obiekt, który koduje znaki Unicode (kodowane w formacie UTF-16) do sekwencji od 1 do 4 bajtów na znak, i dekoduje tablicę bajtową zakodowaną w formacie UTF-8 na znaki Unicode (zakodowane w formacie UTF-16). Aby uzyskać informacje na temat kodowania znaków obsługiwanych przez platformę .NET i omówienie kodowania Unicode do użycia, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF8Encoding> Obiekt, który jest zwracany przez tę właściwość, może nie mieć odpowiednich zachowań dla aplikacji.  
  
-   Zwraca <xref:System.Text.UTF8Encoding> obiekt, który dostarcza znak kolejności bajtów Unicode (BOM). Aby utworzyć wystąpienie kodowania UTF8, które nie zapewnia BOM, wywołaj dowolne Przeciążenie <xref:System.Text.UTF8Encoding.%23ctor%2A> konstruktora.  
  
-   Zwraca <xref:System.Text.UTF8Encoding> obiekt, który używa zamiany zastępczej, aby zastąpić każdy ciąg, którego nie może kodować, i każdego bajtu, którego nie można zdekodować ze znakiem zapytania ("?"). <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Zamiast tego można wywołać konstruktora, aby <xref:System.Text.UTF8Encoding> utworzyć wystąpienie obiektu, <xref:System.Text.EncoderFallbackException> którego rezerwa jest albo a <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę, która składa się z następujących znaków:  
  
-   MAŁA LITERA Z (U + 007A)  
  
-   MAŁA LITERA A (U + 0061)  
  
-   ŁĄCZENIE CAPPUCCINO (U + 0306)  
  
-   MAŁA LITERA AE Z AKCENTEM OSTRYM (U + 01FD)  
  
-   MAŁA GRECKA LITERA BETA (U + 03B2)  
  
-   Para zastępcza (U + D800 U + DD54), która stanowi GRECKIe Stany ACROPHONIC ATTIC 1000 (U + 10154).  
  
 Wyświetla jednostki kodu UTF-16 każdego znaku i określa liczbę bajtów wymaganych przez koder UTF-8 do kodowania tablicy znaków. Następnie koduje znaki i wyświetla wyniki w bajtach zakodowanych w formacie UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera nazwę zarejestrowanej przez organizację IANA (Internet Assigned Numbers Authority) dla bieżącego kodowania.</summary>
        <value>Nazwa organizacji IANA dla bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest taka sama <xref:System.Text.EncodingInfo.Name%2A> jak właściwość. <xref:System.Text.Encoding.WebName%2A>  
  
 Zwróć uwagę <xref:System.Text.Encoding.WebName%2A> , że funkcja zwraca nazwę zarejestrowanego przez organizację IANA dla kodowania. Gdy wartość jest nazwą Standard, implementacja kodowania może nie być zgodna z tym standardem. <xref:System.Text.Encoding.HeaderName%2A> Właściwość definiuje inne kodowanie, które może być lepszym rozwiązaniem w przypadku nagłówków wiadomości e-mail. Większość aplikacji powinna jednak być używana <xref:System.Text.Encoding.WebName%2A> w zamian.  
  
 Aby uzyskać więcej informacji na temat organizacji IANA, przejdź do [www.IANA.org](https://www.iana.org/).  
  
 Jest taka sama <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> jak zwracany przez <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> Niektóre z nazw sieci Web są zduplikowane; <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> Aby uzyskać więcej informacji, zobacz uwagi.  
  
   
  
## Examples  
 Poniższy przykład zawiera <xref:System.Text.Encoding.WebName%2A> element w nagłówku html.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z co najmniej jedną nazwą, która różni się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Jest on <xref:System.Text.Encoding.EncodingName%2A> wyświetlany, ale nie jest porównywany z nim.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, pobiera stronę kodową systemu operacyjnego Windows, która najlepiej odpowiada bieżącemu kodowaniu.</summary>
        <value>Strona kodowa systemu operacyjnego Windows, która najlepiej odpowiada bieżącemu <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest zapewniana pod kątem zgodności z interfejsami API MLang (Windows Multilanguage), na przykład podczas określania rodzin czcionek. W przypadku globalizacji zaleca się użycie jednego z kodowania Unicode. Zaleca się również używanie <xref:System.Text.Encoding.WebName%2A> zamiast programu <xref:System.Text.Encoding.WindowsCodePage%2A> do identyfikowania strony kodowej.  
  
   
  
## Examples  
 Poniższy przykład określa stronę kodową systemu Windows, która najlepiej odpowiada każdemu kodowaniu.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>

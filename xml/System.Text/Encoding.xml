<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="de01cc16cef1b9f68d691629eab2e42dee0b0e83" /><Meta Name="ms.sourcegitcommit" Value="3f21796619d6e69ad383c958cc013ce44c0678de" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/11/2019" /><Meta Name="ms.locfileid" Value="56060316" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania znaków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencji bajtów zakodowany zestaw znaków Unicode. Informacje o Unicode przekształcania formatuje (UTFs) i inne kodowanie obsługiwane przez <xref:System.Text.Encoding>, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Należy pamiętać, że <xref:System.Text.Encoding> jest przeznaczony do działania na znaki Unicode zamiast dowolnego elementu danych binarnych, takich jak tablice typu byte. Jeśli musisz zakodować dowolne dane binarne do tekstu, należy użyć protokołu, takie jak uuencode, który jest implementowany przez metody takie jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET zawiera następujące implementacje <xref:System.Text.Encoding> klasy do obsługi bieżącego kodowania Unicode i inne kodowanie:  
  
-   <xref:System.Text.ASCIIEncoding> znaki Unicode są kodowane jako pojedyncze znaki ASCII 7-bitowego. To kodowanie tylko obsługuje znak wartości z zakresu od U + 0000 i U + 007F. Strona kodowa 20127. Również dostępne za pośrednictwem <xref:System.Text.Encoding.ASCII%2A> właściwości.  
  
-   <xref:System.Text.UTF7Encoding> koduje znaki Unicode przy użyciu kodowania UTF-7. To kodowanie obsługuje wszystkie wartości znakowych Unicode. Strona kodowa 65000. Również dostępne za pośrednictwem <xref:System.Text.Encoding.UTF7%2A> właściwości.  
  
-   <xref:System.Text.UTF8Encoding> koduje znaki Unicode przy użyciu kodowania UTF-8. To kodowanie obsługuje wszystkie wartości znakowych Unicode. Strona kodowa 65001. Również dostępne za pośrednictwem <xref:System.Text.Encoding.UTF8%2A> właściwości.  
  
-   <xref:System.Text.UnicodeEncoding> koduje znaki Unicode przy użyciu kodowania UTF-16. Obsługiwane są zarówno zamówienia endian i przetwarzanie dużej ilości bajtów little endian. Również dostępne za pośrednictwem <xref:System.Text.Encoding.Unicode%2A> właściwości i <xref:System.Text.Encoding.BigEndianUnicode%2A> właściwości.  
  
-   <xref:System.Text.UTF32Encoding> koduje znaki Unicode przy użyciu kodowania UTF-32. Little endian (strona kodowa 12000) i bajtów big endian (strona kodowa 12001) zamówienia są obsługiwane. Również dostępne za pośrednictwem <xref:System.Text.Encoding.UTF32%2A> właściwości.  
  
 <xref:System.Text.Encoding> Klasa jest przeznaczona głównie do konwersji między różnych kodowań i Unicode. Często jednej z klas pochodnych Unicode jest odpowiednim wyborem dla twojej aplikacji.  
  
 Użyj <xref:System.Text.Encoding.GetEncoding%2A> metodę, aby uzyskać inne kodowanie i wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać listę wszystkich kodowania.  
  
 W poniższej tabeli wymieniono kodowania obsługiwane przez .NET Framework i .NET Core. Wyświetla listę każdego kodowania na numer strony kodowej i wartości kodowania firmy <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> i <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> właściwości. Znacznik wyboru w **.NET Framework — Obsługa** i **Obsługa platformy .NET Core** kolumn wskazuje na to, że strona kodowa jest natywnie obsługiwane przez tę implementację platformy .NET, niezależnie od tego, podstawowej platformy. Dla programu .NET Framework dostępności innych kodowania wymienione w tabeli zależy od systemu operacyjnego. Dla platformy .NET Core innego kodowania są dostępne za pomocą <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> klasy lub przez pochodząca od <xref:System.Text.EncodingProvider?displayProperty=nameWithType> klasy.  

> [!NOTE]
> Kod strony, którego <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> właściwość odpowiada międzynarodowego standardu nie musi być w pełni przestrzegać tego standardu. 

|Strona kodowa|Nazwa|Nazwa wyświetlana|Obsługa programu .NET framework| Obsługa platformy .NET core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (US-Canada)|||  
|437|IBM437|OEM-USA|||  
|500|IBM500|IBM EBCDIC (międzynarodowy)|||  
|708|ASMO-708|Arabski (ASMO 708)|||  
|720|DOS-720|Arabski (DOS)|||  
|737|ibm737|Grecki (DOS)|||  
|775|ibm775|Bałtycki (DOS)|||  
|850|ibm850|Zachodnioeuropejski (DOS)|||  
|852|ibm852|Środkowoeuropejski (DOS)|||  
|855|IBM855|OEM Cyrillic|||  
|857|ibm857|Turecki (DOS)|||  
|858|IBM00858|OEM wielojęzyczny Latin I|||  
|860|IBM860|Portugalski (DOS)|||  
|861|ibm861|Islandzki (DOS)|||  
|862|DOS-862|Hebrajski (DOS)|||  
|863|IBM863|Francuski kanadyjski (DOS)|||  
|864|IBM864|Arabski (864)|||  
|865|IBM865|Nordycki (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Grecki współczesny (DOS)|||  
|870|IBM870|IBM EBCDIC (wielojęzyczny Latin-2)|||  
|874|windows-874|Tajski (Windows)|||  
|875|cp875|IBM EBCDIC (grecki współczesny)|||  
|932|shift_jis|Japoński (Shift-JIS)|||  
|936|gb2312|Chiński uproszczony (GB2312)|✓||  
|949|ks_c_5601-1987|koreański|||  
|950|big5|Chiński tradycyjny (Big5)|||  
|1026|IBM1026|IBM EBCDIC (turecki Latin-5)|||  
|1047|IBM01047|IBM Latin-1|||  
|1140|IBM01140|IBM EBCDIC (Stany Zjednoczone Kanada Euro)|||  
|1141|IBM01141|IBM EBCDIC (Niemcy Euro)|||  
|1142|IBM01142|IBM EBCDIC (Dania Norwegia Euro)|||  
|1143|IBM01143|IBM EBCDIC (Finlandia Szwecja Euro)|||  
|1144|IBM01144|IBM EBCDIC (Włochy Euro)|||  
|1145|IBM01145|IBM EBCDIC (Hiszpania Euro)|||  
|1146|IBM01146|IBM EBCDIC (Zjednoczone Królestwo Euro)|||  
|1147|IBM01147|IBM EBCDIC (Francie Euro)|||  
|1148|IBM01148|IBM EBCDIC (międzynarodowy Euro)|||  
|1149|IBM01149|IBM EBCDIC (Island Euro)|||  
|1200|UTF-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|Środkowoeuropejski (Windows)|||  
|1251|windows-1251|Cyrilice (Windows)|||  
|1252|Windows-1252|Zachodnioeuropejski (Windows)|✓||  
|1253|windows-1253|Grecki (Windows)|||  
|1254|windows-1254|Turecki (Windows)|||  
|1255|windows-1255|Hebrajski (Windows)|||  
|1256|windows-1256|Arabski (Windows)|||  
|1257|windows-1257|Bałtycki (Windows)|||  
|1258|windows-1258|Wietnamski (Windows)|||  
|1361|Johab|Koreański (Johab)|||  
|10 000|macintosh|Zachodnioeuropejski (Mac)|||  
|10001|x-mac-japanese|Japoński (Mac)|||  
|10002|x-mac-chinesetrad|Chiński tradycyjny (Mac)|||  
|10003|x-mac-korean|Koreański (Mac)|✓||  
|10004|x-mac-arabic|Arabski (Mac)|||  
|10005|x-mac-hebrew|Hebrajski (Mac)|||  
|10006|x-mac-greek|Grecki (Mac)|||  
|10007|x-mac-cyrillic|Cyrilice (Mac)|||  
|10008|x-mac-chinesesimp|Chiński uproszczony (Mac)|✓||  
|10010|x-mac-romanian|Rumuński (Mac)|||  
|10017|x-mac-ukrainian|Ukraiński (Mac)|||  
|10021|x-mac-thai|Tajski (Mac)|||  
|10029|x-mac-ce|Środkowoeuropejski (Mac)|||  
|10079|x-mac-icelandic|Islandzki (Mac)|||  
|10081|x-mac-turkish|Turecki (Mac)|||  
|10082|x-mac-croatian|Chorwacki (Mac)|||  
|12000|UTF-32|Unicode (UTF-32)|✓|✓|  
|12001|utf-32BE|Unicode (UTF-32 Big endian)|✓|✓|  
|20000|x-Chinese-CNS|Chiński tradycyjny (CNS)|||  
|20001|x-cp20001|WAN TCA|||  
|20002|x-Chinese-Eten|Chiński tradycyjny (Eten)|||  
|20003|x-cp20003|WAN Ibm5550|||  
|20004|x-cp20004|WAN Teletext|||  
|20005|x-cp20005|Tchaj-WAN|||  
|20105|x-IA5|Zachodnioeuropejski (IA5)|||  
|20106|x-IA5 — niemiecki|Niemiecki (IA5)|||  
|20107|x-IA5 — szwedzki|Szwedzki (IA5)|||  
|20108|x-IA5-Norwegian|Norweski (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Niemcy)|||  
|20277|IBM277|IBM EBCDIC (Dania Norwegia)|||  
|20278|IBM278|IBM EBCDIC (Finlandia Szwecja)|||  
|20280|IBM280|IBM EBCDIC (Włochy)|||  
|20284|IBM284|IBM EBCDIC (Hiszpania)|||  
|20285|IBM285|IBM EBCDIC (UK)|||  
|20290|IBM290|IBM EBCDIC (Japonsko-katakana)|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC (arabski)|||  
|20423|IBM423|IBM EBCDIC (grecki)|||  
|20424|IBM424|IBM EBCDIC (hebrajski)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (koreański rozszerzony)|||  
|20838|IBM — tajski|IBM EBCDIC (tajski)|||  
|20866|KOI8-r|Cyrilice (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (islandzki)|||  
|20880|IBM880|IBM EBCDIC (rosyjski cyrylica)|||  
|20905|IBM905|IBM EBCDIC (turecki)|||  
|20924|IBM00924|IBM Latin-1|||  
|20932|EUC-JP|Japoński (JIS 0208 1990 r. i 0212 1990)|||  
|20936|x-cp20936|Chiński uproszczony (GB2312-80)|✓||  
|20949|x-cp20949|Koreański Wansung|✓||  
|21025|cp1025|IBM EBCDIC (serbski bułgarski cyrylica)|||  
|21866|koi8-u|Cyrilice (KOI8-U)|||  
|28591|ISO-8859-1|Zachodnioeuropejski (ISO)|✓|✓|  
|28592|ISO-8859-2|Środkowoeuropejski (ISO)|||  
|28593|ISO-8859-3|3 alfabetu łacińskiego (ISO)|||  
|28594|iso-8859-4|Bałtycki (ISO)|||  
|28595|ISO-8859-5|Cyrillic (ISO)|||  
|28596|ISO-8859-6|Arabski (ISO)|||  
|28597|ISO-8859-7|Grecki (ISO)|||  
|28598|ISO-8859-8|Hebrajski (ISO-Visual)|✓||  
|28599|ISO-8859-9|Turecki (ISO)|||  
|28603|ISO-8859-13|Estoński (ISO)|||  
|28605|ISO-8859-15|Łaciński 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|iso-8859-8-i|Hebrajski (ISO-Logical)|✓||  
|50220|iso-2022-jp|Japoński (JIS)|✓||  
|50221|csISO2022JP|Japoński (JIS-dozwolone 1-bajtowe znaki Kana)|✓||  
|50222|iso-2022-jp|Japoński (JIS-dozwolone 1-bajtowe znaki Kana - tak / SI)|✓||  
|50225|iso-2022-kr|Koreański (ISO)|✓||  
|50227|x-cp50227|Chinese Simplified (ISO-2022)|✓||  
|51932|euc-jp|Japoński (EUC)|✓||  
|51936|EUC-CN|Chiński uproszczony (EUC)|✓||  
|51949|euc-kr|Koreański (EUC)|✓||  
|52936|hz-gb-2312|Chiński uproszczony (HZ)|✓||  
|54936|GB18030|Chiński uproszczony (GB18030)|✓||  
|57002|x-iscii-de|ISCII Devanagari|✓||  
|57003|x-iscii-be|ISCII Bengali|✓||  
|57004|x-iscii-ta|ISCII Tamil|✓||  
|57005|iscii-x Usuń|ISCII Telugu|✓||  
|57006|x-iscii-as|ISCII assamski|✓||  
|57007|x-iscii-or|ISCII Oriya|✓||  
|57008|x-iscii-ka|ISCII Kannada|✓||  
|57009|x-iscii-ma|ISCII Malayalam|✓||  
|57010|x-iscii-gu|ISCII Gujarati|✓||  
|57011|x-iscii-pa|ISCII Punjabi|✓||  
|65000|UTF-7|Unicode (UTF-7)|✓|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|✓|  
  
 Poniższy przykład wywołuje <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> i <xref:System.Text.Encoding.GetEncoding%28System.String%29> kod metody w celu uzyskania Grecki (Windows): kodowanie strony. Porównuje <xref:System.Text.Encoding> obiektów zwróconych przez wywołania metody, aby pokazać, że są równe, a następnie mapy wyświetla punkt kodowy Unicode i wartością odpowiadającego mu kodu strony każdego znaku w alfabetu greckiego.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 Służy kolejności bajtów big endian UTF-16 i UTF-32 koderów (najbardziej znaczący bajt pierwszy) lub nieco kolejności bajtów endian (najmniej znaczący bajt pierwszy). Na przykład Wielka litera (U + 0041) jest serializowany jako następujące (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian UTF-16: 00 41  
  
-   Mały kolejności bajtów endian UTF-16: 41 00  
  
-   Kolejności bajtów big endian UTF-32: 00 00 00 41  
  
-   Mały kolejności bajtów endian UTF-32: 41 00 00 00  
  
 Jest zwykle wydajniejszym rozwiązaniem przechowywania znaki Unicode przy użyciu kolejności bajtów natywnych. Na przykład lepiej jest używać nieco kolejności bajtów endian na little endian platform, takich jak komputery z technologią Intel.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> Metoda pobiera tablicę bajtów, która zawiera znacznik kolejności bajtów (BOM). Jeśli ta tablica bajtów jest umieszczany na strumień zakodowany, pomaga dekodera do identyfikowania użyty format kodowania.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Należy zwrócić uwagę na to, że klas kodowania zezwalają na błędy, aby:  
  
-   Zmień w trybie dyskretnym na "?" znaków.  
  
-   Użyj znaku "best fit".  
  
-   Zmień zachowanie specyficzne dla aplikacji za pośrednictwem <xref:System.Text.EncoderFallback> i <xref:System.Text.DecoderFallback> klas znak zastępczy U + FFFD Unicode.  
  
 Każdy błąd strumienia danych, należy zgłosić wyjątek. Aplikacja korzysta z flagą "throwonerror", jeśli ma to zastosowanie lub korzysta z <xref:System.Text.EncoderExceptionFallback> i <xref:System.Text.DecoderExceptionFallback> klasy. Najlepsze dopasowanie rezerwowe często nie jest zalecane, ponieważ może spowodować utratę danych lub pomyłek i jest mniejsza niż proste znak zamiany. W przypadku kodowania ANSI najlepsze dopasowanie zachowanie jest domyślne.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z jednego formatu kodowania na inny.  
  
> [!NOTE]
>  Tablica bajtów [] jest jedynym typem w tym przykładzie, który zawiera dane zakodowane. Typy .NET Char i parametrów znajdują się Unicode, więc <xref:System.Text.Encoding.GetChars%2A> wywołanie dekoduje dane do standardu Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor klasy pochodnej, musi zostać zastąpiona.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Identyfikator strony kodu preferowanych kodowania.  
  
—lub— 
0, aby użyć domyślnego kodowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasę, która odnosi się do określonej strony kodowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor klasy pochodnej, musi zostać zastąpiona.  
  
 Tworzenie wywołania do tego konstruktora z klasy pochodnej <xref:System.Text.Encoding> obiektu, który używa uwierzytelniania rezerwowego najlepszego dopasowania zarówno kodowania i dekodowania operacji. Zarówno <xref:System.Text.Encoding.DecoderFallback%2A> i <xref:System.Text.Encoding.EncoderFallback%2A> właściwości tylko do odczytu i nie może być modyfikowany. Do kontrolowania strategia rezerwowa dla klasą pochodną <xref:System.Text.Encoding>, wywołaj <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> jest mniejsza niż zero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Kod identyfikator strony kodowania.</param>
        <param name="encoderFallback">Obiekt, który udostępnia procedurę obsługi błędów, jeśli znak nie może zostać zakodowana przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który udostępnia procedurę obsługi błędów podczas sekwencja bajtów nie może zostać zdekodowany przy użyciu bieżącego kodowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasę, która odnosi się do określonej strony kodowej przy użyciu określonego koder i dekoder strategie rezerwowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest `protected`; pochodnej klasy go zastąpić.  
  
 Ten konstruktor jest wywołać z klasy pochodnej w celu kontrolowania rezerwowe, kodowania i dekodowania strategii. <xref:System.Text.Encoding> Konstruktory klasy Tworzenie obiektów tylko do odczytu kodowania, w których encoder lub dekodera rezerwowy, można ustawić po utworzeniu obiektu.  
  
 Jeśli `encoderFallback` lub `decoderFallback` ma wartość null, rezerwowy najlepszego dopasowania jest używany jako odpowiednie strategia rezerwowa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Kodowanie zestawu znaków (7-bitowym) ASCII.</summary>
        <value>Ustaw kodowanie znaków ASCII (7-bitowych).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ASCII są ograniczone do najniższego 128 znaków Unicode od U + 0000 do U + 007F.  
  
 Podczas wybierania kodowanie ASCII dla danej aplikacji należy rozważyć następujące kwestie:  
  
-   Kodowanie ASCII jest zwykle dla protokołów, które wymagają ASCII.  
  
-   Jeśli użytkownik wymaga 8-bitowego kodowania (co jest czasami niepoprawnie określany jako "ASCII"), kodowanie UTF-8, zaleca się za pośrednictwem ASCII kodowania. Znaki 0 7F wyniki są identyczne, ale używanie UTF-8 pozwala uniknąć utraty danych, umożliwiając reprezentacja wszystkich znaków Unicode, które są stałego. Należy pamiętać, że kodowanie ASCII ma 8-bitowych niejednoznaczności, umożliwiająca złośliwe wykorzystanie, ale kodowania UTF-8 usuwa niejednoznaczności dotyczące bit 8.  
  
-   Przed programu .NET Framework w wersji 2.0 .NET Framework mogą fałszowania, ignorując bit 8. Począwszy od programu .NET Framework 2.0, punkty kodowe spoza zestawu ASCII rezerwowe podczas dekodowania.  
  
 <xref:System.Text.ASCIIEncoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji. Używa ona zastąpienie rezerwowego zastąpienia każdego ciągu, który go nie można zakodować i poszczególne bajty, które nie można go zdekodować znakiem zapytania ("?") znaków. Zamiast tego możesz wywołać <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> metodę, aby utworzyć wystąpienie <xref:System.Text.ASCIIEncoding> obiektu, którego uwierzytelniania rezerwowego jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje efekt ASCII kodowanie znaków, które wykraczają poza zakres ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-16, który używa kolejności bajtów big endian.</summary>
        <value>Kodowanie obiekt do formatu UTF-16, który używa kolejności bajtów big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiekt, który jest zwracany przez tę właściwość nie może mieć odpowiednie zachowanie aplikacji. Używa ona zastąpienie rezerwowego zastąpienia każdego ciągu, który go nie można zakodować i poszczególne bajty, które nie można go zdekodować znakiem zapytania ("?") znaków. Zamiast tego możesz wywołać <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia big endian <xref:System.Text.UnicodeEncoding> obiektu, którego uwierzytelniania rezerwowego jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Zwrócony <xref:System.Text.UnicodeEncoding> obiekt ma <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, i <xref:System.Text.Encoding.WebName%2A> właściwości, które dają nazwy "unicodeFFFE". Mimo że znacznika kolejności bajtów big endian UTF-16 szesnastkowej FEFF, nazwa "unicodeFFFE" wybrano, ponieważ znacznik kolejności bajtów jest wyświetlany jako szesnastkowa FFFE na little endian komputerów Windows.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik tekstowy z kodowaniem UTF-16 za pomocą kolejności bajtów big endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę bieżącego kodowania, która może być używany z poczty agenta treść znaczników.</summary>
        <value>Nazwa bieżącego <see cref="T:System.Text.Encoding" /> które mogą być używane z tagami treści agenta poczty.  
  
—lub— 
Ciąg pusty (""), jeśli bieżący <see cref="T:System.Text.Encoding" /> nie mogą być używane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli potrzebujesz kodowania dla nazwy treści, należy wywołać <xref:System.Text.Encoding.GetEncoding%2A> z <xref:System.Text.Encoding.BodyName%2A> właściwości. Często metoda pobiera inne kodowanie z kodowanie testu dostarczony w wywołaniu. Zazwyczaj trzeba pobrać takie kodowania; tylko aplikacji poczty e-mail Większość aplikacji potrzebnych do opisania kodowania należy używać jej <xref:System.Text.Encoding.WebName%2A>.  
  
 W niektórych przypadkach wartość <xref:System.Text.Encoding.BodyName%2A> właściwość odpowiada międzynarodowego standardu, który określa, że kodowania. Nie oznacza to, że implementacja jest zgodna w całości z tym standardem.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowanie z jedną lub więcej nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać ją.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy płytką kopię bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <returns>Kopię bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klon jest zapisywalny nawet wtedy, gdy oryginalny <xref:System.Text.Encoding> obiekt jest tylko do odczytu. W związku z tym można zmodyfikować właściwości klonu.  
  
 Płytką kopię obiektu jest kopią tylko obiekt. Jeśli obiekt zawiera odwołania do innych obiektów, płytka kopia nie tworzy kopii obiektów, do którego się odwołuje. Odwołuje się do obiektów, oryginalnym zamiast tego. Natomiast głębokie kopiowanie obiektu tworzy kopię obiektu i wszystko bezpośrednio lub pośrednio odwołuje się ten obiekt kopię.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej pobiera identyfikator strony kodu bieżącego <see cref="T:System.Text.Encoding" />.</summary>
        <value>Identyfikator strony kodu bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowanie z jedną lub więcej nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać ją.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje tablicę bajtów z jednego formatu kodowania na inny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Format kodowania <paramref name="bytes" />.</param>
        <param name="dstEncoding">Format kodowania docelowego.</param>
        <param name="bytes">Bajty do przekonwertowania.</param>
        <summary>Konwertuje tablicę bajtów całego z jednego formatu kodowania na inny.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierającego wyniki konwersji <paramref name="bytes" /> z <paramref name="srcEncoding" /> do <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje ciąg kodowany w formacie Unicode na ciąg kodowany w formacie ASCII. Ponieważ obiekt kodowanie ASCII zwracany przez <xref:System.Text.Encoding.ASCII%2A> właściwość używa zastąpienie rezerwowego i znak Pi nie jest częścią zestawu znaków ASCII, znak Pi jest zastępowany znaku zapytania jako dane wyjściowe w przykładzie pokazano.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="dstEncoding" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Kodowanie tablicy źródłowej <paramref name="bytes" />.</param>
        <param name="dstEncoding">Kodowanie tablicy danych wyjściowych.</param>
        <param name="bytes">Tablica bajtów do przekonwertowania.</param>
        <param name="index">Indeks pierwszego elementu <paramref name="bytes" /> do przekonwertowania.</param>
        <param name="count">Liczba bajtów do konwersji.</param>
        <summary>Konwertuje zakresu bajtów w tablicy bajtów z jednego formatu kodowania na inny.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierający wynik konwersji zakresu bajtów w <paramref name="bytes" /> z <paramref name="srcEncoding" /> do <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="dstEncoding" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> i <paramref name="count" /> nie określono nieprawidłowy zakres w tablicy bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.DecoderFallback" /> obiektu dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <value>Obiekt rezerwowego dekodera dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy nie mogą zostać zdekodowane sekwencja zakodowany bajtów na znak. Obsługiwany jest dowolny z następujące typy programów obsługi:  
  
-   Najlepszego dopasowania rezerwowego obsługi, który zastępuje bajtów, które nie mogą zostać zdekodowane niektórych znaków odpowiednich obiektów zastępczych.  
  
-   Zastąpienie rezerwowego obsługi, który zastępuje niektóre znak zastępczy dowolnego bajtów, które nie mogą zostać zdekodowane. .NET zawiera jeden obsługi rezerwowego zamieniania, <xref:System.Text.DecoderFallback>, które domyślnie są zastępowane bajtów, które nie mogą zostać zdekodowane znak zapytania ("?") znaków.  
  
-   Rezerwowy obsługi wyjątków, który zgłasza wyjątek, gdy nie mogą zostać zdekodowane bajtów. .NET zawiera jeden rezerwowy aparatu obsługi wyjątków, <xref:System.Text.DecoderExceptionFallback>, który zgłasza <xref:System.Text.DecoderFallbackException> po nie mogą zostać zdekodowane bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji zestawu jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można przypisać wartości w operacji zestawu, ponieważ bieżący <see cref="T:System.Text.Encoding" /> obiekt jest tylko do odczytu.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne kodowanie dla tej implementacji .NET.</summary>
        <value>Określanie domyślnego kodowania dla tej implementacji .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Różne komputery mogą używać różnych kodowań jako domyślne, a kodowanie domyślne można zmienić na pojedynczym komputerze. Jeśli używasz <xref:System.Text.Encoding.Default%2A> kodowanie do kodowania i dekodowania dane przesyłane strumieniowo między komputerami lub pobierane w różnym czasie na tym samym komputerze, jego może tłumaczenie danych niepoprawnie. Ponadto kodowanie zwrócony przez <xref:System.Text.Encoding.Default%2A> właściwość używa najlepszego dopasowania powrotu do mapowania nieobsługiwane znaki znaki obsługiwane przez stronę kodową. Z tego względu przy użyciu domyślnego kodowania nie jest zalecane. Aby upewnić się, że zakodowany bajtów są poprawnie dekodowane, należy użyć kodowania Unicode, takich jak <xref:System.Text.UTF8Encoding> lub <xref:System.Text.UnicodeEncoding>. Aby upewnić się, że ten sam format jest używany do kodowania i dekodowania można także użyć protokołu wyższego poziomu.  

### <a name="the-default-property-in-the-net-framework"></a>Domyślna właściwość w programie .NET Framework

W programie .NET Framework na pulpicie Windows <xref:System.Text.Encoding.Default%2A> właściwość zawsze pobiera stronę kodową systemu i tworzy <xref:System.Text.Encoding> obiekt, który odnosi się do niego. Strona kodowa active może być stronę kodową ANSI, który zawiera zestaw oraz dodatkowe znaki, które różnią się przez strony kodowej znaków ASCII. Ponieważ wszystkie <xref:System.Text.Encoding.Default%2A> kodowania, w oparciu o strony kodowe ANSI utratę danych, rozważ użycie <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> kodowania w zamian. UTF-8 często jest identyczne w U + 00 do U + 7F zakresu, ale można kodowania znaków poza zakresem ASCII bez utraty.

## <a name="the-default-property-on-net-core"></a>Właściwość Default na platformie .NET Core

Na platformie .NET Core <xref:System.Text.Encoding.Default%2A> właściwość zawsze zwraca <xref:System.Text.UTF8Encoding>. UTF-8 są obsługiwane we wszystkich systemach operacyjnych (Windows, Linux i maksymalna OS X) na której działają aplikacje platformy .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.EncoderFallback" /> obiektu dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <value>Koder rezerwowego obiektu dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Obiekt reprezentuje procedurę obsługi błędów, które jest wywoływane, gdy znak nie można przekonwertować sekwencja bajtów zakodowany. Obsługiwany jest dowolny z następujące typy programów obsługi:  
  
-   Najlepszego dopasowania rezerwowego obsługi, który zastępuje znaki, które nie może zostać zakodowana niektórych znaków odpowiednich obiektów zastępczych.  
  
-   Zastąpienie rezerwowego obsługi, który zastępuje znaki, które nie może zostać zakodowana niektóre zastąpienie dowolnego znaku. .NET zawiera jeden obsługi rezerwowego zamieniania, <xref:System.Text.EncoderFallback>, która domyślnie zastępuje znaki, które nie może zostać zakodowana znakiem zapytania ("?") znaków.  
  
-   Rezerwowy obsługi wyjątków, który zgłasza wyjątek, gdy nie może zostać zakodowana znaków. .NET zawiera jeden rezerwowy aparatu obsługi wyjątków, <xref:System.Text.EncoderExceptionFallback>, który zgłasza <xref:System.Text.EncoderFallbackException> po nie mogą zostać zdekodowane znaki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji zestawu jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można przypisać wartości w operacji zestawu, ponieważ bieżący <see cref="T:System.Text.Encoding" /> obiekt jest tylko do odczytu.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera zrozumiałą dla użytkownika opis bieżącego kodowania.</summary>
        <value>Czytelny dla człowieka opis bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> Właściwość jest przeznaczona do wyświetlenia. Aby znaleźć nazwę, która może być przekazywany do <xref:System.Text.Encoding.GetEncoding%2A> metody, użyj <xref:System.Text.Encoding.WebName%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowanie z jedną lub więcej nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać ją.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> jest taki sam, jak bieżące wystąpienie.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.Encoding" /> i jest taki sam jak bieżące wystąpienie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa wystąpienia <xref:System.Text.Encoding> są traktowane jako równe, jeżeli odnoszą się do tej samej strony kodowej i ich `EncoderFallback` i `DecoderFallback` obiekty są sobie równe. W szczególności pochodnej strony kodowe wszystkie mają stronę kodową 0 i ich przejścia są zwykle `null` (`Nothing` w języku Visual Basic .NET). Ten sposób są wszystkie uważane za równe ze sobą. W wyniku jest fakt, że gdy <xref:System.Text.Encoding.Equals%2A> jest używany do wypełniania tabeli wyznaczania wartości skrótu, wszystkie pochodne porównania kodowania jest taki sam i dzielą się na tym samym miejsce tabeli wyznaczania wartości skrótu.  
  
   
  
## Examples  
 Poniższy przykład pobiera dwóch wystąpień tego samego kodowania (po jednym przez stronę kodową), a drugi według nazwy i sprawdza, czy ich równości.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający znaki do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie znaków określoną tablicę znaków.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie znaków określoną tablicę znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć wersjami ciągów <xref:System.Text.Encoding.GetBytes%2A> metody.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie znaków w określonym stringu.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, wersję ciągu <xref:System.Text.Encoding.GetBytes%2A> jest zalecane.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania, ciągu lub zakres w ciągu koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć tablicy dokładny rozmiar <xref:System.Text.Encoding.GetBytes%2A> wymaga do przechowywania wynikowy bajty, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono niektóre zagadnienia dotyczące korzystania z tych metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A> metody.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%2A> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, z określoną tablicę znaków.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, wersję ciągu <xref:System.Text.Encoding.GetBytes%2A> jest zalecane.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do zakodowania trzy znaki z tablicy znaków koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków do sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający znaki do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje wszystkie znaki w określoną tablicę znaków do sekwencji bajtów.</summary>
        <returns>Tablica bajtów zawierająca wyniki z określonego zestawu znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera pary zastępcze może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętają tego znakiem zastępczym wysokiego poziomu, dzięki czemu można połączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> nie będzie możliwe do zarządzania stanem, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy wywołać wersję ciągu <xref:System.Text.Encoding.GetBytes%2A> metody.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający znaki do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje wszystkie znaki w określonym ciągiem znaków do sekwencji bajtów.</summary>
        <returns>Tablica bajtów zawierająca wyniki z określonego zestawu znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera pary zastępcze może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętają tego znakiem zastępczym wysokiego poziomu, dzięki czemu można połączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> nie będzie możliwe do zarządzania stanem, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania, ciągu lub zakres w ciągu koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków, z określoną tablicę znaków do sekwencji bajtów.</summary>
        <returns>Tablica bajtów zawierająca wyniki z określonego zestawu znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera pary zastępcze może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętają tego znakiem zastępczym wysokiego poziomu, dzięki czemu można połączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> nie będzie możliwe do zarządzania stanem, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do zakodowania trzy znaki z tablicy znaków koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków, zaczynając od określonego znaku wskaźnika do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć tablicy dokładny rozmiar <xref:System.Text.Encoding.GetBytes%2A> wymaga do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Jeśli dane do konwersji są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że trzeba ją podzielić na mniejsze bloki, należy użyć podanego obiektu <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> odpowiednio przez metodę <xref:System.Text.Encoding.GetDecoder%2A> lub <xref:System.Text.Encoding.GetEncoder%2A> klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera pary zastępcze może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętają tego znakiem zastępczym wysokiego poziomu, dzięki czemu można połączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> nie będzie możliwe do zarządzania stanem, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków, z określoną tablicę znaków, w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajty, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera pary zastępcze może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętają tego znakiem zastępczym wysokiego poziomu, dzięki czemu można połączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> nie będzie możliwe do zarządzania stanem, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do zakodowania trzy znaki z tablicy znaków koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków do zakodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków z określonego ciągu, w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajty, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metody, która obsługuje wiele konwersje na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne zakodować wiele danych wejściowych znaków na stronę kodową i przetwarzanie znaków przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, biorąc pod uwagę stanu, który jest trwały przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera pary zastępcze może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętają tego znakiem zastępczym wysokiego poziomu, dzięki czemu można połączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> nie będzie możliwe do zarządzania stanem, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Wersja buforu znaku Unicode z <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań przy użyciu <xref:System.Text.Encoder> obiektu lub wstawiania do istniejących buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym wyborem jest w wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłosić wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie strumienia ciągłego, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania, ciągu lub zakres w ciągu koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie wszystkich bajtów w określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> Aby wynikowy znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> metody. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami.  
  
-   Jeśli aplikacja obsługuje ciąg w danych wyjściowych, należy użyć <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Encoding.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami.  
  
-   Jeśli aplikacja obsługuje ciąg w danych wyjściowych, zalecane jest użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetChars%2A> Aby wynikowy znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami.  
  
-   Jeśli aplikacja obsługuje ciąg w danych wyjściowych, zalecane jest użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z jednego formatu kodowania na inny.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje zakresu bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów w zestawie znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje wszystkich bajtów w określonej tablicy bajtów w zestawie znaków.</summary>
        <returns>Tablica znaków, zawierającą wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> pobiera znaków z sekwencji bajtów danych wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje dyskretnych konwersji, podczas gdy <xref:System.Text.Decoder> jest przeznaczony dla wielu przebiegów w jednym strumień wejściowy.  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do pracy na znaki Unicode, a nie na dowolne dane binarne, takie jak tablice typu byte. Jeśli musisz zakodować dowolne dane binarne do tekstu, należy użyć protokołu, takie jak uuencode, który jest implementowany przez metody takie jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym <xref:System.Text.Encoding.GetChars%2A> wywołania i Kontynuuj na początku następnego <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> wywoła plan awaryjny tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętają tych sekwencji dla następnego wywołania metody.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wyjściowych, zalecane jest użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów w zestawie znaków.</summary>
        <returns>Tablica znaków, zawierającą wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> pobiera znaków z sekwencji bajtów danych wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje dyskretnych konwersji, podczas gdy <xref:System.Text.Decoder> jest przeznaczony dla wielu przebiegów w jednym strumień wejściowy.  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do pracy na znaki Unicode, a nie na dowolne dane binarne, takie jak tablice typu byte. Jeśli musisz zakodować dowolne dane binarne do tekstu, należy użyć protokołu, takie jak uuencode, który jest implementowany przez metody takie jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym <xref:System.Text.Encoding.GetChars%2A> wywołania i Kontynuuj na początku następnego <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> wywoła plan awaryjny tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętają tych sekwencji dla następnego wywołania metody.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wyjściowych, zalecane jest użycie <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje zakresu bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów do zestawu znaków, które są przechowywane, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w lokalizacji wskazanej przez <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Encoding.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> pobiera znaków z sekwencji bajtów danych wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje dyskretnych konwersji, podczas gdy <xref:System.Text.Decoder> jest przeznaczony dla wielu przebiegów w jednym strumień wejściowy.  
  
 Jeśli dane do konwersji są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że trzeba ją podzielić na mniejsze bloki, należy użyć podanego obiektu <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> odpowiednio przez metodę <xref:System.Text.Encoding.GetDecoder%2A> lub <xref:System.Text.Encoding.GetEncoder%2A> klasy pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do pracy na znaki Unicode, a nie na dowolne dane binarne, takie jak tablice typu byte. Jeśli musisz zakodować dowolne dane binarne do tekstu, należy użyć protokołu, takie jak uuencode, który jest implementowany przez metody takie jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym <xref:System.Text.Encoding.GetChars%2A> wywołania i Kontynuuj na początku następnego <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> wywoła plan awaryjny tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętają tych sekwencji dla następnego wywołania metody.)  
  
-   Jeśli aplikacja obsługuje dane wyjściowe ciągu, <xref:System.Text.Encoding.GetString%2A> metoda jest zalecana. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów na określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetChars%2A> Aby wynikowy znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > pobiera znaków z sekwencji bajtów danych wejściowych. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje dyskretnych konwersje podczas <xref:System.Text.Decoder> zaprojektowano pod kątem wiele przebiegów na jednym strumień wejściowy.  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do pracy na znaki Unicode, a nie na dowolne dane binarne, takie jak tablice typu byte. Jeśli musisz zakodować dowolne dane binarne do tekstu, należy użyć protokołu, takie jak uuencode, który jest implementowany przez metody takie jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Encoding.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje dyskretnych konwersji, w przeciwieństwie do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metody, która obsługuje wiele przebiegów na jednym strumień wejściowy.  
  
 Różne wersje programu <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono pewne zagadnienia programowania do użytku z następujących metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów danych wejściowych od strony kodowej i przetwarzać bajtów przy użyciu wielu wywołań. W takim przypadku prawdopodobnie trzeba utrzymywać stan między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > wywołania i Kontynuuj na początku następnego [\], Int32, Int32, Char\<odsyłaczy : System.Text.Encoding.GetChars%2A > wywołania. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > wywoła plan awaryjny tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętają tych sekwencji dla następnego wywołania metody.)  
  
-   Jeśli aplikacja obsługuje dane wyjściowe ciągu, <xref:System.Text.Encoding.GetString%2A> metoda jest zalecana. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest nieco wolniej, ale powstałe <xref:System.String> typu, zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia kilka technik szybkie, zwłaszcza w przypadku wielu wywołań do dużych buforów. Mieć na uwadze, jednak, że tej wersji metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacja musi przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W tym przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje danych wyjściowych znaków bufory jest najlepszym wyborem.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Dekodowania ciągłego strumienia, ta metoda jest często najlepszym wyborem.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z jednego formatu kodowania na inny.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje zakresu bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, uzyskuje dekoder, który konwertuje zakodowany sekwencji bajtów na sekwencję znaków.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> konwertuje zakodowany sekwencji bajtów do sekwencji znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów do kolejnych bloków znaków, w sposób podobny do <xref:System.Text.Encoding.GetChars%2A> metody tej klasy. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami, dzięki czemu dekoduje informacje sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja zwraca <see cref="T:System.Text.Decoder" /> wywołująca <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> i <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> metod bieżącego <see cref="T:System.Text.Encoding" />. Należy przesłonić tę metodę, aby zwrócić <see cref="T:System.Text.Decoder" /> , zachowuje swój stan między wywołaniami.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, uzyskuje koder, który konwertuje sekwencję znaków Unicode pod zakodowanego sekwencji bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> sekwencji znaków Unicode, który konwertuje pod zakodowanego sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków do kolejnych bloków bajtów w sposób podobny do <xref:System.Text.Encoding.GetBytes%2A> metody tej klasy. Jednak <xref:System.Text.Encoder> przechowuje informacje o stanie między wywołaniami, dzięki czemu koduje jako sekwencje znaków, które rozciągają się bloki. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloków danych i korzysta z nieprawidłowymi znakami w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane znakiem zastępczym wysokiego poziomu, a pasujące znak zastępczy niskiego poziomu może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Domyślna implementacja zwraca <see cref="T:System.Text.Encoder" /> wywołująca <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> i <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> metod bieżącego <see cref="T:System.Text.Encoding" />. Należy przesłonić tę metodę, aby zwrócić <see cref="T:System.Text.Encoder" /> , zachowuje swój stan między wywołaniami.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kodowania dla określonej strony kodowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Identyfikator strony kodu preferowanych kodowania. Możliwe wartości są wymienione w kolumnie strony kodowej tabelę, która jest wyświetlana w <see cref="T:System.Text.Encoding" /> temat poświęcony klasie.  
  
—lub— 
0 (zero), aby użyć domyślnego kodowania.</param>
        <summary>Zwraca kodowanie skojarzony identyfikator strony określonego kodu.</summary>
        <returns>Kodowanie, które jest skojarzone z określonej strony kodowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program obsługi rezerwowego zależy od typu kodowania z `codepage`. Jeśli `codepage` (DBCS) Kodowanie zestawu znaków kodu strony lub znaków dwubajtowych, najlepszego dopasowania rezerwowego program obsługi jest używany. W przeciwnym razie program obsługi rezerwowego zastępczy jest używany. Te procedury rezerwowej obsługi może nie być odpowiednie dla twojej aplikacji. Aby określić obsługi rezerwowego, używane przez kodowanie określone przez `codepage`, można wywołać <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> przeciążenia.  
  
 W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zależy od możliwości platformy do obsługi większości stron kodowych. Program .NET Framework obsługuje natywnie niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> temat poświęcony klasie. W .NET Core <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca kodowania natywnie obsługiwane przez .NET Core. W obu implementacjach systemu .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać tablicę <xref:System.Text.EncodingInfo> obiektów, które zawiera informacje o wszystkich dostępnych kodowania. 

 Oprócz kodowania, które są natywnie dostępna na platformie .NET Core lub które wewnętrznie są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca dodatkowe kodowania, które są udostępniane przez zarejestrowanie kodowań <xref:System.Text.EncodingProvider> obiektu. Jeśli w tym samym kodowaniem został zarejestrowany za pomocą wielu <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatni zarejestrowany.  

Możesz również dostarczyć wartość 0 dla `codepage` argumentu. Dokładne zachowanie zależy od tego, czy wszystkie kodowania zostały udostępnione przez zarejestrowanie kodowań <xref:System.Text.EncodingProvider> obiektu:

- Jeśli zarejestrowano co najmniej jeden dostawców kodowania, zwraca kodowanie zarejestrowanego dostawcy, który wybrał do zwrócenia, kodowanie, kiedy <xref:System.Text.Encoding.GetEncoding%2A> metody jest przekazywana `codepage` argument 0.     

- Od programu .NET Framework, jeśli bez kodowania dostawca został zarejestrowany, jeśli <xref:System.Text.CodePagesEncodingProvider> jest zarejestrowanego dostawcy kodowania, lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, funkcja zwraca stronę kodową systemu operacyjnego. Aby ustalić, stronę kodową w systemach Windows, należy wywołać Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) funkcji z .NET Framework na pulpicie Windows.

- Na platformie .NET Core, jeśli nie zarejestrowano dostawców kodowania lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, funkcja zwraca <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Nieobsługiwany kod strony Przyczyna <xref:System.ArgumentException> zostanie wygenerowany, inne powodować <xref:System.NotSupportedException>. W związku z tym, kod musi przechwytywać wszystkie wyjątki są wymienione w sekcji wyjątki.  
  
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i można zmienić na jednym komputerze, prowadząc do uszkodzenia danych. Z tego powodu, jeśli stronę kodową jest strony kodowej ANSI, kodowania i dekodowania danych za pomocą domyślną stronę kodową zwracany przez `Encoding.GetEncoding(0)` nie jest zalecane. Aby uzyskać najbardziej spójne wyniki należy użyć kodowania Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, zamiast do konkretnej strony kodowej.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie przy użyciu ustawień domyślnych. Konstruktory klas pochodnych należy użyć, aby pobrać wystąpienie z różnymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasa zawiera konstruktora, który pozwala Ci umożliwiać wykrywanie błędów.  

   
  
## Examples  
 Poniższy przykład pobiera dwóch wystąpień tego samego kodowania (po jednym przez stronę kodową), a drugi według nazwy i sprawdza, czy ich równości.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> jest mniejsza niż zero lub większy niż 65 535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> nie jest obsługiwana przez podstawowej platformy.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> nie jest obsługiwana przez podstawowej platformy.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa strony kodu preferowanych kodowania. Każda wartość zwracana przez <see cref="P:System.Text.Encoding.WebName" /> właściwość jest prawidłowa. Możliwe wartości są wymienione w tabeli, która jest wyświetlana w kolumnie Nazwa <see cref="T:System.Text.Encoding" /> temat poświęcony klasie.</param>
        <summary>Zwraca kodowanie skojarzone z nazwą strony określonego kodu.</summary>
        <returns>Kodowanie skojarzone z określonej strony kodowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program obsługi rezerwowego zależy od typu kodowania z `name`. Jeśli `name` (DBCS) Kodowanie zestawu znaków kodu strony lub znaków dwubajtowych, najlepszego dopasowania rezerwowego program obsługi jest używany. W przeciwnym razie program obsługi rezerwowego zastępczy jest używany. Te procedury rezerwowej obsługi może nie być odpowiednie dla twojej aplikacji. Aby określić obsługi rezerwowego, używane przez kodowanie określone przez `name`, można wywołać <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> przeciążenia.  

W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zależy od możliwości platformy do obsługi większości stron kodowych. Program .NET Framework obsługuje natywnie niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> temat poświęcony klasie. W .NET Core <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca kodowania natywnie obsługiwane przez .NET Core. W obu implementacjach systemu .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać tablicę <xref:System.Text.EncodingInfo> obiektów, które zawiera informacje o wszystkich dostępnych kodowania. 

 Oprócz kodowania, które są natywnie dostępna na platformie .NET Core lub które wewnętrznie są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca dodatkowe kodowania, które są udostępniane przez zarejestrowanie kodowań <xref:System.Text.EncodingProvider> obiektu. Jeśli w tym samym kodowaniem został zarejestrowany za pomocą wielu <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatni zarejestrowany.  
   
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach, lub można zmienić dla pojedynczego komputera, prowadząc do uszkodzenia danych. Aby uzyskać najbardziej spójne wyniki należy użyć Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, zamiast do konkretnej strony kodowej.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie przy użyciu ustawień domyślnych. Konstruktory klas pochodnych należy użyć, aby pobrać wystąpienie z różnymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasa zawiera konstruktora, który pozwala Ci umożliwiać wykrywanie błędów.  
  
## Examples  
 Poniższy przykład pobiera dwóch wystąpień tego samego kodowania (po jednym przez stronę kodową), a drugi według nazwy i sprawdza, czy ich równości.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> nie jest prawidłowy kod nazwę strony.  
  
—lub— 
Stronę kodową wskazane przez <paramref name="name" /> nie jest obsługiwana przez podstawowej platformy.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Identyfikator strony kodu preferowanych kodowania. Możliwe wartości są wymienione w kolumnie strony kodowej tabelę, która jest wyświetlana w <see cref="T:System.Text.Encoding" /> temat poświęcony klasie.  
  
—lub— 
0 (zero), aby użyć domyślnego kodowania.</param>
        <param name="encoderFallback">Obiekt, który udostępnia procedurę obsługi błędów, jeśli znak nie może zostać zakodowana przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który udostępnia procedurę obsługi błędów podczas sekwencja bajtów nie może zostać zdekodowany przy użyciu bieżącego kodowania.</param>
        <summary>Zwraca kodowanie skojarzony identyfikator strony określonego kodu. Parametry określają procedurę obsługi błędów dla znaków, które nie może zostać zakodowany i sekwencje bajtów, które nie mogą zostać zdekodowane.</summary>
        <returns>Kodowanie, które jest skojarzone z określonej strony kodowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Niektóre strony nieobsługiwany kod spowodować wyjątek <xref:System.ArgumentException> zostanie wygenerowany, inne powodować <xref:System.NotSupportedException>. W związku z tym, kod musi przechwytywać wszystkie wyjątki są wymienione w sekcji wyjątki.  

W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zależy od możliwości platformy do obsługi większości stron kodowych. Program .NET Framework obsługuje natywnie niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> temat poświęcony klasie. W .NET Core <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca kodowania natywnie obsługiwane przez .NET Core. W obu implementacjach systemu .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać tablicę <xref:System.Text.EncodingInfo> obiektów, które zawiera informacje o wszystkich dostępnych kodowania. 

 Oprócz kodowania, które są natywnie dostępna na platformie .NET Core lub które wewnętrznie są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca dodatkowe kodowania, które są udostępniane przez zarejestrowanie kodowań <xref:System.Text.EncodingProvider> obiektu. Jeśli w tym samym kodowaniem został zarejestrowany za pomocą wielu <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatni zarejestrowany.  

Możesz również dostarczyć wartość 0 dla `codepage` argumentu. Dokładne zachowanie zależy od tego, czy wszystkie kodowania zostały udostępnione przez zarejestrowanie kodowań <xref:System.Text.EncodingProvider> obiektu:

- Jeśli zarejestrowano co najmniej jeden dostawców kodowania, zwraca kodowanie zarejestrowanego dostawcy, który wybrał do zwrócenia, kodowanie, kiedy <xref:System.Text.Encoding.GetEncoding%2A> metody jest przekazywana `codepage` argument 0.     

- Od programu .NET Framework, jeśli bez kodowania dostawca został zarejestrowany, jeśli <xref:System.Text.CodePagesEncodingProvider> jest zarejestrowanego dostawcy kodowania, lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, funkcja zwraca stronę kodową.

- Na platformie .NET Core, jeśli nie zarejestrowano dostawców kodowania lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, funkcja zwraca <xref:System.Text.UTF8Encoding> kodowania.

> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i można zmienić na jednym komputerze, prowadząc do uszkodzenia danych. Z tego powodu, jeśli stronę kodową jest strony kodowej ANSI, kodowania i dekodowania danych za pomocą domyślną stronę kodową zwracany przez `Encoding.GetEncoding(0)` nie jest zalecane. Aby uzyskać najbardziej spójne wyniki należy użyć Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, zamiast do konkretnej strony kodowej. 
  
 Aby kodowanie skojarzony ze stroną kodową, albo podać wartość 0 dla `codepage` argumentu lub, jeśli kod jest uruchomiony w środowisku .NET Framework na pulpicie Windows, należy pobrać wartość <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> właściwości. Aby określić bieżącej stronie kodowej aktywne, wywołania Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) funkcji z .NET Framework na pulpicie Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie przy użyciu ustawień domyślnych. Konstruktory klas pochodnych należy użyć, aby pobrać wystąpienie z różnymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasa zawiera konstruktora, który pozwala Ci umożliwiać wykrywanie błędów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> metody.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> jest mniejsza niż zero lub większy niż 65 535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> nie jest obsługiwana przez podstawowej platformy.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> nie jest obsługiwana przez podstawowej platformy.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa strony kodu preferowanych kodowania. Każda wartość zwracana przez <see cref="P:System.Text.Encoding.WebName" /> właściwość jest prawidłowa. Możliwe wartości są wymienione w tabeli, która jest wyświetlana w kolumnie Nazwa <see cref="T:System.Text.Encoding" /> temat poświęcony klasie.</param>
        <param name="encoderFallback">Obiekt, który udostępnia procedurę obsługi błędów, jeśli znak nie może zostać zakodowana przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który udostępnia procedurę obsługi błędów podczas sekwencja bajtów nie może zostać zdekodowany przy użyciu bieżącego kodowania.</param>
        <summary>Zwraca kodowanie skojarzone z nazwą strony określonego kodu. Parametry określają procedurę obsługi błędów dla znaków, które nie może zostać zakodowany i sekwencje bajtów, które nie mogą zostać zdekodowane.</summary>
        <returns>Kodowanie, które jest skojarzone z określonej strony kodowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

W .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zależy od możliwości platformy do obsługi większości stron kodowych. Program .NET Framework obsługuje natywnie niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> temat poświęcony klasie. W .NET Core <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca kodowania natywnie obsługiwane przez .NET Core. W obu implementacjach systemu .NET można wywołać <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać tablicę <xref:System.Text.EncodingInfo> obiektów, które zawiera informacje o wszystkich dostępnych kodowania. 

 Oprócz kodowania, które są natywnie dostępna na platformie .NET Core lub które wewnętrznie są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca dodatkowe kodowania, które są udostępniane przez zarejestrowanie kodowań <xref:System.Text.EncodingProvider> obiektu. Jeśli w tym samym kodowaniem został zarejestrowany za pomocą wielu <xref:System.Text.EncodingProvider> obiektów, Metoda ta zwraca ostatni zarejestrowany.  
  
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i można zmienić na jednym komputerze, prowadząc do uszkodzenia danych. Aby uzyskać najbardziej spójne wyniki należy użyć kodowania Unicode, takiego jak UTF-8 (strona kodowa 65001) lub UTF-16, zamiast do konkretnej strony kodowej.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie przy użyciu ustawień domyślnych. Konstruktory klas pochodnych należy użyć, aby pobrać wystąpienie z różnymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasa zawiera konstruktora, który pozwala Ci umożliwiać wykrywanie błędów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> metody.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> nie jest prawidłowy kod nazwę strony.  
  
—lub— 
Stronę kodową wskazane przez <paramref name="name" /> nie jest obsługiwana przez podstawowej platformy.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę zawierającą wszystkie kodowania.</summary>
        <returns>Tablica, która zawiera wszystkie kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca listę obsługiwanych kodowań, jednoznacznie rozróżnianych na podstawie strony kodowej. Aby uzyskać tabelę, która zawiera obsługiwane kodowania, zobacz <xref:System.Text.Encoding> temat poświęcony klasie.  
  
> [!NOTE]
>  Listę obsługiwanych kodowań zwrócony przez <xref:System.Text.Encoding.GetEncodings%2A> metoda nie obejmuje wszelkie dodatkowe kodowania udostępniane przez żaden <xref:System.Text.EncodingProvider> implementacji, które zostały zarejestrowane przez wywołania <xref:System.Text.Encoding.RegisterProvider%2A> metody.  
  
 Od programu .NET Framework kodowania 50220 i 50222 są zarówno skojarzone z nazwą "iso-2022-jp", ale nie są identyczne. Kodowanie 50220 konwertuje znaki Katakana połowę szerokości na znaki katakana o pełnej szerokości, kodowanie 50222, używa sekwencji shift/shift wyewidencjonowania do kodowania znaków Katakana połowę szerokości. Nazwa wyświetlana dla kodowania 50222 jest "japoński (JIS-dozwolone 1-bajtowy Kana - tak / SI)" w odróżnieniu od kodowania 50220, którego ekran ma nazwę "japoński (JIS)".  
  
 Zażądanie kodowania nazwy "iso-2022-jp", zwraca .NET Framework 50220 kodowania. Kodowania, które jest odpowiednie dla twojej aplikacji zależy jednak preferowaną traktowania znakami Katakana połowę szerokości.  
  
 Aby uzyskać specyficznym kodowaniem, należy użyć <xref:System.Text.Encoding.GetEncoding%2A> metody.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> Czasami służy do zaoferowania użytkownikowi listę kodowania w pliku **Zapisz jako** okno dialogowe. Jednak wielu innym niż Unicode kodowania są niekompletne i tłumaczyć wielu znaków na "?", lub kliknięcia różne zachowanie na różnych platformach. Należy rozważyć użycie UTF-8 lub UTF-16 jako domyślny.  
  
   
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logiczne każdej kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza maksymalną liczbę bajtów, generowane przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów, generowane przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount` Parametru faktycznie określa liczbę <xref:System.Char> obiekty reprezentujące znaków Unicode, aby zakodować, ponieważ .NET wewnętrznie używa UTF-16 do reprezentowania znaków Unicode. W związku z tym, znaki Unicode mogą być reprezentowane przez jeden <xref:System.Char> obiekt, ale znak Unicode, reprezentowane przez parę zastępczą, na przykład wymaga dwóch <xref:System.Char> obiektów.  
  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetBytes%2A> Aby wynikowy bajtów, należy użyć <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> pobiera numer najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.Encoding.GetMaxByteCount%2A> pobiera dużych wartościach, zwłaszcza w przypadkach, gdy najgorszego przypadku kodowanie obejmuje przełączanie trybów dla każdego znaku. Na przykład może to nastąpić dla ISO-2022-JP. Aby uzyskać więcej informacji, zobacz wpis na blogu "[co to jest Encoding.GetMaxByteCount() i Encoding.GetMaxCharCount()?](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 W większości przypadków ta metoda pobiera rozsądne wartości dla małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach, gdy bardziej uzasadnionego bufor jest za mały. Można także rozważyć użycie innego podejścia <xref:System.Text.Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Korzystając z <xref:System.Text.Encoding.GetMaxByteCount%2A>, należy przydzielić bufor wyjściowy na podstawie maksymalnego rozmiaru buforu wejściowego. Jeśli bufor wyjściowy jest ograniczony do rozmiaru, można użyć <xref:System.Text.Encoding.Convert%2A> metody.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.GetMaxByteCount%2A> uwzględnia potencjalnych surogaty pozostałość z poprzedniej operacji dekodera. Ze względu na dekoder przekazując wartość 1, do metody pobiera 2 dla kodowania pojedynczych bajtów, takich jak ASCII. Należy używać <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> właściwość, jeśli te informacje są niezbędne.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Wszystkie <see cref="T:System.Text.Encoding" /> implementacji należy zagwarantować, że żadne wyjątki przepełnienia buforu wystąpić, jeśli mają rozmiar buforów, zgodnie z wynikami obliczeniach tej metody.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza maksymalną liczbę znaków, generowane przez określoną liczbę bajtów do zdekodowania.</summary>
        <returns>Maksymalna liczba znaków, generowane przez określoną liczbę bajtów do zdekodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.Encoding.GetChars%2A> Aby wynikowy znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> pobiera numer najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.Encoding.GetMaxCharCount%2A> pobiera dużych wartościach.  
  
 W większości przypadków ta metoda pobiera uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach, bardziej uzasadnionego buforu jest za mały. Można także rozważyć użycie innego podejścia <xref:System.Text.Encoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.Encoding.GetBytes%2A>. Jeśli wymaga podobną funkcję do użycia z <xref:System.Text.Encoding.GetBytes%2A>, należy użyć <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Korzystając z <xref:System.Text.Encoding.GetMaxCharCount%2A>, należy przydzielić bufor wyjściowy na podstawie maksymalnego rozmiaru buforu wejściowego. Jeśli bufor wyjściowy jest ograniczony do rozmiaru, można użyć <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.GetMaxCharCount%2A> uwzględnia najgorszego przypadku bajtów pozostawionych przez poprzednią operację kodera. Dla większości stron kodowych przekazując wartość 0 do tej metody pobiera wartości większe niż lub równa 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Wszystkie <see cref="T:System.Text.Encoding" /> implementacji należy zagwarantować, że żadne wyjątki przepełnienia buforu wystąpić, jeśli mają rozmiar buforów, zgodnie z wynikami obliczeniach tej metody.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej zwraca sekwencję bajtów, który określa sposób kodowania.</summary>
        <returns>Tablica bajtów zawierająca sekwencji bajtów, która określa sposób kodowania.  
  
—lub— 
Tablica bajtów o długości od zera, jeśli preambuła nie jest wymagana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcjonalnie <xref:System.Text.Encoding> obiekt zapewnia preambuły, który jest tablicą bajtów, które mogą być poprzedzone sekwencji bajtów wynikające z procesu kodowania. Jeśli Preambuła zawiera znacznik kolejności bajtów (w formacie Unicode, punkt kodowy U + FEFF), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF.  
  
 Znacznika kolejności bajtów Unicode (BOM) jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   UTF-8: EF BB BF  
  
-   Kolejności bajtów big endian UTF-16: FE FF  
  
-   Mały kolejności bajtów endian UTF-16: FF FE  
  
-   Kolejności bajtów big endian UTF-32: 00 00 FF FE  
  
-   Mały kolejności bajtów endian UTF-32: FF FE 00 00  
  
 Należy użyć znaku BOM, ponieważ zapewnia niemal niektórych Identyfikacja kodowanie plików to inaczej utracić odwołanie do <xref:System.Text.Encoding> obiektu, na przykład nieprawidłowo znacznikami danych w sieci web lub bez nich lub pliki losowego tekstu zapisana, gdy firma nie zmieniła się ma międzynarodowy problemy lub inne dane. Może być można uniknąć często problemów użytkowników, jeśli danych jest spójne i odpowiednio oznaczone, najlepiej w formacie UTF-8 lub UTF-16.  
  
 Pod kątem obsługi standardów, które udostępniają typ kodowania znak BOM jest nieco nadmiarowe. Jednak może służyć ułatwiające serwera wysyłaj poprawny nagłówek kodowania. Alternatywnie może służyć jako rezerwowe w przypadku, gdy kodowanie, w przeciwnym razie zostaną utracone.  
  
 Istnieją pewne wady za pomocą znak BOM. Na przykład jak ograniczyć polach bazy danych, które używają znak BOM, wiedząc, może być trudne. Łączenie plików, może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebne obydwie mogą znaleźć się w trakcie wykonywania danych. Mimo kilku wady jednak użycie znak BOM jest zdecydowanie zaleca się.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowany bajtów są poprawnie dekodowane, powinien prefiks zakodowany bajty od preambuły. Jednak większość kodowania, nie są oferowane preambuły. Aby upewnić się, że zakodowany bajtów są poprawnie dekodowane, należy użyć kodowania Unicode, oznacza to, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding>, od preambuły.  
  
   
  
## Examples  
 Poniższy przykład określa kolejność bajtów kodowania oparte na preambuły.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów na ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje wszystkich bajtów w określonej tablicy bajtów na ciąg.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> obiektu zwróconego przez <xref:System.Text.Encoding.GetDecoder%2A> metody klasy poch Klasa odne.  
  
 Zobacz sekcję Uwagi <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> temat referencyjny dotyczący dyskusję na temat dekodowania techniki i uwagi.  
  
 Należy pamiętać, że dokładne zachowanie <xref:System.Text.Encoding.GetString%2A> metoda dla określonego <xref:System.Text.Encoding> wdrożenia jest zależny od strategia rezerwowa zdefiniowane w tym <xref:System.Text.Encoding> obiektu. Aby uzyskać więcej informacji, zobacz sekcję "Wybieranie strategii powrotu" [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) tematu.  
  
   
  
## Examples  
 Poniższy przykład odczytuje ciąg kodowany w formacie UTF-8 z plikiem binarnym, reprezentowane przez <xref:System.IO.FileStream> obiektu. W przypadku plików, które są mniejsze niż 2048 bajtów odczytuje zawartości całego pliku do tablicy typu byte i wywołania <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> metodę w celu dekodowania. W przypadku plików większych odczytuje 2048 bajtów w czasie do tablicy typu byte, wywołania <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę pozwala ustalić, ile znaków są zawarte w tablicy, a następnie wywołuje <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu dekodowania.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 W przykładzie użyto następujący tekst, który powinien zostać zapisany plik zakodowany w formacie UTF-8 o nazwie Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica bajtów zawiera nieprawidłowe punkty kodowe Unicode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do tablicy typu byte.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje określoną liczbę bajtów w ciąg zaczynając od określonego adresu.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> Metodę zaprojektowano w celu optymalizacji wydajności, gdy wskaźnik natywny do tablicy typu byte. Zamiast tworzenia tablicy typu byte zarządzanych, a następnie dekodowanie go, możesz zamiast tego tę metodę można wywołać bez konieczności tworzenia żadnych obiektów pośrednich.  
  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> obiektu zwróconego przez <xref:System.Text.Encoding.GetDecoder%2A> metody klasy poch Klasa odne.  
  
 Zobacz sekcję Uwagi <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> temat referencyjny dotyczący dyskusję na temat dekodowania techniki i uwagi.  
  
 Należy pamiętać, że dokładne zachowanie <xref:System.Text.Encoding.GetString%2A> metoda dla określonego <xref:System.Text.Encoding> wdrożenia jest zależny od strategia rezerwowa zdefiniowane w tym <xref:System.Text.Encoding> obiektu. Aby uzyskać więcej informacji, zobacz sekcję "Wybieranie strategii powrotu" [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) tematu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest wskaźnikiem wartości null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów na ciąg.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dane, które ma zostać przekonwertowany jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duża, że należy ją podzielić na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, odpowiednio w klasie pochodnej.  
  
 Zobacz sekcję Uwagi <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> temat referencyjny dotyczący dyskusję na temat dekodowania techniki i uwagi.  
  
   
  
## Examples  
 Poniższy przykład odczytuje ciąg kodowany w formacie UTF-8 z plikiem binarnym, który jest reprezentowany przez <xref:System.IO.FileStream> obiektu. W przypadku plików, które są mniejsze niż 2048 bajtów odczytuje zawartości całego pliku do tablicy typu byte i wywołania <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę w celu dekodowania. W przypadku plików większych odczytuje 2048 bajtów w czasie do tablicy typu byte, wywołania <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę pozwala ustalić, ile znaków są zawarte w tablicy, a następnie wywołuje <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu dekodowania.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 W przykładzie użyto następujący tekst, który powinien zostać zapisany plik zakodowany w formacie UTF-8 o nazwie Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica bajtów zawiera nieprawidłowe punkty kodowe Unicode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę bieżącego kodowania, która może być używany z tagów nagłówka agent poczty.</summary>
        <value>Nazwa bieżącego <see cref="T:System.Text.Encoding" /> za pomocą tagów nagłówka agent poczty.  
  
—lub— 
Ciąg pusty (""), jeśli bieżący <see cref="T:System.Text.Encoding" /> nie mogą być używane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli potrzebujesz kodowania dla nazwy nagłówka, należy wywołać <xref:System.Text.Encoding.GetEncoding%2A> metody z <xref:System.Text.Encoding.HeaderName%2A> właściwości. Często metoda pobiera inne kodowanie z kodowanie testu dostarczony w wywołaniu. Zazwyczaj trzeba pobrać takie kodowania tylko aplikacji poczty e-mail.  
  
 W niektórych przypadkach wartość <xref:System.Text.Encoding.BodyName%2A> właściwość odpowiada międzynarodowego standardu, który określa, że kodowania. Nie oznacza to, że implementacja jest zgodna w całości z tym standardem.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.WebName%2A> zwraca nazwę do użycia w celu opisania kodowania. <xref:System.Text.Encoding.HeaderName%2A> Właściwość definiuje innego kodowania, która może działać lepiej dla aplikacji poczty e-mail, na przykład. Użycie właściwości, aby zdefiniować kodowanie nie jest zalecane.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowanie z jedną lub więcej nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać ją.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącego kodowania zawsze jest znormalizować.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżącego kodowania zawsze jest znormalizować, przy użyciu domyślnego formularza normalizacji.</summary>
        <returns><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> jest zawsze znormalizowane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnego formularza normalizacji jest <xref:System.Text.NormalizationForm.FormC>, który używa rozkład pełnej canonical, następuje zastąpienie sekwencji z ich podstawowej złożone, jeśli jest to możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Jedną z <see cref="T:System.Text.NormalizationForm" /> wartości.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego kodowania zawsze jest znormalizować, za pomocą formularza normalizacji w określony.</summary>
        <returns><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> obiekt zawsze jest znormalizować przy użyciu określonego <see cref="T:System.Text.NormalizationForm" /> wartości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnego formularza normalizacji jest <xref:System.Text.NormalizationForm.FormC>, który używa rozkład pełnej canonical, następuje zastąpienie sekwencji z ich podstawowej złożone, jeśli jest to możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego kodowania może służyć przez klientów z przeglądarki do wyświetlania zawartości.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> może być używana przez klientów z przeglądarki do wyświetlania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logiczne każdej kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego kodowania może służyć przez klientów w przeglądarkach do zapisywania zawartości.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> może być używana przez klientów w przeglądarkach do zapisywania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logiczne każdej kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego kodowania może służyć przez klientów poczty e-mail i wiadomości do wyświetlania zawartości.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> mogą być używane przez klientów poczty e-mail i wiadomości w celu wyświetlania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logiczne każdej kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego kodowania może służyć przez klientów poczty e-mail i wiadomości do zapisywania zawartości.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> mogą być używane przez klientów poczty e-mail i wiadomości do zapisywania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logiczne każdej kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżącego kodowania jest tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy punkty kodowe jednobajtowe korzysta z bieżącego kodowania.</summary>
        <value><see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> używa punkty kodowe jednobajtowe; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla pojedynczych bajtów kodowania, na przykład <xref:System.Text.ASCIIEncoding>, ta właściwość umożliwia pobranie `true`.  
  
> [!CAUTION]
>  Należy zachować ostrożność w aplikacji jest wartością dla <xref:System.Text.Encoding.IsSingleByte%2A>. Założenie jak kodowanie będzie kontynuowana, nadal mogą być nieprawidłowe. Na przykład Windows-1252 ma wartość `true` dla <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, ale Encoding.GetMaxByteCount(1) zwraca wartość 2. Jest to spowodowane metoda uwzględnia potencjalnych surogaty pozostałość z poprzedniej operacji dekodera.  
  
   
  
## Examples  
 Poniższy przykład sprawdza wartości właściwości logiczne każdej kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Podklasa klasy <see cref="T:System.Text.EncodingProvider" /> zapewniająca dostęp do kodowania znaków dodatkowych.</param>
        <summary>Rejestruje dostawcę kodowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A> Metoda umożliwia rejestrowanie klasy pochodzącej od <xref:System.Text.EncodingProvider> , sprawia, że znak dostępne na platformie, która w przeciwnym razie ich nie obsługuje kodowania. Po zarejestrowaniu dostawcy kodowania kodowania, które obsługuje może być pobierany przez wywołanie dowolnego <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> przeciążenia. W przypadku wielu dostawców kodowania <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> metoda podejmuje próbę pobrania określonego kodowania z każdego dostawcy, począwszy od ten, który został ostatnio zarejestrowany.

Rejestrowanie dostawcy kodowania za pomocą <xref:System.Text.Encoding.RegisterProvider%2A> metoda również modyfikowanie zachowania [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) i [EncodingProvider.GetEncoding (typu Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) metody, gdy przekazany argument `0`:

- Jeśli jest zarejestrowanego dostawcy <xref:System.Text.CodePagesEncodingProvider>, metoda zwraca kodowania, który odpowiada systemowa strona kodowa aktywne podczas uruchamiania w systemie operacyjnym Windows.

- Można wybrać niestandardowego dostawcy kodowania, kodowania, która do zwrócenia, gdy któraś z tych <xref:System.Text.Encoding.GetEncoding%2A> przeciążenia metody jest przekazywana argumentu `0`. Dostawca może także zwracać kodowania dzięki <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> zwrotu metody `null`. 
  
Począwszy od programu .NET Framework 4.6, program .NET Framework zawiera jeden dostawca kodowania, <xref:System.Text.CodePagesEncodingProvider>, która sprawia, że dostępne kodowania, które znajdują się w pełny program .NET Framework, ale nie są dostępne na platformie Windows Universal. Domyślnie platforma uniwersalna Windows obsługuje tylko kodowania Unicode, ASCII i stronę kodową 28591.  
  
 Jeśli ten sam dostawca kodowania jest używany w wielu wywołaniach do <xref:System.Text.Encoding.RegisterProvider%2A> metody, tylko pierwsze wywołanie metody powoduje zarejestrowanie dostawcy. Kolejne wywołania są ignorowane.  
  
 Jeśli <xref:System.Text.Encoding.RegisterProvider%2A> metoda jest wywoływana, aby zarejestrować wielu dostawców, które obsługują ten sam kodowania, ostatni zarejestrowanego dostawcy jest używany dla wszystkich kodowania i dekodowania operacji. Wszelkie wcześniej zarejestrowanego dostawcy są ignorowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowania dla formatu UTF-16, używając nieco kolejności bajtów endian.</summary>
        <value>Kodowanie do formatu UTF-16, używając nieco kolejności bajtów endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacji na temat kodowania, obsługiwane przez .NET i dyskusji znaków Unicode, które kodowanie do użycia, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Obiekt, który jest zwracany przez tę właściwość nie może mieć odpowiednie zachowanie aplikacji. Używa ona zastąpienie rezerwowego zastąpienia każdego ciągu, który go nie można zakodować i poszczególne bajty, które nie można go zdekodować znakiem zapytania ("?") znaków. Zamiast tego możesz wywołać <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia little endian <xref:System.Text.UnicodeEncoding> obiektu, którego uwierzytelniania rezerwowego jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowania dla formatu UTF-32, używając nieco kolejności bajtów endian.</summary>
        <value>Kodowanie obiekt do formatu UTF-32, używając nieco kolejności bajtów endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Obiekt, który jest zwracany przez tę właściwość nie może mieć odpowiednie zachowanie aplikacji. Aby zastąpić każdego ciągu, który go nie można zakodować i poszczególne bajty, które nie można go zdekodować znak zastępczy Unicode (U + FFFE) używa zastąpienie rezerwowego. Zamiast tego możesz wywołać <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia <xref:System.Text.UTF32Encoding> obiektu, którego uwierzytelniania rezerwowego jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Omówienie little endian bajtów zamówienia, zobacz <xref:System.Text.Encoding> temat poświęcony klasie.  
  
 Aby uzyskać informacji na temat kodowania, obsługiwane przez .NET i dyskusji znaków Unicode, które kodowanie do użycia, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie dla formatu UTF-7.</summary>
        <value>Kodowanie w formacie UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie UTF-7 jest używany głównie w środowiskach, które wcześniej zostały ograniczone do 7 bitów, takich jak NNTP i niektóre aplikacje poczty e-mail. Z powodu problemów z niezawodnością i zabezpieczeń nie należy używać UTF7 kodowania w środowiskach 8-bitową gdzie kodowania UTF-8 można zamiast tego.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie w formacie UTF-8.</summary>
        <value>Kodowanie w formacie UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Text.UTF8Encoding> obiektu kodującej Unicode (UTF-16-kodowane) znaków do sekwencji jednej do czterech bajtów na znak, a które dekoduje na tablicę bajtów algorytmem UTF-8, Unicode (UTF-16-kodowane) znaków. Aby uzyskać informacji na temat kodowania znaków, obsługiwane przez .NET i dyskusji znaków Unicode, które kodowanie do użycia, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF8Encoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji.  
  
-   Zwraca <xref:System.Text.UTF8Encoding> obiektu, który zawiera znacznik kolejności bajtów Unicode (BOM). Do utworzenia wystąpienia UTF8 kodowania, które nie zawiera znak BOM, wywołaj wszystkie przeciążenia <xref:System.Text.UTF8Encoding.%23ctor%2A> konstruktora.  
  
-   Zwraca <xref:System.Text.UTF8Encoding> obiekt, który używa zastąpienie rezerwowej w celu zastąpienia każdego ciągu, który go nie można zakodować i poszczególne bajty, które nie można go zdekodować znakiem zapytania ("?") znaków. Zamiast tego możesz wywołać <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia <xref:System.Text.UTF8Encoding> obiektu, którego uwierzytelniania rezerwowego jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, tak jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę, która składa się z następujących znaków:  
  
-   MAŁA LITERA Z (U + 007A)  
  
-   MAŁA LITERA (U + 0061)  
  
-   ŁĄCZENIE CAPPUCCINO (U + 0306)  
  
-   MAŁA LITERA AE Z OSTRYCH (U + 01FD)  
  
-   GRECKI MAŁA LITERA, BETA (U + 03B2)  
  
-   Para dwuskładnikowa (U + D800 U + DD54), który wchodzi w skład GRECKIM ACROPHONIC ATTIC jeden TYSIĘCY STATERS (U + 10154).  
  
 On wyświetla jednostki kodu UTF-16 każdego znaku i określa liczbę bajtów wymaganą przez koder UTF-8, aby zakodować tablicy znaków. Następnie koduje znaki i wyświetla wynikowy algorytmem UTF-8 bajtów.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę zarejestrowany za pomocą Internet przypisane numery Authority (IANA) dla bieżącego kodowania.</summary>
        <value>Nazwa organizacji IANA dla bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A> Właściwości jest taka sama jak <xref:System.Text.EncodingInfo.Name%2A> właściwości.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.WebName%2A> zwraca nazwę zarejestrowana organizacja IANA kodowania. Gdy jej wartość jest nazwa standardu, implementacja kodowania nie mogą być zgodne w całości z tym standardem. <xref:System.Text.Encoding.HeaderName%2A> Właściwość definiuje innego kodowania, która może działać lepiej w nagłówkach wiadomości e-mail. Jednak większość aplikacje powinny używać <xref:System.Text.Encoding.WebName%2A> zamiast tego.  
  
 Aby uzyskać więcej informacji na temat organizację IANA, przejdź do [www.iana.org](https://www.iana.org/).  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> Jest taka sama jak <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> zwrócone przez <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Niektóre z nazwy sieci web znajdują się duplikaty; Zobacz uwagi, na <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> Aby uzyskać więcej informacji.  
  
   
  
## Examples  
 Poniższy przykład zawiera <xref:System.Text.Encoding.WebName%2A> w nagłówku HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowanie z jedną lub więcej nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać ją.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej pobiera kodowanie stronę kodową systemu operacyjnego Windows, który najlepiej odpowiada bieżącej.</summary>
        <value>Strona kodowa systemu operacyjnego Windows, który najlepiej odpowiada bieżącej <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest podawany potrzeby utrzymywania zgodności z wielu języków Windows (MLang) interfejsów API, na przykład określania rodziny czcionek. Globalizacja przy użyciu jednej z kodowania Unicode zaleca się zamiast tego. Ponadto zaleca się używanie <xref:System.Text.Encoding.WebName%2A> zamiast <xref:System.Text.Encoding.WindowsCodePage%2A> do identyfikowania strony kodowej.  
  
   
  
## Examples  
 Poniższy przykład określa stronę kodową Windows, która najlepiej odpowiada każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
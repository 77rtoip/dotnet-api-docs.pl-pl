<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adda8f83141f6520fcaefa264a4ae9446935542e" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683695" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania znaków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Z kolei dekodowania jest procesem przekształcania sekwencję bajtów zakodowanego do zestawu znaków Unicode. Informacje o Unicode przekształcania formatuje (UTFs) i inne kodowanie obsługiwane przez <xref:System.Text.Encoding>, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Należy pamiętać, że <xref:System.Text.Encoding> jest przeznaczony do działania na znaki Unicode zamiast dowolnych danych binarnych, takich jak tablice typu byte. Jeśli należy zakodować dowolne dane binarne do tekstu, należy użyć protokołu, takie jak uuencode, która jest zaimplementowana za pomocą metod, takich jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 Platforma .NET Framework zapewnia następujące implementacje <xref:System.Text.Encoding> klasy do obsługi bieżącego kodowania Unicode i inne kodowanie:  
  
-   <xref:System.Text.ASCIIEncoding> znaki Unicode są kodowane jako pojedynczy 7-bitowe znaki ASCII. To kodowanie tylko wartości znakowych obsługuje między U + 0000 i U + 007F. Strona kodowa 20127. Również dostępne za pośrednictwem <xref:System.Text.Encoding.ASCII%2A> właściwości.  
  
-   <xref:System.Text.UTF7Encoding> koduje znaki Unicode przy użyciu kodowania UTF-7. Ten typ kodowania obsługuje wszystkie wartości znakowych Unicode. Strona kodowa 65000. Również dostępne za pośrednictwem <xref:System.Text.Encoding.UTF7%2A> właściwości.  
  
-   <xref:System.Text.UTF8Encoding> koduje znaki Unicode przy użyciu kodowania UTF-8. Ten typ kodowania obsługuje wszystkie wartości znakowych Unicode. Strona kodowa 65001. Również dostępne za pośrednictwem <xref:System.Text.Encoding.UTF8%2A> właściwości.  
  
-   <xref:System.Text.UnicodeEncoding> koduje znaki Unicode przy użyciu kodowania UTF-16. Obsługiwane są oba zamówienia, a big endian kolejności bajtów little endian. Również dostępne za pośrednictwem <xref:System.Text.Encoding.Unicode%2A> właściwości i <xref:System.Text.Encoding.BigEndianUnicode%2A> właściwości.  
  
-   <xref:System.Text.UTF32Encoding> koduje znaki Unicode przy użyciu kodowania UTF-32. Zarówno little endian (strona kodowa 12000) i bajtów big endian (strona kodowa 12001) zlecenia są obsługiwane. Również dostępne za pośrednictwem <xref:System.Text.Encoding.UTF32%2A> właściwości.  
  
 <xref:System.Text.Encoding> Klasy mają one konwertowanie różne kodowania Unicode. Często jednej z klas pochodnych Unicode jest poprawny wybór dla aplikacji.  
  
 Użyj <xref:System.Text.Encoding.GetEncoding%2A> metodę, aby uzyskać inne kodowanie i Wywołaj <xref:System.Text.Encoding.GetEncodings%2A> metodę, aby uzyskać listę wszystkich kodowania.  
  
 W poniższej tabeli wymieniono kodowania obsługiwane przez program .NET Framework. Przedstawia on każdego kodowanie na numer strony kodowej i wartości kodowania w <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> i <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> właściwości. Gwiazdki w ostatniej kolumnie wskazuje, czy strona kodowa jest obsługiwany natywnie w programie .NET Framework, niezależnie od podstawowej platformy. Uwaga kodu strony, którego <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> właściwość odpowiada międzynarodowego standardu niekoniecznie nie są zgodne w pełni z tym standard.  
  
|Strona kodowa|Nazwa|Nazwa wyświetlana|.NET framework — Obsługa|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC (US-Canada)||  
|437|IBM437|Stany Zjednoczone przez producenta OEM||  
|500|IBM500|IBM EBCDIC (międzynarodowy)||  
|708|ASMO-708|Arabski (ASMO 708)||  
|720|DOS-720|Arabski (DOS)||  
|737|ibm737|Grecki (DOS)||  
|775|ibm775|Bałtycki (DOS)||  
|850|ibm850|Europa Zachodnia (DOS)||  
|852|ibm852|Europa Środkowa (DOS)||  
|855|IBM855|OEM Cyrillic||  
|857|ibm857|Turecki (DOS)||  
|858|IBM00858|OEM wielojęzyczny Latin I||  
|860|IBM860|Portugalski (DOS)||  
|861|ibm861|Islandzki (DOS)||  
|862|DOS-862|Hebrajski (DOS)||  
|863|IBM863|Francuski kanadyjskich (DOS)||  
|864|IBM864|Arabski (864)||  
|865|IBM865|Nordycki (DOS)||  
|866|cp866|Cyrylica (DOS)||  
|869|ibm869|Grecki, Nowoczesny (DOS)||  
|870|IBM870|IBM EBCDIC (wielojęzyczny Latin-2)||  
|874|windows-874|Tajski (system Windows)||  
|875|cp875|IBM EBCDIC (grecki nowoczesny)||  
|932|shift_jis|Japoński (Shift JIS)||  
|936|gb2312|Chiński uproszczony (GB2312)|✓|  
|949|ks_c_5601-1987|koreański||  
|950|big5|Chiński tradycyjny (Big5)||  
|1026|IBM1026|IBM EBCDIC (turecki Latin-5)||  
|1047|IBM01047|IBM Latin-1||  
|1140|IBM01140|IBM EBCDIC (USA Kanada EUR)||  
|1141|IBM01141|IBM EBCDIC (Niemcy EUR)||  
|1142|IBM01142|IBM EBCDIC (Dania Norwegia EUR)||  
|1143|IBM01143|IBM EBCDIC (Finlandia Szwecja EUR)||  
|1144|IBM01144|IBM EBCDIC (waluta włoska)||  
|1145|IBM01145|IBM EBCDIC (Hiszpania EUR)||  
|1146|IBM01146|IBM EBCDIC (Zjednoczone Królestwo EUR)||  
|1147|IBM01147|IBM EBCDIC (Francja EUR)||  
|1148|IBM01148|IBM EBCDIC (Międzynarodowa EUR)||  
|1149|IBM01149|IBM EBCDIC (islandzkim EUR)||  
|1200|UTF-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|  
|1250|windows-1250|Europa Środkowa (system Windows)||  
|1251|windows-1251|Cyrylica (system Windows)||  
|1252|Windows-1252|Europa Zachodnia (system Windows)|✓|  
|1253|windows-1253|Grecki (system Windows)||  
|1254|windows-1254|Turecki (system Windows)||  
|1255|windows-1255|Hebrajski (system Windows)||  
|1256|windows-1256|Arabski (system Windows)||  
|1257|windows-1257|Bałtyckiego (system Windows)||  
|1258|windows-1258|Wietnamski (system Windows)||  
|1361|Johab|Koreański (Johab)||  
|10000|Macintosh|Europa Zachodnia (Mac)||  
|10001|japoński x-mac|Japoński (Mac)||  
|10002|x-mac-chinesetrad|Chiński tradycyjny (Mac)||  
|10003|koreański x-mac|Koreański (Mac)|✓|  
|10004|x-mac-arabic|Arabski (Mac)||  
|10005|x-mac-hebrew|Hebrajski (Mac)||  
|10006|mac-x grecki|Grecki (Mac)||  
|10007|x-mac-cyrillic|Cyrylica (Mac)||  
|10008|x-mac-chinesesimp|Chiński uproszczony (Mac)|✓|  
|10010|x-mac — rumuński|Rumuński (Mac)||  
|10017|x-mac-ukrainian|Ukraiński (Mac)||  
|10021|x-mac — tajski|Tajski (Mac)||  
|10029|ce-x-mac|Europa Środkowa (Mac)||  
|10079|islandzkim x-mac|Islandzki (Mac)||  
|10081|x-mac-turkish|Turecki (Mac)||  
|10082|x-mac — chorwacki|Chorwacki (Mac)||  
|12000|UTF-32.|Unicode (UTF-32)|✓|  
|12001|utf-32BE|Unicode (UTF-32 Big endian)|✓|  
|20000|x-Chinese-CNS|Chiński tradycyjny (CN)||  
|20001|x-cp20001|Całkowitego (wersja tajwańska)||  
|20002|x-Chinese-Eten|Chiński tradycyjny (Eten)||  
|20003|x-cp20003|IBM5550 Tajwan||  
|20004|x-cp20004|TeleText Tajwan||  
|20005|x-cp20005|Wang Tajwan||  
|20105|x-IA5|Europa Zachodnia (IA5)||  
|20106|x IA5 niemiecki|Niemiecki (IA5)||  
|20107|x-IA5 — szwedzki|Szwedzki (IA5)||  
|20108|x-IA5-Norwegian|Norweski (IA5)||  
|20127|us-ascii|US-ASCII|✓|  
|20261|x-cp20261|T.61||  
|20269|x-cp20269|ISO-6937||  
|20273|IBM273|IBM EBCDIC (Niemcy)||  
|20277|IBM277|IBM EBCDIC (Dania Norwegia)||  
|20278|IBM278|IBM EBCDIC (Finlandia Szwecja)||  
|20280|IBM280|IBM EBCDIC (Włochy)||  
|20284|IBM284|IBM EBCDIC (Hiszpania)||  
|20285|IBM285|IBM EBCDIC (UK)||  
|20290|IBM290|IBM EBCDIC (japoński katakana)||  
|20297|IBM297|IBM EBCDIC (Francja)||  
|20420|IBM420|IBM EBCDIC (arabski)||  
|20423|IBM423|IBM EBCDIC (grecki)||  
|20424|IBM424|IBM EBCDIC (wersja hebrajska)||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (koreański rozszerzony)||  
|20838|IBM tajski|IBM EBCDIC (tajski)||  
|20866|KOI8-r|Cyrylica (KOI8-R)||  
|20871|IBM871|IBM EBCDIC (islandzki)||  
|20880|IBM880|IBM EBCDIC (rosyjski cyrylica)||  
|20905|IBM905|IBM EBCDIC (turecki)||  
|20924|IBM00924|IBM Latin-1||  
|20932|EUC-JP|Japoński (JIS 0208-1990 i 0212-1990)||  
|20936|x-cp20936|Chiński uproszczony (GB2312-80)|✓|  
|20949|x-cp20949|Koreański Wansung|✓|  
|21025|cp1025|IBM EBCDIC (serbski bułgarski cyrylica)||  
|21866|KOI8-u|Cyrylica (KOI8-U)||  
|28591|ISO 8859-1|Europa Zachodnia (ISO)|✓|  
|28592|ISO 8859-2|Europa Środkowa (ISO)||  
|28593|ISO 8859-3|Łaciński 3 (ISO)||  
|28594|ISO-8859-4|Bałtycki (ISO)||  
|28595|ISO-8859-5|Cyrylica (ISO)||  
|28596|ISO-8859-6|Arabski (ISO)||  
|28597|ISO-8859-7|Grecki (ISO)||  
|28598|ISO-8859-8|Hebrajski (ISO-Visual)|✓|  
|28599|ISO-8859-9|Turecki (ISO)||  
|28603|ISO-8859-13|Estoński (ISO)||  
|28605|ISO-8859-15|Łaciński 9 (ISO)||  
|29001|x-Europa|Europa||  
|38598|iso-8859-8-i|Hebrajski (ISO-logiczna)|✓|  
|50220|iso-2022-jp|Japoński (JIS)|✓|  
|50221|csISO2022JP|Japoński (JIS dozwolony, 1-bajtowy Kana)|✓|  
|50222|iso-2022-jp|Japoński (JIS dozwolony, 1-bajtowy Kana - tak / SI)|✓|  
|50225|ISO-2022-kr|Koreański (ISO)|✓|  
|50227|x-cp50227|Chiński uproszczony (ISO-2022)|✓|  
|51932|euc-jp|Japoński (EUC)|✓|  
|51936|EUC-CN|Chiński uproszczony (EUC)|✓|  
|51949|euc-kr|Koreański (EUC)|✓|  
|52936|hz-gb-2312|Chiński uproszczony (HZ)|✓|  
|54936|GB18030|Chiński uproszczony (GB18030)|✓|  
|57002|x-iscii-de|ISCII dewanagari|✓|  
|57003|x-iscii-be|ISCII Bengali|✓|  
|57004|x-iscii — ta|ISCII tamilski|✓|  
|57005|x-iscii-te|ISCII Telugu|✓|  
|57006|x-iscii — jako|ISCII assamski|✓|  
|57007|x iscii lub|ISCII orija|✓|  
|57008|x-iscii-ka|ISCII Kannada|✓|  
|57009|x-iscii-ma|ISCII Malayalam|✓|  
|57010|x-iscii-gu|ISCII Gujarati|✓|  
|57011|x-iscii-pa|ISCII Punjabi|✓|  
|65000|UTF-7|Unicode (UTF-7)|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|  
  
 Następujące przykładowe wywołania <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> i <xref:System.Text.Encoding.GetEncoding%28System.String%29> metody w celu uzyskania Grecki (system Windows) kodu kodowanie strony. Porównuje <xref:System.Text.Encoding> obiekty zwrócone przez wywołania metody, aby pokazać, czy są równe, a następnie mapy wyświetla punkt kodu Unicode i odpowiedniego strony kodowej dla każdego znaku w greckiego alfabetu.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 UTF-16 i UTF-32 koderów mogą używać kolejności bajtów big endian (najbardziej znaczący bajt pierwszy) lub małego kolejność bajtów endian (najmniej znaczący bajt pierwszy). Na przykład Wielka litera (U + 0041) jest szeregowana jako zgodna (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian UTF-16: 00 41  
  
-   UTF-16 little endian bajtów kolejności: 41 00  
  
-   Kolejności bajtów big endian UTF-32: 00 00 00 41  
  
-   UTF-32 little endian bajtów kolejności: 41 00 00 00  
  
 Jest zazwyczaj bardziej wydajne do przechowywania przy użyciu kolejności bajtów natywnego znaków Unicode. Na przykład lepiej jest użycie małego kolejność endian bajtów little endian platform, takich jak komputery Intel.  
  
 <xref:System.Text.Encoding.GetPreamble%2A> Metoda pobiera tablicę bajtów zawierającą znacznika kolejności bajtów (BOM). To tablica bajtów jest prefiksem zakodowanego strumieniu, pomaga dekoder, aby zidentyfikować używany format kodowania.  
  
 Aby uzyskać więcej informacji o kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Należy pamiętać, że błędy, aby umożliwić kodowania klasy:  
  
-   Zmień w trybie dyskretnym na "?" znaków.  
  
-   Użyj znaku "optymalnie".  
  
-   Zmień zachowanie specyficzne dla aplikacji za pomocą <xref:System.Text.EncoderFallback> i <xref:System.Text.DecoderFallback> klasy ze znakiem zastępującym U + FFFD Unicode.  
  
 Każdy błąd strumienia danych powinien zgłosić wyjątek. Aplikacja używa flagi "throwonerror", jeśli jest to wymagane lub korzysta z <xref:System.Text.EncoderExceptionFallback> i <xref:System.Text.DecoderExceptionFallback> klasy. Najlepsze dopasowanie powrotu często nie jest zalecane, ponieważ może spowodować utratę danych lub pomyłek i działa wolniej niż zamiany prostego znaku. Dla kodowania ANSI najlepsze dopasowanie zachowanie jest ustawieniem domyślnym.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z kodowań na inny.  
  
> [!NOTE]
>  Tablica typu byte [] to jedyny typ w tym przykładzie, który zawiera dane zakodowane. Typy .NET Char i ciąg sami Unicode, są tak <xref:System.Text.Encoding.GetChars%2A> wywołania dekoduje dane do Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne zastąpienie tego konstruktora.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Kod identyfikator strony preferowaną metodę kodowania.  
  
 —lub—  
  
 0, aby użyć domyślnego kodowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy, która odpowiada na określoną stronę kodową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne zastąpienie tego konstruktora.  
  
 Tworzenie wywołania do tego konstruktora z klasy pochodnej <xref:System.Text.Encoding> obiekt, który używa zarówno kodowania i dekodowania operacji powrotu najlepszego dopasowania. Zarówno <xref:System.Text.Encoding.DecoderFallback%2A> i <xref:System.Text.Encoding.EncoderFallback%2A> właściwości tylko do odczytu i nie może być modyfikowany. Aby kontrolować strategia rezerwowa dla klasą pochodną <xref:System.Text.Encoding>, wywołaj <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> jest mniejsza od zera.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Kod identyfikator strony kodowania.</param>
        <param name="encoderFallback">Obiekt, który udostępnia procedury obsługi błędów, gdy znak nie może zostać zakodowany przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który udostępnia procedurę obsługi błędów podczas sekwencji bajtów nie może zostać odczytany z bieżącego kodowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoding" /> klasy, która odpowiada określona strona kodowa z określonym koder i dekoder strategii rezerwowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest `protected`; pochodnej klasy jej zastąpienie.  
  
 Ten konstruktor jest wywoływana z klasy pochodnej w celu kontrolowania powrotu kodowania i dekodowania strategii. <xref:System.Text.Encoding> Konstruktorów klas tworzyć tylko do odczytu obiektów kodowania, które nie zezwalaj na koder lub dekodera rezerwowej, można ustawić po utworzeniu obiektu.  
  
 Jeśli dowolny `encoderFallback` lub `decoderFallback` ma wartość null, najlepszego dopasowania powrotu jest używany jako odpowiednie strategia rezerwowa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Kodowanie zestawu znaków (7-bitowym) ASCII.</summary>
        <value>Kodowanie znaków ASCII (7-bitowym) Ustaw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaki ASCII są ograniczone do najniższego 128 znaków Unicode z 0000 U + do U + 007F.  
  
 Wybierając kodowanie ASCII dla aplikacji, należy rozważyć następujące kwestie:  
  
-   Kodowanie ASCII jest zazwyczaj odpowiednia dla protokołów, które wymagają ASCII.  
  
-   Jeśli wymagane, 8-bitowego kodowania (który jest niepoprawnie czasami nazywany "ASCII"), zaleca się kodowania UTF-8 za pośrednictwem ASCII kodowania. Znaki 0 7F wyniki są identyczne, ale używanie UTF-8 pozwala uniknąć utraty danych, zezwalając reprezentacja wszystkich znaków Unicode, które są można przedstawić. Należy zauważyć, że kodowanie ASCII ma 8 bitów niejednoznaczności umożliwiająca złośliwym korzystaniem, ale kodowania UTF-8 usuwa niejednoznaczności 8 bitowej.  
  
-   Przed programu .NET Framework w wersji 2.0 .NET Framework mogą fałszowania ignorując 8 bitowej. Począwszy od programu .NET Framework 2.0, punktów kodowych innych niż ASCII wrócić podczas dekodowania.  
  
 <xref:System.Text.ASCIIEncoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji. Używa wymiany rezerwowy, aby każdy ciąg, który go nie można zakodować i każdego bajtu, którego nie można go zdekodować Zamień na znak zapytania ("?") znaków. Zamiast tego można wywołać <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> metody tworzenia wystąpienia <xref:System.Text.ASCIIEncoding> obiektu, w których powrotu jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 Poniższy przykład ilustruje efekt ASCII kodowania znaków, które są poza zakresem ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie formatu UTF-16, który używa kolejności bajtów big endian.</summary>
        <value>Kodowania obiekt do formatu UTF-16, który używa kolejności bajtów big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji. Używa wymiany rezerwowy, aby każdy ciąg, który go nie można zakodować i każdego bajtu, którego nie można go zdekodować Zamień na znak zapytania ("?") znaków. Zamiast tego można wywołać <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia big endian <xref:System.Text.UnicodeEncoding> obiektu, w których powrotu jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Zwrócona <xref:System.Text.UnicodeEncoding> obiekt ma <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, i <xref:System.Text.Encoding.WebName%2A> właściwości, które zwracają nazwy "unicodeFFFE". Mimo że znacznika kolejności bajtów big endian UTF-16 szesnastkową FEFF, nazwa "unicodeFFFE" wybrano, ponieważ znacznika kolejności bajtów jest wyświetlany jako szesnastkowe FFFE na little endian komputerów z systemem Windows.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik tekstowy z UTF-16 kodowanie przy użyciu kolejności bajtów big endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę bieżącego kodowania, która może być używany z tagów treści agent poczty.</summary>
        <value>Nazwa bieżącego <see cref="T:System.Text.Encoding" /> które mogą być używane z tagami treści agenta poczty.  
  
 —lub—  
  
 Ciąg pusty (""), jeśli bieżący <see cref="T:System.Text.Encoding" /> nie można użyć.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie nazwy treści, należy powinny wywoływać <xref:System.Text.Encoding.GetEncoding%2A> z <xref:System.Text.Encoding.BodyName%2A> właściwości. Często metoda pobiera inne kodowanie kodowania testu dostarczony w wywołaniu. Zazwyczaj tylko aplikacji poczty e-mail, trzeba pobrać takie kodowania; Większość aplikacji wymagających do opisywania kodowania powinny używać jej <xref:System.Text.Encoding.WebName%2A>.  
  
 W niektórych przypadkach wartość <xref:System.Text.Encoding.BodyName%2A> właściwość odpowiada międzynarodowe standard, który określa, że kodowania. To nie oznacza, że implementacja jest zgodna w pełni z tym standard.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z jedną lub kilka nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać go.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej tworzy kopię pobieżną bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <returns>Kopię bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klon jest zapisywalny nawet wtedy, gdy oryginalne <xref:System.Text.Encoding> obiekt jest tylko do odczytu. W związku z tym można zmodyfikować właściwości klonu.  
  
 Kopia pobieżna obiektu jest kopię tylko obiekt. Jeśli obiekt zawiera odwołania do innych obiektów, kopię pobieżną nie tworzy kopie określono obiektów. Odnosi się do oryginalnych obiektów zamiast tego. Z kolei głęboką kopię obiektu tworzy kopię obiektu i kopie wszystkich bezpośrednio lub pośrednio odwołuje się ten obiekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera kod identyfikator strony bieżącego <see cref="T:System.Text.Encoding" />.</summary>
        <value>Identyfikator strony kod bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z jedną lub kilka nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać go.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje tablicę bajtów z kodowań na inny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Format kodowania <c>bajtów</c>.</param>
        <param name="dstEncoding">Format kodowania docelowej.</param>
        <param name="bytes">Bajty do konwersji.</param>
        <summary>Konwertuje tablicę bajtów całego kodowań na inny.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierającego wyniki konwersji <paramref name="bytes" /> z <paramref name="srcEncoding" /> do <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje ciąg kodowany w formacie Unicode na ciąg kodowany w formacie ASCII. Ponieważ obiekt kodowanie ASCII zwracany przez <xref:System.Text.Encoding.ASCII%2A> właściwość używa wymiany rezerwowy i znak Pi nie jest częścią zestawu znaków ASCII, znak Pi jest zastępowany znak zapytania jako dane wyjściowe w przykładzie.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="dstEncoding" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Kodowanie tablicy źródłowej <c>bajtów</c>.</param>
        <param name="dstEncoding">Kodowanie tablicy danych wyjściowych.</param>
        <param name="bytes">Tablica bajtów do konwersji.</param>
        <param name="index">Indeks pierwszego elementu obiektu <c>bajtów</c> do przekonwertowania.</param>
        <param name="count">Liczba bajtów do konwersji.</param>
        <summary>Konwertuje zakresu bajtów w tablicy bajtowej kodowań na inny.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierający wynik konwersji zakresu bajtów w <paramref name="bytes" /> z <paramref name="srcEncoding" /> do <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="dstEncoding" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> i <paramref name="count" /> nie określono nieprawidłowy zakres w tablicy bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.DecoderFallback" /> obiektu dla bieżącej <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <value>Obiekt rezerwowy dekodera dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy nie można dekodować sekwencji zakodowanego bajtów na znak. Obsługiwany jest jeden z następujących typów programu obsługi:  
  
-   Najlepszego dopasowania rezerwowy obsługi, który zastępuje bajtów, których nie można zdekodować niektórych znaków odpowiednich obiektów zastępczych.  
  
-   Zastąpienie rezerwowy obsługi, który zastępuje niektórych znak zastępczy dowolnego bajtów, które nie mogą zostać zdekodowane. .NET Framework zawiera jeden obsługi rezerwowego zastąpienia, <xref:System.Text.DecoderFallback>, domyślnie zastępuje bajtów, których nie można zdekodować znakiem zapytania ("?") znaków.  
  
-   Rezerwowy program obsługi wyjątku, który zgłasza wyjątek, gdy nie można dekodować bajtów. .NET Framework zawiera jeden rezerwowy program obsługi wyjątku, <xref:System.Text.DecoderExceptionFallback>, który zgłasza <xref:System.Text.DecoderFallbackException> gdy nie można dekodować bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji set jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można przypisać wartości w operacji set, ponieważ bieżący <see cref="T:System.Text.Encoding" /> obiekt jest tylko do odczytu.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne kodowanie używane dla tej implementacji .NET.</summary>
        <value>Domyślnym kodowaniem dla tej implementacji .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Różne komputery mogą używać różnych kodowań jako domyślny, a kodowanie domyślne można zmienić na pojedynczym komputerze. Jeśli używasz <xref:System.Text.Encoding.Default%2A> kodowanie do kodowania i dekodowania danych między komputerami są przesyłane strumieniowo lub pobrać zmienia się na tym samym komputerze, jej może tłumaczyć danych niepoprawnie. Ponadto kodowanie zwrócony przez <xref:System.Text.Encoding.Default%2A> właściwość używa najlepszego dopasowania powrotu do mapowania nieobsługiwane znaki obsługiwane za pomocą stron kodowych znaków. Z tego względu przy użyciu kodowania domyślnego nie jest zalecane. Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować, należy użyć kodowanie Unicode, takich jak <xref:System.Text.UTF8Encoding> lub <xref:System.Text.UnicodeEncoding>. Aby upewnić się, że ten sam format jest używany do kodowania i dekodowania można użyć również wyższego poziomu protokołu.  

### <a name="the-default-property-in-the-net-framework"></a>Właściwości domyślne w programie .NET Framework

W programie .NET Framework na pulpicie systemu Windows <xref:System.Text.Encoding.Default%2A> właściwość zawsze pobiera stronę kodową systemu i tworzy <xref:System.Text.Encoding> obiekt, który odpowiada on. Strona kodowa active może być strony kodowej ANSI, która zawiera zestaw oraz dodatkowe znaki, które różnią się za pomocą stron kodowych znaków ASCII. Ponieważ wszystkie <xref:System.Text.Encoding.Default%2A> kodowanie oparte na stronach kodowych ANSI utratę danych, rozważ użycie <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> zamiast kodowania. UTF-8 często jest takie same jak w 00 U + U + 7F zakresu, ale może zakodować znaki spoza zakresu ASCII bez utraty.

## <a name="the-default-property-on-net-core"></a>Właściwości domyślne w .NET Core

Na .NET Core <xref:System.Text.Encoding.Default%2A> właściwość zawsze zwraca <xref:System.Text.UTF8Encoding>. UTF-8 jest obsługiwane we wszystkich systemach operacyjnych (Windows, Linux lub Max OS X) na których działają aplikacje .NET Core.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.EncoderFallback" /> obiektu dla bieżącej <see cref="T:System.Text.Encoding" /> obiektu.</summary>
        <value>Obiekt rezerwowy kodera dla bieżącego <see cref="T:System.Text.Encoding" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy nie można przekonwertować znak sekwencji zakodowanego bajtów. Obsługiwany jest jeden z następujących typów programu obsługi:  
  
-   Najlepszego dopasowania rezerwowy obsługi, który zastępuje znaki, które nie może zostać zakodowany niektórych znaków odpowiednich obiektów zastępczych.  
  
-   Zastąpienie rezerwowy obsługi, który zastępuje znaki, które nie może zostać zakodowany niektórych zastąpienie dowolnego znaku. .NET Framework zawiera jeden obsługi rezerwowego zastąpienia, <xref:System.Text.EncoderFallback>, która domyślnie zastępuje znaki, które nie może zostać zakodowany znakiem zapytania ("?") znaków.  
  
-   Rezerwowy program obsługi wyjątku, który zgłasza wyjątek, gdy nie może zostać zakodowany znaków. .NET Framework zawiera jeden rezerwowy program obsługi wyjątku, <xref:System.Text.EncoderExceptionFallback>, który zgłasza <xref:System.Text.EncoderFallbackException> gdy nie można dekodować znaków.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji set jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można przypisać wartości w operacji set, ponieważ bieżący <see cref="T:System.Text.Encoding" /> obiekt jest tylko do odczytu.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera zrozumiałą dla użytkownika opis bieżącego kodowania.</summary>
        <value>Zrozumiałą dla użytkownika opis bieżącej <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A> Właściwości jest przeznaczony do wyświetlania. Aby znaleźć nazwę, które mogą zostać przekazane do <xref:System.Text.Encoding.GetEncoding%2A> metody, użyj <xref:System.Text.Encoding.WebName%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z jedną lub kilka nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać go.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> jest taki sam, jak bieżące wystąpienie.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.Encoding" /> i jest taki sam, jak bieżące wystąpienie w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa wystąpienia <xref:System.Text.Encoding> są traktowane jako równe, jeśli odpowiada tej samej strony kodowej i ich `EncoderFallback` i `DecoderFallback` obiekty są takie same. W szczególności pochodnej kodowe wszystkie mają stronę kodową 0 i ich przejścia są zazwyczaj `null` (`Nothing` w języku Visual Basic .NET). W związku z tym są wszystkie uważane za taki sam do siebie. W wyniku jest to, że gdy <xref:System.Text.Encoding.Equals%2A> używany do wypełnienia tabeli skrótów, wszystkich pochodnych równy Porównaj kodowania i dzielą się na tym samym gnieździe tabeli skrótów.  
  
   
  
## Examples  
 Poniższy przykład pobiera dwa wystąpienia tego samego kodowania (jeden przez stronę kodową) i drugi według nazwy i sprawdza ich równości.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający znaki do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów wyprodukowanych przez kodowanie znaków określoną tablicę znaków.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie znaków określoną tablicę znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołaj <xref:System.Text.Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu wersji <xref:System.Text.Encoding.GetBytes%2A> metody.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Jeśli aplikacji musi dokonać konwersji dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów wyprodukowanych przez kodowanie znaków w określonym ciągu.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołaj <xref:System.Text.Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciąg, ciąg wersji <xref:System.Text.Encoding.GetBytes%2A> jest zalecane.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania ciąg lub zakresu w ciągu koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków, zaczynając od wskaźnika określony znak.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Encoding.GetBytes%2A> wymaga do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka kwestii dotyczących za pomocą następujących metod:  
  
-   Aplikacja może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A> metody.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%2A> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów utworzonego przez zestaw znaków z określoną tablicę znaków kodowania.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołaj <xref:System.Text.Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany.  
  
-   Jeśli aplikacja obsługuje dane wejściowe ciąg, ciąg wersji <xref:System.Text.Encoding.GetBytes%2A> jest zalecane.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania trzy znaki z tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków w kolejności bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający znaki do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje znaków określoną tablicę znaków w kolejności bajtów.</summary>
        <returns>Tablica bajtów zawierająca wyniki z określonego zestawu znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera znaki dwuskładnikowe może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętuje tego zastępczym wysokiego poziomu, aby można go łączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> Nie można zachować stanu, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy wywołać ciągu <xref:System.Text.Encoding.GetBytes%2A> metody.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający znaki do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje wszystkie znaki w ciągu określonej w kolejności bajtów.</summary>
        <returns>Tablica bajtów zawierająca wyniki z określonego zestawu znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera znaki dwuskładnikowe może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętuje tego zastępczym wysokiego poziomu, aby można go łączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> Nie można zachować stanu, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania ciąg lub zakresu w ciągu koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków z określoną tablicę znaków w kolejności bajtów.</summary>
        <returns>Tablica bajtów zawierająca wyniki z określonego zestawu znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera znaki dwuskładnikowe może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętuje tego zastępczym wysokiego poziomu, aby można go łączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> Nie można zachować stanu, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania trzy znaki z tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków, zaczynając od wskaźnika określony znak do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określonym bajcie.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Encoding.GetBytes%2A> wymaga aby przechowywać wynikowy bajtów, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Jeśli dane do konwersji są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że trzeba ją podzielić na mniejsze bloki, należy użyć podanego obiektu <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> odpowiednio przez metodę <xref:System.Text.Encoding.GetDecoder%2A> lub <xref:System.Text.Encoding.GetEncoder%2A> klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera znaki dwuskładnikowe może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętuje tego zastępczym wysokiego poziomu, aby można go łączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> Nie można zachować stanu, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera znaki dwuskładnikowe może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętuje tego zastępczym wysokiego poziomu, aby można go łączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> Nie można zachować stanu, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania trzy znaki z tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków z określonego ciągu w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 <xref:System.Text.Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> metodę, która obsługuje wiele konwersje na pojedynczy strumień wejściowy.  
  
 Wiele wersji <xref:System.Text.Encoding.GetByteCount%2A> i <xref:System.Text.Encoding.GetBytes%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacji może być konieczne kodowania wiele wprowadzanie znaków na stronę kodową i przetwarzanie znaków, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy zachować stanu między wywołaniami, biorąc pod uwagę stanu, który jest zachowywane przez <xref:System.Text.Encoder> obiekt używany. (Na przykład sekwencja znaków, który zawiera znaki dwuskładnikowe może kończyć się znakiem zastępczym wysokiego poziomu. <xref:System.Text.Encoder> Zapamiętuje tego zastępczym wysokiego poziomu, aby można go łączyć z dwuskładnikowego na początku następujące wywołanie. <xref:System.Text.Encoding> Nie można zachować stanu, więc znak zostanie wysłane do <xref:System.Text.EncoderFallback>.)  
  
-   Jeśli aplikacja obsługuje ciąg w danych wejściowych, należy użyć ciągu <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   Znak buforu wersji Unicode <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku wielu wywołań za pomocą <xref:System.Text.Encoder> obiektu lub wstawianie do istniejących buforów. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku <xref:System.Text.Encoding.GetBytes%2A> najlepszym rozwiązaniem jest wersji, która obsługuje tablice typu byte.  
  
-   Należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetByteCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały. Kodowanie ciągłego strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania ciąg lub zakresu w ciągu koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania wszystkich bajtów w określonej tablicy bajtów.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> do przechowywania wynikowy znaków, należy używać <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy użyć <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> metody. <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami.  
  
-   Jeśli aplikacja obsługuje ciągów, należy użyć <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów, licząc od wskaźnika określonym bajcie.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Encoding.GetChars%2A> wymaga aby wynikowe znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami.  
  
-   Jeśli aplikacja obsługuje ciągów, zaleca się używania <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy używać <xref:System.Text.Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami.  
  
-   Jeśli aplikacja obsługuje ciągów, zaleca się używania <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z kodowań na inny.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje zakresu bajtów na tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje wszystkich bajtów w określonej tablicy bajtów na zestaw znaków.</summary>
        <returns>Tablica znaków, zawierającego wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> pobiera znaków z sekwencji bajtów wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje odrębny konwersje podczas <xref:System.Text.Decoder> jest przeznaczony dla wielu przebiegów w jednym strumienia wejściowego.  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do działania na znaków Unicode, nie na dowolnych danych binarnych, takich jak tablice typu byte. Jeśli trzeba kodować dowolne dane binarne na tekst, należy użyć protokołu, takie jak uuencode, która jest zaimplementowana za pomocą metod, takich jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym <xref:System.Text.Encoding.GetChars%2A> połączenia i kontynuować od początku następnej <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> wywoła powrotu tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętuje tych sekwencji dla następnego wywołania funkcji.)  
  
-   Jeśli aplikacja obsługuje ciągów, zaleca się używania <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów z określonej tablicy bajtów w zestawie znaków.</summary>
        <returns>Tablica znaków, zawierającego wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> pobiera znaków z sekwencji bajtów wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje odrębny konwersje podczas <xref:System.Text.Decoder> jest przeznaczony dla wielu przebiegów w jednym strumienia wejściowego.  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do działania na znaków Unicode, nie na dowolnych danych binarnych, takich jak tablice typu byte. Jeśli trzeba kodować dowolne dane binarne na tekst, należy użyć protokołu, takie jak uuencode, która jest zaimplementowana za pomocą metod, takich jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym <xref:System.Text.Encoding.GetChars%2A> połączenia i kontynuować od początku następnej <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> wywoła powrotu tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętuje tych sekwencji dla następnego wywołania funkcji.)  
  
-   Jeśli aplikacja obsługuje ciągów, zaleca się używania <xref:System.Text.Encoding.GetString%2A> metody. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje zakresu bajtów na tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisu.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów, licząc od wskaźnika określonym bajcie do zestawu znaków, które są przechowywane, zaczynając od wskaźnika określony znak.</summary>
        <returns>Rzeczywista liczba znaków zapisany w lokalizacji wskazanej przez <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Encoding.GetChars%2A> wymaga aby wynikowe znaków, należy użyć <xref:System.Text.Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> pobiera znaków z sekwencji bajtów wejściowych. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje odrębny konwersje podczas <xref:System.Text.Decoder> jest przeznaczony dla wielu przebiegów w jednym strumienia wejściowego.  
  
 Jeśli dane do konwersji są dostępne tylko w blokach sekwencyjnych (takich jak dane odczytane ze strumienia) lub jeśli ilość danych jest tak duża, że trzeba ją podzielić na mniejsze bloki, należy użyć podanego obiektu <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> odpowiednio przez metodę <xref:System.Text.Encoding.GetDecoder%2A> lub <xref:System.Text.Encoding.GetEncoder%2A> klasy pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do działania na znaków Unicode, nie na dowolnych danych binarnych, takich jak tablice typu byte. Jeśli trzeba kodować dowolne dane binarne na tekst, należy użyć protokołu, takie jak uuencode, która jest zaimplementowana za pomocą metod, takich jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym <xref:System.Text.Encoding.GetChars%2A> połączenia i kontynuować od początku następnej <xref:System.Text.Encoding.GetChars%2A> wywołania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> wywoła powrotu tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętuje tych sekwencji dla następnego wywołania funkcji.)  
  
-   Jeśli aplikacja obsługuje wyjść ciąg <xref:System.Text.Encoding.GetString%2A> zaleca się metodę. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów z określonej tablicy bajtów do określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków w zapisywane <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy używać <xref:System.Text.Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > pobiera znaków z sekwencji bajtów wejściowych. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > różni się od <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> ponieważ <xref:System.Text.Encoding> oczekuje odrębny konwersje podczas <xref:System.Text.Decoder> zaprojektowano pod kątem wiele przekazuje jednego strumienia wejściowego.  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 **Uwaga** ta metoda jest przeznaczona do działania na znaków Unicode, nie na dowolnych danych binarnych, takich jak tablice typu byte. Jeśli trzeba kodować dowolne dane binarne na tekst, należy użyć protokołu, takie jak uuencode, która jest zaimplementowana za pomocą metod, takich jak <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Encoding.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Metoda oczekuje odrębny konwersje contrast do <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> metodę, która obsługuje wiele przebiegów w jednym strumienia wejściowego.  
  
 Wiele wersji <xref:System.Text.Encoding.GetCharCount%2A> i <xref:System.Text.Encoding.GetChars%2A> są obsługiwane. Poniżej przedstawiono kilka programowania kwestii dotyczących użycia tych metod:  
  
-   Aplikacja może być konieczne dekodowania wielu bajtów wejściowych od strony kodowej i przetwarzać bajty, korzystając z wielu wywołań. W takim przypadku prawdopodobnie należy do zarządzania stanem między wywołaniami, ponieważ sekwencji bajtów może zostać przerwane podczas przetwarzania w partiach. (Na przykład część sekwencji shift ISO-2022 może kończyć się jednym [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > połączenia i kontynuować od początku następnej [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > wywołania. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > wywoła powrotu tych niekompletne sekwencji, ale <xref:System.Text.Decoder> zapamiętuje tych sekwencji dla następnego wywołania funkcji.)  
  
-   Jeśli aplikacja obsługuje wyjść ciąg <xref:System.Text.Encoding.GetString%2A> zaleca się metodę. Ponieważ ta metoda musi sprawdzić długość ciągu i przydzielić buforu, jest wolniejsze, ale powstałe w ten sposób <xref:System.String> typu zaleca się.  
  
-   Wersja bajtów <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> umożliwia niektóre szybkie techniki, zwłaszcza w przypadku dużych buforów wielu wywołań. Należy przy tym pamiętać, że ta wersja — metoda czasami jest niebezpieczne, ponieważ wskaźniki są wymagane.  
  
-   Aplikację należy przekonwertować dużej ilości danych, należy używać ponownie bufor wyjściowy. W takim przypadku [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > wersji, że obsługuje output znaków najlepszym rozwiązaniem jest buforów.  
  
-   Należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> zamiast metody <xref:System.Text.Encoding.GetCharCount%2A>. Metoda konwersji konwertuje jak najwięcej danych i zgłasza wyjątek, jeśli bufor wyjściowy jest zbyt mały. Ciągłe dekodowania strumienia, ta metoda jest często najlepszym rozwiązaniem.  
  
   
  
## Examples  
 Poniższy przykład konwertuje ciąg z kodowań na inny.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje zakresu bajtów na tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="byteindex" /> i <paramref name="byteCount" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  
  
 —lub—  
  
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> nie ma wystarczającej wydajności z <paramref name="charIndex" /> do końca tablicy, tak aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera dekoder, który konwertuje zakodowanego sekwencji bajtów na sekwencji znaków.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> konwertująca zakodowanego sekwencji bajtów w sekwencji znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów na bloki kolejnych znaków w sposób podobny do <xref:System.Text.Encoding.GetChars%2A> metody tej klasy. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami tak poprawnie dekoduje sekwencji bajtów, obejmujące bloków. <xref:System.Text.Decoder> Również zachowuje bajtów końcowych na końcu bloki danych i używa bajtów końcowych w następnej operacji dekodowania. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja zwraca <see cref="T:System.Text.Decoder" /> wywołującym <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> i <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> metody bieżącego <see cref="T:System.Text.Encoding" />. Należy przesłonić tę metodę, aby zwrócić <see cref="T:System.Text.Decoder" /> który przechowuje stanu między wywołaniami.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera koder, który konwertuje sekwencji znaków Unicode w zakodowanym sekwencji bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> sekwencji znaków Unicode, który konwertuje na zakodowanego sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków na kolejne bloki bajtów w sposób podobny do <xref:System.Text.Encoding.GetBytes%2A> metody tej klasy. Jednak <xref:System.Text.Encoder> przechowuje informacje o stanie między wywołaniami tak niepoprawnie koduje sekwencji znaków, które obejmują bloków. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloki danych i używa znaki końcowe w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane zastępczym wysokiego poziomu, a pasujące dwuskładnikowego może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Domyślna implementacja zwraca <see cref="T:System.Text.Encoder" /> wywołującym <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> i <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> metody bieżącego <see cref="T:System.Text.Encoding" />. Należy przesłonić tę metodę, aby zwrócić <see cref="T:System.Text.Encoder" /> który przechowuje stanu między wywołaniami.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kodowania dla określonej strony kodowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Kod identyfikator strony preferowaną metodę kodowania. Możliwe wartości są wyświetlane w kolumnie tabeli, która jest wyświetlana w stronę kodową <see cref="T:System.Text.Encoding" /> klasy tematu.  
  
 —lub—  
  
 0 (zero), aby użyć domyślnego kodowania.</param>
        <summary>Zwraca kodowanie skojarzonych z identyfikatorem strony określony kod.</summary>
        <returns>Kodowanie, które jest skojarzone z określoną stronę kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program obsługi rezerwowego zależy od typu kodowania `codepage`. Jeśli `codepage` (DBCS) Kodowanie zestawu znaków kodu strony lub dwubajtowych, najlepszego dopasowania rezerwowy program obsługi jest używany. W przeciwnym razie obsługi rezerwowego zastępczy jest używany. Te rezerwowy programy obsługi zdarzeń nie może być odpowiednie dla twojej aplikacji. Aby określić rezerwowy używane przez kodowanie określone przez program obsługi `codepage`, można wywołać <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> przeciążenia.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Metoda zależy od podstawowej platformy, aby obsługiwać większość stron kodowych. .NET Framework natywnie obsługuje jednak niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> klasy tematu. Alternatywnie możesz wywołać <xref:System.Text.Encoding.GetEncodings%2A> metody, aby uzyskać tablicę <xref:System.Text.EncodingInfo> obiektów, które zawiera informacje o wszystkich kodowania.  
  
 Oprócz kodowania, które bardzo są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca wszelkie dodatkowe kodowania, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu. Jeśli kodowanie tego samego został zarejestrowany przez wiele <xref:System.Text.EncodingProvider> obiekty, ta metoda zwraca ostatnią zarejestrowany.  

Możesz także podać wartość 0 dla `codepage` argumentu. Dokładne zachowanie zależy od tego, czy wszystkie kodowania udostępnione przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu:

- Jeśli co najmniej jednego dostawcy kodowania zostały zarejestrowane, zwraca kodowanie ostatniego zarejestrowanego dostawcę wybrany tak, aby zwrócić kodowania, kiedy <xref:System.Text.Encoding.GetEncoding%2A> metody jest przekazywany `codepage` argumentu o wartości 0.     

- W programie .NET Framework, jeśli bez kodowania dostawca został zarejestrowany, jeśli <xref:System.Text.CodePagesEncodingProvider> zarejestrowanego dostawcę kodowania, lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, zwraca stronę kodową systemu operacyjnego. Aby określić stronę kodową dla systemów Windows, należy wywołać systemu Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) funkcji .NET Framework na pulpicie systemu Windows.

- .NET Core, jeśli nie, kodowania dostawca został zarejestrowany lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, zwraca <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Niektóre nieobsługiwany kod strony Przyczyna <xref:System.ArgumentException> zostanie wygenerowany, inne powodować <xref:System.NotSupportedException>. W związku z tym kodzie należy przechwytywać wszystkie wyjątki wymienione w sekcji wyjątki.  
  
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i zmieniać na jednym komputerze, co może prowadzić do uszkodzenia danych. Z tego powodu w przypadku stronę kodową strony kodowej ANSI, kodowania i dekodowania danych za pomocą domyślną stronę kodową zwrócony przez `Encoding.GetEncoding(0)` nie jest zalecane. Najbardziej spójne wyniki należy używać kodowanie Unicode, takie jak (strona kodowa 65001) UTF-8 lub UTF-16, zamiast do konkretnej strony kodowej.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Konstruktory klas pochodnych należy używać można pobrać wystąpienia z innymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasy zawiera konstruktora, który umożliwia wykrywanie błędów.  

   
  
## Examples  
 Poniższy przykład pobiera dwa wystąpienia tego samego kodowania (jeden za pomocą stron kodowych) i drugi według nazwy i sprawdza ich równości.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> jest mniejsza niż zero lub większy niż 65 535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> nie jest obsługiwana przez platformę podstawowej.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> nie jest obsługiwana przez platformę podstawowej.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa strony kodu preferowanych kodowania. Każda wartość zwracana przez <see cref="P:System.Text.Encoding.WebName" /> właściwości jest nieprawidłowa. Możliwe wartości są wymienione w kolumnie Nazwa tabeli, która jest wyświetlana w <see cref="T:System.Text.Encoding" /> klasy tematu.</param>
        <summary>Zwraca kodowanie skojarzone z nazwą strony określony kod.</summary>
        <returns>Kodowanie skojarzone z określoną stronę kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program obsługi rezerwowego zależy od typu kodowania `name`. Jeśli `name` (DBCS) Kodowanie zestawu znaków kodu strony lub dwubajtowych, najlepszego dopasowania rezerwowy program obsługi jest używany. W przeciwnym razie obsługi rezerwowego zastępczy jest używany. Te rezerwowy programy obsługi zdarzeń nie może być odpowiednie dla twojej aplikacji. Aby określić rezerwowy używane przez kodowanie określone przez program obsługi `name`, można wywołać <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> przeciążenia.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Metoda zależy od podstawowej platformy, aby obsługiwać większość stron kodowych. .NET Framework natywnie obsługuje jednak niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> klasy tematu. Alternatywnie możesz wywołać <xref:System.Text.Encoding.GetEncodings%2A> metody, aby uzyskać tablicę <xref:System.Text.EncodingInfo> obiektów, które zawiera informacje o wszystkich kodowania. 
  
 Oprócz kodowania, które bardzo są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca wszelkie dodatkowe kodowania, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu. Jeśli kodowanie tego samego został zarejestrowany przez wiele <xref:System.Text.EncodingProvider> obiekty, ta metoda zwraca ostatnią zarejestrowany.  
   
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach, lub można zmienić na pojedynczym komputerze, co może prowadzić do uszkodzenia danych. Najbardziej spójne wyniki należy używać Unicode, takie jak (strona kodowa 65001) UTF-8 lub UTF-16, zamiast do konkretnej strony kodowej.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Konstruktory klas pochodnych należy używać można pobrać wystąpienia z innymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasy zawiera konstruktora, który umożliwia wykrywanie błędów.  
  
## Examples  
 Poniższy przykład pobiera dwa wystąpienia tego samego kodowania (jeden za pomocą stron kodowych) i drugi według nazwy i sprawdza ich równości.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> nie jest prawidłowym kodem nazwą strony.  
  
 —lub—  
  
 Strona kodowa wskazywanym przez <paramref name="name" /> nie jest obsługiwany przez podstawowej platformy.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Kod identyfikator strony preferowaną metodę kodowania. Możliwe wartości są wyświetlane w kolumnie tabeli, która jest wyświetlana w stronę kodową <see cref="T:System.Text.Encoding" /> klasy tematu.  
  
 —lub—  
  
 0 (zero), aby użyć domyślnego kodowania.</param>
        <param name="encoderFallback">Obiekt, który udostępnia procedury obsługi błędów, gdy znak nie może zostać zakodowany przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który udostępnia procedurę obsługi błędów podczas sekwencji bajtów nie może zostać odczytany z bieżącego kodowania.</param>
        <summary>Zwraca kodowanie skojarzonych z identyfikatorem strony określony kod. Parametry określają program obsługi błędów dla znaków, które nie może zostać zakodowany i sekwencji bajtów, które nie mogą zostać zdekodowane.</summary>
        <returns>Kodowanie, które jest skojarzone z określoną stronę kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Niektóre strony nieobsługiwany kod spowodować wyjątek <xref:System.ArgumentException> zostanie wygenerowany, inne powodować <xref:System.NotSupportedException>. W związku z tym kodzie należy przechwytywać wszystkie wyjątki wymienione w sekcji wyjątki.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Metoda zależy od podstawowej platformy, aby obsługiwać większość stron kodowych. .NET Framework natywnie obsługuje jednak niektóre kodowania. Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> klasy tematu. Możesz wywołać <xref:System.Text.Encoding.GetEncodings%2A> metody pełne .NET Framework na pulpicie systemu Windows w celu uzyskania listy wszystkich kodowania.   
  
 Oprócz kodowania, które bardzo są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca wszelkie dodatkowe kodowania, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu.  Jeśli kodowanie tego samego został zarejestrowany przez wiele <xref:System.Text.EncodingProvider> obiekty, ta metoda zwraca ostatnią zarejestrowany.  

Możesz także podać wartość 0 dla `codepage` argumentu. Dokładne zachowanie zależy od tego, czy wszystkie kodowania udostępnione przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu:

- Jeśli co najmniej jednego dostawcy kodowania zostały zarejestrowane, zwraca kodowanie ostatniego zarejestrowanego dostawcę wybrany tak, aby zwrócić kodowania, kiedy <xref:System.Text.Encoding.GetEncoding%2A> metody jest przekazywany `codepage` argumentu o wartości 0.     

- W programie .NET Framework, jeśli bez kodowania dostawca został zarejestrowany, jeśli <xref:System.Text.CodePagesEncodingProvider> zarejestrowanego dostawcę kodowania, lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, zwraca stronę kodową.

- .NET Core, jeśli nie, kodowania dostawca został zarejestrowany lub jeśli nie zarejestrowanego dostawcy kodowania obsługuje `codepage` wartość 0, zwraca <xref:System.Text.UTF8Encoding> kodowania.

> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i zmieniać na jednym komputerze, co może prowadzić do uszkodzenia danych. Z tego powodu w przypadku stronę kodową strony kodowej ANSI, kodowania i dekodowania danych za pomocą domyślną stronę kodową zwrócony przez `Encoding.GetEncoding(0)` nie jest zalecane. Najbardziej spójne wyniki należy używać Unicode, takie jak (strona kodowa 65001) UTF-8 lub UTF-16, zamiast do konkretnej strony kodowej. 
  
 Uzyskanie kodowanie skojarzony ze stroną kodową można albo podaj wartość 0 dla `codepage` argument lub, jeśli kod jest uruchomiony na pełne .NET Framework na pulpicie systemu Windows, należy pobrać wartość <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> właściwości. Ustalenie bieżącej stronie kodowej active wywołanie systemu Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) funkcji .NET Framework na pulpicie systemu Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Konstruktory klas pochodnych należy używać można pobrać wystąpienia z innymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasy zawiera konstruktora, który umożliwia wykrywanie błędów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> metody.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> jest mniejsza niż zero lub większy niż 65 535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> nie jest obsługiwana przez platformę podstawowej.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> nie jest obsługiwana przez platformę podstawowej.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa strony kodu preferowanych kodowania. Każda wartość zwracana przez <see cref="P:System.Text.Encoding.WebName" /> właściwości jest nieprawidłowa. Możliwe wartości są wymienione w kolumnie Nazwa tabeli, która jest wyświetlana w <see cref="T:System.Text.Encoding" /> klasy tematu.</param>
        <param name="encoderFallback">Obiekt, który udostępnia procedury obsługi błędów, gdy znak nie może zostać zakodowany przy użyciu bieżącego kodowania.</param>
        <param name="decoderFallback">Obiekt, który udostępnia procedurę obsługi błędów podczas sekwencji bajtów nie może zostać odczytany z bieżącego kodowania.</param>
        <summary>Zwraca kodowanie skojarzone z nazwą strony określony kod. Parametry określają program obsługi błędów dla znaków, które nie może zostać zakodowany i sekwencji bajtów, które nie mogą zostać zdekodowane.</summary>
        <returns>Kodowanie, które jest skojarzone z określoną stronę kodową.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetEncoding%2A> Metoda zależy od podstawowej platformy, aby obsługiwać większość stron kodowych. .NET Framework natywnie obsługuje jednak niektóre kodowania.  
  
 Oprócz kodowania, które bardzo są obsługiwane w wersji określonej platformy .NET Framework <xref:System.Text.Encoding.GetEncoding%2A> metoda zwraca wszelkie dodatkowe kodowania, które są udostępniane przez zarejestrowanie <xref:System.Text.EncodingProvider> obiektu. Jeśli kodowanie tego samego został zarejestrowany przez wiele <xref:System.Text.EncodingProvider> obiekty, ta metoda zwraca ostatnią zarejestrowany. 
  
> [!NOTE]
>  Strony kodowe ANSI mogą być różne na różnych komputerach i zmieniać na jednym komputerze, co może prowadzić do uszkodzenia danych. Najbardziej spójne wyniki należy używać kodowanie Unicode, takie jak (strona kodowa 65001) UTF-8 lub UTF-16, zamiast do konkretnej strony kodowej.  
  
 Aby uzyskać listę stron kodowych, zobacz <xref:System.Text.Encoding> klasy tematu. Możesz wywołać <xref:System.Text.Encoding.GetEncodings%2A> metody pełne .NET Framework na pulpicie systemu Windows w celu uzyskania listy wszystkich kodowania.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Zwraca buforowane wystąpienie z ustawieniami domyślnymi. Konstruktory klas pochodnych należy używać można pobrać wystąpienia z innymi ustawieniami. Na przykład <xref:System.Text.UTF32Encoding> klasy zawiera konstruktora, który umożliwia wykrywanie błędów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> metody.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> nie jest prawidłowym kodem nazwą strony.  
  
 —lub—  
  
 Strona kodowa wskazywanym przez <paramref name="name" /> nie jest obsługiwany przez podstawowej platformy.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tablicę, która zawiera wszystkie rodzaje kodowania.</summary>
        <returns>Tablica, która zawiera wszystkie rodzaje kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca listę obsługiwanych kodowań jednoznacznie rozróżnianych za pomocą stron kodowych. Aby uzyskać tabelę, która zawiera obsługiwane kodowania, zobacz <xref:System.Text.Encoding> klasy tematu.  
  
> [!NOTE]
>  Lista obsługiwanych kodowań zwrócony przez <xref:System.Text.Encoding.GetEncodings%2A> — metoda nie ma żadnych dodatkowych kodowania udostępnione przez żaden <xref:System.Text.EncodingProvider> implementacji, które zostały zarejestrowane w wyniku wywołania <xref:System.Text.Encoding.RegisterProvider%2A> — metoda.  
  
 Kodowanie 50220 i 50222 są oba skojarzone z nazwą "iso-2022-jp", ale nie są identyczne. Kodowanie 50220 konwertuje znaki Katakana połówkowej szerokości znakami Katakana pełnej szerokości, kodowanie 50222 zastosowań sekwencji shift lub shift Brak do kodowania znaków Katakana połówkowej szerokości. Nazwa wyświetlana dla kodowania 50222 jest "japoński (JIS dozwolony 1-bajtowy Kana - tak / SI)" odróżniający go od kodowanie 50220, którego ekran ma nazwę "japoński (JIS)".  
  
 Zażądanie kodowania nazwy "iso-2022-jp", zwraca .NET Framework 50220 kodowania. Jednak kodowania, które jest odpowiednie dla twojej aplikacji zależy od preferowanego traktowanie znakami Katakana połówkowej szerokości.  
  
 Aby uzyskać określonego kodowania, należy użyć <xref:System.Text.Encoding.GetEncoding%2A> metody.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> Czasami służy do prezentowania użytkownika z listy kodowania w pliku **Zapisz jako** okno dialogowe. Jednak wiele kodowania Unicode nie są niekompletne i tłumaczyć wielu znaków "?", lub w niewielkim stopniu różnić zachowują się na różnych platformach. Należy rozważyć użycie UTF-8 lub UTF-16 jako domyślny.  
  
   
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie wartości logicznych właściwości każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza maksymalną liczbę bajtów utworzone przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów utworzone przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount` Parametru faktycznie określa liczbę <xref:System.Char> obiekty reprezentujące znaków Unicode do kodowania, ponieważ programu .NET Framework wewnętrznie używa UTF-16 do reprezentowania znaków Unicode. W związku z tym, znaki Unicode mogą być reprezentowane przez jedną <xref:System.Char> obiekt, ale znaku Unicode reprezentowany przez para zastępcza, na przykład wymaga dwóch <xref:System.Char> obiektów.  
  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy używać <xref:System.Text.Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, użyj <xref:System.Text.Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> pobiera najgorszych numer, tym najgorszego dla aktualnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.Encoding.GetMaxByteCount%2A> pobiera dużych wartości, szczególnie w przypadku, gdy najgorszego kodowania obejmuje przełączanie trybów każdego znaku. Na przykład może tak się zdarzyć ISO-2022-JP. Aby uzyskać więcej informacji, zobacz wpis w blogu "[co to jest Encoding.GetMaxByteCount() i Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 W większości przypadków ta metoda pobiera rozsądne wartości dla małych ciągów. Ciągi duży może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach, gdy bardziej przystępne bufor jest za mały. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Korzystając z <xref:System.Text.Encoding.GetMaxByteCount%2A>, należy przydzielić buforu wyjściowego na podstawie maksymalnego rozmiaru buforu wejściowego. Jeśli bufor wyjściowy jest ograniczony w rozmiarze, można użyć <xref:System.Text.Encoding.Convert%2A> metody.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.GetMaxByteCount%2A> uwzględnia potencjalnych pozostałość surogatów z poprzedniej operacji dekodera. Z powodu dekoder przekazanie wartości 1 do metody pobiera 2 do kodowania jednobajtowe, takich jak ASCII. Należy używać <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> właściwości, jeśli te informacje są potrzebne.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Wszystkie <see cref="T:System.Text.Encoding" /> implementacje gwarantują, że żadne wyjątki przepełnienie buforu wystąpić, jeśli mają rozmiar buforów, zgodnie z wynikami obliczeń tej metody.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza maksymalną liczbę znaków, utworzonego przez dekodowania określoną liczbę bajtów.</summary>
        <returns>Maksymalna liczba znaków utworzonego przez dekodowania określoną liczbę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy używać <xref:System.Text.Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, użyj <xref:System.Text.Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> pobiera najgorszych numer, tym najgorszego dla aktualnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.Encoding.GetMaxCharCount%2A> pobiera dużej wartości.  
  
 W większości przypadków ta metoda pobiera uzasadnione numery dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach, że bardziej przystępne bufor jest za mały. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.Encoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.Encoding.GetBytes%2A>. Jeśli musi podobną funkcję do użycia z <xref:System.Text.Encoding.GetBytes%2A>, należy użyć <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Korzystając z <xref:System.Text.Encoding.GetMaxCharCount%2A>, należy przydzielić buforu wyjściowego na podstawie maksymalnego rozmiaru buforu wejściowego. Jeśli bufor wyjściowy jest ograniczony w rozmiarze, można użyć <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> metody.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.GetMaxCharCount%2A> uwzględnia najgorszego pozostałość bajtów z poprzedniej operacji kodera. Dla większości stron kodowych przekazanie wartości 0 dla tej metody pobiera wartości większe niż lub równa 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Wszystkie <see cref="T:System.Text.Encoding" /> implementacje gwarantują, że żadne wyjątki przepełnienie buforu wystąpić, jeśli mają rozmiar buforów, zgodnie z wynikami obliczeń tej metody.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po przesłonięciu w klasie pochodnej zwraca sekwencję bajtów określający kodowanie używane.</summary>
        <returns>Tablica bajtów zawierająca sekwencję bajtów określający kodowanie używane.  
  
 —lub—  
  
 Tablica bajtów długości zerowej, jeśli preambuły nie jest wymagana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcjonalnie <xref:System.Text.Encoding> obiekt zapewnia preambuły będący tablicę bajtów, które mogą być poprzedzona do sekwencji bajtów procesu kodowania. Jeśli preambuły zawiera znacznik kolejności bajtów (w standardzie Unicode punkt kodu U + FEFF), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF.  
  
 Znacznika kolejności bajtów Unicode (BOM) jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   UTF-8: BF BB EF  
  
-   Kolejności bajtów big endian UTF-16: FE FF  
  
-   UTF-16 little endian bajtów kolejności: FF FE  
  
-   Kolejności bajtów big endian UTF-32: 00 00 FF FE  
  
-   UTF-32 little endian bajtów kolejności: FF FE 00 00  
  
 Należy używać BOM, ponieważ zapewnia prawie niektórych Identyfikacja kodowanie plików to inaczej utracić odwołanie do <xref:System.Text.Encoding> obiektu, na przykład nieprawidłowo znacznikami danych w sieci web lub bez nich lub losowego tekstu pliki przechowywane, jeśli firma nie ma międzynarodowy problemy lub innych danych. Często problemów użytkowników może można uniknąć, jeśli dane są spójne i poprawnie, najlepiej w formacie UTF-8 lub UTF-16.  
  
 Standardów, które udostępniają typ kodowania BOM jest nieco nadmiarowy. Jednak można użyć ułatwiające serwer wysłał poprawne kodowania nagłówka. Alternatywnie może służyć jako rezerwowe w przypadku kodowanie, w przeciwnym razie zostaną utracone.  
  
 Dostępne są niektóre wady przy użyciu BOM. Na przykład wiedząc, jak ograniczyć pola bazy danych, które używają BOM może być trudne. Łączenie plików może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebnych może zakończyć środku danych. Mimo kilku wady jednak użycie BOM jest zdecydowanie zalecane.  
  
 Aby uzyskać więcej informacji o kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować, powinien prefiks zakodowanego bajtów z preambuły. Jednak większość kodowania nie udostępniają preambuły. Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować, należy użyć kodowanie Unicode, oznacza to, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding>, od preambuły.  
  
   
  
## Examples  
 Poniższy przykład określa kolejność bajtów kodowanie oparte na preambuły.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów na ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje wszystkich bajtów w określonej tablicy bajtów na ciąg.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> obiektu zwróconego przez <xref:System.Text.Encoding.GetDecoder%2A> metody deri Zezwalaj na przenoszenie klasy.  
  
 Zobacz sekcję uwag <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> temat referencyjny omówienie dekodowania technik i zagadnienia.  
  
 Należy pamiętać, że zachowanie dokładne <xref:System.Text.Encoding.GetString%2A> metoda dla określonego <xref:System.Text.Encoding> strategia rezerwowa zdefiniowane w tym zależy od implementacji <xref:System.Text.Encoding> obiektu. Aby uzyskać więcej informacji, zobacz sekcję "Wybieranie strategii powrotu" [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) tematu.  
  
   
  
## Examples  
 Poniższy przykład odczytuje ciąg kodowany w formacie UTF-8 z pliku binarnego reprezentowany przez <xref:System.IO.FileStream> obiektu. Dla plików, które są mniejsze niż 2048 bajtów, odczytuje zawartość cały plik na tablicę bajtów i wywołania <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> metodę w celu dekodowanie. W przypadku plików większych odczytuje 2048 bajtów w czasie do tablicy typu byte, wywołania <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby określić, ile znaków są zawarte w tablicy, a następnie wywołuje <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu dekodowanie.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 W przykładzie użyto następujący tekst, który ma zostać zapisany w pliku kodowany w formacie UTF-8 o nazwie Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica bajtów zawiera nieprawidłowe kody znaków Unicode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do tablicy typu byte.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje określoną liczbę bajtów, licząc od określonego adresu na ciąg.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A> Metodę zaprojektowano w celu optymalizacji wydajności w przypadku natywnej wskaźnika do tablicy typu byte. Zamiast tworzenia tablicy bajtów z zarządzanego i jej dekodowaniu tę metodę można wywołać zamiast bez konieczności tworzenia wszystkie obiekty pośrednie.  
  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> obiektu zwróconego przez <xref:System.Text.Encoding.GetDecoder%2A> metody deri Zezwalaj na przenoszenie klasy.  
  
 Zobacz sekcję uwag <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> temat referencyjny omówienie dekodowania technik i zagadnienia.  
  
 Należy pamiętać, że zachowanie dokładne <xref:System.Text.Encoding.GetString%2A> metoda dla określonego <xref:System.Text.Encoding> strategia rezerwowa zdefiniowane w tym zależy od implementacji <xref:System.Text.Encoding> obiektu. Aby uzyskać więcej informacji, zobacz sekcję "Wybieranie strategii powrotu" [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) tematu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest wskaźnika o wartości null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów z określonej tablicy bajtów w ciąg.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli można przekonwertować danych jest dostępna tylko w kolejnych bloków (na przykład dane odczytane ze strumienia) lub ilości danych jest tak duży, że musi zostać podzielona na mniejsze bloki, należy użyć <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.Encoding.GetDecoder%2A> Metoda lub <xref:System.Text.Encoding.GetEncoder%2A> metody, klasy pochodnej.  
  
 Zobacz sekcję uwag <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> temat referencyjny omówienie dekodowania technik i zagadnienia.  
  
   
  
## Examples  
 Poniższy przykład odczytuje plik binarny, który jest reprezentowany przez ciąg kodowany w formacie UTF-8 <xref:System.IO.FileStream> obiektu. Dla plików, które są mniejsze niż 2048 bajtów, odczytuje zawartość cały plik na tablicę bajtów i wywołania <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę w celu dekodowanie. W przypadku plików większych odczytuje 2048 bajtów w czasie do tablicy typu byte, wywołania <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodę, aby określić, ile znaków są zawarte w tablicy, a następnie wywołuje <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> metodę w celu dekodowanie.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 W przykładzie użyto następujący tekst, który ma zostać zapisany w pliku kodowany w formacie UTF-8 o nazwie Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica bajtów zawiera nieprawidłowe kody znaków Unicode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę bieżącego kodowania, która może być używany z tagów nagłówka agent poczty.</summary>
        <value>Nazwa bieżącego <see cref="T:System.Text.Encoding" /> do korzystania z poczty agenta nagłówka tagów.  
  
 —lub—  
  
 Ciąg pusty (""), jeśli bieżący <see cref="T:System.Text.Encoding" /> nie można użyć.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli potrzebujesz kodowanie nazwy nagłówka, należy wywołać <xref:System.Text.Encoding.GetEncoding%2A> metody z <xref:System.Text.Encoding.HeaderName%2A> właściwości. Często metoda pobiera inne kodowanie kodowania testu dostarczony w wywołaniu. Zazwyczaj trzeba pobrać takie kodowania tylko aplikacji poczty e-mail.  
  
 W niektórych przypadkach wartość <xref:System.Text.Encoding.BodyName%2A> właściwość odpowiada międzynarodowe standard, który określa, że kodowania. To nie oznacza, że implementacja jest zgodna w pełni z tym standard.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.WebName%2A> zwraca nazwę umożliwiająca opisanie kodowania. <xref:System.Text.Encoding.HeaderName%2A> Właściwość definiuje inne kodowanie, które mogą działać lepiej dla aplikacji poczty e-mail, na przykład. Użycie właściwości, aby zdefiniować kodowanie nie jest zalecane.  
  
   
  
## Examples  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z jedną lub kilka nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać go.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący kodowanie jest zawsze znormalizowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący kodowanie jest zawsze znormalizowany, przy użyciu domyślnego formularza normalizacji.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> jest zawsze znormalizowaną; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Forma normalizacji domyślny jest <xref:System.Text.NormalizationForm.FormC>, który używa pełnej canonical rozkład, następuje zastąpienia sekwencje z ich kompozyty głównej, jeśli to możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Jeden z <see cref="T:System.Text.NormalizationForm" /> wartości.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie jest zawsze znormalizowany, użyta zostanie forma normalizacji określony.</summary>
        <returns>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> obiektu jest zawsze znormalizowany przy użyciu określonego <see cref="T:System.Text.NormalizationForm" /> wartości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Forma normalizacji domyślny jest <xref:System.Text.NormalizationForm.FormC>, który używa pełnej canonical rozkład, następuje zastąpienia sekwencje z ich kompozyty głównej, jeśli to możliwe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie może służyć klienci przeglądarki do wyświetlania zawartości.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> może być używana przez klientów przeglądarki do wyświetlania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie wartości logicznych właściwości każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie może służyć klienci przeglądarki do zapisywania zawartości.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> może być używana przez klientów w przeglądarkach do zapisywania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie wartości logicznych właściwości każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie może służyć przez klientów poczty i grup dyskusyjnych do wyświetlania zawartości.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> mogą być używane przez klientów poczty i wiadomości w celu wyświetlania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie wartości logicznych właściwości każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie może służyć przez klientów poczty i grup dyskusyjnych do zapisywania zawartości.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> może być używana przez klientów poczty i wiadomości do zapisywania zawartości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie wartości logicznych właściwości każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera wartość wskazującą, czy bieżący kodowanie używa punktów kodowych jednobajtowe.</summary>
        <value>
          <see langword="true" /> Jeśli bieżący <see cref="T:System.Text.Encoding" /> używa punktów kodowych jednobajtowe; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla jednego bajtu kodowania, na przykład <xref:System.Text.ASCIIEncoding>, pobiera tę właściwość `true`.  
  
> [!CAUTION]
>  Należy zachować ostrożność w aplikacji jest na wartość dla <xref:System.Text.Encoding.IsSingleByte%2A>. Założenie jak kodowanie będzie kontynuowana nadal może być nieprawidłowy. Na przykład Windows-1252 ma wartość `true` dla <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, ale Encoding.GetMaxByteCount(1) zwraca 2. Jest to spowodowane metoda uwzględnia potencjalnych pozostałość surogatów z poprzedniej operacji dekodera.  
  
   
  
## Examples  
 Poniższy przykład umożliwia sprawdzenie wartości logicznych właściwości każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Podklasa <see cref="T:System.Text.EncodingProvider" /> , który zapewnia dostęp do dodatkowych znaków kodowania.</param>
        <summary>Rejestruje dostawcę kodowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A> Metoda pozwala zarejestrować klasę pochodzącą od <xref:System.Text.EncodingProvider> czy sprawia, że znak dostępne na platformie, które w przeciwnym razie ich nie obsługuje kodowania. Po zarejestrowaniu kodowania dostawcy kodowania, który go obsługuje można pobrać po wywołaniu dowolnej <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> przeciążenia. Jeśli istnieje wielu dostawców kodowania, <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> metoda próbuje pobrać określonego kodowania od poszczególnych dostawców, począwszy od jednej ostatnio zarejestrowane.

Rejestrowanie dostawcy kodowania za pomocą <xref:System.Text.Encoding.RegisterProvider%2A> metody także modyfikuje zachowanie [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) i [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) metody, gdy przekazany argument `0`:

- Jeśli jest zarejestrowany dostawca <xref:System.Text.CodePagesEncodingProvider>, metoda zwraca metodę kodowania, która odpowiada stronę kodową systemu podczas uruchamiania w systemie operacyjnym Windows.

- Dostawcy niestandardowego kodowania można wybrać, które kodowanie do zwrócenia, gdy każda z tych <xref:System.Text.Encoding.GetEncoding%2A> przeciążenia metody jest przekazany argument `0`. Dostawcę można także wybrać opcję Zwraca kodowanie dzięki użyciu <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> zwracany metody `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] zawiera jeden dostawca kodowania, <xref:System.Text.CodePagesEncodingProvider>, która sprawia, że dostępne kodowania, które znajdują się w pełnej .NET Framework, ale nie są dostępne w [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. Domyślnie [!INCLUDE[net_v46](~/includes/net-v46-md.md)] obsługuje tylko kodowania Unicode, ASCII i strona kodowa 28591.  
  
 Jeśli ten sam dostawca kodowania jest używany w wielu wywołań <xref:System.Text.Encoding.RegisterProvider%2A> metoda, tylko w pierwszym wywołaniu metody rejestruje dostawcę. Kolejne wywołania są pomijane.  
  
 Jeśli <xref:System.Text.Encoding.RegisterProvider%2A> metoda jest wywoływana, aby zarejestrować wielu dostawców, które obsłużyć tego samego kodu, ostatni zarejestrowanych dostawców jest używane dla wszystkich kodowania i dekodowania operacji. Wszystkie wcześniej zarejestrowanego dostawcę są ignorowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie przy użyciu małego kolejności bajtów endian formatu UTF-16.</summary>
        <value>Kodowanie przy użyciu małego kolejności bajtów endian formatu UTF-16.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby informacji na temat kodowania obsługiwane przez .NET Framework oraz omówienie Unicode, których kodowanie do użycia, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji. Używa wymiany rezerwowy, aby każdy ciąg, który go nie można zakodować i każdego bajtu, którego nie można go zdekodować Zamień na znak zapytania ("?") znaków. Zamiast tego można wywołać <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia little endian <xref:System.Text.UnicodeEncoding> obiektu, w których powrotu jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie przy użyciu małego kolejności bajtów endian formatu UTF-32.</summary>
        <value>Obiekt kodowania przy użyciu małego kolejności bajtów endian formatu UTF-32.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji. Używa wymiany rezerwowego zastąpić każdy ciąg, który go nie można zakodować i każdego bajtu, którego nie można go zdekodować znak zastępczy Unicode (U + FFFE). Zamiast tego można wywołać <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia <xref:System.Text.UTF32Encoding> obiektu, w których powrotu jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Omówienie little endian bajtów kolejności, zobacz <xref:System.Text.Encoding> klasy tematu.  
  
 Aby informacji na temat kodowania obsługiwane przez .NET Framework oraz omówienie Unicode, których kodowanie do użycia, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowania w formacie UTF-7.</summary>
        <value>Kodowanie w formacie UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie UTF-7 jest używany głównie w środowiskach, które wcześniej zostały ograniczone do 7 bitów, takich jak NNTP i niektóre aplikacje poczty e-mail. Z powodu problemów dotyczących zabezpieczeń i niezawodności nie należy używać UTF7 kodowania w środowiskach 8-bitową gdzie kodowania UTF-8 w zamian można używać.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do kodowania tablicy znaków, koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowania w formacie UTF-8.</summary>
        <value>Kodowanie w formacie UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Text.UTF8Encoding> obiektu, który koduje znaki w standardzie Unicode (UTF-16-kodowane) w sekwencji 1 do 4 bajty na znak i który dekoduje tablicy algorytmem UTF-8 bajtów Unicode (UTF-16-kodowane) znaków. Aby uzyskać informacje o kodowań znaków obsługiwanych przez .NET Framework oraz omówienie Unicode, których kodowanie do użycia, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF8Encoding> Obiekt, który jest zwracany przez tę właściwość może nie mieć odpowiednich zachowanie aplikacji.  
  
-   Zwraca <xref:System.Text.UTF8Encoding> obiekt, który zawiera znacznik kolejności bajtów Unicode (BOM). Można utworzyć wystąpienia z kodowaniem UTF8 który nie zapewnia BOM, wywołaj wszystkie przeciążenia <xref:System.Text.UTF8Encoding.%23ctor%2A> konstruktora.  
  
-   Zwraca <xref:System.Text.UTF8Encoding> obiekt, który używa wymiany rezerwowej w celu zastąpienia każdy ciąg, który go nie można zakodować i każdego bajtu, którego nie można go zdekodować znakiem zapytania ("?") znaków. Zamiast tego można wywołać <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> Konstruktor do tworzenia wystąpienia <xref:System.Text.UTF8Encoding> obiektu, w których powrotu jest albo <xref:System.Text.EncoderFallbackException> lub <xref:System.Text.DecoderFallbackException>, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę, która składa się z następujących znaków:  
  
-   MAŁA LITERA Z (U + 007A)  
  
-   MAŁA LITERA (U + 0061)  
  
-   ŁĄCZENIE CAPPUCCINO (U + 0306)  
  
-   MAŁA LITERA AE Z OSTREGO (U + 01FD)  
  
-   GRECKI MAŁA LITERA BETA (U + 03B2)  
  
-   Para dwuskładnikowa (U + D800 U + DD54), który wchodzi w skład GRECKI ACROPHONIC ATTIC jeden TYSIĘCY STATERS (U + 10154).  
  
 On wyświetla jednostek kodu UTF-16 każdego znaku i określa liczbę bajtów wymaganej przez koder UTF-8 do kodowania tablicy znaków. Następnie koduje znaki i wyświetla wynikowy algorytmem UTF-8 bajtów.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera nazwę zarejestrowany z Internetu przypisane numery Authority (IANA) dla bieżącego kodowania.</summary>
        <value>Nazwa IANA dla bieżącego <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A> Właściwości jest taka sama jak <xref:System.Text.EncodingInfo.Name%2A> właściwości.  
  
 Należy pamiętać, że <xref:System.Text.Encoding.WebName%2A> zwraca nazwę zarejestrowana organizacja IANA kodowania. Po jego wartość to nazwa standard, implementacja kodowanie może jest zgodna z w pełni na standardzie. <xref:System.Text.Encoding.HeaderName%2A> Właściwość definiuje inne kodowanie, które mogą działać lepiej w nagłówkach wiadomości e-mail. Jednak większość aplikacji należy używać <xref:System.Text.Encoding.WebName%2A> zamiast tego.  
  
 Aby uzyskać więcej informacji dotyczących organizacja IANA, przejdź do [www.iana.org](https://www.iana.org/).  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> Jest taka sama jak <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> zwrócony przez <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Niektóre nazwy sieci web są duplikatami; Zobacz uwagi dla <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> Aby uzyskać więcej informacji.  
  
   
  
## Examples  
 Poniższy przykład zawiera <xref:System.Text.Encoding.WebName%2A> w nagłówku HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 Poniższy przykład pobiera różne nazwy dla każdego kodowania i wyświetla kodowania z jedną lub kilka nazw, które różnią się od <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Wyświetla <xref:System.Text.Encoding.EncodingName%2A> , ale nie porównać go.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej pobiera kodowanie strony kodowej systemu operacyjnego Windows, który najlepiej odpowiada bieżącej.</summary>
        <value>Strona kodowa systemu operacyjnego Windows, który najlepiej odpowiada bieżącej <see cref="T:System.Text.Encoding" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest udostępniana dla zgodności z wielu języków systemu Windows (MLang) interfejsów API, na przykład przy określaniu rodziny czcionek. Globalizacja przy użyciu jednej z kodowania Unicode zaleca się zamiast tego. Zalecane jest również używać <xref:System.Text.Encoding.WebName%2A> zamiast <xref:System.Text.Encoding.WindowsCodePage%2A> do identyfikowania strony kodowej.  
  
   
  
## Examples  
 Poniższy przykład określa stronę kodową systemu Windows, która najlepiej odpowiada każdego kodowania.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
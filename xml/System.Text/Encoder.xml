<Type Name="Encoder" FullName="System.Text.Encoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3b97f6eb666f014e0c92f4a43f11f2fc3897c060" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407986" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoder abstract" />
  <TypeSignature Language="F#" Value="type Encoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Konwertuje zestaw znaków sekwencję bajtów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskanie wystąpienia implementacja <xref:System.Text.Encoder> klasy, należy użyć aplikacji <xref:System.Text.Encoding.GetEncoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
 <xref:System.Text.Encoder.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoder.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem. Wiele wersji obie te metody są dostępne w <xref:System.Text.Encoder> klasy. Aby uzyskać więcej informacji, zobacz <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>.  
  
 A <xref:System.Text.Encoder> obiekt przechowuje informacje o stanie między kolejnych wywołań `GetBytes` lub <xref:System.Text.Decoder.Convert%2A> metod, którego nie można poprawnie kodowania znaków sekwencji, które obejmują bloków. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloki danych i używa znaki końcowe w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane zastępczym wysokiego poziomu, a pasujące dwuskładnikowego może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
> [!NOTE]
>  Gdy aplikacja wykonuje się za pomocą strumienia danych, należy upewnić się, że informacje o stanie jest opróżniany przez ustawienie `flush` parametr `true` w wywołaniu odpowiedniej metody. Jeśli wystąpi wyjątek lub gdy aplikacja strumieni, powinny wywoływać <xref:System.Text.Encoder.Reset%2A> wyczyść wewnętrzny stan klasy `Encoder` obiektu.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 A <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> można zserializować obiektu podczas operacji konwersji. Stan obiektu jest zachowanego, jeśli deserializowany jest w tej samej wersji programu .NET Framework, ale jeśli deserializowany jest w innej wersji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak przekonwertować tablicy znaków Unicode na bloki bajtów przy użyciu określonego kodowania. Dla porównania, tablicy znaków jest najpierw zakodowane przy użyciu <xref:System.Text.UTF7Encoding>. Następnie tablicy znaków jest zakodowany przy użyciu <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.Encoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.Encoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Gdy aplikacja z tej klasy, musi ono przesłonić wszystkie elementy członkowskie.</para>
    </block>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoding" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskanie wystąpienia implementacja tej klasy, należy używać aplikacji <xref:System.Text.Encoding.GetEncoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano dwie metody inicjowania nowy <xref:System.Text.Encoder> wystąpienia.  
  
 [!code-cpp[System.Text.Encoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Encoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Encoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje buforu lub tablicy znaków Unicode do sekwencji bajtów zakodowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, bytes, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, charCount, bytes, byteCount, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Adres ciąg UTF-16 zakodowany znaków do konwersji.</param>
        <param name="charCount">Liczba znaków w <c>znaków</c> do przekonwertowania.</param>
        <param name="bytes">Adres buforu do przechowywania przekonwertowanego bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów w <c>bajtów</c> do użycia w konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać żadne dodatkowe dane jest do skonwertowania; w przeciwnym razie <see langword="false" />.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaków</c> które były używane w konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="bytesUsed">Gdy metoda zwróci wartość, zawiera liczbę bajtów, które były używane w konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określony przez <c>charCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje buforu znaków Unicode do sekwencji bajtów zakodowany i zapisuje wynik w buforze na inny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiektu zapisuje stan między wywołania <xref:System.Text.Encoder.Convert%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, koder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego. Pozostałe dane przetworzonych będącej częścią jednostki logicznej, takich jak zastępczym wysokiego poziomu o para zastępcza jest konwertowana zgodnie z bieżącym przełączanie awaryjne.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do kodowania dowolnego ilość danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Wynik operacji kodowania przechowuje do buforu o stałym rozmiarze. <xref:System.Text.Encoder.GetBytes%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwracania znaków odczytu oraz zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 `completed` Parametr wyjściowy wskazuje, czy wszystkie dane w buforze wejściowym został przekonwertować i przechowywać w buforze danych wyjściowych. Ten parametr ma wartość `false` Jeśli liczba znaków, określony przez `charCount` nie można przekonwertować parametru bez większej niż liczba bajtów określona przez `byteCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowe buforu wyjściowego, przyrost `chars` parametru według liczby znaków określonych przez `charsUsed` parametru wywoływać `Convert` ponownie — metoda Aby proces pozostałe dane wejściowe.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `charsUsed` i `charCount` parametry są takie same. Ta sytuacja występuje, gdy nadal są danymi <xref:System.Text.Encoder> obiekt, który nie była przechowywana w `chars` buforu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest za mały, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinna być większa niż lub równe rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Encoder.GetByteCount" /> metody.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, byteCount As Integer, flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : char[] * int * int * byte[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : char[] * int * int * byte[] * int * int * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, charIndex, charCount, bytes, byteIndex, byteCount, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków do konwersji.</param>
        <param name="charIndex">Pierwszy element <c>znaków</c> do przekonwertowania.</param>
        <param name="charCount">Liczba elementów <c>znaków</c> do przekonwertowania.</param>
        <param name="bytes">Tablica przechowywania przekonwertowanego bajtów.</param>
        <param name="byteIndex">Pierwszy element <c>bajtów</c> , w których dane są przechowywane.</param>
        <param name="byteCount">Maksymalna liczba elementów <c>bajtów</c> do użycia w konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać żadne dodatkowe dane jest do skonwertowania; w przeciwnym razie <see langword="false" />.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaków</c> które były używane w konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="bytesUsed">Gdy metoda zwróci wartość, zawiera liczbę bajtów, które zostały utworzone w procesie konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określony przez <c>charCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje tablicę znaków Unicode do sekwencji bajtów zakodowany i zapisuje wynik w tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiektu zapisuje stan między wywołania <xref:System.Text.Encoder.Convert%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, koder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego. Pozostałe dane przetworzonych będącej częścią jednostki logicznej, takich jak zastępczym wysokiego poziomu o para zastępcza jest konwertowana zgodnie z bieżącym przełączanie awaryjne.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zdekodowania dowolnego ilość danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Wynik operacji kodowania przechowuje do buforu o stałym rozmiarze. <xref:System.Text.Encoder.GetBytes%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwracania znaków odczytu oraz zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 `completed` Parametr wyjściowy wskazuje, czy wszystkie dane w buforze wejściowym został przekonwertować i przechowywać w buforze danych wyjściowych. Ten parametr ma wartość `false` Jeśli liczba znaków, określony przez `charCount` nie można przekonwertować parametru bez większej niż liczba bajtów określona przez `byteCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowe buforu wyjściowego, przyrost `chars` parametru według liczby znaków określonych przez `charsUsed` parametru wywoływać `Convert` ponownie — metoda Aby proces pozostałe dane wejściowe.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `charsUsed` i `charCount` parametry są takie same. Ta sytuacja występuje, gdy nadal są danymi <xref:System.Text.Encoder> obiekt, który nie była przechowywana w `chars` buforu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.Encoder.Convert%2A> metody, aby skonwertować plik UTF-16 znaków UTF-8, a następnie używa <xref:System.Text.Decoder.Convert%2A> metody, aby przekonwertować znaków UTF-8 znaków UTF-16.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" />, lub <paramref name="byteCount" /> jest mniejsza od zera.  - lub - długość <paramref name="chars" />  -  <paramref name="charIndex" /> jest mniejsza niż <paramref name="charCount" />.  - lub - długość <paramref name="bytes" />  -  <paramref name="byteIndex" /> jest mniejsza niż <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest za mały, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinna być większa niż lub równe rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Encoder.GetByteCount" /> metody.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ Fallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.EncoderFallback" /> obiektu dla bieżącej <see cref="T:System.Text.Encoder" /> obiektu.</summary>
        <value>A <see cref="T:System.Text.EncoderFallback" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy nie można przekonwertować znak sekwencji zakodowanego bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji set jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Nie można przypisać nową wartość w operacji set, ponieważ bieżący <see cref="T:System.Text.EncoderFallbackBuffer" /> obiekt zawiera dane, które nie zostały jeszcze zakodowany.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As EncoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallbackBuffer ^ FallbackBuffer { System::Text::EncoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.EncoderFallbackBuffer" Usage="System.Text.Encoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Text.EncoderFallbackBuffer" /> obiekt skojarzony z bieżącym <see cref="T:System.Text.Encoder" /> obiektu.</summary>
        <value>A <see cref="T:System.Text.EncoderFallbackBuffer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.FallbackBuffer%2A> Obiekt reprezentuje dane używane przez <xref:System.Text.EncoderFallback> obiektu. <xref:System.Text.EncoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy nie można przekonwertować znak sekwencji zakodowanego bajtów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.ReadOnlySpan{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; * bool -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; * bool -&gt; int" Usage="encoder.GetByteCount (chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="encoder.GetByteCount (chars, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby symulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków, zaczynając od wskaźnika określony znak. Parametr wskazuje, czy po zakończeniu obliczania Wyczyść stan wewnętrzny kodera.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków i wszystkie znaki w buforu wewnętrznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan kodera.  
  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Encoder.GetBytes%2A> wymaga, aby wynikowy bajtów, należy użyć aplikacji <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` ustawioną `false`, koder przechowuje znakami na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszelkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int * bool -&gt; int" Usage="encoder.GetByteCount (chars, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby symulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów utworzonego przez zestaw znaków z określoną tablicę znaków kodowania. Parametr wskazuje, czy po zakończeniu obliczania Wyczyść stan wewnętrzny kodera.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków i wszystkie znaki w buforu wewnętrznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan kodera.  
  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Encoder.GetBytes%2A> wymaga, aby wynikowy bajtów, należy użyć aplikacji <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` ustawioną `false`, koder przechowuje znakami na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszelkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.Encoder.GetByteCount%2A> metoda zwraca liczbę bajtów wymaganą do kodowania tablicy znaków Unicode <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków w kolejności bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool -&gt; int" Usage="encoder.GetBytes (chars, bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="encoder.GetBytes (chars, charCount, bytes, byteCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <param name="flush">
          <see langword="true" /> Wyczyść stan wewnętrzny kodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków, zaczynając od wskaźnika określony znak i wszystkie znaki w wewnętrznego buforu do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określonym bajcie. Parametr wskazuje, czy Wyczyść stan wewnętrzny kodera po konwersji.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiektu zapisuje stan między wywołania <xref:System.Text.Encoder.GetBytes%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` w ostatnim wywołaniem `GetBytes` do upewnij się, że informacje o stanie jest opróżniany i poprawnie zakończenia zakodowanego bajtów. To ustawienie, koder ignoruje nieprawidłowe bajty na końcu bloku danych, takich jak niedopasowane surogatów lub sekwencje niekompletne łączenie i czyści buforu wewnętrznego.  
  
 Do obliczenia dokładne buforu rozmiaru `GetBytes` wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` ustawioną `false`, koder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszelkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 Jeśli można przekonwertować wiele segmentów strumienia wejściowego aplikacji, należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A> metody. <xref:System.Text.Encoder.GetBytes%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwracania znaków odczytu oraz zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int * bool -&gt; int" Usage="encoder.GetBytes (chars, charIndex, charCount, bytes, byteIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="flush">
          <see langword="true" /> Wyczyść stan wewnętrzny kodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków z określoną tablicę znaków i wszystkie znaki w buforu wewnętrznego w określonej tablicy bajtów. Parametr wskazuje, czy Wyczyść stan wewnętrzny kodera po konwersji.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiektu zapisuje stan między wywołania <xref:System.Text.Encoder.GetBytes%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` w ostatnim wywołaniem `GetBytes` do upewnij się, że informacje o stanie jest opróżniany i poprawnie zakończenia zakodowanego bajtów. To ustawienie, koder ignoruje nieprawidłowe bajty na końcu bloku danych, takich jak niedopasowane surogatów lub sekwencje niekompletne łączenie i czyści buforu wewnętrznego.  
  
 Do obliczenia dokładne buforu rozmiaru `GetBytes` wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` ustawioną `false`, koder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszelkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 Jeśli można przekonwertować wiele segmentów strumienia wejściowego aplikacji, należy rozważyć użycie <xref:System.Text.Encoder.Convert%2A> metody. <xref:System.Text.Encoder.GetBytes%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwracania znaków odczytu oraz zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób kodowania zakresu elementów z tablicy znaków i przechowywania zakodowanego bajtów w zakresie elementów w tablicy bajtów. <xref:System.Text.Encoder.GetByteCount%2A> Metoda jest używana do określenia rozmiaru tablicy wymagane przez <xref:System.Text.Encoder.GetBytes%2A>.  
  
 [!code-cpp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  - lub - <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  - lub - <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Encoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="encoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia koder do stanu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wewnętrzny stan klasy <xref:System.Text.Encoder> obiektu. Metoda usuwa żadnych informacji o stanie zachowywane z poprzedniego wywołania <xref:System.Text.Encoder.GetBytes%2A> lub <xref:System.Text.Decoder.Convert%2A>, w tym końcowe znaki na końcu poprzedniego bloku danych, takich jak niedopasowane zastępczym wysokiego poziomu.  
  
 Aplikacja powinna wywołać `Reset` metodę, jeśli chce ponownie użyć tego samego kodera, nawet po wyjątku przez <xref:System.Text.Encoder.GetBytes%2A> lub <xref:System.Text.Encoder.GetByteCount%2A>, lub gdy aplikacja strumieni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
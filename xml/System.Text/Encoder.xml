<Type Name="Encoder" FullName="System.Text.Encoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="225da4bd69ecd7c17987505ef472500bec0f8513" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37755053" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoder abstract" />
  <TypeSignature Language="F#" Value="type Encoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Konwertuje zestaw znaków do sekwencji bajtów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do uzyskania wystąpienie implementacji <xref:System.Text.Encoder> klasy, aplikacja powinna używać <xref:System.Text.Encoding.GetEncoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
 <xref:System.Text.Encoder.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.Encoder.GetBytes%2A> metoda wykonuje rzeczywistego kodowania. Różne wersje programu obie te metody są dostępne w <xref:System.Text.Encoder> klasy. Aby uzyskać więcej informacji, zobacz <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>.  
  
 A <xref:System.Text.Encoder> obiekt przechowuje informacje o stanie między kolejne wywołania `GetBytes` lub <xref:System.Text.Decoder.Convert%2A> metody, tak że można poprawne kodowanie znaków w sekwencji, które rozciągają się bloki. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloków danych i korzysta z nieprawidłowymi znakami w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane znakiem zastępczym wysokiego poziomu, a pasujące znak zastępczy niskiego poziomu może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
> [!NOTE]
>  Gdy aplikacja jest przeprowadzane za pomocą strumienia danych powinien upewnij się, że informacje o stanie jest opróżniany, ustawiając `flush` parametr `true` w wywołaniu odpowiednią metodę. Jeśli wystąpi wyjątek lub jeśli aplikacja zostanie przełączona strumieni, powinny wywoływać <xref:System.Text.Encoder.Reset%2A> Wyczyść stan wewnętrzny `Encoder` obiektu.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 A <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> można wykonywać serializację obiektu podczas operacji konwersji. Stan obiektu jest przechowywane, jeśli jest ona przeprowadzona w tej samej wersji programu .NET Framework, ale jeśli jest ona przeprowadzona w innej wersji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób konwertowania tablicy znaków Unicode na bloki bajtów przy użyciu określonego kodowania. Dla porównania tablicę znaków jest najpierw zakodowane przy użyciu <xref:System.Text.UTF7Encoding>. Następnie tablicę znaków są kodowane za pomocą <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.Encoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.Encoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Gdy aplikacja dziedziczy z tej klasy, musi ono przesłonić wszystkie elementy członkowskie.</para>
    </block>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoding" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Encoder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do uzyskania wystąpienie implementacją tej klasy, należy użyć aplikacji <xref:System.Text.Encoding.GetEncoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano dwie techniki dla inicjowania nowego <xref:System.Text.Encoder> wystąpienia.  
  
 [!code-cpp[System.Text.Encoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Encoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Encoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje buforu lub tablicy znaków Unicode do sekwencji bajtów zakodowany.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, bytes, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, charCount, bytes, byteCount, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Adres ciąg UTF-16 zakodowanych znaków do przekonwertowania.</param>
        <param name="charCount">Liczba znaków w <c>znaki</c> do przekonwertowania.</param>
        <param name="bytes">Adres buforu do przechowywania przekonwertowanego bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów w <c>bajtów</c> służące do konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać, żadne dodatkowe dane ma być przekonwertowany; w przeciwnym razie <see langword="false" />.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaki</c> które były używane do konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="bytesUsed">Po powrocie z tej metody zawiera liczbę bajtów, które były używane do konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określone przez <c>charCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje bufor znaków Unicode do sekwencji bajtów zakodowany i zapisuje wynik w buforze na inny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Encoder.Convert%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, kodera ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny. Pozostałe dane przetworzone należącego do jednostki logicznej, takich jak znakiem zastępczym wysokiego poziomu para zastępcza jest konwertowany zgodnie z bieżące ustawienia rezerwowe.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zakodowania dowolnej ilości danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Przechowuje dane wyjściowe działania kodowania do buforu o stałym rozmiarze. <xref:System.Text.Encoder.GetBytes%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwraca znaki odczytu i zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 `completed` Parametru wyjściowego wskazuje, czy wszystkie dane w buforze wejściowym, który został przekonwertowany i przechowywane w bufor wyjściowy. Ten parametr ma wartość `false` Jeśli liczbę znaków, które są określone przez `charCount` nie można przekonwertować parametru bez przekraczania liczbę bajtów określoną przez `byteCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowy bufor wyjściowy, przyrost `chars` parametr według liczby znaków określoną przez `charsUsed` parametr, następnie wywołać `Convert` ponownie — metoda do przetwarzania pozostałych danych wejściowych.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `charsUsed` i `charCount` parametry są równe. Taka sytuacja ma miejsce, jeśli jest nadal dane w <xref:System.Text.Encoder> obiektów, które nie zostały zapisane w `chars` buforu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest zbyt mała, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinien być większy lub równy rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Encoder.GetByteCount" /> metody.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, byteCount As Integer, flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : char[] * int * int * byte[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : char[] * int * int * byte[] * int * int * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, charIndex, charCount, bytes, byteIndex, byteCount, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków do przekonwertowania.</param>
        <param name="charIndex">Pierwszy element <c>znaki</c> do przekonwertowania.</param>
        <param name="charCount">Liczba elementów <c>znaki</c> do przekonwertowania.</param>
        <param name="bytes">Tablica, gdzie są przechowywane przekonwertowanego bajtów.</param>
        <param name="byteIndex">Pierwszy element <c>bajtów</c> w danych, które są przechowywane.</param>
        <param name="byteCount">Maksymalna liczba elementów <c>bajtów</c> służące do konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać, żadne dodatkowe dane ma być przekonwertowany; w przeciwnym razie <see langword="false" />.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaki</c> które były używane do konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="bytesUsed">Po powrocie z tej metody zawiera liczbę bajtów, które zostały utworzone przez konwersję. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określone przez <c>charCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje tablicę znaków Unicode do sekwencji bajtów zakodowany i zapisuje wynik w tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Encoder.Convert%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, kodera ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny. Pozostałe dane przetworzone należącego do jednostki logicznej, takich jak znakiem zastępczym wysokiego poziomu para zastępcza jest konwertowany zgodnie z bieżące ustawienia rezerwowe.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zdekodowania dowolnej ilości danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Przechowuje dane wyjściowe działania kodowania do buforu o stałym rozmiarze. <xref:System.Text.Encoder.GetBytes%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwraca znaki odczytu i zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 `completed` Parametru wyjściowego wskazuje, czy wszystkie dane w buforze wejściowym, który został przekonwertowany i przechowywane w bufor wyjściowy. Ten parametr ma wartość `false` Jeśli liczbę znaków, które są określone przez `charCount` nie można przekonwertować parametru bez przekraczania liczbę bajtów określoną przez `byteCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowy bufor wyjściowy, przyrost `chars` parametr według liczby znaków określoną przez `charsUsed` parametr, następnie wywołać `Convert` ponownie — metoda do przetwarzania pozostałych danych wejściowych.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `charsUsed` i `charCount` parametry są równe. Taka sytuacja ma miejsce, jeśli jest nadal dane w <xref:System.Text.Encoder> obiektów, które nie zostały zapisane w `chars` buforu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.Encoder.Convert%2A> metodę, aby przekonwertować plik UTF-16 znaków na UTF-8, a następnie używa <xref:System.Text.Decoder.Convert%2A> metodę, aby przekonwertować znaków UTF-8 znaków UTF-16.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" />, lub <paramref name="byteCount" /> jest mniejsza niż zero.  - lub - długość <paramref name="chars" />  -  <paramref name="charIndex" /> jest mniejsza niż <paramref name="charCount" />.  - lub - długość <paramref name="bytes" />  -  <paramref name="byteIndex" /> jest mniejsza niż <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest zbyt mała, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinien być większy lub równy rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Encoder.GetByteCount" /> metody.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ Fallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.EncoderFallback" /> obiektu dla bieżącego <see cref="T:System.Text.Encoder" /> obiektu.</summary>
        <value>Element <see cref="T:System.Text.EncoderFallback" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback> Obiekt reprezentuje procedurę obsługi błędów, które jest wywoływane, gdy znak nie można przekonwertować sekwencja bajtów zakodowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji zestawu jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Nie można przypisać nową wartość w operacji zestawu, ponieważ bieżący <see cref="T:System.Text.EncoderFallbackBuffer" /> obiekt zawiera dane, które nie zostały jeszcze zakodowany.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As EncoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallbackBuffer ^ FallbackBuffer { System::Text::EncoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.EncoderFallbackBuffer" Usage="System.Text.Encoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Text.EncoderFallbackBuffer" /> obiekt skojarzony z bieżącym <see cref="T:System.Text.Encoder" /> obiektu.</summary>
        <value>Element <see cref="T:System.Text.EncoderFallbackBuffer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.FallbackBuffer%2A> Obiekt reprezentuje dane używane przez <xref:System.Text.EncoderFallback> obiektu. <xref:System.Text.EncoderFallback> Obiekt reprezentuje procedurę obsługi błędów, które jest wywoływane, gdy znak nie można przekonwertować sekwencja bajtów zakodowany.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.ReadOnlySpan{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; * bool -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; * bool -&gt; int" Usage="encoder.GetByteCount (chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="encoder.GetByteCount (chars, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby zasymulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, zaczynając od określonego znaku wskaźnika. Parametr wskazuje, czy po zakończeniu obliczania Wyczyść stan wewnętrzny kodera.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków i znaków do wewnętrznego buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan kodera.  
  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Encoder.GetBytes%2A> wymaga, aby przechowywać wynikowy bajtów, aplikacja powinna używać <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` równa `false`, kodera końcowe znaki na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszystkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int * bool -&gt; int" Usage="encoder.GetByteCount (chars, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby zasymulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, z określoną tablicę znaków. Parametr wskazuje, czy po zakończeniu obliczania Wyczyść stan wewnętrzny kodera.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków i znaków do wewnętrznego buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan kodera.  
  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Encoder.GetBytes%2A> wymaga, aby przechowywać wynikowy bajtów, aplikacja powinna używać <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` równa `false`, kodera końcowe znaki na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszystkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.Encoder.GetByteCount%2A> metodę, aby zwrócić liczbę bajtów wymaganą do kodowania tablicy znaków Unicode <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  - lub - <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków do sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool -&gt; int" Usage="encoder.GetBytes (chars, bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="encoder.GetBytes (chars, charCount, bytes, byteCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <param name="flush">
          <see langword="true" /> Wyczyść stan wewnętrzny kodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków, zaczynając od wskaźnika określony znak i wszystkie znaki w wewnętrznego buforu do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określoną liczbę bajtów. Parametr wskazuje, czy Wyczyść stan wewnętrzny kodera po konwersji.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Encoder.GetBytes%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` w ostatnim wywołaniu `GetBytes` do upewnij się, że informacje o stanie jest opróżniany i prawidłowo kończą zakodowany bajtów. To ustawienie, kodera ignoruje nieprawidłowe bajty na końcu bloku danych, takich jak surogaty niedopasowane lub sekwencji łączenie niekompletne i czyści bufor wewnętrzny.  
  
 Do obliczania buforu dokładny rozmiar `GetBytes` wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` równa `false`, kodera końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszystkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 W przypadku aplikacji można przekonwertować wiele segmentów strumienia wejściowego, należy wziąć pod uwagę przy użyciu <xref:System.Text.Encoder.Convert%2A> metody. <xref:System.Text.Encoder.GetBytes%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwraca znaki odczytu i zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int * bool -&gt; int" Usage="encoder.GetBytes (chars, charIndex, charCount, bytes, byteIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="flush">
          <see langword="true" /> Wyczyść stan wewnętrzny kodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, koduje zestaw znaków z określoną tablicę znaków i znaków do wewnętrznego buforu, w określonej tablicy bajtów. Parametr wskazuje, czy Wyczyść stan wewnętrzny kodera po konwersji.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Encoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Encoder.GetBytes%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` w ostatnim wywołaniu `GetBytes` do upewnij się, że informacje o stanie jest opróżniany i prawidłowo kończą zakodowany bajtów. To ustawienie, kodera ignoruje nieprawidłowe bajty na końcu bloku danych, takich jak surogaty niedopasowane lub sekwencji łączenie niekompletne i czyści bufor wewnętrzny.  
  
 Do obliczania buforu dokładny rozmiar `GetBytes` wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Jeśli `GetBytes` jest wywoływana z `flush` równa `false`, kodera końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji kodowania. Aplikacja powinna wywołać `GetByteCount` w bloku danych bezpośrednio przed wywołaniem `GetBytes` na tym samym bloku, aby wszystkie końcowe znaki z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 W przypadku aplikacji można przekonwertować wiele segmentów strumienia wejściowego, należy wziąć pod uwagę przy użyciu <xref:System.Text.Encoder.Convert%2A> metody. <xref:System.Text.Encoder.GetBytes%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Encoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwraca znaki odczytu i zapisanych bajtów. Zobacz też <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak kodować zakres elementów w tablicy znaków i zapisać zakodowany bajtów w zakres elementów w tablicy bajtów. <xref:System.Text.Encoder.GetByteCount%2A> Metoda jest używana do określenia rozmiaru tablicy wymagane przez <xref:System.Text.Encoder.GetBytes%2A>.  
  
 [!code-cpp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  - lub - <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  - lub - <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET wyjaśnienie większy) - i - <see cref="P:System.Text.Encoder.Fallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="encoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia kodera do stanu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wewnętrzny stan <xref:System.Text.Encoder> obiektu. Metoda powoduje wyczyszczenie wszelkich informacji o stanie zachowywane z poprzedniego wywołania <xref:System.Text.Encoder.GetBytes%2A> lub <xref:System.Text.Decoder.Convert%2A>, w tym końcowe znaki na końcu poprzedniego bloku danych, takich jak niedopasowane znakiem zastępczym wysokiego poziomu.  
  
 Twoja aplikacja powinna wywołać `Reset` metody, jeśli chce ponownie użyć tego samego kodera, nawet po zakończeniu wyjątek jest generowany przez <xref:System.Text.Encoder.GetBytes%2A> lub <xref:System.Text.Encoder.GetByteCount%2A>, czy aplikacja zostanie przełączona strumieni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
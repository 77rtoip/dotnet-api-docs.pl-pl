<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="79e5dbe1b55b77ab04af7487ca07fa41656661b5" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68901406" /></Metadata><TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowanie UTF-32 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode w sekwencję bajtów. Dekodowanie jest procesem przekształcania sekwencji zakodowanych bajtów na zestaw znaków Unicode.  
  
 [Standard Unicode](https://go.microsoft.com/fwlink/?linkid=37123) przypisuje punkt kodu (numer) do każdego znaku w każdym obsługiwanym skrypcie. Format przekształcenia Unicode (UTF) jest sposobem kodowania tego punktu kodu. W [standardzie Unicode](https://go.microsoft.com/fwlink/?linkid=37123) jest stosowany następujący UTFs:  
  
-   UTF-8, który reprezentuje każdy punkt kodu jako sekwencję od 1 do 4 bajtów.  
  
-   UTF-16, który reprezentuje każdy punkt kodu jako sekwencję od 1 do 2 16-bitowych liczb całkowitych.  
  
-   UTF-32, który reprezentuje każdy punkt kodu jako 32-bitową liczbę całkowitą.  
  
 Aby uzyskać więcej informacji na temat UTFs i innych kodowań obsługiwanych przez <xref:System.Text>program, zobacz [kodowanie znaków w programie .NET](~/docs/standard/base-types/character-encoding.md).
  
 <xref:System.Text.UTF32Encoding> Klasa reprezentuje kodowanie UTF-32. Koder może używać kolejności bajtów big endian (najpierw najbardziej znaczący bajt) lub little endian kolejności bajtów (najpierw znaczący bajt). Na przykład Wielka litera A (punkt kodu U + 0041) jest serializowana w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów big endian: 00 00 00 41  
  
-   Mała kolejność bajtów endian: 41 00 00 00  
  
 Zwykle bardziej wydajne jest przechowywanie znaków Unicode przy użyciu kolejności bajtów natywnych. Na przykład lepiej jest używać kolejności bajtów little endian na platformach little endian, takich jak komputery Intel. <xref:System.Text.UTF32Encoding>odnosi się do stron kodowych systemu Windows 12000 (kolejność bajtów little endian) i 12001 (kolejność bajtów big endian). Możesz określić "przydziały" dla określonej architektury, wywołując <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> metodę.  
  
 <xref:System.Text.UTF32Encoding> Opcjonalnie obiekt zawiera znacznik kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzone sekwencją bajtów w wyniku procesu kodowania. Jeśli Preambuła zawiera znacznik kolejności bajtów (BOM), pomaga dekoderowi określić kolejność bajtów i format przekształcenia lub UTF tablicy bajtowej.  
  
 Jeśli wystąpienie jest skonfigurowane do dostarczania BOM, można je pobrać, <xref:System.Text.UTF32Encoding.GetPreamble%2A> wywołując metodę; w przeciwnym razie metoda zwraca pustą tablicę. <xref:System.Text.UTF32Encoding> Należy pamiętać, że nawet jeśli <xref:System.Text.UTF32Encoding> dla obiektu jest skonfigurowany do obsługi BOM, należy uwzględnić BOM na początku strumienia zakodowanych bajtów, zgodnie z potrzebami, metody <xref:System.Text.UTF32Encoding> kodowania klasy nie są automatycznie.  

> [!CAUTION]  
> Aby włączyć wykrywanie błędów i uczynić wystąpienie klasy bardziej <xref:System.Text.UTF32Encoding> bezpieczne, należy utworzyć wystąpienie obiektu przez <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie konstruktora i ustawienie jego `throwOnInvalidBytes` argumentu na `true`. W przypadku wykrywania błędów Metoda, która wykrywa nieprawidłową sekwencję znaków lub bajtów zgłasza <xref:System.ArgumentException> wyjątek. Bez wykrycia błędów nie jest zgłaszany żaden wyjątek, a Nieprawidłowa sekwencja jest zwykle ignorowana.  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF32Encoding> obiektu na wiele sposobów, w zależności od tego, czy chcesz udostępnić znacznik kolejności bajtów (BOM), czy ma być używane kodowanie big-endian czy little-endian, oraz czy chcesz włączyć wykrywanie błędów. Poniższa tabela zawiera listę <xref:System.Text.UTF32Encoding> konstruktorów <xref:System.Text.Encoding> i właściwości, które zwracają <xref:System.Text.UnicodeEncoding> obiekt.  
  
|Element członkowski|Endian|BOM|Wykrywanie błędów|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little-endian|Tak|Nie (alternatywa zamienna)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little-endian|Tak|Nie (alternatywa zamienna)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Nie (alternatywa zamienna)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.UTF32Encoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 Podobnie <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.UTF32Encoding.GetChars%2A> a metody i <xref:System.Text.UTF32Encoding.GetString%2A> wykonuje rzeczywiste dekodowanie.  
  
 Dla kodera lub dekodera, który może zapisywać informacje o stanie podczas kodowania lub dekodowania danych obejmujących wiele bloków (takich jak ciąg znaków 1 000 000, który jest zakodowany w segmentach znaków 100 000), <xref:System.Text.UTF32Encoding.GetEncoder%2A> Użyj <xref:System.Text.UTF32Encoding.GetDecoder%2A> właściwości i piwo.  
  
   
  
## Examples  
 Poniższy przykład ilustruje zachowanie <xref:System.Text.UTF32Encoding> obiektów z włączonym wykrywaniem błędów i bez niego. Tworzy tablicę bajtową, której ostatnie cztery bajty reprezentują nieprawidłową parę dwuskładnikową; po znaku wieloskładnikowym U + D8FF następuje znak U + 01FF, który znajduje się poza zakresem małych surogatów (0xDC00 przez 0xDFFF). Bez wykrycia błędów, dekoder UTF32 używa powrotu zamiennej, aby zastąpić nieprawidłową parę surogatu ZNAKiem ZASTĘPCZym (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 Poniższy przykład koduje ciąg znaków Unicode w tablicy bajtowej przy użyciu <xref:System.Text.UTF32Encoding> obiektu. Tablica bajtowa jest następnie zdekodowana do ciągu, aby udowodnić, że dane nie są tracone.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 Poniższy przykład używa tego samego ciągu co poprzedni, z tą różnicą, że zapisuje zakodowane bajty do pliku i prefiksy strumienia bajtów ze znacznikiem kolejności bajtów (BOM). Następnie odczytuje plik na dwa różne sposoby: jako plik tekstowy przy użyciu <xref:System.IO.StreamReader> obiektu oraz jako plik binarny. Zgodnie z oczekiwaniami, żaden nowo odczytany ciąg nie obejmuje BOM.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które używa kolejności bajtów little endian, udostępnia znacznik kolejności bajtów Unicode i nie generuje wyjątku w przypadku wykrycia nieprawidłowego kodowania.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora i ustawienie jego `throwOnInvalidCharacters` argumentu na `true`.  
  
   
  
## Examples  
 Poniższy przykład pobiera i wyświetla znacznik kolejności bajtów dla różnych <xref:System.Text.UTF32Encoding> wystąpień.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" />Aby użyć kolejności bajtów big endian (najpierw najbardziej znaczącego bajtu) lub <see langword="false" /> użyć kolejności bajtów little endian (najpierw znaczący bajt).</param>
        <param name="byteOrderMark"><see langword="true" />Aby określić, że jest dostępny znacznik kolejności bajtów Unicode; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy. Parametry określają, czy należy używać kolejności bajtów big endian i czy <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> Metoda zwraca znacznik kolejności bajtów Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątku, gdy wykryto nieprawidłowe kodowanie.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora i ustawienie jego `throwOnInvalidCharacters` argumentu na `true`.  
  
## Examples  
 Poniższy przykład pobiera i wyświetla znacznik kolejności bajtów dla różnych <xref:System.Text.UTF32Encoding> wystąpień.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" />Aby użyć kolejności bajtów big endian (najpierw najbardziej znaczącego bajtu) lub <see langword="false" /> użyć kolejności bajtów little endian (najpierw znaczący bajt).</param>
        <param name="byteOrderMark"><see langword="true" />Aby określić, że jest dostępny znacznik kolejności bajtów Unicode; w przeciwnym razie. <see langword="false" /></param>
        <param name="throwOnInvalidCharacters"><see langword="true" />Aby określić, że wyjątek ma być zgłaszany w przypadku wykrycia nieprawidłowego kodowania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy. Parametry określają, czy ma być używana kolejność bajtów big endian, czy ma być podany znacznik kolejności bajtów Unicode, oraz czy zgłaszać wyjątek, gdy zostanie wykryte nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `throwOnInvalidCharacters` <xref:System.ArgumentException?displayProperty=nameWithType>jest `true`, metoda, która wykrywa nieprawidłowe sekwencje bajtów. W przeciwnym razie metoda nie zgłasza wyjątku, a Nieprawidłowa sekwencja jest ignorowana.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora i ustawienie jego `throwOnInvalidCharacters` argumentu na `true`.
  
## Examples  
 Poniższy przykład ilustruje zachowanie programu <xref:System.Text.UTF32Encoding>, z włączonym wykrywaniem błędów i bez.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> element jest równy bieżącemu <see cref="T:System.Text.UTF32Encoding" /> obiektowi.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest <see langword="false" />wystąpieniem i jest równe bieżącemu obiektowi; w przeciwnym razie,. <see cref="T:System.Text.UTF32Encoding" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UTF32Encoding> obiekty są uważane za równe, jeśli spełnione są wszystkie następujące warunki:  
  
-   Oba obiekty używają tego samego kolejności bajtów.  
  
-   Oba obiekty zapewniają znacznik kolejności bajtów lub oba nie.  
  
-   Oba obiekty używają tego samego powrotu do kodera.  
  
-   Oba obiekty używają tego samego powrotu dekodera.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Text.UTF32Encoding> obiekty przy użyciu różnych wartości parametrów, a następnie sprawdza je pod kątem równości.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów generowanych przez zakodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Zawiera zestaw znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów wytwarzanych przez zakodowanie znaków w określonym <see cref="T:System.String" />.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów, a liczba bajtów w preambule nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody i <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> , aby obliczyć maksymalną i rzeczywistą liczbę bajtów wymaganą do zakodowania ciągu. Wyświetla również rzeczywistą liczbę bajtów wymaganą do przechowywania strumienia bajtów ze znacznikiem kolejności bajtów.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków, zaczynając od określonego wskaźnika znakowego.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów, a liczba bajtów w preambule nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków z określonej tablicy znaków.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów, a liczba bajtów w preambule nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodę.  
  
   
  
## Examples  
 Poniższy przykład wypełnia tablicę wielkimi literami i małymi literami, a następnie wywołuje <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę w celu określenia liczby bajtów wymaganych do zakodowania małych liter łacińskich. Następnie wyświetla te informacje wraz z łączną liczbą bajtów, które są niezbędne, jeśli zostanie dodany znacznik kolejności bajtów. Porównuje tę liczbę z wartością zwracaną przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, która wskazuje maksymalną liczbę bajtów wymaganą do kodowania małych liter. Poniższy przykład wypełnia tablicę kombinacją znaków greckich i cyrylicy i wywołuje <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę w celu określenia liczby bajtów wymaganych do zakodowania znaków cyrylicy. Następnie wyświetla te informacje wraz z łączną liczbą bajtów, które są niezbędne, jeśli zostanie dodany znacznik kolejności bajtów. Porównuje tę liczbę z wartością zwracaną przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, która wskazuje maksymalną liczbę bajtów wymaganą do zakodowania znaków cyrylicy.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestaw znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której ma zostać rozpoczęte pisanie sekwencji bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od określonego wskaźnika znakowego do sekwencji bajtów, które są przechowywane, zaczynając od określonego wskaźnika bajtu.</summary>
        <returns>Rzeczywista liczba bajtów zapisywana w lokalizacji wskazywanej przez <paramref name="bytes" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku, lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja używa <xref:System.Text.Encoder> <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub dostarczonej odpowiednio <xref:System.Text.UTF32Encoding.GetEncoder%2A> przez metodę lub metodę.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów do zapisania w pliku) jest odpowiedzialnością dla deweloperów. <xref:System.Text.UTF32Encoding.GetBytes%2A> Metoda nie dołącza preambuły do początku sekwencji zakodowanych bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="byteCount" />jest mniejsza niż liczba bajtów będących wynikiem.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów, która zawiera wyniki sekwencji bajtów.</param>
        <param name="byteIndex">Indeks, od którego ma zostać rozpoczęte zapisywanie wyniku sekwencji bajtów.</param>
        <summary>Koduje zestaw znaków z określonej tablicy znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów do <paramref name="bytes" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku, lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja używa <xref:System.Text.Encoder> <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub dostarczonej odpowiednio <xref:System.Text.UTF32Encoding.GetEncoder%2A> przez metodę lub metodę.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów do zapisania w pliku) jest odpowiedzialnością dla deweloperów. <xref:System.Text.UTF32Encoding.GetBytes%2A> Metoda nie dołącza preambuły do początku sekwencji zakodowanych bajtów.
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania trzech znaków z tablicy znaków, a następnie koduje znaki i wyświetla wyniki.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />lub <paramref name="charCount" />jestmniejszaod zera.<paramref name="byteIndex" />  
  
—lub— 
 <paramref name="charIndex" />i <paramref name="charCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" />nie jest prawidłowym indeksem <paramref name="bytes" />w.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" />nie ma wystarczającej pojemności od <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Zawiera zestaw znaków do kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów, która zawiera wyniki sekwencji bajtów.</param>
        <param name="byteIndex">Indeks, od którego ma zostać rozpoczęte zapisywanie wyniku sekwencji bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów do <paramref name="bytes" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku, lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja używa <xref:System.Text.Encoder> <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub dostarczonej odpowiednio <xref:System.Text.UTF32Encoding.GetEncoder%2A> przez metodę lub metodę.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów do zapisania w pliku) jest odpowiedzialnością dla deweloperów. <xref:System.Text.UTF32Encoding.GetBytes%2A> Metoda nie dołącza preambuły do początku sekwencji zakodowanych bajtów.
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania ciągu, a następnie koduje ciąg i wyświetla wyniki.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />lub <paramref name="charCount" />jestmniejszaod zera.<paramref name="byteIndex" />  
  
—lub— 
 <paramref name="charIndex" />i <paramref name="charCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" />nie jest prawidłowym indeksem <paramref name="bytes" />w.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" />nie ma wystarczającej pojemności od <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów, zaczynając od określonego wskaźnika bajtu.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A>oblicza dokładny rozmiar tablicy wymagany przez <xref:System.Text.UTF32Encoding.GetChars%2A> metodę do przechowywania wyników. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda oblicza dokładny rozmiar tablicy wymagany <xref:System.Text.UTF32Encoding.GetChars%2A> przez metodę do przechowywania wyników. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje bajty do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do zdekodowania.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której ma zostać rozpoczęte pisanie zestawu znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Dekoduje sekwencję bajtów rozpoczynającą się od określonego wskaźnika Byte do zestawu znaków, które są przechowywane, zaczynając od określonego wskaźnika znakowego.</summary>
        <returns>Rzeczywista liczba znaków zapisywana w lokalizacji wskazywanej przez <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> program do przechowywania wyników, <xref:System.Text.UTF32Encoding.GetCharCount%2A> Wywołaj metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów do zdekodowania obejmuje oznaczenie kolejności bajtów (BOM) i tablicę bajtową zwróconą przez metodę typu nieopartego na BOM, znak U + FFFE jest zawarty w tablicy znaków zwracanej przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku, lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja używa <xref:System.Text.Encoder> <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub dostarczonej odpowiednio <xref:System.Text.UTF32Encoding.GetEncoder%2A> przez metodę lub metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="charCount" />jest mniejsza niż liczba znaków będących wynikiem.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków, która będzie zawierać zestaw znaków.</param>
        <param name="charIndex">Indeks, od którego należy zacząć pisać zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z określonej tablicy bajtów do określonej tablicy znaków.</summary>
        <returns>Rzeczywista liczba znaków do <paramref name="chars" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> program do przechowywania wyników, <xref:System.Text.UTF32Encoding.GetCharCount%2A> Wywołaj metodę. Aby obliczyć maksymalny rozmiar tablicy, wywołaj <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów do zdekodowania obejmuje oznaczenie kolejności bajtów (BOM) i tablicę bajtową zwróconą przez metodę typu nieopartego na BOM, znak U + FFFE jest zawarty w tablicy znaków zwracanej przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku, lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja używa <xref:System.Text.Encoder> <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub dostarczonej odpowiednio <xref:System.Text.UTF32Encoding.GetEncoder%2A> przez metodę lub metodę.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje bajty do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />lub <paramref name="byteCount" />jestmniejszaod zera.<paramref name="charIndex" />  
  
—lub— 
 <paramref name="byteindex" />i <paramref name="byteCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" />nie jest prawidłowym indeksem <paramref name="chars" />w.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="chars" />nie ma wystarczającej pojemności od <paramref name="charIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje zakodowaną sekwencję bajtów UTF-32 na sekwencję znaków Unicode.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> , który konwertuje zakodowaną sekwencję bajtów UTF-32 na sekwencję znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda konwertuje sekwencyjne bloki bajtów do sekwencyjnych bloków znaków w sposób podobny <xref:System.Text.UTF32Encoding.GetChars%2A> do metody. <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> <xref:System.Text.Decoder> Jednak utrzymuje informacje o stanie między wywołaniami, aby można było poprawnie zdekodować sekwencje bajtów, które obejmują bloki. Zachowuje <xref:System.Text.Decoder> również końcowe bajty na końcu bloków danych i używa końcowych bajtów w następnej operacji dekodowania. W związku z <xref:System.Text.UTF32Encoding.GetEncoder%2A> tym isąprzydatnewprzypadkuoperacjitransmisjiwsieciiplików,ponieważteoperacjeczęstozajmująsięblokamidanych,aniezpełnymstrumieniemdanych.<xref:System.Text.UTF32Encoding.GetDecoder%2A>  
  
 Jeśli jest włączone wykrywanie błędów, oznacza to, `throwOnInvalidCharacters` że parametr konstruktora został ustawiony na `true`, wykrywanie błędów <xref:System.Text.Decoder> jest również włączone w zwracanym przez tę metodę. W przypadku włączenia wykrywania błędów i napotkania nieprawidłowej sekwencji stan dekodera jest niezdefiniowany i przetwarzanie musi zostać zatrzymane.  
  
   
  
## Examples  
 Poniższy przykład używa kodera i dekodera do kodowania ciągu do tablicy bajtów, a następnie dekodowanie bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje koder, który konwertuje sekwencję znaków Unicode na sekwencję bajtów w formacie UTF-32.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> , która konwertuje sekwencję znaków Unicode na sekwencję bajtów w formacie UTF-32.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda konwertuje sekwencyjne bloki znaków na bloki sekwencyjne bajtów w sposób podobny <xref:System.Text.UTF32Encoding.GetBytes%2A> do metody. <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> <xref:System.Text.Encoder> Jednak utrzymuje informacje o stanie między wywołaniami, dzięki czemu mogą poprawnie kodować sekwencje znaków, które obejmują bloki. Zachowuje <xref:System.Text.Encoder> również końcowe znaki na końcu bloków danych i używa znaków końcowych w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowanym znakiem wieloskładnikowym, a dopasowanie niskiego surogatu może znajdować się w następnym bloku danych. W związku z <xref:System.Text.UTF32Encoding.GetEncoder%2A> tym isąprzydatnewprzypadkuoperacjitransmisjiwsieciiplików,ponieważteoperacjeczęstozajmująsięblokamidanych,aniezpełnymstrumieniemdanych.<xref:System.Text.UTF32Encoding.GetDecoder%2A>  
  
 Jeśli jest włączone wykrywanie błędów, oznacza to, `throwOnInvalidCharacters` że parametr konstruktora został ustawiony na `true`, wykrywanie błędów <xref:System.Text.Encoder> jest również włączone w zwracanym przez tę metodę. W przypadku włączenia wykrywania błędów i napotkania nieprawidłowej sekwencji stan kodera jest niezdefiniowany i przetwarzanie musi zostać zatrzymane.  
  
   
  
## Examples  
 Poniższy przykład używa kodera i dekodera do kodowania ciągu do tablicy bajtów, a następnie dekodowanie bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego wystąpienia.</summary>
        <returns>Kod skrótu dla bieżącego <see cref="T:System.Text.UTF32Encoding" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów wyprodukowanych przez zakodowanie określonej liczby znaków.</summary>
        <returns>Maksymalna liczba bajtów wygenerowanych przez kodowanie określonej liczby znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetByteCount%2A>  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>to najgorsza liczba przypadków, w tym najgorszy przypadek dla aktualnie wybranego <xref:System.Text.EncoderFallback>elementu. W przypadku wybrania rezerwy z potencjalnie dużym ciągiem <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> może zwracać duże wartości.  
  
 W większości przypadków ta metoda zwraca rozsądne liczby dla małych ciągów. W przypadku dużych ciągów może zajść potrzeba wyboru między użyciem bardzo dużych buforów i przechwycenia błędów w rzadkich przypadkach, gdy zostanie przekroczony bardziej rozsądny bufor. Warto również rozważyć inne podejście i użycie <xref:System.Text.UTF32Encoding.GetByteCount%2A> lub. <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>nie ma relacji z <xref:System.Text.UTF32Encoding.GetChars%2A>. Jeśli potrzebujesz podobną funkcję do użycia z <xref:System.Text.UTF32Encoding.GetChars%2A>, użyj. <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>  
  
> [!NOTE]
>  `GetMaxByteCount(N)`nie musi być taka sama jak `N* GetMaxByteCount(1)`wartość.  
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganych do zakodowania ciągu, a następnie koduje ciąg i wyświetla wyniki.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków wyprodukowanych przez dekodowanie określonej liczby bajtów.</summary>
        <returns>Maksymalna liczba znaków wytworzonych przez odkodowanie określonej liczby bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> program do przechowywania wyników, należy <xref:System.Text.UTF32Encoding.GetCharCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UTF32Encoding.GetCharCount%2A>  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>to najgorsza liczba przypadków, w tym najgorszy przypadek dla aktualnie wybranego <xref:System.Text.DecoderFallback>elementu. W przypadku wybrania rezerwy z potencjalnie dużym ciągiem <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> może zwracać duże wartości.  
  
 W większości przypadków ta metoda zwraca rozsądne liczby dla małych ciągów. W przypadku dużych ciągów może zajść potrzeba wyboru między użyciem bardzo dużych buforów i przechwycenia błędów w rzadkich przypadkach, gdy zostanie przekroczony bardziej rozsądny bufor. Warto również rozważyć inne podejście i użycie <xref:System.Text.UTF32Encoding.GetCharCount%2A> lub. <xref:System.Text.Decoder.Convert%2A>  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>nie ma relacji z <xref:System.Text.UTF32Encoding.GetBytes%2A>. Jeśli potrzebujesz podobną funkcję do użycia z <xref:System.Text.UTF32Encoding.GetBytes%2A>, użyj. <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>  
  
> [!NOTE]
>  `GetMaxCharCount(N)`nie musi być taka sama jak `N* GetMaxCharCount(1)`wartość.  
  
## Examples  
 Poniższy przykład koduje ciąg w tablicy bajtów, a następnie dekoduje bajty do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowany w formacie UTF-32, jeśli obiekt <see cref="T:System.Text.UTF32Encoding" /> jest skonfigurowany do jego dostarczania.</summary>
        <returns>Tablica bajtowa zawierająca znacznik kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UTF32Encoding" /> obiekt jest skonfigurowany do dostarczania jednego. W przeciwnym razie ta metoda zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Obiekt może dostarczyć preambuły, który jest tablicą bajtów, które mogą być poprzedzone sekwencją bajtów w wyniku procesu kodowania. Poprzednia sekwencja zakodowanych bajtów ze znacznikiem kolejności bajtów (punkty kodów U + 0000 U + FEFF) ułatwiają określenie kolejności bajtów i formatu transformacji lub UTF. Znacznik kolejności bajtów (BOM) Unicode jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów big endian: 00 00 FE FF  
  
-   Mała kolejność bajtów endian: FF FE 00 00  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF32Encoding> obiektu, którego <xref:System.Text.UTF32Encoding.GetPreamble%2A> Metoda zwraca prawidłowy BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UTF32Encoding> obiekt zwrócony <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> przez właściwość.  
  
-   Wywołując <xref:System.Text.UTF32Encoding.%23ctor> Konstruktor bez parametrów, aby <xref:System.Text.UTF32Encoding> utworzyć wystąpienie obiektu.  
  
-   Dostarczając `true` jako wartość `byteOrderMark` argumentu <xref:System.Text.UTF32Encoding.%23ctor%2A> i konstruktorów.<xref:System.Text.UTF32Encoding.%23ctor%2A>  
  
 Zalecamy korzystanie z BOM, ponieważ zapewnia niemal pewnej identyfikacji kodowania dla plików, które w przeciwnym razie utraciły odwołanie do <xref:System.Text.UTF32Encoding> obiektu, na przykład nieoznakowane lub nieprawidłowo oznakowane dane sieci Web, lub losowe pliki tekstowe przechowywane podczas Firma nie ma obaw międzynarodowych ani innych danych. Często można uniknąć problemów z użytkownikami, jeśli dane są spójne i poprawnie oznakowane.  
  
 W przypadku standardów, które zapewniają typ kodowania, BOM jest nieco nadmiarowy. Można go jednak użyć, aby ułatwić serwerowi wysyłanie poprawnego nagłówka kodowania. Alternatywnie, może być używany jako rezerwa w przypadku, gdy kodowanie jest tracone.  
  
 Istnieją pewne wady dotyczące korzystania z BOM. Na przykład poznanie sposobu ograniczania pól bazy danych, które używają BOM, może być trudne. Łączenie plików może być również problemem, na przykład podczas scalania plików w taki sposób, że niezbędny znak może kończyć się w danych. Pomimo tego, że użycie BOM jest zdecydowanie zalecane.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, zobacz Standard Unicode na [stronie głównej Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, należy prefiksować zakodowane bajty z preambuły. Należy zauważyć, <xref:System.Text.UTF32Encoding.GetBytes%2A> że metoda nie dołącza BOM do sekwencji zakodowanych bajtów; dostarczenie BOM na początku odpowiedniego strumienia bajtów jest odpowiedzialnością dla deweloperów.  
  
## Examples  
 Poniższy przykład kodu pobiera i wyświetla znacznik kolejności bajtów dla różnych <xref:System.Text.UTF32Encoding> wystąpień.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 W poniższym przykładzie tworzone są dwa <xref:System.Text.UTF32Encoding> obiekty, z których pierwszy nie zawiera BOM, a drugie. Następnie wywołuje <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodę, aby napisać BOM do pliku przed zapisaniem ciągu zakodowanego w formacie UTF-32. Jak wynika z przykładu, plik, który zapisuje bajty z drugiego kodera, ma cztery więcej bajtów, które pierwszy.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Pliki można także porównać przy użyciu `fc` polecenia w oknie konsoli lub można sprawdzić pliki w edytorze tekstów zawierający tryb widoku szesnastkowego. Należy pamiętać, że gdy plik zostanie otwarty w edytorze obsługującym kodowanie UTF-32, nie jest wyświetlany BOM.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Dekoduje zakres bajtów z tablicy bajtowej do ciągu.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów do zdekodowania zawiera znacznik kolejności bajtów (BOM), a tablica bajtów została zwrócona przez metodę typu nieopartego na BOM, znak U + FFFE jest dołączany do tablicy znaków zwróconej przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub <xref:System.Text.UTF32Encoding.GetDecoder%2A> odpowiednio do metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w dwóch tablicach bajtów, jeden w kolejności little-endian i drugi w kolejności big-endian. Następnie dekoduje bajty z powrotem do ciągu.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 W poniższym przykładzie jest inicjowana tablica przez wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody w celu określenia dokładnie liczby bajtów wymaganych przez zakodowany ciąg, a następnie dodania rozmiaru znacznika kolejności bajtów (BOM). Przykład następnie wywołuje <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodę w celu zapisania BOM do tablicy przed <xref:System.Text.UTF32Encoding.GetBytes%2A> wywołaniem metody w celu zapisania zakodowanych bajtów do tablicy. Przykład następnie wywołuje metodę, <xref:System.Text.UTF32Encoding.GetString%2A> Aby zdekodować ciąg.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Należy zauważyć, że w tym przypadku zdekodowany ciąg różni się od oryginalnego ciągu, ponieważ zaczyna się od 32-bitowego znaku kolejności bajtów U + FFFE U + 0000. Oznacza to, że dwa ciągi będą porównywane jako nierówne i że jeśli ciąg jest wyprowadzany, będzie on wyświetlany jako znak zastępczy "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać kompletne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UTF32Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UTF32Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera znacznik kolejności bajtów Unicode zakodowany w formacie UTF-32, jeśli ten obiekt jest skonfigurowany do jego dostarczania.</summary>
        <value>Zakres bajtów zawierający znacznik kolejności bajtów Unicode, jeśli ten obiekt jest skonfigurowany do jego dostarczania; w przeciwnym razie domyślnym zakresem.</value><remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Obiekt może zapewnić preambułę, która jest zakresem bajtów, które mogą być poprzedzone sekwencją bajtów w wyniku procesu kodowania. Poprzednia sekwencja zakodowanych bajtów ze znacznikiem kolejności bajtów (punkty `U+0000` `U+FEFF`kodów) pomaga dekoderowi określić kolejność bajtów i format transformacji lub UTF. Znacznik kolejności bajtów (BOM) Unicode jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów big endian:`00 00 FE FF`  
  
-   Mała kolejność bajtów endian:`FF FE 00 00`  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF32Encoding> obiektu, którego <xref:System.Text.UTF32Encoding.Preamble> właściwość jest prawidłowym BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UTF32Encoding> obiekt zwrócony <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> przez właściwość.  
  
-   Wywołując <xref:System.Text.UTF32Encoding.%23ctor> Konstruktor bez parametrów, aby <xref:System.Text.UTF32Encoding> utworzyć wystąpienie obiektu.  
  
-   Dostarczając `true` jako wartość `byteOrderMark` argumentu <xref:System.Text.UTF32Encoding.%23ctor%2A> i konstruktorów.<xref:System.Text.UTF32Encoding.%23ctor%2A>  
  
 Zalecamy korzystanie z BOM, ponieważ zapewnia niemal pewne identyfikatory kodowania dla plików, które w przeciwnym razie utraciły odwołanie do <xref:System.Text.UTF32Encoding> obiektu, takie jak nieoznakowane lub niewłaściwie oznakowane dane sieci Web, lub losowe pliki tekstowe przechowywane w firmie nie masz obaw międzynarodowych ani innych danych. Często można uniknąć problemów z użytkownikami, jeśli dane są spójne i poprawnie oznakowane.  
  
 W przypadku standardów, które zapewniają typ kodowania, BOM jest nieco nadmiarowy. Można go jednak użyć, aby ułatwić serwerowi wysyłanie poprawnego nagłówka kodowania. Alternatywnie, może być używany jako rezerwa w przypadku, gdy kodowanie jest tracone.  
  
 Istnieją pewne wady dotyczące korzystania z BOM. Na przykład poznanie sposobu ograniczania pól bazy danych, które używają BOM, może być trudne. Łączenie plików może być również problemem, na przykład podczas scalania plików w taki sposób, że niezbędny znak może kończyć się w danych. Pomimo tego, że użycie BOM jest zdecydowanie zalecane.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, zobacz Standard Unicode na [stronie głównej Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, należy prefiksować zakodowane bajty z preambuły. Należy zauważyć, <xref:System.Text.UTF32Encoding.GetBytes%2A> że metoda nie dołącza BOM do sekwencji zakodowanych bajtów; dostarczenie BOM na początku odpowiedniego strumienia bajtów jest odpowiedzialnością dla deweloperów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

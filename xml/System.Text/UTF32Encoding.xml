<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f95e573289acacb798f6a2ed881a000896e12920" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48666740" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania UTF-32 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencji bajtów zakodowany zestaw znaków Unicode.  
  
 [Standardu Unicode](http://go.microsoft.com/fwlink/?linkid=37123) przypisuje punkt kodowy (liczba) do każdego znaku w każdej obsługiwanej skryptu. Format przekształcenia Unicode (UTF) to sposób kodowania tego punktu kodu. [Standardu Unicode](http://go.microsoft.com/fwlink/?linkid=37123) używa następujących UTFs:  
  
-   UTF-8, która reprezentuje każdy punkt kodu jako sekwencja jednej do czterech bajtów.  
  
-   UTF-16, co reprezentuje każdy punkt kodu jako sekwencję liczb całkowitych, jednej do dwóch 16-bitowych.  
  
-   UTF-32, co reprezentuje każdy punkt kodowy jako liczba całkowita 32-bitowych.  
  
 Aby uzyskać więcej informacji na temat UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowanie znaków na platformie .NET](~/docs/standard/base-types/character-encoding.md).
  
 <xref:System.Text.UTF32Encoding> Klasa reprezentuje z kodowaniem UTF-32. Koder służy kolejności bajtów big endian (najbardziej znaczący bajt pierwszy) lub nieco kolejności bajtów endian (najmniej znaczący bajt pierwszy). Na przykład Wielka litera (punkt kodowy 0041 U +) jest serializowany jako następujące (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian: 00 00 00 41  
  
-   Mały kolejności bajtów endian: 41 00 00 00  
  
 Jest zwykle wydajniejszym rozwiązaniem przechowywania znaki Unicode przy użyciu kolejności bajtów natywnych. Na przykład lepiej jest używać nieco kolejności bajtów endian na little endian platform, takich jak komputery z technologią Intel. <xref:System.Text.UTF32Encoding> odnosi się do stron kodowych Windows 12000 (mały kolejności bajtów endian) i 12001 (kolejności bajtów big endian). Możesz określić "kolejność bajtów" szczególna architektura, wywołując <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> metody.  
  
 Opcjonalnie <xref:System.Text.UTF32Encoding> obiekt zawiera znacznika kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzone sekwencji bajtów wynikające z procesu kodowania. Jeśli Preambuła zawiera znacznik kolejności bajtów (BOM), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF tablicy bajtów.  
  
 Jeśli <xref:System.Text.UTF32Encoding> wystąpienia jest skonfigurowana do dostarczania znak BOM, można go pobrać, wywołując <xref:System.Text.UTF32Encoding.GetPreamble%2A> metody; w przeciwnym razie metoda zwraca pustą tablicę. Należy zauważyć, że nawet wtedy, gdy <xref:System.Text.UTF32Encoding> obiektu jest skonfigurowany na potrzeby obsługi BOM, musi zawierać znak BOM na początku strumienia bajtów zakodowany zgodnie z potrzebami; metody kodowania <xref:System.Text.UTF32Encoding> klasy nie należy tego robić automatycznie.  
  
 Umożliwiające wykrywanie błędów i zabezpieczyć wystąpienia klasy, należy utworzyć wystąpienie <xref:System.Text.UTF32Encoding> obiektu przez wywołanie metody <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`. Za pomocą wykrywania błędów zgłasza metodę, która wykrywa nieprawidłową sekwencję znaków lub bajtów <xref:System.ArgumentException> wyjątku. Bez wykrycia błąd jest zgłaszany żaden wyjątek, a nieprawidłowa sekwencja jest brany pod uwagę.  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF32Encoding> obiektu na różne sposoby w zależności od tego, czy chcesz go zapewnienie znacznika kolejności bajtów (BOM), czy ma little-endian lub big-endian kodowania i tego, czy chcesz włączyć wykrywanie błędów. W poniższej tabeli wymieniono <xref:System.Text.UTF32Encoding> konstruktorów i <xref:System.Text.Encoding> właściwości, które zwracają <xref:System.Text.UnicodeEncoding> obiektu.  
  
|Element członkowski|Kolejność bajtów|BOM|Wykrywanie błędów|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little-endian|Tak|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little-endian|Tak|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.UTF32Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania.  
  
 Podobnie <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.UTF32Encoding.GetChars%2A> i <xref:System.Text.UTF32Encoding.GetString%2A> metody wykonywania rzeczywiste dekodowania.  
  
 Dla koder i dekoder, który jest w stanie zapisać informacje o stanie podczas kodowania lub dekodowania danych, która obejmuje wiele bloków (na przykład ciąg 1 milion znaków, który jest kodowany w segmentach 100 000 znaków), użyj <xref:System.Text.UTF32Encoding.GetEncoder%2A> i <xref:System.Text.UTF32Encoding.GetDecoder%2A> właściwości odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład demonstruje działanie <xref:System.Text.UTF32Encoding> obiektów z lub bez wykrywanie błędów włączona. Tworzy tablicę bajtów, którego ostatnie cztery bajty reprezentują para zastępcza nieprawidłowy; znakiem zastępczym wysokiego poziomu U + D8FF następuje U + 01FF, który znajduje się poza zakresem surogaty niski (0xDC00 do 0xDFFF). Bez wykrywanie błędów dekodera UTF32 używa zastąpienie rezerwowego zastąpić para zastępcza nieprawidłowy znak zastępczy (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 Poniższy przykład koduje ciąg znaków Unicode w tablicy bajtów przy użyciu <xref:System.Text.UTF32Encoding> obiektu. Tablica bajtów jest następnie dekodowana na ciąg w celu zademonstrowania, że istnieje bez utraty danych.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 W poniższym przykładzie użyto tych samych parametrach jak poprzedni, z tą różnicą, że zapisuje zakodowany bajtów do pliku, a prefiksy strumień bajtów przy użyciu znacznika kolejności bajtów (BOM). Następnie odczytuje plik na dwa sposoby: jako plik tekstowy przy użyciu <xref:System.IO.StreamReader> obiektu; i jako plik binarny. Jak można oczekiwać w przypadku ani BOM znajduje się w ciągu nowo odczytu.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które używa kolejności bajtów endian mały, zawiera znacznik kolejności bajtów Unicode i nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidCharacters` argument `true`.  
  
   
  
## Examples  
 Poniższy przykład pobiera i wyświetla znak kolejności bajtów dla różnych <xref:System.Text.UTF32Encoding> wystąpień.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> do użycia w kolejności bajtów big endian (najbardziej znaczący bajt pierwszy), lub <see langword="false" /> do kolejność little endian bajtów (najmniej znaczący bajt pierwszy).</param>
        <param name="byteOrderMark">
          <see langword="true" /> Aby określić, czy znajduje się znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy. Parametry określają, czy ma być używany w kolejności bajtów big endian oraz tego, czy <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> metoda zwróci wartość znacznika kolejności bajtów Unicode, Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidCharacters` argument `true`.  
  
   
  
## Examples  
 Poniższy przykład pobiera i wyświetla znak kolejności bajtów dla różnych <xref:System.Text.UTF32Encoding> wystąpień.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> do użycia w kolejności bajtów big endian (najbardziej znaczący bajt pierwszy), lub <see langword="false" /> do kolejność little endian bajtów (najmniej znaczący bajt pierwszy).</param>
        <param name="byteOrderMark">
          <see langword="true" /> Aby określić, czy znajduje się znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters">
          <see langword="true" /> Aby określić, czy należy zgłosić wyjątek po wykryciu Nieprawidłowe kodowanie; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF32Encoding" /> klasy. Parametry określają, czy ma być używany w kolejności bajtów big endian, czy zapewnienie znacznika kolejności bajtów Unicode i czy chcesz zgłosić wyjątek po wykryciu Nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `throwOnInvalidCharacters` jest `true`, zgłasza wyjątek w metodzie, która wykrywa sekwencji nieprawidłowy bajt <xref:System.ArgumentException?displayProperty=nameWithType>. W przeciwnym razie metoda nie zgłasza wyjątku, i jest ignorowana nieprawidłową sekwencję.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidCharacters` argument `true`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje działanie <xref:System.Text.UTF32Encoding>, zarówno za pomocą wykrywania błędów włączona, jak i bez.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> jest taki sam, jak bieżący <see cref="T:System.Text.UTF32Encoding" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.UTF32Encoding" /> i jest taki sam jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UTF32Encoding> obiekty są traktowane jako równe, jeśli spełnione są wszystkie następujące warunki:  
  
-   Oba obiekty używają tej samej kolejności bajtów.  
  
-   Oba obiekty zapewniają znacznika kolejności bajtów lub oba nie obsługują.  
  
-   Oba obiekty, użyj tego samego kodera rezerwowego.  
  
-   Oba obiekty, użyj tego samego dekoder rezerwowego.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Text.UTF32Encoding> obiektów przy użyciu różnych parametrów wartości, a następnie sprawdza ich pod kątem równości.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Zawierający zestaw znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie znaków w określonym <see cref="T:System.String" />.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> i <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metody służące do obliczania maksymalnej rzeczywista liczba bajtów potrzebnych do zakodowania ciąg. Wyświetla również rzeczywista liczba bajtów potrzebnych do przechowania strumień bajtów przy użyciu znacznika kolejności bajtów.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako strumień lub plik, można prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, z określoną tablicę znaków.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako strumień lub plik, można prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład powoduje wypełnienie tablicy o liczbie łaciński, wielkie i małe litery i wywołania <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę pozwala ustalić liczbę bajtów potrzebnych do zakodowania znaki małe litery alfabetu łacińskiego. Następnie wyświetla te informacje wraz z całkowitą liczbą bajtów potrzebnych Jeśli znacznik kolejności bajtów jest dodawany. Porównuje tę liczbę za pomocą wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody, która określa maksymalną liczbę bajtów potrzebnych do zakodowania znaki małe litery alfabetu łacińskiego. Poniższy przykład wypełnia tablicę przy użyciu kombinacji znaków alfabetu greckiego i cyrylica i wywołania <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę pozwala ustalić liczbę bajtów potrzebnych do kodowania znaków cyrylicy. Następnie wyświetla te informacje wraz z całkowitą liczbą bajtów potrzebnych Jeśli znacznik kolejności bajtów jest dodawany. Porównuje tę liczbę za pomocą wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody, która określa maksymalną liczbę bajtów potrzebnych do kodowania znaków cyrylicy.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestawu znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od określonego znaku wskaźnika do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja używa <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UTF32Encoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków, z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja używa <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UTF32Encoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do zakodowania trzy znaki z tablicy znaków, a następnie koduje znaki i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Zawierający zestaw znaków do zakodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja używa <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UTF32Encoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do zakodowania ciąg, a następnie koduje ciąg i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> oblicza rozmiar tablicy dokładnie, wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> metodę, aby przechować wynikowy znaków. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda oblicza rozmiar tablicy dokładnie, wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> metodę, aby przechować wynikowy znaków. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów w zestawie znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Dekoduje sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów do zestawu znaków, które są przechowywane, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w lokalizacji wskazanej przez <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF32Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja używa <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody, odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów na określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF32Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja używa <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje sekwencję bajtów UTF-32 zakodowane na sekwencję znaków Unicode.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> konwertuje sekwencję bajtów UTF-32 zakodowane na sekwencję znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów do kolejnych bloków znaków, w sposób podobny do <xref:System.Text.UTF32Encoding.GetChars%2A> metody. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami, aby go można prawidłowo zdekodować sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF32Encoding.GetDecoder%2A> i <xref:System.Text.UTF32Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 Jeśli błędów jest włączone wykrywanie, oznacza to, `throwOnInvalidCharacters` ustawiono parametr konstruktora `true`, również jest włączone wykrywanie błędów w <xref:System.Text.Decoder> zwracanego przez tę metodę. Jeśli napotka nieprawidłową sekwencję wykrywanie błędów jest włączone, stan dekodera jest niezdefiniowana, i należy zatrzymać przetwarzanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto koder i dekoder, aby zakodować ciąg na tablicę bajtów, a następnie dekodowania bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencję znaków Unicode na UTF-32 zakodowane sekwencji bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> , konwertuje sekwencję znaków Unicode na UTF-32 zakodowane sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków do kolejnych bloków bajtów w sposób podobny do <xref:System.Text.UTF32Encoding.GetBytes%2A> metody. Jednak <xref:System.Text.Encoder> przechowuje informacje o stanie między wywołaniami, więc może ona poprawne kodowanie sekwencje znaków, które rozciągają się bloki. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloków danych i korzysta z nieprawidłowymi znakami w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane zastępczy wysokiej i dopasowania zastępczy niskiego może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.UTF32Encoding.GetDecoder%2A> i <xref:System.Text.UTF32Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 Jeśli błędów jest włączone wykrywanie, oznacza to, `throwOnInvalidCharacters` ustawiono parametr konstruktora `true`, również jest włączone wykrywanie błędów w <xref:System.Text.Encoder> zwracanego przez tę metodę. Jeśli napotka nieprawidłową sekwencję wykrywanie błędów jest włączone, stan kodera jest niezdefiniowana, i należy zatrzymać przetwarzanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto koder i dekoder, aby zakodować ciąg na tablicę bajtów, a następnie dekodowania bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Text.UTF32Encoding" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów, generowane przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów, generowane przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF32Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF32Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> jest liczbą najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda zwraca uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Możesz również wziąć pod uwagę różne podejścia i używać <xref:System.Text.UTF32Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> nie ma relacji <xref:System.Text.UTF32Encoding.GetChars%2A>. Jeśli potrzebujesz podobną funkcję do użycia z <xref:System.Text.UTF32Encoding.GetChars%2A>, użyj <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład określa liczbę bajtów wymaganą do zakodowania ciąg, a następnie koduje ciąg i wyświetla wynikowy bajtów.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, generowane przez określoną liczbę bajtów do zdekodowania.</summary>
        <returns>Maksymalna liczba znaków, generowane przez określoną liczbę bajtów do zdekodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF32Encoding.GetChars%2A> aby przechowywać wynikowy znaków, należy wywołać <xref:System.Text.UTF32Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF32Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> jest liczbą najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda zwraca uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Możesz również wziąć pod uwagę różne podejścia i używać <xref:System.Text.UTF32Encoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> nie ma relacji <xref:System.Text.UTF32Encoding.GetBytes%2A>. Jeśli potrzebujesz podobną funkcję do użycia z <xref:System.Text.UTF32Encoding.GetBytes%2A>, użyj <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na tablicę znaków.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowane w formacie UTF-32, jeśli <see cref="T:System.Text.UTF32Encoding" /> obiektu jest skonfigurowany do Podaj profil.</summary>
        <returns>Tablica bajtów zawierająca znacznika kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UTF32Encoding" /> obiektu jest skonfigurowany do Podaj profil. W przeciwnym razie metoda ta zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding> Obiektu może zapewnić preambuły jest tablicą bajtów, które mogą być poprzedzone sekwencji bajtów wynikające z procesu kodowania. Prefacing sekwencji bajtów zakodowany za pomocą znacznika kolejności bajtów (punkty kodowe U + 0000 U + FEFF) pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Znacznika kolejności bajtów Unicode (BOM) jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian: 00 00 FF FE  
  
-   Mały kolejności bajtów endian: FF FE 00 00  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF32Encoding> którego <xref:System.Text.UTF32Encoding.GetPreamble%2A> metoda zwraca prawidłowy znak BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UTF32Encoding> obiektu zwróconego przez <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> właściwości.  
  
-   Przez wywołanie metody bez parametrów <xref:System.Text.UTF32Encoding.%23ctor> Konstruktor do tworzenia wystąpienia <xref:System.Text.UTF32Encoding> obiektu.  
  
-   Podając `true` jako wartość `byteOrderMark` argument <xref:System.Text.UTF32Encoding.%23ctor%2A> i <xref:System.Text.UTF32Encoding.%23ctor%2A> konstruktorów.  
  
 Zalecane jest użycie znaku BOM, ponieważ zapewnia niemal niektórych Identyfikacja kodowanie plików to inaczej utracić odwołanie do <xref:System.Text.UTF32Encoding> obiektu, na przykład nieoznakowany niepoprawnie oznakowane danych w sieci web i/lub przechowywane pliki losowego tekstu, gdy Business nie miał międzynarodowych problemów lub innych danych. Często może można uniknąć problemów użytkowników, jeśli dane spójne i odpowiednio oznaczone.  
  
 Pod kątem obsługi standardów, które udostępniają typ kodowania znak BOM jest nieco nadmiarowe. Jednak może służyć ułatwiające serwera wysyłaj poprawny nagłówek kodowania. Alternatywnie może służyć jako rezerwowe w przypadku, gdy kodowanie, w przeciwnym razie zostaną utracone.  
  
 Istnieją pewne wady za pomocą znak BOM. Na przykład jak ograniczyć polach bazy danych, które używają znak BOM, wiedząc, może być trudne. Łączenie plików, może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebne obydwie mogą znaleźć się w trakcie wykonywania danych. Mimo kilku wady jednak użycie znak BOM jest zdecydowanie zaleca się.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowany bajtów są poprawnie dekodowane, powinien prefiks zakodowany bajty od preambuły. Należy pamiętać, że <xref:System.Text.UTF32Encoding.GetBytes%2A> metody nie poprzedzić znak BOM sekwencji bajtów zakodowany; BOM na początku strumienia bajtów odpowiednie dostarczenie jest odpowiedzialność deweloperów.  
  
   
  
## Examples  
 Następujące kodu przykładzie pobiera i wyświetla znak kolejności bajtów dla różnych <xref:System.Text.UTF32Encoding> wystąpień.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 Poniższy przykład tworzy dwie <xref:System.Text.UTF32Encoding> obiektów, pierwszy z nich nie zawiera znak BOM i drugi która. Następnie wywołuje <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodę, aby zapisać BOM do pliku przed napisaniem ciąg zakodowany UTF-32. Dane wyjściowe z przykładu pokazują, plik, który zapisuje bajty z kodera drugi ma cztery większą liczbę bajtów, pierwszy.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Można również porównać plików za pomocą `fc` polecenie w oknie konsoli, lub można sprawdzić pliki w edytorze tekstu, który zawiera trybu widoku szesnastkowy. Należy pamiętać, że jeśli plik jest otwarty w edytorze, który obsługuje UTF-32, znak BOM nie jest wyświetlana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtów na ciąg.</summary>
        <returns>Ciąg, który zawiera wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), a tablica bajtów został zwrócony przez metodę typu pamiętać-BOM, znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF32Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF32Encoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład koduje ciąg w dwóch tablicach tablic bajtów, co w kolejności little-endian i drugi w kolejności big-endian. Dekoduje następnie bajtów do ciągu.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 Poniższy przykład Inicjuje tablicę, wywołując <xref:System.Text.UTF32Encoding.GetByteCount%2A> metodę, aby określić dokładnie liczbę bajtów są wymagane dla zakodowany ciąg, a następnie dodając rozmiar znacznika kolejności bajtów (BOM). Przykład następnie wywołuje <xref:System.Text.UTF32Encoding.GetPreamble%2A> metodę, aby przechowywać BOM do tablicy przed wywołaniem <xref:System.Text.UTF32Encoding.GetBytes%2A> metodę, aby przechowywać zakodowany bajtów do tablicy. Przykład następnie wywołuje <xref:System.Text.UTF32Encoding.GetString%2A> metoda zdekodować ciągu.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Należy pamiętać, że w tym przypadku Dekodowany ciąg różni się od oryginalnego ciągu, ponieważ rozpoczyna się znacznik kolejności bajtów 32-bitowych U + FFFE U + 0000. Oznacza to, czy dwa ciągi zostanie porównany ich nierówność i, jeśli ciąg jest dane wyjściowe, BOM będą wyświetlane jako znaku zastępczego "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
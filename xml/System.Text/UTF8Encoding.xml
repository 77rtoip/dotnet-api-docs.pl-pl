<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fb6c70ac0c176b49d4d924c136d74cf91ce93967" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36607443" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania UTF-8 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencję bajtów zakodowanego do zestawu znaków Unicode.  
  
 Kodowanie Unicode reprezentuje każdy punkt kodu sekwencję 1 do 4 bajtów jest UTF-8. W przeciwieństwie do kodowania UTF-16 i UTF 32 kodowania UTF-8 nie wymaga "kolejności bajtów"; schemat kodowania jest taki sam, niezależnie od tego, czy procesor jest big-endian lub little endian. <xref:System.Text.UTF8Encoding> odnosi się do systemu Windows strona kodowa 65001. Aby uzyskać więcej informacji o UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Można utworzyć wystąpienia <xref:System.Text.UTF8Encoding> obiekt na kilka sposobów, w zależności od tego, czy chcesz go zapewnienie znacznika kolejności bajtów (BOM) i określa, czy chcesz włączyć wykrywanie błędów. W poniższej tabeli wymieniono konstruktorów i <xref:System.Text.Encoding> właściwość, która zwraca <xref:System.Text.UTF8Encoding> obiektu.  
  
|Element członkowski|BOM|Wykrywanie błędów|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Tak|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|Nie|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.UTF8Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem.  
  
 Podobnie <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.UTF8Encoding.GetChars%2A> i <xref:System.Text.UTF8Encoding.GetString%2A> metody wykonać dekodowanie rzeczywistych.  
  
 Koder i dekoder, który może zapisać informacji o stanie podczas kodowania lub dekodowania danych obejmującej wiele bloków (na przykład ciąg znaków 1 milion zakodowany w segmentach 100 000 znaków), użyj <xref:System.Text.UTF8Encoding.GetEncoder%2A> i <xref:System.Text.UTF8Encoding.GetDecoder%2A> właściwości odpowiednio.  
  
 Opcjonalnie <xref:System.Text.UTF8Encoding> obiektu zawiera znacznik kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzona na początku będącą wynikiem proces kodowania strumienia bajtów. Strumień bajtów zakodowanym formacie UTF-8 jest poprzedzone znakiem znacznika kolejności bajtów (BOM), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Należy jednak pamiętać, że standardu Unicode nie wymaga ani strumieni zakodowane zaleca BOM w formacie UTF-8. Aby uzyskać więcej informacji o kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Koder jest skonfigurowana do dostarczania BOM, można przywrócić go przez wywołanie metody <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody; w przeciwnym razie metoda zwraca pustą tablicę. Należy zauważyć, że nawet jeśli <xref:System.Text.UTF8Encoding> obiektu jest skonfigurowany na potrzeby obsługi BOM, musi zawierać BOM na początku strumień bajtów zakodowanego zależnie od potrzeb; kodowania metody <xref:System.Text.UTF8Encoding> klasy nie należy tego robić automatycznie.  
  
> [!NOTE]
>  Aby włączyć wykrywanie błędów i zabezpieczyć wystąpienia klasy, należy wywołać <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> Konstruktor i zestaw `throwOnInvalidBytes` parametr `true`. Z wykrywanie błędów jest włączone, to metoda, która wykrywa nieprawidłową sekwencję znaków lub bajtów zgłasza <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nie wyjątku i Nieprawidłowa sekwencja jest brany pod uwagę.  
  
> [!NOTE]
>  Stan obiektu kodowany w formacie UTF-8 nie jest zachowywany, jeśli obiekt jest serializacji i deserializacji za pomocą innej wersji systemu .NET Framework.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding> obiekt do zakodowania ciąg znaków Unicode i przechowywać je w tablicy bajtów. Ciąg Unicode zawiera dwa znaki Pi (U + 03A0) i Sigma (U + 03A3), które są poza zakresem znaków ASCII. Gdy tablica bajtów zakodowany jest dekodowany wstecz na ciąg, Pi i Sigma znaki są nadal dostępne.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 W poniższym przykładzie użyto tych samych parametrach co w poprzednim przykładzie, z wyjątkiem tego, który zapisuje bajty zakodowanym w pliku i prefiksy strumień bajtów z znacznika kolejności bajtów (BOM). Następnie odczytuje plik na dwa sposoby: jako pliku tekstowego za pomocą <xref:System.IO.StreamReader> obiekt; i jako plik binarny. Jak można oczekiwać w przypadku ani BOM znajduje się w ciągu nowo odczytu.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie ma znacznik kolejności bajtów Unicode i nie zgłasza wyjątek po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa zaleca się włączyć wykrywanie błędów przez wywołanie konstruktora z `throwOnInvalidBytes` parametr i ustawienie jej wartość `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Text.UTF8Encoding> wystąpienia i wyświetla jego nazwę.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> Aby określić, że <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> metoda zwraca znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy. Parametr określa, czy zapewnienie znacznika kolejności bajtów Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątek po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie konstruktora, który obejmuje `throwOnInvalidBytes` parametr i ustawienie jej wartość `true`.  
  
 `encoderShouldEmitUTF8Identifier` Parametr steruje działaniem <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą znacznika kolejności bajtów Unicode (BOM) w formacie UTF-8.  Jeśli `false`, zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `encoderShouldEmitUTF8Identifier` do `true` nie powoduje <xref:System.Text.UTF8Encoding.GetBytes%2A> metodę prefiksu BOM na początku tablicy bajtów ani go powoduje <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę w celu uwzględnienia liczba bajtów w BOM liczba bajtów.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Text.UTF8Encoding> wystąpienia i określa, że prefiksem znacznika kolejności bajtów Unicode powinny być wysyłany przez <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody. <xref:System.Text.UTF8Encoding.GetPreamble%2A> Następnie metoda zwraca prefiksem znacznika kolejności bajtów Unicode.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> Aby określić, że <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> metoda powinna zwrócić znacznika kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli zostanie wykryte nieprawidłowe kodowanie; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy. Parametry określają, czy zapewnienie znacznika kolejności bajtów Unicode i Zgłoś wyjątek, jeśli zostanie wykryte nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `encoderShouldEmitUTF8Identifier` Parametr steruje działaniem <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą znacznika kolejności bajtów Unicode (BOM) w formacie UTF-8.  Jeśli `false`, zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `encoderShouldEmitUTF8Identifier` do `true` nie powoduje <xref:System.Text.UTF8Encoding.GetBytes%2A> metodę prefiksu BOM na początku tablicy bajtów ani go powoduje <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę w celu uwzględnienia liczba bajtów w BOM liczba bajtów.  
  
 Jeśli `throwOnInvalidBytes` jest `true`, metody, która wykrywa sekwencji nieprawidłowy bajt zgłasza <xref:System.ArgumentException?displayProperty=nameWithType> wyjątku. W przeciwnym razie metoda nie zgłasza wyjątek i Nieprawidłowa sekwencja jest ignorowana.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie konstruktora, który obejmuje `throwOnInvalidBytes` parametr i ustawienie parametru `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Text.UTF8Encoding> wystąpienia, określając, że <xref:System.Text.UTF8Encoding.GetPreamble%2A> — metoda nie powinna Emituj prefiksem znacznika kolejności bajtów Unicode i zgłaszany wyjątek, jeśli zostanie wykryte nieprawidłowe kodowanie. Zachowanie tego konstruktora jest porównywany domyślne <xref:System.Text.UTF8Encoding.%23ctor> konstruktora, który nie zgłasza wyjątek po wykryciu Nieprawidłowe kodowanie. Dwa <xref:System.Text.UTF8Encoding> wystąpień zakodować tablicy znaków, która zawiera dwa wysokiej części znaku dwuskładnikowego (U + D801 i U + D802) w wierszu, który jest nieprawidłową sekwencję znaków; zastępczym wysokiego poziomu powinny zawsze występować dwuskładnikowego.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy określony obiekt jest taki sam, jak bieżący <see cref="T:System.Text.UTF8Encoding" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.UTF8Encoding" /> i jest taki sam jak bieżący obiekt, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UTF8Encoding> obiekty są traktowane jako równe, jeśli spełnione są wszystkie poniższe warunki:  
  
-   Oba obiekty Podaj znacznika kolejności bajtów, lub obie nie.  
  
-   Zarówno do obiektów, użyj tego samego kodera rezerwowego.  
  
-   Oba obiekty Użyj tego samego dekoder rezerwowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.Equals%2A> metody do testowania czy bieżące <xref:System.Text.UTF8Encoding> obiekt jest taki sam innej <xref:System.Text.UTF8Encoding> obiektu. Cztery <xref:System.Text.UTF8Encoding> obiekty są tworzone i porównać i są wyświetlane wyniki porównania.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">
          <see cref="T:System.String" /> Zawierający zestaw znaków kodowania.</param>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie znaków w określonym <see cref="T:System.String" />.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialność i liczba bajtów w preambuły nie zostaną uwzględnione w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> — metoda.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> i <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> metody do obliczenia maksymalnej rzeczywista liczba bajtów potrzebna, aby zakodować ciąg. Wyświetla rzeczywistą liczbę bajtów wymaganą do zapisania strumień bajtów z znacznik kolejności bajtów.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków, zaczynając od wskaźnika określony znak.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> metody do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialność i liczba bajtów w preambuły nie zostaną uwzględnione w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> — metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.  - lub - wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów utworzonego przez zestaw znaków z określoną tablicę znaków kodowania.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać zastosowań <xref:System.Text.UTF8Encoding.GetByteCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialność i liczba bajtów w preambuły nie zostaną uwzględnione w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> — metoda.  
  
   
  
## Examples  
 Poniższy przykład powoduje wypełnienie tablicy o Latin wielkich i małych liter oraz wywołania <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę, aby określić liczbę bajtów potrzebne do kodowania znaki małe litery alfabetu łacińskiego. Następnie wyświetla te informacje oraz całkowita liczba bajtów, niezbędny w przypadku dodaniu znacznik kolejności bajtów. Następuje porównanie z wartością zwróconą przez ten numer <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodę, która określa maksymalną liczbę bajtów potrzebne do kodowania znaki małe litery alfabetu łacińskiego.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="chars" />.  - lub - wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> właściwość jest ustawiona na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestaw znaków w kolejności bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od wskaźnika określony znak do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określonym bajcie.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> zwrócony przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody odpowiednio.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialny za dewelopera. <xref:System.Text.UTF8Encoding.GetBytes%2A> — Metoda nie dołączy preambuły na początku sekwencji zakodowanego bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  - lub - <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  - lub - <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody odpowiednio.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialny za dewelopera. <xref:System.Text.UTF8Encoding.GetBytes%2A> — Metoda nie dołączy preambuły na początku sekwencji zakodowanego bajtów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetBytes%2A> do kodowania zakres znaków z ciągu i sklepach zakodowane bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  - lub - <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  - lub - <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  - lub - <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  - lub - <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody odpowiednio.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialny za dewelopera. <xref:System.Text.UTF8Encoding.GetBytes%2A> — Metoda nie dołączy preambuły na początku sekwencji zakodowanego bajtów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetBytes%2A> metodę kodowania zakresu elementów z tablicy znaków Unicode i przechowywać zakodowanego bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.  - lub - <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  - lub - <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  - lub - <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  - lub - <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów, licząc od wskaźnika określonym bajcie.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.  - lub - wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.DecoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetCharCount%2A> metoda zwraca liczbę znaków utworzonego przez dekodowania szereg elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  - lub - wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.DecoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisu.</param>
        <summary>Dekoduje sekwencję bajtów, licząc od wskaźnika określonym bajcie do zestawu znaków, które są przechowywane, zaczynając od wskaźnika określony znak.</summary>
        <returns>Rzeczywista liczba znaków zapisany w lokalizacji wskazanej przez <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Jeśli zakres bajtów ma być zdekodowany zawiera znacznika kolejności bajtów (BOM) i Tablica bajtów został zwrócony przez metodę typu pamiętać z systemem innym niż BOM, znak U + FFFE znajduje się w tablicy znaków zwracane przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczony przez obiekt <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  - lub - <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  - lub - <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.DecoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z określonej tablicy bajtów do określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków w zapisywane <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Jeśli zakres bajtów ma być zdekodowany zawiera znacznika kolejności bajtów (BOM) i Tablica bajtów został zwrócony przez metodę typu pamiętać z systemem innym niż BOM, znak U + FFFE znajduje się w tablicy znaków zwracane przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetChars%2A> sposób dekodowania zakresu elementów w tablicy bajtowej i zapisać wynik w tablicy znaków.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  - lub - <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza od zera.  - lub - <paramref name="byteindex" /> i <paramref name="byteCount" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  - lub - <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  - lub - <paramref name="chars" /> nie ma wystarczającej wydajności z <paramref name="charIndex" /> do końca tablicy, tak aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.DecoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje sekwencję kodowany w formacie UTF-8 bajtów na sekwencję znaków Unicode.</summary>
        <returns>Dekoder, który konwertuje UTF-8 zakodowany sekwencję bajtów w sekwencji znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów na bloki kolejnych znaków w sposób podobny do <xref:System.Text.UTF8Encoding.GetChars%2A> metody tej klasy. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami tak on prawidłowo zdekodować sekwencji bajtów, obejmujące bloków. <xref:System.Text.Decoder> Również zachowuje bajtów końcowych na końcu bloki danych i używa bajtów końcowych w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF8Encoding.GetDecoder%2A> i <xref:System.Text.UTF8Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
 Jeśli wykrywanie błędów jest włączona, oznacza to, `throwOnInvalidCharacters` ustawiono parametr konstruktora `true`, wykrywanie błędów również jest włączone w <xref:System.Text.Decoder> zwracane przez tę metodę. Napotkano nieprawidłową sekwencję wykrywanie błędów jest włączone, stan dekodera jest niezdefiniowane i przetwarzania należy zatrzymać.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodę, aby uzyskać dekodera UTF-8. Dekoder konwertuje sekwencję bajtów sekwencji znaków.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencji znaków Unicode do sekwencji kodowany w formacie UTF-8 bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> sekwencji znaków Unicode, który konwertuje na sekwencję kodowany w formacie UTF-8 bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków na kolejne bloki bajtów w sposób podobny do <xref:System.Text.UTF8Encoding.GetBytes%2A> metody. Jednak <xref:System.Text.Encoder> przechowuje informacje o stanie między wywołaniami tak ją poprawnie kodowania sekwencji znaków, które obejmują bloków. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloki danych i używa znaki końcowe w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane zastępczym wysokiego poziomu, a pasujące dwuskładnikowego może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.UTF8Encoding.GetDecoder%2A> i <xref:System.Text.UTF8Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
 Jeśli wykrywanie błędów jest włączona, oznacza to, `throwOnInvalidCharacters` ustawiono parametr konstruktora `true`, wykrywanie błędów również jest włączone w <xref:System.Text.Encoder> zwracane przez tę metodę. Napotkano nieprawidłową sekwencję wykrywanie błędów jest włączone, stan koder jest niezdefiniowane i przetwarzania należy zatrzymać.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodę, aby uzyskać kodera, aby przekonwertować sekwencji znaków UTF-8 zakodowane sekwencji bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetHashCode%2A> metoda zwraca wartość skrótu dla <xref:System.Text.UTF8Encoding> wystąpień. Powiadomienie, że skrótu zwracane przez tę metodę jest zależna od Konstruktor używany do tworzenia <xref:System.Text.UTF8Encoding> obiektu.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów utworzone przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów utworzone przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> jest liczbą najgorszego łącznie najgorszego dla aktualnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> może zwrócić dużej wartości.  
  
 W większości przypadków ta metoda zwraca wartość liczby uzasadnione dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach przekroczenie bardziej przystępne buforu. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.UTF8Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Na przykład tekst w języku angielskim i wielu innych języków często wymaga tylko jednego bajtu UTF-8, do reprezentowania znak, ale liczba zwróconych przez <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> musi zapewniać możliwość, że ciąg do przekonwertowania będzie składać się wyłącznie z znaków każdy wymaga czterech bajtów.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> nie ma związku <xref:System.Text.UTF8Encoding.GetChars%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF8Encoding.GetChars%2A>, należy go używać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodę, aby zwrócić maksymalną liczbę bajtów wymaganą do kodowania określoną liczbę znaków.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza od zera.  - lub - wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.EncoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, utworzonego przez dekodowania określoną liczbę bajtów.</summary>
        <returns>Maksymalna liczba znaków utworzonego przez dekodowania określoną liczbę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> — metoda. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> jest liczbą najgorszego łącznie najgorszego dla aktualnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> może zwrócić dużej wartości.  
  
 W większości przypadków ta metoda zwraca wartość liczby uzasadnione dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach przekroczenie bardziej przystępne buforu.  Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.UTF8Encoding.GetCharCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.UTF8Encoding.GetBytes%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF8Encoding.GetBytes%2A>, należy go używać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodę, aby zwrócić maksymalną liczbę znaków utworzonego przez dekodowania określoną liczbę bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza od zera.  - lub - wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.DecoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowane w formacie UTF-8, jeśli <see cref="T:System.Text.UTF8Encoding" /> skonfigurowano obiekt kodowania go.</summary>
        <returns>Tablica bajtów zawierająca znacznika kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UTF8Encoding" /> skonfigurowano obiekt kodowania go. W przeciwnym razie ta metoda zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF8Encoding> Obiektu zapewniają preambuły jest tablica bajtów, które mogą być poprzedzona do sekwencji bajtów, które wynikają z procesu kodowania. Prefacing sekwencję zakodowanego bajtów z znacznika kolejności bajtów (punkt kodu U + FEFF) pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Znacznika kolejności bajtów Unicode (BOM) jest szeregowana jako 0xEF 0xBB 0xBF. Należy pamiętać, że standardu Unicode nie wymaga ani nie zaleca się stosowania BOM UTF-8 zakodowany strumieni.  
  
 Można utworzyć wystąpienia <xref:System.Text.UTF8Encoding> którego <xref:System.Text.UTF8Encoding.GetPreamble%2A> metoda zwraca prawidłowe BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UTF8Encoding> obiektu zwróconego przez <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> właściwości.  
  
-   Wywołując <xref:System.Text.UTF8Encoding> konstruktora z `encoderShouldEmitUTF8Identifier` parametr i ustawienie z wartością ustawioną na `true`.  
  
 Wszystkie inne <xref:System.Text.UTF8Encoding> obiekty są konfigurowane do zwrócić pustą tablicę zamiast BOM prawidłowe.  
  
 BOM Zidentyfikuj niemal niektórych kodowania plików, które w przeciwnym razie utracić odwołanie do ich kodowania, takich jak web nieoznakowanego lub nieprawidłowo oznaczyć danych lub pliki losowego tekstu przechowywane, jeśli firma nie miał międzynarodowe problemy. Często problemów użytkowników może można uniknąć, jeśli dane spójnie i odpowiednio oznakowane.  
  
 Standardów, które udostępniają typ kodowania BOM jest nieco nadmiarowy. Jednak można użyć ułatwiające serwer wysłał poprawne kodowania nagłówka. Alternatywnie może służyć jako rezerwowe w przypadku kodowanie, w przeciwnym razie zostaną utracone.  
  
 Dostępne są niektóre wady przy użyciu BOM. Na przykład wiedząc, jak ograniczyć pola bazy danych, które używają BOM może być trudne. Łączenie plików może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebnych może zakończyć środku danych. Mimo kilku wady jednak użycie BOM jest zdecydowanie zalecane.  
  
 Aby uzyskać więcej informacji o kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks początek strumienia bajtów zakodowanego o preambuły. Należy pamiętać, że <xref:System.Text.UTF8Encoding.GetBytes%2A> — metoda nie dołączy BOM do sekwencji bajtów zakodowanego; podanie BOM na początku strumień bajtów odpowiednie jest odpowiedzialność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetPreamble%2A> znak zakodowane w formacie UTF-8 kolejność metodę, aby zwrócić bajtów Unicode. Zwróć uwagę, że domyślnego konstruktora dla <xref:System.Text.UTF8Encoding> nie zapewnia preambuły.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Poniższy przykład tworzy dwa <xref:System.Text.UTF8Encoding> obiektów, pierwsza przez wywołanie metody bez parametrów <xref:System.Text.UTF8Encoding.%23ctor> konstruktora, który nie zapewnia wywołując BOM, a drugi <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> konstruktora z jego `encoderShouldEmitUTF8Identifier` argument wartość `true`. Następnie wywołuje <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodę, aby przed zapisaniem ciąg kodowany w formacie UF8 zapisać BOM do pliku. Jak pokazano na dane wyjściowe z przykładu z konsoli, pliku, który zapisuje bajty z drugiego kodera ma trzy więcej bajtów niż pierwszy.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 Można także porównać pliki za pomocą `fc` polecenie w oknie konsoli lub należy sprawdzić pliki w edytorze tekstu, zawierającą tryb wyświetlania szesnastkowy. Należy pamiętać, że jeśli plik jest otwarty w edytorze, który obsługuje UTF-8, BOM nie jest wyświetlana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtowej na ciąg.</summary>
        <returns>A <see cref="T:System.String" /> zawierającego wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Jeśli zakres bajtów ma być zdekodowany zawiera znacznika kolejności bajtów (BOM) i Tablica bajtów został zwrócony przez metodę typu pamiętać z systemem innym niż BOM, znak U + FFFE znajduje się w tablicy znaków zwracane przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie inicjowane tablicy przez wywołanie metody <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę, aby określić dokładnie liczbę bajtów są wymagane dla zaszyfrowanym ciągiem, a następnie dodanie rozmiar znacznika kolejności bajtów (BOM). Przykład wywołuje <xref:System.Text.UTF8Encoding.GetPreamble%2A> przechowywania BOM do tablicy przed wywołaniem metody <xref:System.Text.UTF8Encoding.GetBytes%2A> metody do przechowywania zakodowanego bajtów do tablicy. Przykład wywołuje <xref:System.Text.UTF8Encoding.GetString%2A> metody zdekodować ciągu.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Należy pamiętać, że w takim przypadku Dekodowany ciąg różni się od oryginalnego ciągu, ponieważ rozpoczyna się znacznik kolejności bajtów 16-bitowych U + FFFD. Oznacza to, czy porównuje dwa ciągi jako nierównej i że ciągu w przypadku dane wyjściowe, BOM będzie wyświetlany jako znak zastępczy "?". Aby usunąć BOM na początku ciąg, można wywołać <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET dla pełne wyjaśnienie) - i - <see cref="P:System.Text.Encoding.DecoderFallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
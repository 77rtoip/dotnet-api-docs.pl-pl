<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0cd6864b3235bb1d4b70e10a4b4c1533327cf909" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48763715" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF8Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania UTF-8 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencji bajtów zakodowany zestaw znaków Unicode.  
  
 UTF-8 to, że Unicode kodowania, które reprezentuje każdy punkt kodu jako sekwencja jednej do czterech bajtów. W przeciwieństwie do kodowania UTF-16 i UTF-32 kodowanie UTF-8 nie wymaga "kolejność bajtów"; schemat kodowania jest taki sam, niezależnie od tego, czy procesor jest little-endian lub big-endian. <xref:System.Text.UTF8Encoding> odnosi się do Windows strona kodowa 65001. Aby uzyskać więcej informacji na temat UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF8Encoding> obiektu na różne sposoby w zależności od tego, czy chcesz go zapewnienie znacznika kolejności bajtów (BOM) i czy chcesz włączyć wykrywanie błędów. W poniższej tabeli wymieniono konstruktory i <xref:System.Text.Encoding> właściwość, która zwraca <xref:System.Text.UTF8Encoding> obiektu.  
  
|Element członkowski|BOM|Wykrywanie błędów|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Tak|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|Nie|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.UTF8Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania.  
  
 Podobnie <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.UTF8Encoding.GetChars%2A> i <xref:System.Text.UTF8Encoding.GetString%2A> metody wykonywania rzeczywiste dekodowania.  
  
 Dla koder i dekoder, który jest w stanie zapisać informacje o stanie podczas kodowania lub dekodowania danych, która obejmuje wiele bloków (na przykład ciąg 1 milion znaków, który jest kodowany w segmentach 100 000 znaków), użyj <xref:System.Text.UTF8Encoding.GetEncoder%2A> i <xref:System.Text.UTF8Encoding.GetDecoder%2A> właściwości odpowiednio.  
  
 Opcjonalnie <xref:System.Text.UTF8Encoding> obiekt zawiera znacznika kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzone na początku strumienia bajtów, która wynika z procesu kodowania. Jeśli strumień zakodowany bajtów UTF-8 są poprzedzone znakiem znacznika kolejności bajtów (BOM), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Należy jednak pamiętać, że Unicode Standard nie wymaga ani nie zaleca BOM w formacie UTF-8 zakodowany strumieni. Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Jeśli kodera jest skonfigurowana do dostarczania znak BOM, można go pobrać, wywołując <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody; w przeciwnym razie metoda zwraca pustą tablicę. Należy zauważyć, że nawet wtedy, gdy <xref:System.Text.UTF8Encoding> obiektu jest skonfigurowany na potrzeby obsługi BOM, musi zawierać znak BOM na początku strumienia bajtów zakodowany zgodnie z potrzebami; metody kodowania <xref:System.Text.UTF8Encoding> klasy nie należy tego robić automatycznie.  
  
> [!NOTE]
>  Aby włączyć wykrywanie błędów i zabezpieczyć wystąpienia klasy, należy wywołać <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> Konstruktor i zestaw `throwOnInvalidBytes` parametr `true`. Za pomocą wykrywania błędów jest włączone, metody, która wykrywa nieprawidłową sekwencję znaków lub bajtów zgłasza <xref:System.ArgumentException> wyjątku. Bez wykrycia błąd jest zgłaszany żaden wyjątek, a nieprawidłowa sekwencja jest brany pod uwagę.  
  
> [!NOTE]
>  Stan obiektu kodowany w formacie UTF-8 nie są zachowywane, jeśli obiekt jest serializacji i deserializacji za pomocą różnych wersji programu .NET Framework.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding> obiekt do zakodowania ciąg znaków Unicode i przechowywać je w tablicy bajtów. Ciąg Unicode zawiera dwa znaki Pi (U + 03A0) i Sigma (U + 03A3), które są spoza zakresu znaków ASCII. Gdy tablica zakodowany bajtowej jest dekodowana do ciągu, Pi i Sigma znaki są nadal dostępne.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 W poniższym przykładzie użyto tych samych parametrach jak w poprzednim przykładzie, z tą różnicą, że zapisuje zakodowany bajtów do pliku, a prefiksy strumień bajtów przy użyciu znacznika kolejności bajtów (BOM). Następnie odczytuje plik na dwa sposoby: jako plik tekstowy przy użyciu <xref:System.IO.StreamReader> obiektu; i jako plik binarny. Jak można oczekiwać w przypadku ani BOM znajduje się w ciągu nowo odczytu.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zawiera znacznika kolejności bajtów Unicode i nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa zaleca się włączyć wykrywanie błędów przez wywołanie konstruktora z `throwOnInvalidBytes` parametr i ustawiając jej wartość na `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Text.UTF8Encoding> wystąpienia i wyświetla jego nazwę.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding encoderShouldEmitUTF8Identifier" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> Aby określić, że <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> metoda zwróci wartość znacznika kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy. Parametr określa, czy należy podać znacznika kolejności bajtów Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie konstruktora, który zawiera `throwOnInvalidBytes` parametr i ustawiając jej wartość na `true`.  
  
 `encoderShouldEmitUTF8Identifier` Parametr steruje działaniem <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą Unicode znacznik kolejności bajtów (BOM) w formacie UTF-8.  Jeśli `false`, funkcja zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `encoderShouldEmitUTF8Identifier` do `true` nie powoduje <xref:System.Text.UTF8Encoding.GetBytes%2A> metody jako prefiks BOM na początku tablicy bajtowej, ani nie powoduje ona, że <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę, aby uwzględnić liczbę bajtów w BOM liczba bajtów.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Text.UTF8Encoding> wystąpienia i określa, że prefiksem znacznika kolejności bajtów Unicode powinny być emitowana przez <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody. <xref:System.Text.UTF8Encoding.GetPreamble%2A> Następnie metoda zwraca prefiksem znacznika kolejności bajtów Unicode.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF8Encoding : bool * bool -&gt; System.Text.UTF8Encoding" Usage="new System.Text.UTF8Encoding (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          <see langword="true" /> Aby określić, że <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> metoda powinna zwrócić znacznika kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> Aby zgłosić wyjątek, jeśli zostanie wykryte nieprawidłowe kodowanie; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF8Encoding" /> klasy. Parametry określają, czy zapewnienie znacznika kolejności bajtów Unicode i czy chcesz zgłosić wyjątek po wykryciu Nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `encoderShouldEmitUTF8Identifier` Parametr steruje działaniem <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą Unicode znacznik kolejności bajtów (BOM) w formacie UTF-8.  Jeśli `false`, funkcja zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `encoderShouldEmitUTF8Identifier` do `true` nie powoduje <xref:System.Text.UTF8Encoding.GetBytes%2A> metody jako prefiks BOM na początku tablicy bajtowej, ani nie powoduje ona, że <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę, aby uwzględnić liczbę bajtów w BOM liczba bajtów.  
  
 Jeśli `throwOnInvalidBytes` jest `true`, zgłasza wyjątek w metodzie, która wykrywa sekwencji nieprawidłowy bajt <xref:System.ArgumentException?displayProperty=nameWithType> wyjątku. W przeciwnym razie metoda nie zgłasza wyjątku, i jest ignorowana nieprawidłową sekwencję.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie konstruktora, który zawiera `throwOnInvalidBytes` parametr i ustawienie tego parametru `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Text.UTF8Encoding> wystąpienia, określając, że <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody nie powinien emitować prefiksem znacznika kolejności bajtów Unicode i należy zgłosić wyjątek po wykryciu Nieprawidłowe kodowanie. Zachowanie tego konstruktora jest porównywany z domyślnie <xref:System.Text.UTF8Encoding.%23ctor> konstruktora, który nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie. Dwa <xref:System.Text.UTF8Encoding> wystąpień kodowanie tablicę znaków, która zawiera dwa surogaty wysokiej (U + D801 i U + D802) w wierszu, który jest nieprawidłową sekwencję znaków; znakiem zastępczym wysokiego poziomu powinny zawsze występować znak zastępczy niskiego poziomu.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF8Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Określa, czy określony obiekt jest taki sam, do bieżącego <see cref="T:System.Text.UTF8Encoding" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.UTF8Encoding" /> i jest taki sam jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UTF8Encoding> obiekty są traktowane jako równe, jeśli spełnione są wszystkie następujące warunki:  
  
-   Oba obiekty zapewniają znacznika kolejności bajtów lub oba nie obsługują.  
  
-   Oba obiekty, użyj tego samego kodera rezerwowego.  
  
-   Oba obiekty, użyj tego samego dekoder rezerwowego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.Equals%2A> metody do testowania czy bieżący <xref:System.Text.UTF8Encoding> obiekt jest taki sam na inne <xref:System.Text.UTF8Encoding> obiektu. Cztery <xref:System.Text.UTF8Encoding> obiekty są tworzone i porównywane, a wyniki porównania są wyświetlane.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF8Encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">
          <see cref="T:System.String" /> Zawierający zestaw znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie znaków w określonym <see cref="T:System.String" />.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> i <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> metody służące do obliczania maksymalnej rzeczywista liczba bajtów potrzebnych do zakodowania ciąg. Wyświetla również rzeczywista liczba bajtów potrzebnych do przechowania strumień bajtów przy użyciu znacznika kolejności bajtów.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> metodę, aby przechowywać wynikowy bajtów, należy wywołać <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF8Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, z określoną tablicę znaków.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie zastosowań <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład powoduje wypełnienie tablicy o liczbie łaciński, wielkie i małe litery i wywołania <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę pozwala ustalić liczbę bajtów potrzebnych do zakodowania znaki małe litery alfabetu łacińskiego. Następnie wyświetla te informacje wraz z całkowitą liczbą bajtów potrzebnych Jeśli znacznik kolejności bajtów jest dodawany. Porównuje tę liczbę za pomocą wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody, która określa maksymalną liczbę bajtów potrzebnych do zakodowania znaki małe litery alfabetu łacińskiego.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
<see cref="P:System.Text.Encoding.EncoderFallback" /> Właściwość jest ustawiona na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestawu znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="uTF8Encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od określonego znaku wskaźnika do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub jeśli ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> zwrócone przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody, odpowiednio.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UTF8Encoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków, z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub jeśli ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody, odpowiednio.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UTF8Encoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetBytes%2A> metody do zakodowania szeroką gamę znaków z ciągu i magazyny zakodowany bajtów w zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF8Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Zawierający zestaw znaków do zakodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub jeśli ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody, odpowiednio.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UTF8Encoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetBytes%2A> metody do zakodowania zakres elementów w tablicy znaków Unicode i przechowywać zakodowany bajtów w zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF8Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetCharCount%2A> metodę, aby zwrócić liczbę znaków, generowane przez dekodowanie zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów w zestawie znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Dekoduje sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów do zestawu znaków, które są przechowywane, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w lokalizacji wskazanej przez <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub jeśli ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> obiekt udostępniany przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody, odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF8Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów na określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub jeśli ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetChars%2A> metody dekodowania zakres elementów w tablicy bajtów i zapisać wynik w tablicy znaków.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF8Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje sekwencję kodowany w formacie UTF-8 bajtów do sekwencji znaków Unicode.</summary>
        <returns>Dekoder, który konwertuje UTF-8 zakodowany sekwencji bajtów do sekwencji znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów do kolejnych bloków znaków, w sposób podobny do <xref:System.Text.UTF8Encoding.GetChars%2A> metody tej klasy. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami, aby go można prawidłowo zdekodować sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF8Encoding.GetDecoder%2A> i <xref:System.Text.UTF8Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 Jeśli błędów jest włączone wykrywanie, oznacza to, `throwOnInvalidCharacters` parametr konstruktora jest ustawiony na `true`, również jest włączone wykrywanie błędów w <xref:System.Text.Decoder> zwracanego przez tę metodę. Jeśli napotka nieprawidłową sekwencję wykrywanie błędów jest włączone, stan dekodera jest niezdefiniowana, i należy zatrzymać przetwarzanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetDecoder%2A> metodę, aby uzyskać dekodera UTF-8. Dekoder konwertuje sekwencję bajtów na sekwencję znaków.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF8Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencję znaków Unicode do sekwencji kodowany w formacie UTF-8 bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> konwertuje sekwencję znaków Unicode do sekwencji kodowany w formacie UTF-8 bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków do kolejnych bloków bajtów w sposób podobny do <xref:System.Text.UTF8Encoding.GetBytes%2A> metody. Jednak <xref:System.Text.Encoder> przechowuje informacje o stanie między wywołaniami, więc może ona poprawne kodowanie sekwencje znaków, które rozciągają się bloki. <xref:System.Text.Encoder> Również zachowuje końcowe znaki na końcu bloków danych i korzysta z nieprawidłowymi znakami w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane znakiem zastępczym wysokiego poziomu, a pasujące znak zastępczy niskiego poziomu może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.UTF8Encoding.GetDecoder%2A> i <xref:System.Text.UTF8Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 Jeśli błędów jest włączone wykrywanie, oznacza to, `throwOnInvalidCharacters` parametr konstruktora jest ustawiony na `true`, również jest włączone wykrywanie błędów w <xref:System.Text.Encoder> zwracanego przez tę metodę. Jeśli napotka nieprawidłową sekwencję wykrywanie błędów jest włączone, stan kodera jest niezdefiniowana, i należy zatrzymać przetwarzanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetEncoder%2A> metodę, aby uzyskać kodera w celu konwersji sekwencji znaków na UTF-8 zakodowane sekwencji bajtów.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF8Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetHashCode%2A> metodę, aby zwrócić wartość skrótu dla <xref:System.Text.UTF8Encoding> wystąpień. Zwróć uwagę, że skrótu zwracanego przez tę metodę jest zależna od konstruktora, który został użyty do utworzenia <xref:System.Text.UTF8Encoding> obiektu.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF8Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów, generowane przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów, generowane przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metody. <xref:System.Text.UTF8Encoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> jest liczbą najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda zwraca uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Można także rozważyć użycie innego podejścia <xref:System.Text.UTF8Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Na przykład tekst w języku angielskim i wiele innych języków często wymaga tylko jednego bajtu UTF-8 do reprezentowania znaku, ale liczba zwróconych przez <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> musi zapewniać możliwość, że ciąg do przekonwertowania będzie składać się wyłącznie z znaków każdy wymaga czterech bajtów.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> nie ma związku <xref:System.Text.UTF8Encoding.GetChars%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF8Encoding.GetChars%2A>, powinna korzystać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> metodę, aby zwrócić maksymalną liczbę bajtów wymaganych do kodowania określoną liczbę znaków.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF8Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, generowane przez określoną liczbę bajtów do zdekodowania.</summary>
        <returns>Maksymalna liczba znaków, generowane przez określoną liczbę bajtów do zdekodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF8Encoding.GetChars%2A> aby przechowywać wynikowy znaków, należy wywołać <xref:System.Text.UTF8Encoding.GetCharCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metody. <xref:System.Text.UTF8Encoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> jest liczbą najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda zwraca uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne.  Można także rozważyć użycie innego podejścia <xref:System.Text.UTF8Encoding.GetCharCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.UTF8Encoding.GetBytes%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF8Encoding.GetBytes%2A>, powinna korzystać <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> metodę, aby zwrócić maksymalną liczbę znaków generowane przez określoną liczbę bajtów dekodowania.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF8Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowane w formacie UTF-8, jeśli <see cref="T:System.Text.UTF8Encoding" /> obiekt kodowania jest skonfigurowany do Podaj profil.</summary>
        <returns>Tablica bajtów zawierająca znacznika kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UTF8Encoding" /> obiekt kodowania jest skonfigurowany do Podaj profil. W przeciwnym razie metoda ta zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF8Encoding> Obiektu może zapewnić preambuły jest tablica bajtów, która może być poprzedzona sekwencji bajtów, które wynikają z procesu kodowania. Prefacing sekwencji bajtów zakodowany za pomocą znacznika kolejności bajtów (punkt kodowy U + FEFF) pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Znacznika kolejności bajtów Unicode (BOM) jest serializowany jako 0xEF 0xBB 0xBF. Należy pamiętać, że Unicode Standard nie wymaga nie zaleca stosowania znak BOM UTF-8 zakodowany strumieni.  
  
 Można utworzyć wystąpienie <xref:System.Text.UTF8Encoding> którego <xref:System.Text.UTF8Encoding.GetPreamble%2A> metoda zwraca prawidłowy znak BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UTF8Encoding> obiektu zwróconego przez <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> właściwości.  
  
-   Przez wywołanie metody <xref:System.Text.UTF8Encoding> konstruktora z `encoderShouldEmitUTF8Identifier` parametr i ustawiając jej wartość równa `true`.  
  
 Wszystkie inne <xref:System.Text.UTF8Encoding> obiekty są konfigurowane do zwrócenia pustej tablicy, a nie w prawidłowy znak BOM.  
  
 Znak BOM identyfikacji prawie pewne kodowania dla plików, które w przeciwnym razie utracić odwołanie do ich kodowania, takich jak web tagów lub niepoprawnie oznakowane danych lub plików losowego tekstu zapisana, gdy firma nie ma międzynarodowy problemy. Może być można uniknąć często problemów użytkowników, jeśli dane spójne i odpowiednio oznaczone.  
  
 Pod kątem obsługi standardów, które udostępniają typ kodowania znak BOM jest nieco nadmiarowe. Jednak może służyć ułatwiające serwera wysyłaj poprawny nagłówek kodowania. Alternatywnie może służyć jako rezerwowe w przypadku, gdy kodowanie, w przeciwnym razie zostaną utracone.  
  
 Istnieją pewne wady za pomocą znak BOM. Na przykład jak ograniczyć polach bazy danych, które używają znak BOM, wiedząc, może być trudne. Łączenie plików, może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebne obydwie mogą znaleźć się w trakcie wykonywania danych. Mimo kilku wady jednak użycie znak BOM jest zdecydowanie zaleca się.  
  
 Aby uzyskać więcej informacji na temat kolejności bajtów i znacznika kolejności bajtów, patrz Unicode Standard na [strony głównej Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks początku strumień zakodowany w bajtach od preambuły. Należy pamiętać, że <xref:System.Text.UTF8Encoding.GetBytes%2A> metody nie poprzedzić znak BOM sekwencji bajtów zakodowany; BOM na początku strumienia bajtów odpowiednie dostarczenie jest odpowiedzialność deweloperów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.UTF8Encoding.GetPreamble%2A> metody zwracają wartość bajtu Unicode kolejność znacznik zakodowane w formacie UTF-8. Należy zauważyć, że domyślnego konstruktora dla <xref:System.Text.UTF8Encoding> nie zapewnia preambuły.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Poniższy przykład tworzy dwie <xref:System.Text.UTF8Encoding> obiektów, pierwszy przez wywołanie metody bez parametrów <xref:System.Text.UTF8Encoding.%23ctor> konstruktora, który nie zawiera znak BOM, a drugi, wywołując <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> konstruktora z jego `encoderShouldEmitUTF8Identifier` argument wartość `true`. Następnie wywołuje <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodę, aby przed zapisaniem ciąg kodowany w formacie UF8 zapisać BOM do pliku. Konsola danych wyjściowych z przykładu pokazują, plik który zapisuje bajty z kodera drugi ma trzy bajty więcej niż pierwszy.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 Można również porównać plików za pomocą `fc` polecenie w oknie konsoli, lub można sprawdzić pliki w edytorze tekstu, który zawiera trybu widoku szesnastkowy. Należy pamiętać, że jeśli plik jest otwarty w edytorze, który obsługuje UTF-8, znak BOM nie jest wyświetlana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF8Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtów na ciąg.</summary>
        <returns>A <see cref="T:System.String" /> zawierającą wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException> wyjątku. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub jeśli ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, użyj <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF8Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF8Encoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład Inicjuje tablicę, wywołując <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę, aby określić dokładnie liczbę bajtów są wymagane dla zakodowany ciąg, a następnie dodając rozmiar znacznika kolejności bajtów (BOM). Przykład następnie wywołuje <xref:System.Text.UTF8Encoding.GetPreamble%2A> metodę, aby przechowywać BOM do tablicy przed wywołaniem <xref:System.Text.UTF8Encoding.GetBytes%2A> metodę, aby przechowywać zakodowany bajtów do tablicy. Przykład następnie wywołuje <xref:System.Text.UTF8Encoding.GetString%2A> metoda zdekodować ciągu.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Należy pamiętać, że w tym przypadku Dekodowany ciąg różni się od oryginalnego ciągu, ponieważ rozpoczyna się znacznik kolejności bajtów 16-bitowych U + FFFD. Oznacza to, czy dwa ciągi zostanie porównany ich nierówność i, jeśli ciąg jest dane wyjściowe, BOM będą wyświetlane jako znaku zastępczego "?". Aby usunąć znak BOM na początku ciągu, można wywołać <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
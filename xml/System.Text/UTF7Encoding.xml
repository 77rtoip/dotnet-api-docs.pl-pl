<Type Name="UTF7Encoding" FullName="System.Text.UTF7Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40f36be3d79f3c461e6cad74d571b93712f0f577" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30579889" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF7Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF7Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF7Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF7Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF7Encoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania UTF-7 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencję bajtów zakodowanego do zestawu znaków Unicode.  
  
 Kodowanie UTF-7 reprezentuje znaków Unicode jako sekwencję 7-bitowe znaki ASCII. Ten typ kodowania obsługuje niektórych protokołów, dla których wymagane jest, najczęściej poczty e-mail lub grup dyskusyjnych protokołów. Ponieważ UTF-7 nie jest szczególnie bezpieczny i niezawodny i większość nowoczesnych systemów Zezwalaj kodowania 8-bitową, UTF-8 należy preferowana względem UTF-7.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Ze względów bezpieczeństwa należy używać aplikacji <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
 Aby uzyskać więcej informacji o UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.UTF7Encoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem.  
  
 Podobnie <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.UTF7Encoding.GetChars%2A> i <xref:System.Text.UTF7Encoding.GetString%2A> metody wykonać dekodowanie rzeczywistych.  
  
 <xref:System.Text.UTF7Encoding> odnosi się do strony kodowej systemu Windows 65000.  
  
> [!NOTE]
>  Stan obiektu zakodowane UTF-7 nie jest zachowywany, jeśli obiekt jest serializacji i deserializacji za pomocą innej wersji systemu .NET Framework.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding> kodowanie ciągu znaków Unicode i przechowywać je w tablicy bajtów. Zwróć uwagę, że gdy tablica bajtów jest dekodowany ciąg do, zostały utracone żadne dane.  
  
 [!code-cpp[System.Text.UTF7Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF7Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF7Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF7Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF7Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF7Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zezwala na znaki opcjonalne. Wywoływanie <xref:System.Text.UTF7Encoding.%23ctor%2A> Konstruktor jest odpowiednikiem wywołania <xref:System.Text.UTF7Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType> konstruktora przyjmującego `allowOptionals` parametru i określając `false` tego parametru.  
  
 Wystąpienie umożliwia znaki opcjonalne, punktów kodowych Unicode są zakodowane za pomocą odpowiednich opcjonalnego parametru zamiast podstawowej zmodyfikowane 64 znaki. Znaki opcjonalne są wykrzyknika ("!"), ukośnik odwrotny ("\\"), linii pionowej ("&#124;"), podwójnego cudzysłowu ("" "), liczba znak ("#"), dolara ("$"), wartość procentowa znak ("%"), ampersandu ("& "), gwiazdka (" * "), średnikami (";"), po lewej nawiasu ostrego ("\<"), prawego nawiasu ostrego (">"), lewego nawiasu klamrowego ("{"), prawy nawias klamrowy ("}"), otwierający nawias kwadratowy ("["), prawy nawias kwadratowy ("]"), znak równości ("="), znak ("@"), akcentu cyrkumfleksowego ("^"), znaku podkreślenia ("_") i grave Akcent ("" ").  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia nowego <xref:System.Text.UTF7Encoding> wystąpień i wyświetlanie nazwy kodowania.  
  
 [!code-cpp[System.Text.UTF7Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF7Encoding (bool allowOptionals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool allowOptionals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (allowOptionals As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF7Encoding(bool allowOptionals);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="allowOptionals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowOptionals">
          <see langword="true" /> Aby określić, czy znaki opcjonalne są dozwolone; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF7Encoding" /> klasy. Parametr określa, czy zezwalać na znaki opcjonalne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie umożliwia znaki opcjonalne, punktów kodowych Unicode są zakodowane za pomocą odpowiednich opcjonalnego parametru zamiast podstawowej zmodyfikowane 64 znaki. Znaki opcjonalne są wykrzyknika ("!"), ukośnik odwrotny ("\\"), linii pionowej ("&#124;"), podwójnego cudzysłowu ("" "), liczba znak ("#"), dolara ("$"), wartość procentowa znak ("%"), ampersandu ("& "), gwiazdka (" * "), średnikami (";"), po lewej nawiasu ostrego ("\<"), prawego nawiasu ostrego (">"), lewego nawiasu klamrowego ("{"), prawy nawias klamrowy ("}"), otwierający nawias kwadratowy ("["), prawy nawias kwadratowy ("]"), znak równości ("="), znak ("@"), akcentu cyrkumfleksowego ("^"), znaku podkreślenia ("_") i grave Akcent ("" ").  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia nowego <xref:System.Text.UTF7Encoding> wystąpienia, który umożliwia znaki opcjonalne.  
  
 [!code-cpp[System.Text.UTF7Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącą <see cref="T:System.Text.UTF7Encoding" /> obiektu.</param>
        <summary>Pobiera wartość wskazującą, czy określony obiekt jest taki sam, jak bieżący <see cref="T:System.Text.UTF7Encoding" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest <see cref="T:System.Text.UTF7Encoding" /> obiektu i jest taki sam, jak bieżący <see cref="T:System.Text.UTF7Encoding" /> obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UTF7Encoding> obiekty są takie same, jeśli obie albo Zezwalaj lub nie zezwalaj na znaki opcjonalne i w razie ich bazowy <xref:System.Text.Encoding.EncoderFallback%2A> i <xref:System.Text.Encoding.DecoderFallback%2A> właściwości są takie same.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:System.Text.UTF7Encoding.#ctor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Obiekt zawierający zestaw znaków kodowania.</param>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie znaków w określonym <see cref="T:System.String" /> obiektu.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.UTF7Encoding.GetBytes%2A> wymaga, aby przechowywać wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetByteCount%2A> metoda zwraca liczbę bajtów wymaganą do kodowania tablicy znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków, zaczynając od wskaźnika określony znak.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.UTF7Encoding.GetBytes%2A> wymaga, aby przechowywać wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów utworzonego przez zestaw znaków z określoną tablicę znaków kodowania.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetByteCount%2A> metoda zwraca liczbę bajtów wymaganą do kodowania tablicy znaków Unicode.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestaw znaków w kolejności bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od wskaźnika określony znak do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określonym bajcie.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Nieprawidłowe znaki są kodowane jako podstawowej zmodyfikowane 64 znaki. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Nieprawidłowe znaki są kodowane jako podstawowej zmodyfikowane 64 znaki. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetBytes%2A> do kodowania zakres znaków z <xref:System.String> i przechowywać zakodowanego bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> Zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Nieprawidłowe znaki są kodowane jako podstawowej zmodyfikowane 64 znaki. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetBytes%2A> metodę kodowania zakresu elementów z tablicy znaków Unicode i przechowywania zakodowanego bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów, licząc od wskaźnika określonym bajcie.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> aby wynikowych znaków, użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba znaków jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UTF7Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> aby wynikowych znaków, użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetCharCount%2A> metoda zwraca liczbę znaków utworzonego przez dekodowania szereg elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  
  
 —lub—  
  
 Wynikowa liczba znaków jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF7Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisu.</param>
        <summary>Dekoduje sekwencję bajtów, licząc od wskaźnika określonym bajcie do zestawu znaków, które są przechowywane, zaczynając od wskaźnika określony znak.</summary>
        <returns>Rzeczywista liczba znaków zapisany w lokalizacji wskazanej przez <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> aby wynikowych znaków, użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Gdy występują nieprawidłowe bajty, <xref:System.Text.UTF7Encoding> zazwyczaj emituje nieprawidłowe bajty. Jeśli bajt jest większy niż szesnastkowe 0x7F, wartość bajtu nie będzie rozszerzony zero w znaków Unicode, wynik jest zapisywany w `chars` tablic i sekwencji żadnych shift zostanie zakończony. Na przykład jeśli bajtów do kodowania 0x81 szesnastkowych, wynikowy znak jest 0081 U +. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z określonej tablicy bajtów do określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków w zapisywane <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> aby wynikowych znaków, użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Gdy występują nieprawidłowe bajty, <xref:System.Text.UTF7Encoding> zazwyczaj emituje nieprawidłowe bajty. Jeśli bajt jest większy niż szesnastkowe 0x7F, wartość bajtu nie będzie rozszerzony zero w znaków Unicode, wynik jest zapisywany w `chars` tablic i sekwencji żadnych shift zostanie zakończony. Na przykład jeśli bajtów do kodowania 0x81 szesnastkowych, wynikowy znak jest 0081 U +. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetChars%2A> sposób dekodowania zakresu elementów w tablicy bajtowej i zapisać wynik w tablicy znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="byteindex" /> i <paramref name="byteCount" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  
  
 —lub—  
  
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> nie ma wystarczającej wydajności z <paramref name="charIndex" /> do końca tablicy, tak aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje UTF-7 zakodowane sekwencję bajtów na sekwencję znaków Unicode.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> konwertująca UTF-7 zakodowane sekwencję bajtów w sekwencji znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów na bloki kolejnych znaków w sposób podobny do <xref:System.Text.UTF7Encoding.GetChars%2A> metody tej klasy. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami tak on prawidłowo zdekodować sekwencji bajtów, obejmujące bloków. <xref:System.Text.Decoder> Również zachowuje bajtów końcowych na końcu bloki danych i używa bajtów końcowych w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF7Encoding.GetDecoder%2A> i <xref:System.Text.UTF7Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetDecoder%2A> metodę, aby uzyskać dekodera przekonwertować UTF-7 kodowane bajtów do sekwencji znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencji znaków Unicode, UTF-7 zakodowane sekwencję bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> sekwencji znaków Unicode, który konwertuje na UTF-7 zakodowane sekwencję bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów na bloki kolejnych znaków w sposób podobny do <xref:System.Text.UTF7Encoding.GetChars%2A> metody. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami tak on prawidłowo zdekodować sekwencji bajtów, obejmujące bloków. <xref:System.Text.Decoder> Również zachowuje bajtów końcowych na końcu bloki danych i używa bajtów końcowych w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF7Encoding.GetDecoder%2A> i <xref:System.Text.UTF7Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetEncoder%2A> metodę, aby uzyskać kodera, aby przekonwertować sekwencji znaków UTF-7 zakodowane sekwencji bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Text.UTF7Encoding" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez <xref:System.Text.UTF7Encoding.GetHashCode%2A> metoda nie jest odpowiednia do rozróżniania jedną <xref:System.Text.UTF7Encoding> obiekt od drugiego. Jeśli aplikacja wymaga unikatową wartość skrótu, należy zastąpić <xref:System.Text.UTF7Encoding.GetHashCode%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów utworzone przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów utworzone przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> jest liczbą najgorszego łącznie najgorszego dla aktualnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> może zwrócić dużej wartości.  
  
 W większości przypadków ta metoda zwraca wartość liczby uzasadnione dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach przekroczenie bardziej przystępne buforu. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.UTF7Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Chociaż UTF-7 jest bardzo wydajny w kodowanie ASCII danych jednego bajtu na znak, jest bardzo mało wydajne innych danych. Jak zauważali powyżej, <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> dotyczy najgorszym przypadku. Jeśli dane mają być kodowane w dużej mierze ASCII, a zwłaszcza, jeśli znaki ASCII klastra ze sobą, UTF-7 jest znacznie więcej wydajne niż liczba zwracanych przez tę metodę zawiera sugestie.  
  
 <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> nie ma związku <xref:System.Text.UTF7Encoding.GetChars%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF7Encoding.GetChars%2A>, należy go używać <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metodę, aby zwrócić maksymalną liczbę bajtów wymaganą do kodowania określoną liczbę znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, utworzonego przez dekodowania określoną liczbę bajtów.</summary>
        <returns>Maksymalna liczba znaków utworzonego przez dekodowania określoną liczbę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda zazwyczaj umożliwia alokacji mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> jest liczbą najgorszego łącznie najgorszego dla aktualnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> może zwrócić dużej wartości.  
  
 W większości przypadków ta metoda zwraca wartość liczby uzasadnione dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach przekroczenie bardziej przystępne buforu. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.UTF7Encoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.UTF7Encoding.GetBytes%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF7Encoding.GetBytes%2A>, należy go używać <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metodę, aby zwrócić maksymalną liczbę znaków utworzonego przez dekodowania określoną liczbę bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba znaków jest większa niż maksymalna liczba, która może być zwracany jako int.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) pełne wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtowej na ciąg.</summary>
        <returns>A <see cref="T:System.String" /> zawierającego wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> wykrywa błąd. Gdy występują nieprawidłowe bajty, <xref:System.Text.UTF7Encoding> zazwyczaj emituje nieprawidłowe bajty. Jeśli bajt jest większy niż szesnastkowe 0x7F, wartość bajtu nie będzie rozszerzony zero w znaków Unicode, wynik jest zapisywany w `chars` tablic i sekwencji żadnych shift zostanie zakończony. Na przykład jeśli bajtów do kodowania 0x81 szesnastkowych, wynikowy znak jest 0081 U +. Ze względów bezpieczeństwa zaleca się aplikacji, aby użyć <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów na ciąg.  
  
 [!code-cpp[System.Text.UTF7Encoding.getstring#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.getstring/CPP/getstring.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.getstring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.getstring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.getstring/VB/getstring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="UTF7Encoding" FullName="System.Text.UTF7Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3577903944716f5c8fa85f9997538ae938e55175" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52381570" /></Metadata><TypeSignature Language="C#" Value="public class UTF7Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF7Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF7Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF7Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF7Encoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF7Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania UTF-7 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencji bajtów zakodowany zestaw znaków Unicode.  
  
 Kodowanie UTF-7 przedstawia znaków Unicode jako sekwencje znaków ASCII 7-bitowego. To kodowanie obsługuje niektóre protokoły, dla których wymagane jest, w większości przypadków protokołów poczty e-mail lub grupy dyskusyjnej. Ponieważ UTF-7 nie jest szczególnie bezpieczny i niezawodny oraz większość nowoczesnych systemów Zezwalaj na 8-bitową kodowania UTF-8 należy preferowany do UTF-7.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Ze względów bezpieczeństwa aplikacja powinna używać <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
 Aby uzyskać więcej informacji na temat UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.UTF7Encoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania.  
  
 Podobnie <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.UTF7Encoding.GetChars%2A> i <xref:System.Text.UTF7Encoding.GetString%2A> metody wykonywania rzeczywiste dekodowania.  
  
 <xref:System.Text.UTF7Encoding> odnosi się do strony kodowej Windows 65000.  
  
> [!NOTE]
>  Stan UTF-7 kodowany obiektu nie jest zachowywany, jeśli obiekt jest serializacji i deserializacji za pomocą różnych wersji programu .NET Framework.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding> zakodować ciąg znaków Unicode i przechowywać je w tablicy bajtów. Należy zauważyć, że gdy tablica bajtowej jest dekodowana do ciągu, zostaną utracone żadne dane.  
  
 [!code-cpp[System.Text.UTF7Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF7Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF7Encoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF7Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF7Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF7Encoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zezwala na znaki opcjonalne. Wywoływanie <xref:System.Text.UTF7Encoding.%23ctor%2A> Konstruktor jest równoważne z wywoływaniem <xref:System.Text.UTF7Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType> konstruktora przyjmującego `allowOptionals` parametru i określając `false` dla tego parametru.  
  
 Jeśli wystąpienie umożliwia znaki opcjonalne, punkty kodowe Unicode są kodowane za pomocą odpowiedniego opcjonalny znak, nie zmodyfikowanych podstawowego znak 64. Znaki opcjonalne są wykrzyknika ("!"), kreski ułamkowej odwróconej ("\\"), linii pionowej ("&#124;"), podwójny cudzysłów ("" "), liczba znak ("#"), dolara ($"), procent znak ("%"), handlowe "i" ("&"), gwiazdki ("*"), średnikami (";"), po lewej nawiasu ostrego ("\<"), prawego nawiasu ostrego (">"), lewy nawias klamrowy ("{"), prawy nawias klamrowy ("}"), lewy nawias kwadratowy ("["), prawy nawias kwadratowy ("]"), znaku równości ("="), znak ("@"), akcent cyrkumfleksowy ("^"), znaku podkreślenia ("_") i grave akcentu ("" ").  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć nową <xref:System.Text.UTF7Encoding> wystąpienia i nazwę wyświetlaną dla kodowania.  
  
 [!code-cpp[System.Text.UTF7Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF7Encoding (bool allowOptionals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool allowOptionals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (allowOptionals As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF7Encoding(bool allowOptionals);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF7Encoding : bool -&gt; System.Text.UTF7Encoding" Usage="new System.Text.UTF7Encoding allowOptionals" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="allowOptionals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowOptionals"><see langword="true" /> Aby określić, że dozwolone są znaki opcjonalne; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UTF7Encoding" /> klasy. Parametr określa, czy zezwalać na znaki opcjonalne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpienie umożliwia znaki opcjonalne, punkty kodowe Unicode są kodowane za pomocą odpowiedniego opcjonalny znak, nie zmodyfikowanych podstawowego znak 64. Znaki opcjonalne są wykrzyknika ("!"), kreski ułamkowej odwróconej ("\\"), linii pionowej ("&#124;"), podwójny cudzysłów ("" "), liczba znak ("#"), dolara ($"), procent znak ("%"), handlowe "i" ("&"), gwiazdki ("*"), średnikami (";"), po lewej nawiasu ostrego ("\<"), prawego nawiasu ostrego (">"), lewy nawias klamrowy ("{"), prawy nawias klamrowy ("}"), lewy nawias kwadratowy ("["), prawy nawias kwadratowy ("]"), znaku równości ("="), znak ("@"), akcent cyrkumfleksowy ("^"), znaku podkreślenia ("_") i grave akcentu ("" ").  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć nową <xref:System.Text.UTF7Encoding> wystąpienie, które umożliwia znaki opcjonalne.  
  
 [!code-cpp[System.Text.UTF7Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF7Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącą <see cref="T:System.Text.UTF7Encoding" /> obiektu.</param>
        <summary>Pobiera wartość wskazującą, czy określony obiekt jest taki sam, do bieżącego <see cref="T:System.Text.UTF7Encoding" /> obiektu.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="value" /> jest <see cref="T:System.Text.UTF7Encoding" /> obiektu i jest taki sam, jak bieżący <see cref="T:System.Text.UTF7Encoding" /> obiektu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UTF7Encoding> obiekty są takie same, jeśli oba albo zezwolić lub nie zezwalaj na znaki opcjonalne i, gdy ich bazowe <xref:System.Text.Encoding.EncoderFallback%2A> i <xref:System.Text.Encoding.DecoderFallback%2A> właściwości są takie same.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="Overload:System.Text.UTF7Encoding.#ctor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF7Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Obiekt zawierający zestaw znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie znaków w określonym <see cref="T:System.String" /> obiektu.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć tablicy dokładny rozmiar <xref:System.Text.UTF7Encoding.GetBytes%2A> wymaga, aby przechowywać wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetByteCount%2A> metodę, aby zwrócić liczbę bajtów wymaganą do kodowania tablicy znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF7Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć tablicy dokładny rozmiar <xref:System.Text.UTF7Encoding.GetBytes%2A> wymaga, aby przechowywać wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF7Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, z określoną tablicę znaków.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetByteCount%2A> metodę, aby zwrócić liczbę bajtów wymaganą do kodowania tablicy znaków Unicode.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestawu znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF7Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od określonego znaku wskaźnika do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Nieprawidłowe znaki są kodowane jako zmodyfikowane podstawowego znak 64. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF7Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków, z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Nieprawidłowe znaki są kodowane jako zmodyfikowane podstawowego znak 64. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetBytes%2A> metody do zakodowania zakresu znaków z <xref:System.String> i przechowywać zakodowany bajtów w zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF7Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> Zawierający zestaw znaków do zakodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Nieprawidłowe znaki są kodowane jako zmodyfikowane podstawowego znak 64. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetBytes%2A> metody do zakodowania zakres elementów w tablicy znaków Unicode i przechowywać zakodowany bajtów w zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF7Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba znaków jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UTF7Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF7Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetCharCount%2A> metodę, aby zwrócić liczbę znaków, generowane przez dekodowanie zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
Wynikowa liczba znaków jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF7Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów w zestawie znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF7Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Dekoduje sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów do zestawu znaków, które są przechowywane, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w lokalizacji wskazanej przez <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Po napotkaniu nieprawidłowe bajty <xref:System.Text.UTF7Encoding> ogólnie emituje nieprawidłowe bajty. Jeśli bajt jest większy niż 0x7F szesnastkowych, wartość bajtu nie będzie zero — rozszerzone do postaci znaku Unicode, wynik jest przechowywany w `chars` tablicy i dowolnej sekwencji shift zostanie zakończony. Na przykład jeśli bajtów kodowania jest szesnastkowe 0x81, wynikowy znak jest 0081 U +. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF7Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów na określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> do przechowywania wynikowy znaków, należy użyć <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Po napotkaniu nieprawidłowe bajty <xref:System.Text.UTF7Encoding> ogólnie emituje nieprawidłowe bajty. Jeśli bajt jest większy niż 0x7F szesnastkowych, wartość bajtu nie będzie zero — rozszerzone do postaci znaku Unicode, wynik jest przechowywany w `chars` tablicy i dowolnej sekwencji shift zostanie zakończony. Na przykład jeśli bajtów kodowania jest szesnastkowe 0x81, wynikowy znak jest 0081 U +. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetChars%2A> metody dekodowania zakres elementów w tablicy bajtów i zapisać wynik w tablicy znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF7Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje sekwencję bajtów UTF-7 kodowany na sekwencję znaków Unicode.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> konwertuje sekwencję znaków Unicode UTF-7 kodowany sekwencję bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów do kolejnych bloków znaków, w sposób podobny do <xref:System.Text.UTF7Encoding.GetChars%2A> metody tej klasy. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami, aby go można prawidłowo zdekodować sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF7Encoding.GetDecoder%2A> i <xref:System.Text.UTF7Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetDecoder%2A> metodę, aby uzyskać dekoder, aby przekonwertować UTF-7 kodowany bajtów do sekwencji znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF7Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencję znaków Unicode na UTF-7 kodowany sekwencji bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> , konwertuje sekwencję znaków Unicode na UTF-7 kodowany sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów do kolejnych bloków znaków, w sposób podobny do <xref:System.Text.UTF7Encoding.GetChars%2A> metody. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami, aby go można prawidłowo zdekodować sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.UTF7Encoding.GetDecoder%2A> i <xref:System.Text.UTF7Encoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetEncoder%2A> metodę, aby uzyskać kodera w celu konwersji sekwencji znaków na UTF-7 kodowany sekwencji bajtów.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF7Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego <see cref="T:System.Text.UTF7Encoding" /> obiektu.</summary>
        <returns>Kod skrótu 32-bitowej liczby całkowitej ze znakiem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwrócona przez obiekt <xref:System.Text.UTF7Encoding.GetHashCode%2A> metody nie nadaje się do rozróżniania jeden <xref:System.Text.UTF7Encoding> obiektu z innego. Jeśli aplikacja wymaga unikatowych skrótu, należy zastąpić <xref:System.Text.UTF7Encoding.GetHashCode%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF7Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów, generowane przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów, generowane przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UTF7Encoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>. <xref:System.Text.UTF7Encoding.GetByteCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> jest liczbą najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda zwraca uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Można także rozważyć użycie innego podejścia <xref:System.Text.UTF7Encoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. UTF-7 jest bardzo wydajny w kodowaniu ASCII danych, jeden bajt na znak, ale jest bardzo mało wydajne innych danych. Zgodnie z zainteresowanych stron zauważyły powyżej, <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> zajmuje się najgorszym przypadku. Jeśli dane, które ma być zdekodowany stopniu ASCII, a zwłaszcza, jeśli znaki ASCII klastra ze sobą, UTF-7 jest znacznie więcej są wydajne niż wartość zwracana przez tę metodę sugeruje.  
  
 <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> nie ma związku <xref:System.Text.UTF7Encoding.GetChars%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF7Encoding.GetChars%2A>, powinna korzystać <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A> metodę, aby zwrócić maksymalną liczbę bajtów wymaganych do kodowania określoną liczbę znaków.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF7Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, generowane przez określoną liczbę bajtów do zdekodowania.</summary>
        <returns>Maksymalna liczba znaków, generowane przez określoną liczbę bajtów do zdekodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UTF7Encoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UTF7Encoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A>. <xref:System.Text.UTF7Encoding.GetCharCount%2A> Metoda ogólnie Umożliwia przydzielenie mniej pamięci podczas <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> jest liczbą najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda zwraca uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Można także rozważyć użycie innego podejścia <xref:System.Text.UTF7Encoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.UTF7Encoding.GetBytes%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UTF7Encoding.GetBytes%2A>, powinna korzystać <xref:System.Text.UTF7Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.UTF7Encoding.GetMaxCharCount%2A> metodę, aby zwrócić maksymalną liczbę znaków generowane przez określoną liczbę bajtów dekodowania.  
  
 [!code-cpp[System.Text.UTF7Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba znaków jest większa niż maksymalna liczba, które mogą być zwracane w formie typu int.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie pełna) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF7Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF7Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtów na ciąg.</summary>
        <returns>A <see cref="T:System.String" /> zawierającą wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UTF7Encoding.GetDecoder%2A> metody lub <xref:System.Text.UTF7Encoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  <xref:System.Text.UTF7Encoding> nie zapewnia wykrywanie błędów. Po napotkaniu nieprawidłowe bajty <xref:System.Text.UTF7Encoding> ogólnie emituje nieprawidłowe bajty. Jeśli bajt jest większy niż 0x7F szesnastkowych, wartość bajtu nie będzie zero — rozszerzone do postaci znaku Unicode, wynik jest przechowywany w `chars` tablicy i dowolnej sekwencji shift zostanie zakończony. Na przykład jeśli bajtów kodowania jest szesnastkowe 0x81, wynikowy znak jest 0081 U +. Ze względów bezpieczeństwa Twoje aplikacje są zalecane do stosowania <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, lub <xref:System.Text.UTF32Encoding> i włączyć wykrywanie błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu koduje ciąg na tablicę bajtów, a następnie dekoduje bajtów do ciągu.  
  
 [!code-cpp[System.Text.UTF7Encoding.getstring#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.getstring/CPP/getstring.cpp#1)]
 [!code-csharp[System.Text.UTF7Encoding.getstring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF7Encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF7Encoding.getstring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF7Encoding.getstring/VB/getstring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF7Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF7Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF7Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
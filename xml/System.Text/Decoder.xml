<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13b84f63684da5556905ba4fdf5eed7f591aa9bd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408127" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <TypeSignature Language="F#" Value="type Decoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Konwertuje sekwencję bajtów zakodowany na zestaw znaków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskanie wystąpienia implementacja <xref:System.Text.Decoder> klasy, należy użyć aplikacji <xref:System.Text.Encoding.GetDecoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
 <xref:System.Text.Decoder.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.Decoder.GetChars%2A> metoda wykonuje rzeczywiste dekodowania. Wiele wersji obie te metody są dostępne w <xref:System.Text.Decoder> klasy. Aby uzyskać więcej informacji, zobacz <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>. A <xref:System.Text.Decoder> obiekt przechowuje informacje o stanie między kolejnych wywołań `GetChars` lub <xref:System.Text.Decoder.Convert%2A> metody tak on prawidłowo zdekodować sekwencji bajtów, obejmujące bloków. <xref:System.Text.Decoder> Również zachowuje bajtów końcowych na końcu bloki danych i używa bajtów końcowych w następnej operacji dekodowania. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku operacji przekazywania i plików sieciowych, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
> [!NOTE]
>  Po zakończeniu aplikacji za pomocą strumienia danych powinien upewnij się, że informacje o stanie jest opróżniany przez ustawienie `flush` parametr `true` w wywołaniu odpowiedniej metody. Jeśli wystąpi wyjątek lub gdy aplikacja strumieni, powinny wywoływać <xref:System.Text.Decoder.Reset%2A> wyczyść wewnętrzny stan klasy `Decoder` obiektu.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 A <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> można zserializować obiektu podczas operacji konwersji. Stan obiektu jest zachowanego, jeśli deserializowany jest w tej samej wersji programu .NET Framework, ale jeśli deserializowany jest w innej wersji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Text.Decoder> do konwertowania dwie tablice typu byte różnych do tablicy znaków. Jeden znak bajtów, które obejmuje tablic. Jest to podobne do co <xref:System.IO.StreamReader> obiektu jest wewnętrznie podczas odczytywania strumienia.  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Gdy aplikacja z tej klasy, musi ono przesłonić wszystkie elementy członkowskie.</para>
    </block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Decoder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uzyskanie wystąpienia implementacja tej klasy, należy używać aplikacji <xref:System.Text.Encoding.GetDecoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano dwie metody inicjowania nowy <xref:System.Text.Decoder> wystąpienia.  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje sekwencji bajtów zakodowany ciąg lub tablica znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, chars, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteCount, chars, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Adres buforu, który zawiera sekwencji bajtów do konwersji.</param>
        <param name="byteCount">Liczba bajtów w <c>bajtów</c> do przekonwertowania.</param>
        <param name="chars">Adres buforu do przechowywania konwertowane znaki.</param>
        <param name="charCount">Maksymalna liczba znaków w <c>znaków</c> do użycia w konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać żadne dodatkowe dane jest do skonwertowania; w przeciwnym razie <see langword="false" />.</param>
        <param name="bytesUsed">Gdy metoda zwróci wartość, zawiera liczbę bajtów, które zostały utworzone w procesie konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaków</c> które były używane w konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określony przez <c>byteCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje Bufor bajtów zakodowanego algorytmem UTF-16 znaków i zapisuje wynik w innym buforu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiektu zapisuje stan między wywołania <xref:System.Text.Decoder.Convert%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, dekoder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego. Pozostałe dane przetworzonych będącej częścią jednostki logicznej, takich jak zastępczym wysokiego poziomu o para zastępcza jest konwertowana zgodnie z bieżącym przełączanie awaryjne.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zdekodowania dowolnego ilość danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Wynik operacji dekodowania przechowuje do buforu o stałym rozmiarze. <xref:System.Text.Decoder.GetChars%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwrócić bajtów odczytanych i zapisywane znaków. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 `completed` Parametr wyjściowy wskazuje, czy wszystkie dane w buforze wejściowym został przekonwertować i przechowywać w buforze danych wyjściowych. Ten parametr ma wartość `false` Jeśli liczba bajtów jest określona przez `byteCount` nie można przekonwertować parametru przekraczając liczbę znaków, określony przez `charCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowe buforu wyjściowego, przyrost `bytes` parametru przez liczbę bajtów określona przez `bytesUsed` parametru, następnie wywołaj `Convert` metodę ponownie proces pozostałe dane wejściowe.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `bytesUsed` i `byteCount` parametry są takie same. Ta sytuacja występuje, gdy nadal są danymi <xref:System.Text.Decoder> obiekt, który nie była przechowywana w `bytes` buforu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest za mały, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinna być większa niż lub równe rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Decoder.GetCharCount" /> metody.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteIndex, byteCount, chars, charIndex, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów do konwersji.</param>
        <param name="byteIndex">Pierwszy element <c>bajtów</c> do przekonwertowania.</param>
        <param name="byteCount">Liczba elementów <c>bajtów</c> do przekonwertowania.</param>
        <param name="chars">Tablica do przechowywania konwertowane znaki.</param>
        <param name="charIndex">Pierwszy element <c>znaków</c> , w których dane są przechowywane.</param>
        <param name="charCount">Maksymalna liczba elementów <c>znaków</c> do użycia w konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać nieprawidłowość dalsze dane do konwersji; w przeciwnym razie <see langword="false" />.</param>
        <param name="bytesUsed">Gdy metoda zwróci wartość, zawiera liczbę bajtów, które były używane w konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaków</c> które zostały utworzone w procesie konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określony przez <c>byteCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje tablicę bajtów zakodowanego algorytmem UTF-16 znaków i zapisuje wynik w tablicy znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiektu zapisuje stan między wywołania <xref:System.Text.Decoder.Convert%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, dekoder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego. Pozostałe dane przetworzonych będącej częścią jednostki logicznej, takich jak zastępczym wysokiego poziomu o para zastępcza jest konwertowana zgodnie z bieżącym przełączanie awaryjne.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zdekodowania dowolnego ilość danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Wynik operacji dekodowania przechowuje do buforu o stałym rozmiarze. <xref:System.Text.Decoder.GetChars%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwrócić bajtów odczytanych i zapisywane znaków. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 `completed` Parametr wyjściowy wskazuje, czy wszystkie dane w buforze wejściowym został przekonwertować i przechowywać w buforze danych wyjściowych. Ten parametr ma wartość `false` Jeśli liczba bajtów jest określona przez `byteCount` nie można przekonwertować parametru przekraczając liczbę znaków, określony przez `charCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowe buforu wyjściowego, przyrost `bytes` parametru przez liczbę bajtów określona przez `bytesUsed` parametru, następnie wywołaj `Convert` metodę ponownie proces pozostałe dane wejściowe.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `bytesUsed` i `byteCount` parametry są takie same. Ta sytuacja występuje, gdy nadal są danymi <xref:System.Text.Decoder> obiekt, który nie była przechowywana w `bytes` buforu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Text.Encoder.Convert%2A> metody, aby skonwertować plik znaków UTF-16, UTF-8. Następnie używa <xref:System.Text.Decoder.Convert%2A> metodę, aby przekonwertować znaków UTF-8 z powrotem do UTF-16 znaków.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" />, lub <paramref name="byteCount" /> jest mniejsza od zera.  - lub - długość <paramref name="chars" />  -  <paramref name="charIndex" /> jest mniejsza niż <paramref name="charCount" />.  - lub - długość <paramref name="bytes" />  -  <paramref name="byteIndex" /> jest mniejsza niż <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest za mały, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinna być większa niż lub równe rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Decoder.GetCharCount" /> metody.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Decoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.DecoderFallback" /> obiektu dla bieżącej <see cref="T:System.Text.Decoder" /> obiektu.</summary>
        <value>A <see cref="T:System.Text.DecoderFallback" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy sekwencji bajtów zakodowanego nie można przekonwertować na znak.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji set jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Nie można przypisać nową wartość w operacji set, ponieważ bieżący <see cref="T:System.Text.DecoderFallbackBuffer" /> obiekt zawiera dane, które nie zostały jeszcze zdekodować.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.DecoderFallbackBuffer" Usage="System.Text.Decoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Text.DecoderFallbackBuffer" /> obiekt skojarzony z bieżącym <see cref="T:System.Text.Decoder" /> obiektu.</summary>
        <value>A <see cref="T:System.Text.DecoderFallbackBuffer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallbackBuffer> Obiekt reprezentuje dane używane przez <xref:System.Text.DecoderFallback> obiektu. <xref:System.Text.DecoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy sekwencji bajtów zakodowanego nie można przekonwertować na znak.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int" Usage="decoder.GetCharCount (bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby symulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów, licząc od wskaźnika określonym bajcie. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po obliczeniu.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów i wszelkie bajtów w buforze wewnętrznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan dekodera.  
  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Decoder.GetChars%2A> wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` ustawioną `false`, dekoder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie bajtów końcowych z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="decoder.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów i wszelkie bajtów w buforze wewnętrznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan dekodera.  
  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Decoder.GetChars%2A> wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` ustawioną `false`, dekoder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie bajtów końcowych z poprzedniego bloku są uwzględniane w obliczeniach.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Text.Decoder.GetCharCount%2A> metodę obliczania liczbę znaków wymaganą w celu zdekodowania określony zakres bajtów w tablicy.  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int * bool -&gt; int&#xA;override this.GetCharCount : byte[] * int * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby symulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów z określonej tablicy bajtów. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po obliczeniu.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów i wszelkie bajtów w buforze wewnętrznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan dekodera.  
  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.Decoder.GetChars%2A> wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` ustawioną `false`, dekoder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie bajtów końcowych z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int" Usage="decoder.GetChars (bytes, chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteCount, chars, charCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisu.</param>
        <param name="flush">
          <see langword="true" /> Aby wyczyścić wewnętrzny stan dekodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów, licząc od wskaźnika określonym bajcie i wszystkich bajtów w buforze wewnętrzny do zestawu znaków, które są przechowywane, zaczynając od wskaźnika określony znak. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po konwersji.</summary>
        <returns>Rzeczywista liczba znaków zapisany w lokalizacji wskazanej przez <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiektu zapisuje stan między wywołania <xref:System.Text.Decoder.GetChars%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, dekoder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego.  
  
 Do obliczenia dokładne buforu rozmiaru `GetChars` wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` ustawioną `false`, dekoder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie bajtów końcowych z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 Jeśli można przekonwertować wiele segmentów strumienia wejściowego aplikacji, należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A> metody. <xref:System.Text.Decoder.GetChars%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwrócić bajtów odczytanych i zapisywane znaków. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencji bajtów z określonej tablicy bajtów i wszystkich bajtów w buforze wewnętrzny pod określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków w zapisywane <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiektu zapisuje stan między wywołania <xref:System.Text.Decoder.GetChars%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, dekoder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego.  
  
 Do obliczenia dokładne tablicy rozmiaru `GetChars` wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` ustawioną `false`, dekoder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie bajtów końcowych z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 Jeśli można przekonwertować wiele segmentów strumienia wejściowego aplikacji, należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A> metody. <xref:System.Text.Decoder.GetChars%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwrócić bajtów odczytanych i zapisywane znaków. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób dekodowania zakresu elementów z tablicy bajtów i przechowywać je w tablicy znaków Unicode. <xref:System.Text.Decoder.GetCharCount%2A> Metoda jest używana do obliczania liczby znaków niezbędne do przechowywania dekodowane elementów w tablicy `bytes`. <xref:System.Text.Decoder.GetChars%2A> Metoda dekoduje określonych elementów w tablicy bajtów i przechowuje je w nowej tablicy znaków.  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza od zera.  - lub - <paramref name="byteindex" /> i <paramref name="byteCount" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  - lub - <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> nie ma wystarczającej wydajności z <paramref name="charIndex" /> do końca tablicy, tak aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int * bool -&gt; int&#xA;override this.GetChars : byte[] * int * int * char[] * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <param name="flush">
          <see langword="true" /> Aby wyczyścić wewnętrzny stan dekodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencji bajtów z określonej tablicy bajtów i wszystkich bajtów w buforze wewnętrzny pod określoną tablicę znaków. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po konwersji.</summary>
        <returns>Rzeczywista liczba znaków w zapisywane <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiektu zapisuje stan między wywołania <xref:System.Text.Decoder.GetChars%2A>. Gdy aplikacja jest wykonywana za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że informacje o stanie jest opróżniany. To ustawienie, dekoder ignoruje nieprawidłowy bajtów na końcu bloku danych i czyści buforu wewnętrznego.  
  
 Do obliczenia dokładne tablicy rozmiaru `GetChars` wymaga, aby wynikowe znaki, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` ustawioną `false`, dekoder przechowuje bajtów końcowych na końcu bloku danych w bufor wewnętrzny i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie bajtów końcowych z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 Jeśli można przekonwertować wiele segmentów strumienia wejściowego aplikacji, należy rozważyć użycie <xref:System.Text.Decoder.Convert%2A> metody. <xref:System.Text.Decoder.GetChars%2A> Zgłoś wyjątek, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> wypełnienia tyle samo miejsca, jak to możliwe, a zwrócić bajtów odczytanych i zapisywane znaków. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu więcej komentarzy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza od zera.  - lub - <paramref name="byteindex" /> i <paramref name="byteCount" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  - lub - <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> nie ma wystarczającej wydajności z <paramref name="charIndex" /> do końca tablicy, tak aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Rezerwowe wystąpił (zobacz [kodowanie znaków w Framework](~/docs/standard/base-types/character-encoding.md) .NET na pełniejsze wyjaśnienie) - i - <see cref="P:System.Text.Decoder.Fallback" /> ma ustawioną wartość <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="decoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia dekoder wróć do stanu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wewnętrzny stan klasy <xref:System.Text.Decoder> obiektu. Metoda usuwa żadnych informacji o stanie zachowywane z poprzedniego wywołania <xref:System.Text.Decoder.GetChars%2A> lub <xref:System.Text.Decoder.Convert%2A>, w tym końcowe bajtów na końcu poprzedniego bloku danych.  
  
 Aplikacja powinna wywołać <xref:System.Text.Decoder.Reset%2A> metodę, jeśli chce ponownie użyć tego samego dekodera, nawet po wyjątku przez <xref:System.Text.Decoder.GetChars%2A>, <xref:System.Text.Decoder.Convert%2A>, lub <xref:System.Text.Decoder.GetCharCount%2A>, lub jeśli dekoder zmienia strumieni i rozpoczyna się w celu zdekodowania innego strumienia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
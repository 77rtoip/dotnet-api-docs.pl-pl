<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8652f49341ab4075bcd5008fda1e48fc026a2d69" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39850339" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <TypeSignature Language="F#" Value="type Decoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Konwertuje sekwencję bajtów zakodowany zestaw znaków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do uzyskania wystąpienie implementacji <xref:System.Text.Decoder> klasy, aplikacja powinna używać <xref:System.Text.Encoding.GetDecoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
 <xref:System.Text.Decoder.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.Decoder.GetChars%2A> metoda przeprowadza rzeczywiste dekodowania. Różne wersje programu obie te metody są dostępne w <xref:System.Text.Decoder> klasy. Aby uzyskać więcej informacji, zobacz <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>. A <xref:System.Text.Decoder> obiekt przechowuje informacje o stanie między kolejne wywołania `GetChars` lub <xref:System.Text.Decoder.Convert%2A> metody, aby go można prawidłowo zdekodować sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.Encoding.GetDecoder%2A> i <xref:System.Text.Encoding.GetEncoder%2A> są przydatne w przypadku operacji przekazywania i plik sieci, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
> [!NOTE]
>  Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, powinny upewnij się, że informacje o stanie jest opróżniany, ustawiając `flush` parametr `true` w wywołaniu odpowiednią metodę. Jeśli wystąpi wyjątek lub jeśli aplikacja zostanie przełączona strumieni, powinny wywoływać <xref:System.Text.Decoder.Reset%2A> Wyczyść stan wewnętrzny `Decoder` obiektu.  
  
## <a name="version-considerations"></a>Uwagi dotyczące wersji  
 A <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> można wykonywać serializację obiektu podczas operacji konwersji. Stan obiektu jest przechowywane, jeśli jest ona przeprowadzona w tej samej wersji programu .NET Framework, ale jeśli jest ona przeprowadzona w innej wersji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Text.Decoder> do konwertowania dwie tablice bajtów różnych do tablicy znaków. Jeden bajtów znaków zajmuje tablic. Jest to podobne do czego <xref:System.IO.StreamReader> obiekt ma wewnętrznie podczas odczytywania strumienia.  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Gdy aplikacja dziedziczy z tej klasy, musi ono przesłonić wszystkie elementy członkowskie.</para>
    </block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.Decoder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do uzyskania wystąpienie implementacją tej klasy, należy użyć aplikacji <xref:System.Text.Encoding.GetDecoder%2A> metody <xref:System.Text.Encoding> implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano dwie techniki dla inicjowania nowego <xref:System.Text.Decoder> wystąpienia.  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje sekwencja bajtów zakodowany ciąg lub tablicę znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, chars, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteCount, chars, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Adres buforu, który zawiera sekwencje bajtów do przekonwertowania.</param>
        <param name="byteCount">Liczba bajtów w <c>bajtów</c> do przekonwertowania.</param>
        <param name="chars">Adres buforu do przechowywania konwertowane znaki.</param>
        <param name="charCount">Maksymalna liczba znaków w <c>znaki</c> służące do konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać, żadne dodatkowe dane ma być przekonwertowany; w przeciwnym razie <see langword="false" />.</param>
        <param name="bytesUsed">Po powrocie z tej metody zawiera liczbę bajtów, które zostały utworzone przez konwersję. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaki</c> które były używane do konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określone przez <c>byteCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje buforu zakodowany bajtów UTF-16 zakodowanych znaków i zapisuje wynik w buforze na inny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Decoder.Convert%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, dekoder ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny. Pozostałe dane przetworzone należącego do jednostki logicznej, takich jak znakiem zastępczym wysokiego poziomu para zastępcza jest konwertowany zgodnie z bieżące ustawienia rezerwowe.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zdekodowania dowolnej ilości danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Przechowuje dane wyjściowe działania dekodowania do buforu o stałym rozmiarze. <xref:System.Text.Decoder.GetChars%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwracać odczytanych bajtów i zapisany znaki. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 `completed` Parametru wyjściowego wskazuje, czy wszystkie dane w buforze wejściowym, który został przekonwertowany i przechowywane w bufor wyjściowy. Ten parametr ma wartość `false` Jeśli liczba bajtów jest określona przez `byteCount` nie można przekonwertować parametru nie przekraczając liczby znaków, określony przez `charCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowy bufor wyjściowy, przyrost `bytes` parametru przez liczbę bajtów określoną przez `bytesUsed` parametr, następnie wywołać `Convert` metody ponownie proces pozostałych danych wejściowych.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `bytesUsed` i `byteCount` parametry są równe. Taka sytuacja ma miejsce, jeśli jest nadal dane w <xref:System.Text.Decoder> obiektów, które nie zostały zapisane w `bytes` buforu.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest zbyt mała, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinien być większy lub równy rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Decoder.GetCharCount" /> metody.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteIndex, byteCount, chars, charIndex, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów do przekonwertowania.</param>
        <param name="byteIndex">Pierwszy element <c>bajtów</c> do przekonwertowania.</param>
        <param name="byteCount">Liczba elementów <c>bajtów</c> do przekonwertowania.</param>
        <param name="chars">Tablica do przechowywania konwertowane znaki.</param>
        <param name="charIndex">Pierwszy element <c>znaki</c> w danych, które są przechowywane.</param>
        <param name="charCount">Maksymalna liczba elementów <c>znaki</c> służące do konwersji.</param>
        <param name="flush">
          <see langword="true" /> Aby wskazać, że żadne dalsze dane ma być przekonwertowany; w przeciwnym razie <see langword="false" />.</param>
        <param name="bytesUsed">Po powrocie z tej metody zawiera liczbę bajtów, które były używane do konwersji. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="charsUsed">Po powrocie z tej metody zawiera liczbę znaków od <c>znaki</c> który jest produkowany przez konwersję. Ten parametr jest przekazywany niezainicjowany.</param>
        <param name="completed">Po powrocie z tej metody zawiera <see langword="true" /> Jeśli wszystkie znaki określone przez <c>byteCount</c> zostały przekonwertowane; w przeciwnym razie <see langword="false" />. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Konwertuje tablicę bajtów zakodowanych znaków UTF-16 kodowany i zapisuje wynik w tablicy znaków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Decoder.Convert%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, dekoder ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny. Pozostałe dane przetworzone należącego do jednostki logicznej, takich jak znakiem zastępczym wysokiego poziomu para zastępcza jest konwertowany zgodnie z bieżące ustawienia rezerwowe.  
  
 `Convert` Metoda jest przeznaczona do użycia w pętli do zdekodowania dowolnej ilości danych wejściowych, takich jak dane odczytane z pliku lub strumienia. Przechowuje dane wyjściowe działania dekodowania do buforu o stałym rozmiarze. <xref:System.Text.Decoder.GetChars%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwracać odczytanych bajtów i zapisany znaki. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 `completed` Parametru wyjściowego wskazuje, czy wszystkie dane w buforze wejściowym, który został przekonwertowany i przechowywane w bufor wyjściowy. Ten parametr ma wartość `false` Jeśli liczba bajtów jest określona przez `byteCount` nie można przekonwertować parametru nie przekraczając liczby znaków, określony przez `charCount` parametru. W takiej sytuacji aplikacji należy użyć zawartości buforu wyjściowego lub podaj nowy bufor wyjściowy, przyrost `bytes` parametru przez liczbę bajtów określoną przez `bytesUsed` parametr, następnie wywołać `Convert` metody ponownie proces pozostałych danych wejściowych.  
  
 `completed` Można również ustawić parametr `false`, nawet jeśli `bytesUsed` i `byteCount` parametry są równe. Taka sytuacja ma miejsce, jeśli jest nadal dane w <xref:System.Text.Decoder> obiektów, które nie zostały zapisane w `bytes` buforu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Text.Encoder.Convert%2A> metodę, aby przekonwertować plik UTF-16 znaków na UTF-8. Następnie używa <xref:System.Text.Decoder.Convert%2A> metodę, aby skonwertować znaki UTF-8 z powrotem do UTF-16 znaków.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> lub <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" />, lub <paramref name="byteCount" /> jest mniejsza niż zero.  - lub - długość <paramref name="chars" />  -  <paramref name="charIndex" /> jest mniejsza niż <paramref name="charCount" />.  - lub - długość <paramref name="bytes" />  -  <paramref name="byteIndex" /> jest mniejsza niż <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">Bufor wyjściowy jest zbyt mała, aby zawierać żadnego z przekonwertowanego danych wejściowych. Bufor wyjściowy powinien być większy lub równy rozmiarowi wskazywanym przez <see cref="Overload:System.Text.Decoder.GetCharCount" /> metody.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Decoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Text.DecoderFallback" /> obiektu dla bieżącego <see cref="T:System.Text.Decoder" /> obiektu.</summary>
        <value>Element <see cref="T:System.Text.DecoderFallback" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy sekwencja bajtów zakodowany nie można przekonwertować na znak.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość w operacji zestawu jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">Nie można przypisać nową wartość w operacji zestawu, ponieważ bieżący <see cref="T:System.Text.DecoderFallbackBuffer" /> obiekt zawiera dane, które nie zostały jeszcze zdekodowane.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.DecoderFallbackBuffer" Usage="System.Text.Decoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Text.DecoderFallbackBuffer" /> obiekt skojarzony z bieżącym <see cref="T:System.Text.Decoder" /> obiektu.</summary>
        <value>Element <see cref="T:System.Text.DecoderFallbackBuffer" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallbackBuffer> Obiekt reprezentuje dane używane przez <xref:System.Text.DecoderFallback> obiektu. <xref:System.Text.DecoderFallback> Obiekt reprezentuje program obsługi błędów, które jest wywoływane, gdy sekwencja bajtów zakodowany nie można przekonwertować na znak.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int" Usage="decoder.GetCharCount (bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby zasymulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po obliczeniu.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów i wszystkich bajtów do wewnętrznego buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan dekodera.  
  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Decoder.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` równa `false`, dekoder końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie końcowe bajty z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="decoder.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów i wszystkich bajtów do wewnętrznego buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan dekodera.  
  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Decoder.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` równa `false`, dekoder końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie końcowe bajty z poprzedniego bloku są uwzględniane w obliczeniach.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Text.Decoder.GetCharCount%2A> metodę, aby obliczyć liczbę znaków wymaganą do zdekodowania określony zakres bajtów w tablicy.  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  - lub - <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int * bool -&gt; int&#xA;override this.GetCharCount : byte[] * int * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <param name="flush">
          <see langword="true" /> Aby zasymulować, czyszcząc stan wewnętrzny kodera po obliczeniu; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po obliczeniu.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów i wszystkich bajtów do wewnętrznego buforu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie ma wpływu na stan dekodera.  
  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.Decoder.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` równa `false`, dekoder końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie końcowe bajty z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  - lub - <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencję bajtów w zestawie znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int" Usage="decoder.GetChars (bytes, chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteCount, chars, charCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <param name="flush">
          <see langword="true" /> Aby wyczyścić wewnętrzny stan dekodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów i wszelkie bajtów do wewnętrznego buforu do zestawu znaków, które są przechowywane, zaczynając od określonego znaku wskaźnika. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po konwersji.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w lokalizacji wskazanej przez <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Decoder.GetChars%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, dekoder ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny.  
  
 Do obliczania buforu dokładny rozmiar `GetChars` wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` równa `false`, dekoder końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie końcowe bajty z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 W przypadku aplikacji można przekonwertować wiele segmentów strumienia wejściowego, należy wziąć pod uwagę przy użyciu <xref:System.Text.Decoder.Convert%2A> metody. <xref:System.Text.Decoder.GetChars%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwracać odczytanych bajtów i zapisany znaki. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencji bajtów z tablicy określoną liczbę bajtów i wszelkie bajtów do wewnętrznego buforu na określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Decoder.GetChars%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, dekoder ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny.  
  
 Do obliczania tablicy dokładny rozmiar `GetChars` wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` równa `false`, dekoder końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie końcowe bajty z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 W przypadku aplikacji można przekonwertować wiele segmentów strumienia wejściowego, należy wziąć pod uwagę przy użyciu <xref:System.Text.Decoder.Convert%2A> metody. <xref:System.Text.Decoder.GetChars%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwracać odczytanych bajtów i zapisany znaki. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dekodowanie szereg elementów z tablicy bajtowej i przechowywać je w tablicy znaków Unicode. <xref:System.Text.Decoder.GetCharCount%2A> Metoda jest używana do obliczenia liczby potrzebnych do przechowywania zdekodowany elementów w tablicy znaków `bytes`. <xref:System.Text.Decoder.GetChars%2A> Metoda dekoduje określonych elementów w tablicy bajtów i przechowuje je w nowej tablicy znaków.  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  - lub - <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  - lub - <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int * bool -&gt; int&#xA;override this.GetChars : byte[] * int * int * char[] * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="flush">
          <see langword="true" /> Aby wyczyścić wewnętrzny stan dekodera po konwersji; w przeciwnym razie <see langword="false" />.</param>
        <summary>W przypadku przesłonięcia w klasie pochodnej, dekoduje sekwencji bajtów z tablicy określoną liczbę bajtów i wszelkie bajtów do wewnętrznego buforu na określoną tablicę znaków. Parametr wskazuje, czy należy wyczyścić wewnętrzny stan dekodera po konwersji.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że <xref:System.Text.Decoder> obiekt zapisuje stan między wywołaniami <xref:System.Text.Decoder.GetChars%2A>. Gdy aplikacja jest przeprowadzane za pomocą strumienia danych, należy ustawić `flush` parametr `true` aby upewnić się, że jest opróżniany informacje o stanie. To ustawienie, dekoder ignoruje nieprawidłowe bajty na końcu bloku danych i czyści bufor wewnętrzny.  
  
 Do obliczania tablicy dokładny rozmiar `GetChars` wymaga, aby przechowywać wynikowy znaków, należy użyć aplikacji <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Jeśli `GetChars` jest wywoływana z `flush` równa `false`, dekoder końcowe bajty na końcu bloku danych są przechowywane w buforu wewnętrznego i użycie ich w następnej operacji dekodowania. Aplikacja powinna wywołać `GetCharCount` w bloku danych bezpośrednio przed wywołaniem `GetChars` na tym samym bloku, tak aby wszystkie końcowe bajty z poprzedniego bloku są uwzględniane w obliczeniach.  
  
 W przypadku aplikacji można przekonwertować wiele segmentów strumienia wejściowego, należy wziąć pod uwagę przy użyciu <xref:System.Text.Decoder.Convert%2A> metody. <xref:System.Text.Decoder.GetChars%2A> spowoduje zgłoszenie wyjątku, jeśli bufor wyjściowy jest zbyt mały, ale <xref:System.Text.Decoder.Convert%2A> spowoduje wypełnienie tyle miejsca, jak to możliwe i zwracać odczytanych bajtów i zapisany znaki. Zobacz też <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tematu, aby uzyskać więcej komentarzy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  - lub - <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  - lub - <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  - lub - <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) - i - <see cref="P:System.Text.Decoder.Fallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="decoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku przesłonięcia w klasie pochodnej, ustawia dekoder, wróć do stanu początkowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wewnętrzny stan <xref:System.Text.Decoder> obiektu. Metoda powoduje wyczyszczenie wszelkich informacji o stanie zachowywane z poprzedniego wywołania <xref:System.Text.Decoder.GetChars%2A> lub <xref:System.Text.Decoder.Convert%2A>, w tym końcowe bajty na końcu poprzedniego bloku danych.  
  
 Twoja aplikacja powinna wywołać <xref:System.Text.Decoder.Reset%2A> metody, jeśli chce, aby ponownie użyć tego samego dekodera mimo wyjątek jest generowany przez <xref:System.Text.Decoder.GetChars%2A>, <xref:System.Text.Decoder.Convert%2A>, lub <xref:System.Text.Decoder.GetCharCount%2A>, lub jeśli dekoder przełącza strumieni i rozpoczyna się zdekodować inny strumień.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Rune" FullName="System.Text.Rune">
  <Metadata><Meta Name="ms.openlocfilehash" Value="37a81dc10914841f35337c2d9f8795ec46b83199" /><Meta Name="ms.sourcegitcommit" Value="43c8e74d92c78325492baf27e41b400443f0dfbf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/08/2019" /><Meta Name="ms.locfileid" Value="68859282" /></Metadata><TypeSignature Language="C#" Value="public struct Rune : IComparable&lt;System.Text.Rune&gt;, IEquatable&lt;System.Text.Rune&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Rune extends System.ValueType implements class System.IComparable`1&lt;valuetype System.Text.Rune&gt;, class System.IEquatable`1&lt;valuetype System.Text.Rune&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Text.Rune" />
  <TypeSignature Language="VB.NET" Value="Public Structure Rune&#xA;Implements IComparable(Of Rune), IEquatable(Of Rune)" />
  <TypeSignature Language="C++ CLI" Value="public value class Rune : IComparable&lt;System::Text::Rune&gt;, IEquatable&lt;System::Text::Rune&gt;" />
  <TypeSignature Language="F#" Value="type Rune = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje wartość skalarną Unicode ([U + 0000.. U + D7FF], włącznie; lub [U + E000.. U + 10FFFF], włącznie).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

Konstruktory tego typu i operatory konwersji sprawdzają poprawność danych wejściowych, dzięki czemu klienci mogą wywoływać <xref:System.Text.Rune> interfejsy API przy założeniu, że wystąpienie bazowe jest poprawnie sformułowane.

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char ch);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char -&gt; System.Text.Rune" Usage="new System.Text.Rune ch" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Jednostka kodu UTF-16.</param>
        <summary><see cref="T:System.Text.Rune" /> Tworzy z dostarczonej jednostki kodu UTF-16.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ch" />reprezentuje punkt kodu wieloskładnikowego UTF-16 (U + D800.. U + DFFF, włącznie).</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(int value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : int -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość skalarna Unicode.</param>
        <summary><see cref="T:System.Text.Rune" /> Tworzy z określonej 32-bitowej liczby całkowitej, która reprezentuje wartość skalarną Unicode.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />nie reprezentuje wartości skalarnej Unicode.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : uint32 -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość skalarna Unicode.</param>
        <summary><see cref="T:System.Text.Rune" /> Tworzy z określonej 32-bitowej liczby całkowitej bez znaku, która reprezentuje wartość skalarną Unicode.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />nie reprezentuje wartości skalarnej Unicode.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (highSurrogate As Char, lowSurrogate As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char * char -&gt; System.Text.Rune" Usage="new System.Text.Rune (highSurrogate, lowSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Górny Surogat pary dwuskładnikowej.</param>
        <param name="lowSurrogate">Dolny Surogat pary dwuskładnikowej.</param>
        <summary><see cref="T:System.Text.Rune" /> Tworzy z podanej pary zastępczej UTF-16.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="highSurrogate" />nie reprezentuje wieloskładnikowego kodu w formacie UTF-16.
          
—lub—

<paramref name="lowSurrogate" />nie reprezentuje dolnego punktu kodu w formacie UTF-16.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.CompareTo(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Rune) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Text.Rune -&gt; int&#xA;override this.CompareTo : System.Text.Rune -&gt; int" Usage="rune.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other">Wystąpienie, które ma zostać porównane z bieżącym wystąpieniem.</param>
        <summary>Porównuje bieżące wystąpienie z określonym <see cref="T:System.Text.Rune" /> wystąpieniem.</summary>
        <returns>Liczba całkowita ze znakiem wskazująca pozycję tego wystąpienia w kolejności sortowania w odniesieniu do <paramref name="other" />: <br />-Mniejsze od zera: To wystąpienie poprzedza <paramref name="other" />. 
<br />Zer Wystąpienie ma taką samą pozycję w kolejności sortowania, jak <paramref name="other" />.
<br />-Większe niż zero: To wystąpienie jest <paramref name="other" />następujące.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf16 : ReadOnlySpan&lt;char&gt; *  *  -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Zakres znaków UTF-16 tylko do odczytu.</param>
        <param name="result">Gdy ta metoda zwraca, zdekodowane Rune.</param>
        <param name="charsConsumed">Gdy ta metoda zwraca, liczba znaków odczytywanych w celu utworzenia Rune.</param>
        <summary>Dekoduje <see cref="T:System.Text.Rune" /> na początku dostarczonego bufora źródłowego UTF-16.</summary>
        <returns><see cref="F:System.Buffers.OperationStatus.Done" />Jeśli bufor źródłowy zaczyna się od prawidłowej zakodowanej wartości skalarnej UTF-16. <paramref name="result" />następnie zawiera zdekodowane <see cref="T:System.Text.Rune" />i <paramref name="charsConsumed" /> zawiera liczbę <see cref="T:System.Char" /> wartości <see cref="T:System.Text.Rune" />używanych w buforze wejściowym do kodowania.
            
<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />Jeśli bufor źródłowy jest pusty lub zawiera tylko autonomiczny znak dwuskładnikowy UTF-16. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="charsConsumed" /> zawiera długość buforu wejściowego.
            
<see cref="F:System.Buffers.OperationStatus.InvalidData" />Jeśli bufor źródłowy zaczyna się od nieprawidłowo sformułowanej wartości skalarnej zakodowanej w formacie UTF-16. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="charsConsumed" /> zawiera liczbę <see cref="T:System.Char" /> wartości używanych do kodowania nieprawidłowo sformułowanej sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ogólna Konwencja polega na wywołaniu tej metody w pętli, `source` oddzieleniu buforu przez `charsConsumed` elementy w każdej iteracji pętli. W każdej iteracji pętli `result` zawiera rzeczywistą wartość skalarną, jeśli dane zostały pomyślnie zdekodowane, lub zawiera <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> , jeśli dane nie zostały pomyślnie zdekodowane. Ten wzorzec zapewnia wygodne automatyczne podstawianie nieprawidłowych sekwencji U + FFFD podczas iteracji w pętli.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune result, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef result As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf8 : ReadOnlySpan&lt;byte&gt; *  *  -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf8 (source, result, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Zakres bajtów szyfrowany tylko do odczytu UTF-8.</param>
        <param name="result">Gdy ta metoda zwraca, zdekodowane Rune.</param>
        <param name="bytesConsumed">Gdy ta metoda zwraca, liczba bajtów odczytywanych w celu utworzenia Rune.</param>
        <summary>Dekoduje <see cref="T:System.Text.Rune" /> na początku dostarczonego bufora źródłowego UTF-8.</summary>
        <returns><see cref="F:System.Buffers.OperationStatus.Done" />Jeśli bufor źródłowy zaczyna się od prawidłowej zakodowanej wartości skalarnej UTF-8. <paramref name="result" />następnie zawiera zdekodowane <see cref="T:System.Text.Rune" />i <paramref name="bytesConsumed" /> zawiera liczbę <see cref="T:System.Byte" /> wartości <see cref="T:System.Text.Rune" />używanych w buforze wejściowym do kodowania.
            
<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />Jeśli bufor źródłowy jest pusty lub zawiera tylko autonomiczny znak dwuskładnikowy UTF-8. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="bytesConsumed" /> zawiera długość buforu wejściowego.
            
<see cref="F:System.Buffers.OperationStatus.InvalidData" />Jeśli bufor źródłowy zaczyna się od źle sformułowanej wartości skalarnej zakodowanej w formacie UTF-8. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="bytesConsumed" /> zawiera liczbę <see cref="T:System.Byte" /> wartości używanych w buforze wejściowym do kodowania nieprawidłowo sformułowanej sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ogólna Konwencja polega na wywołaniu tej metody w pętli, `source` oddzieleniu buforu przez `bytesConsumed` elementy w każdej iteracji pętli. W każdej iteracji pętli `result` zawiera rzeczywistą wartość skalarną, jeśli został pomyślnie zdekodowany lub zawiera <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> , jeśli nie można pomyślnie zdekodować danych. Ten wzorzec zapewnia wygodne automatyczne podstawianie nieprawidłowych sekwencji U + FFFD podczas iteracji w pętli.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf16 : ReadOnlySpan&lt;char&gt; *  *  -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Zakres znaków zakodowanych w formacie UTF-16.</param>
        <param name="result">Gdy ta metoda zwraca, zdekodowane Rune.</param>
        <param name="charsConsumed">Gdy ta metoda zwraca, liczba bajtów odczytywanych w celu utworzenia Rune.</param>
        <summary>Dekoduje <see cref="T:System.Text.Rune" /> na końcu dostarczonego bufora źródłowego UTF-16.</summary>
        <returns><see cref="F:System.Buffers.OperationStatus.Done" />Jeśli bufor źródłowy zaczyna się od prawidłowej zakodowanej wartości skalarnej UTF-16. <paramref name="result" />następnie zawiera zdekodowane <see cref="T:System.Text.Rune" />i <paramref name="charsConsumed" /> zawiera liczbę <see cref="T:System.Char" /> wartości <see cref="T:System.Text.Rune" />używanych w buforze wejściowym do kodowania.
            
<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />Jeśli bufor źródłowy jest pusty lub zawiera tylko autonomiczny znak dwuskładnikowy UTF-16. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="charsConsumed" /> zawiera długość buforu wejściowego.
            
<see cref="F:System.Buffers.OperationStatus.InvalidData" />Jeśli bufor źródłowy zaczyna się od nieprawidłowo sformułowanej wartości skalarnej zakodowanej w formacie UTF-16. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="charsConsumed" /> zawiera liczbę <see cref="T:System.Char" /> wartości używanych do kodowania nieprawidłowo sformułowanej sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest bardzo podobna do <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)>, z tą różnicą, że umożliwia wywołującemu pętlę do tyłu zamiast do przodu. Typową konwencją wywoływania jest to, że w każdej iteracji pętli obiekt wywołujący powinien oddzielić końcowe `charsConsumed` elementy `source` buforu.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune value, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; value, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef value As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % value, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf8 : ReadOnlySpan&lt;byte&gt; *  *  -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf8 (source, value, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source">Zakres bajtów szyfrowany tylko do odczytu UTF-8.</param>
        <param name="value">Gdy ta metoda zwraca, zdekodowane Rune.</param>
        <param name="bytesConsumed">Gdy ta metoda zwraca, liczba bajtów odczytywanych w celu utworzenia Rune.</param>
        <summary>Dekoduje <see cref="T:System.Text.Rune" /> na końcu podanego buforu źródłowego UTF-8.</summary>
        <returns><see cref="F:System.Buffers.OperationStatus.Done" />Jeśli bufor źródłowy zostanie zakończony prawidłową wartością skalarną w formacie UTF-8. <paramref name="result" />następnie zawiera zdekodowane <see cref="T:System.Text.Rune" />i <paramref name="bytesConsumed" /> zawiera liczbę <see cref="T:System.Byte" /> wartości <see cref="T:System.Text.Rune" />używanych w buforze wejściowym do kodowania.
            
<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />Jeśli bufor źródłowy jest pusty lub zawiera tylko autonomiczny znak dwuskładnikowy UTF-8. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="bytesConsumed" /> zawiera długość buforu wejściowego.
            
<see cref="F:System.Buffers.OperationStatus.InvalidData" />Jeśli bufor źródłowy zostanie zakończony nieprawidłowo sformułowaną wartością skalarną UTF-8. <paramref name="result" />następnie zawiera <see cref="P:System.Text.Rune.ReplacementChar" />i <paramref name="bytesConsumed" /> zawiera liczbę <see cref="T:System.Byte" /> wartości używanych w buforze wejściowym do kodowania nieprawidłowo sformułowanej sekwencji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest bardzo podobna do <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)>, z tą różnicą, że umożliwia wywołującemu pętlę do tyłu zamiast do przodu. Typową konwencją wywoływania jest to, że w każdej iteracji pętli obiekt wywołujący powinien oddzielić końcowe `bytesConsumed` elementy `source` buforu.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf16">
      <MemberSignature Language="C#" Value="public int EncodeToUtf16 (Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf16 (destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf16(Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf16 : Span&lt;char&gt; -&gt; int" Usage="rune.EncodeToUtf16 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Bufor, do którego ma zostać zapisana wartość w formacie UTF-16.</param>
        <summary>Koduje to <see cref="T:System.Text.Rune" /> w buforze docelowym UTF-16.</summary>
        <returns>Liczba <see cref="T:System.Char" /> wartości zapisywana w <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destination" />nie jest wystarczająco duży, aby można było przechowywać dane wyjściowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf8">
      <MemberSignature Language="C#" Value="public int EncodeToUtf8 (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf8 (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf8(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf8 : Span&lt;byte&gt; -&gt; int" Usage="rune.EncodeToUtf8 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">Bufor, do którego ma zostać zapisana wartość w formacie UTF-8.</param>
        <summary>Koduje tę <see cref="T:System.Text.Rune" /> wartość do bufora docelowego UTF-8.</summary>
        <returns>Liczba <see cref="T:System.Byte" /> wartości zapisywana w <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destination" />nie jest wystarczająco duży, aby można było przechowywać dane wyjściowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="rune.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określony obiekt są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> jest typu <see cref="T:System.Text.Rune" /> i jest równe bieżącemu wystąpieniu; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.Rune -&gt; bool" Usage="rune.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other">Obiekt do porównania z bieżącym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy bieżące wystąpienie i określone Rune są równe.</summary>
        <returns><see langword="true" />Jeśli bieżące wystąpienie i <paramref name="other" /> są równe; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="rune.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla tego wystąpienia.</summary>
        <returns>Kod skrótu dla tego wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetNumericValue(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (value As Rune) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : System.Text.Rune -&gt; double" Usage="System.Text.Rune.GetNumericValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune, dla którego ma zostać uzyskana wartość liczbowa.</param>
        <summary>Pobiera wartość liczbową skojarzoną z określonym Rune.</summary>
        <returns>Wartość liczbowa skojarzona <paramref name="value" />z, lub-1 <paramref name="value" /> , jeśli nie reprezentuje znaku numerycznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda ma zachowanie równoważne <xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType>. Aby uzyskać więcej informacji, zapoznaj się z tą dokumentacją.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRuneAt">
      <MemberSignature Language="C#" Value="public static System.Text.Rune GetRuneAt (string input, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune GetRuneAt(string input, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRuneAt (input As String, index As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune GetRuneAt(System::String ^ input, int index);" />
      <MemberSignature Language="F#" Value="static member GetRuneAt : string * int -&gt; System.Text.Rune" Usage="System.Text.Rune.GetRuneAt (input, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, z którego ma zostać utworzony Rune.</param>
        <param name="index">Pozycja początkowa w <paramref name="input" /> lokalizacji, w której ma zostać utworzony Rune.</param>
        <summary><see cref="T:System.Text.Rune" /> Pobiera, który rozpoczyna się od określonej pozycji w ciągu.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />nie odwołuje się do początku prawidłowej wartości skalarnej <paramref name="input" />w.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (value As Rune) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : System.Text.Rune -&gt; System.Globalization.UnicodeCategory" Usage="System.Text.Rune.GetUnicodeCategory value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune, dla którego ma zostać uzyskana kategoria Unicode.</param>
        <summary>Pobiera kategorię Unicode skojarzoną z określonym Rune.</summary>
        <returns>Kategoria Unicode skojarzona z <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda ma zachowanie równoważne <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>. Aby uzyskać więcej informacji, zapoznaj się z tą dokumentacją.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAscii">
      <MemberSignature Language="C#" Value="public bool IsAscii { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAscii" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsAscii" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAscii As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAscii { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAscii : bool" Usage="System.Text.Rune.IsAscii" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wartość skalarna skojarzona z tym <see cref="T:System.Text.Rune" /> jest w zakresie kodowania ASCII.</summary>
        <value><see langword="true" />Jeśli wartość skalarna jest skojarzona z zakresem kodowania ASCII ([U + 0000.. U + 007F]) i w związku z tym zaprezentowania przez pojedynczą jednostkę kodu UTF-8; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBmp">
      <MemberSignature Language="C#" Value="public bool IsBmp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBmp" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsBmp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBmp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBmp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBmp : bool" Usage="System.Text.Rune.IsBmp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wartość skalarna skojarzona z tym <see cref="T:System.Text.Rune" /> jest w zakresie kodowania BMP.</summary>
        <value><see langword="true" />Jeśli wartość skalarna jest skojarzona z zakresem kodowania BMP ([U + 0000.. U + FFFF]) i w związku z tym zaprezentowania przez pojedynczą jednostkę kodu UTF-16; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsControl(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsControl : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsControl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako znak kontrolny.</summary>
        <returns><see langword="true" />if <paramref name="value" /> jest znakiem kontrolnym; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest równoznaczna z badaniem <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> i porównaniem <xref:System.Globalization.UnicodeCategory.Control>wyniku.

Dla [zasad stateczności Unicode](https://www.unicode.org/policies/stability_policy.html)zestaw znaków sterujących jest trwale ustalony jako związek z `[ U+0000..U+001F ]` i. `[ U+007F..U+009F ]`

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsControl%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako cyfra dziesiętna.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest cyfrą dziesiętną; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest równoznaczna z badaniem <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> i porównaniem <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>wyniku.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetter(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetter : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako literę.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest literą; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> Ta metoda jest równoznaczna z badaniem i porównaniem wyniku z dowolnymi wartościami <xref:System.Globalization.UnicodeCategory.LowercaseLetter> <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter> <xref:System.Globalization.UnicodeCategory.ModifierLetter>,, i <xref:System.Globalization.UnicodeCategory.OtherLetter>.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetterOrDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetterOrDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako litera, czy cyfra dziesiętna.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest literą lub cyfrą dziesiętną; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> Ta metoda jest równoznaczna z badaniem i porównaniem wyniku z dowolnymi wartościami <xref:System.Globalization.UnicodeCategory.LowercaseLetter> <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter> <xref:System.Globalization.UnicodeCategory.ModifierLetter> <xref:System.Globalization.UnicodeCategory.OtherLetter>,,, i <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLower(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLower : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLower value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako mała litera.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest małą literą; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest równoznaczna z badaniem <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> i porównaniem <xref:System.Globalization.UnicodeCategory.LowercaseLetter>wyniku.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsLower%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsNumber(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsNumber : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsNumber value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako liczba.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest liczbą; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest równoznaczna z badaniem <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> i porównaniem wyniku z dowolnymi wartościami <xref:System.Globalization.UnicodeCategory.LetterNumber> <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>, i <xref:System.Globalization.UnicodeCategory.OtherNumber>.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsPunctuation(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsPunctuation value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako znak interpunkcyjny.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest znakiem interpunkcji; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> Ta metoda jest równoznaczna z badaniem i porównaniem wyniku z dowolnymi wartościami <xref:System.Globalization.UnicodeCategory.DashPunctuation> <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation> <xref:System.Globalization.UnicodeCategory.OpenPunctuation> <xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation>, <xref:System.Globalization.UnicodeCategory.ClosePunctuation> <xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation>,,, i <xref:System.Globalization.UnicodeCategory.OtherPunctuation>.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSeparator(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSeparator value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako znak separatora.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest znakiem separatora; w <see langword="false" />przeciwnym razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest równoznaczna z badaniem <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> i porównaniem wyniku z dowolnymi wartościami <xref:System.Globalization.UnicodeCategory.LineSeparator> <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, i <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSymbol(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSymbol value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako znak symbolu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest znakiem symbolu; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> równoznaczna z badaniem i porównaniem wyniku z jakąkolwiek z wartości <xref:System.Globalization.UnicodeCategory.MathSymbol>, <xref:System.Globalization.UnicodeCategory.CurrencySymbol> <xref:System.Globalization.UnicodeCategory.ModifierSymbol>, i <xref:System.Globalization.UnicodeCategory.OtherSymbol>.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsUpper(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsUpper : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsUpper value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako wielką literą.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest wielką literą; w przeciwnym<see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest równoznaczna z badaniem <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> i porównaniem <xref:System.Globalization.UnicodeCategory.UppercaseLetter>wyniku.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(int value);" />
      <MemberSignature Language="F#" Value="static member IsValid : int -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość skalarna Unicode.</param>
        <summary>Zwraca wartość wskazującą, czy 32-bitowa liczba całkowita ze znakiem reprezentuje prawidłową wartość skalarną Unicode; oznacza to, że znajduje się w zakresie [U + 0000.. U + D7FF] włącznie; lub [U + E000.. U + 10FFFF] włącznie.</summary>
        <returns><see langword="true" />if <paramref name="value" /> jest prawidłową wartością skalarną Unicode; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member IsValid : uint32 -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość skalarna Unicode.</param>
        <summary>Zwraca wartość wskazującą, czy 32-bitowa liczba całkowita bez znaku reprezentuje prawidłową wartość skalarną Unicode; oznacza to, że znajduje się w zakresie [U + 0000.. U + D7FF], włącznie lub [U + E000.. U + 10FFFF] włącznie.</summary>
        <returns><see langword="true" />if <paramref name="value" /> jest prawidłową wartością skalarną Unicode; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsWhiteSpace(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">Rune do obliczenia.</param>
        <summary>Zwraca wartość wskazującą, czy określony Rune jest kategoryzowany jako biały znak.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest znakiem odstępu; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Ta metoda jest <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> zwykle równoważna z badaniem i porównaniem wyników z jakąkolwiek z wartości <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>i. <xref:System.Globalization.UnicodeCategory.ParagraphSeparator> Istnieją jednak pewne <xref:System.Text.Rune>elementy <xref:System.Globalization.UnicodeCategory.Control> w kategorii, które również są klasyfikowane jako znaki odstępu, a ta metoda obejmuje te wartości.

Aby uzyskać więcej informacji, zobacz <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Equality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.Text.Rune" /> wystąpienia są równe.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> sąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Char)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (ch As Char) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(char ch);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : char -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">16-bitowy znak Unicode do przekonwertowania.</param>
        <summary>Definiuje jawną konwersję 16-bitowego znaku Unicode na <see cref="T:System.Text.Rune" />.</summary>
        <returns><paramref name="ch" />jako 32-bitowy znak Unicode.</returns>
         <remarks>To be added.</remarks>
         <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="ch" />jest skalarną Unicode, która reprezentuje punkt kodu zastępczego.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Int32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(int value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowa liczba całkowita ze znakiem do przekonwertowania.</param>
        <summary>Definiuje jawną konwersję 32-bitowej podpisanej liczby całkowitej na <see cref="T:System.Text.Rune" />.</summary>
        <returns><paramref name="value" />jako 32-bitowy znak Unicode.</returns>
         <remarks>To be added.</remarks>
         <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />jest nieprawidłowym skalarniem Unicode.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.UInt32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInteger) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint32 -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowa liczba całkowita ze znakiem do przekonwertowania.</param>
        <summary>Definiuje jawną konwersję 32-bitowej nieoznaczonej liczby całkowitej <see cref="T:System.Text.Rune" />na.</summary>
        <returns><paramref name="value" />jako 32-bitowy znak Unicode.</returns>
         <remarks>To be added.</remarks>
         <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" />jest nieprawidłowym skalarniem Unicode.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Text.Rune" /> element jest większy niż określony. <see cref="T:System.Text.Rune" /></summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większa niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Text.Rune" /> element jest większy lub równy innemu określonemu. <see cref="T:System.Text.Rune" /></summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest większe lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Inequality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="System.Text.Rune.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa <see cref="T:System.Text.Rune" /> wystąpienia mają różne wartości.</summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> i <paramref name="right" /> niesąrówne;<see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Text.Rune" /> element jest mniejszy od innego określonego. <see cref="T:System.Text.Rune" /></summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsza niż <paramref name="right" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsza wartość do porównania.</param>
        <param name="right">Druga wartość do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Text.Rune" /> element jest mniejszy niż lub równy innemu określonemu. <see cref="T:System.Text.Rune" /></summary>
        <returns><see langword="true" />Jeśli <paramref name="left" /> jest mniejsze lub <paramref name="right" />równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plane">
      <MemberSignature Language="C#" Value="public int Plane { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Plane" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Plane" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Plane As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Plane { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Plane : int" Usage="System.Text.Rune.Plane" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera płaszczyznę Unicode (od 0 do 16 włącznie), która zawiera tę wartość skalarną.</summary>
        <value>Płaszczyzna Unicode (od 0 do 16 włącznie), która zawiera tę wartość skalarną.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplacementChar">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ReplacementChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Text.Rune ReplacementChar" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.ReplacementChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ReplacementChar As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Rune ReplacementChar { System::Text::Rune get(); };" />
      <MemberSignature Language="F#" Value="member this.ReplacementChar : System.Text.Rune" Usage="System.Text.Rune.ReplacementChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Text.Rune" /> Pobiera wystąpienie, które reprezentuje znak zastępczy Unicode U + FFFD.</summary>
        <value><see cref="T:System.Text.Rune" /> Wystąpienie, które reprezentuje znak zastępczy Unicode U + FFFD.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLower (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLower(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLower(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLower (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowy znak Unicode do przekonwertowania.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię określonego <see cref="T:System.Text.Rune" /> przekonwertowanej na małe litery przy użyciu reguł wielkości liter w określonej kulturze.</summary>
        <returns>Odpowiednik małymi literami <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLowerInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLowerInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLowerInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLowerInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLowerInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowy znak Unicode do przekonwertowania.</param>
        <summary>Zwraca kopię określonej <see cref="T:System.Text.Rune" /> konwersji na małe litery przy użyciu reguł wielkości liter kultury niezmiennej.</summary>
        <returns>Odpowiednik małymi literami <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="rune.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący to <see cref="T:System.Text.Rune" /> wystąpienie.</summary>
        <returns>Ciąg reprezentujący ten Rune.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpper (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpper(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpper(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpper (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowy znak Unicode do przekonwertowania.</param>
        <param name="culture">Obiekt, który dostarcza reguły dotyczące wielkości znaków z uwzględnieniem ustawień kulturowych.</param>
        <summary>Zwraca kopię określonego <see cref="T:System.Text.Rune" /> przekonwertowanego na wielkie litery przy użyciu reguł wielkości liter w określonej kulturze.</summary>
        <returns>Wielkie litery <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpperInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpperInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpperInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpperInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpperInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value">32-bitowy znak Unicode do przekonwertowania.</param>
        <summary>Zwraca kopię określonego <see cref="T:System.Text.Rune" /> przekonwertowanego na wielkie litery przy użyciu reguł wielkości liter w kulturze niezmiennej.</summary>
        <returns>Wielkie litery <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char ch, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char ch, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (ch As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char ch, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char *  -&gt; bool" Usage="System.Text.Rune.TryCreate (ch, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ch">Znak, z którego ma zostać utworzony Rune.</param>
        <param name="result">Gdy ta metoda zwraca, Rune odpowiada <paramref name="ch" />.</param>
        <summary>Próbuje utworzyć <see cref="T:System.Text.Rune" /> od określonego znaku i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli metoda zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (int value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As Integer, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(int value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : int *  -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wartość skalarna Unicode.</param>
        <param name="result">Gdy ta metoda zwraca, Rune odpowiada <paramref name="value" />.</param>
        <summary>Próbuje utworzyć <see cref="T:System.Text.Rune" /> z określonej liczby całkowitej ze znakiem, która reprezentuje wartość skalarną Unicode.</summary>
        <returns><see langword="true" />Jeśli metoda zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (uint value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(unsigned int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As UInteger, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::UInt32 value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : uint32 *  -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Wartość skalarna Unicode.</param>
        <param name="result">Gdy ta metoda zwraca, Rune odpowiada <paramref name="value" />.</param>
        <summary>Próbuje utworzyć <see cref="T:System.Text.Rune" /> z określoną 32-bitową liczbę całkowitą bez znaku, która reprezentuje wartość skalarną Unicode.</summary>
        <returns><see langword="true" />Jeśli metoda zakończyła się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char highSurrogate, char lowSurrogate, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char highSurrogate, char lowSurrogate, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (highSurrogate As Char, lowSurrogate As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char highSurrogate, char lowSurrogate, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * char *  -&gt; bool" Usage="System.Text.Rune.TryCreate (highSurrogate, lowSurrogate, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Górny Surogat pary dwuskładnikowej.</param>
        <param name="lowSurrogate">Dolny Surogat pary dwuskładnikowej.</param>
        <param name="result">Rune, który odpowiada określonej parze surogatu.</param>
        <summary>Próbuje utworzyć <see cref="T:System.Text.Rune" /> z określonej pary zastępczej UTF-16 i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli operacja zakończyła się pomyślnie; <see langword="false" /> Jeśli wartości wejściowe nie reprezentują poprawnie sformułowanej pary zastępczej UTF-16.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf16">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf16 (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf16 (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf16(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf16 : Span&lt;char&gt; *  -&gt; bool" Usage="rune.TryEncodeToUtf16 (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">Bufor, do którego ma zostać zapisana wartość zakodowana w formacie UTF-16.</param>
        <param name="charsWritten">Liczba <see cref="T:System.Char" /> wartości zapisywana w <paramref name="destination" />lub 0, jeśli bufor docelowy nie jest wystarczająco duży, aby można było zawierać dane wyjściowe.</param>
        <summary>Koduje to <see cref="T:System.Text.Rune" /> w buforze docelowym zakodowanym w formacie UTF-16.</summary>
        <returns><see langword="true" />Jeśli wartość została zapisywana w buforze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

Przed określeniem wymaganego rozmiaru `destination` buforu można wykonać zapytanie o Właściwośćprzedczasem.<xref:System.Text.Rune.Utf16SequenceLength>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf8">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf8 (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf8 (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf8(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf8 : Span&lt;byte&gt; *  -&gt; bool" Usage="rune.TryEncodeToUtf8 (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">Bufor, do którego ma zostać zapisana zakodowana wartość UTF-8.</param>
        <param name="bytesWritten">Liczba <see cref="T:System.Byte" /> wartości zapisywana w <paramref name="destination" />lub 0, jeśli bufor docelowy nie jest wystarczająco duży, aby można było zawierać dane wyjściowe.</param>
        <summary>Koduje to <see cref="T:System.Text.Rune" /> w buforze docelowym zakodowanym przy użyciu kodowania UTF-8.</summary>
        <returns><see langword="true" />Jeśli wartość została zapisywana w buforze; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

Przed określeniem wymaganego rozmiaru `destination` buforu można wykonać zapytanie o Właściwośćprzedczasem.<xref:System.Text.Rune.Utf8SequenceLength>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRuneAt">
      <MemberSignature Language="C#" Value="public static bool TryGetRuneAt (string input, int index, out System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetRuneAt(string input, int32 index, [out] valuetype System.Text.Rune&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetRuneAt (input As String, index As Integer, ByRef value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetRuneAt(System::String ^ input, int index, [Runtime::InteropServices::Out] System::Text::Rune % value);" />
      <MemberSignature Language="F#" Value="static member TryGetRuneAt : string * int *  -&gt; bool" Usage="System.Text.Rune.TryGetRuneAt (input, index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ciąg, z którego ma zostać wyodrębniony Rune.</param>
        <param name="index">Indeks (liczony od zera), z którego ma zostać wyodrębniony Rune.</param>
        <param name="value">Gdy ta metoda zwraca, zdekodowane Rune.</param>
        <summary>Próbuje uzyskać <see cref="T:System.Text.Rune" /> , który rozpoczyna się w określonej pozycji w ciągu, i zwraca wartość wskazującą, czy operacja zakończyła się pomyślnie.</summary>
        <returns><see langword="true" />Jeśli wartość skalarna została pomyślnie wyodrębniona z określonego indeksu; <see langword="false" /> Jeśli nie można wyodrębnić wartości z powodu nieprawidłowych danych.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest poza zakresem <paramref name="input" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Utf16SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf16SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf16SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf16SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf16SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf16SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf16SequenceLength : int" Usage="System.Text.Rune.Utf16SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość w jednostkach kodu (<see cref="T:System.Char" />) sekwencji UTF-16 wymaganych do reprezentowania tej wartości skalarnej.</summary>
        <value>Długość w jednostkach kodu (<see cref="T:System.Char" />) sekwencji UTF-16 wymagana do reprezentowania tej wartości skalarnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wartość zwracana będzie równa 1 lub 2.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Utf8SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf8SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf8SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf8SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf8SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf8SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf8SequenceLength : int" Usage="System.Text.Rune.Utf8SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość w jednostkach kodu sekwencji UTF-8 wymaganych do reprezentowania tej wartości skalarnej.</summary>
        <value>Długość w jednostkach kodu sekwencji UTF-8 wymagana do reprezentowania tej wartości skalarnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Wartość zwracana będzie wynosić od 1 do 4 włącznie.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public int Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Value" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Value { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : int" Usage="System.Text.Rune.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość skalarną Unicode jako liczbę całkowitą.</summary>
        <value>Wartość skalarna Unicode jako liczba całkowita.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3880f1cd8f8dfff982bdcaa318e9898d93bcec92" /><Meta Name="ms.sourcegitcommit" Value="24f564114ee2fa9c63dbac1b25b82826cc4e320f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/25/2019" /><Meta Name="ms.locfileid" Value="68488203" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje modyfikowalny ciąg znaków. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa reprezentuje obiekt podobny do typu String, którego wartość jest modyfikowalną sekwencją znaków.  
  
 W tej sekcji:  
  
-   [Typy ciągów i StringBuilder](#StringAndSB)  
  
-   [Jak działa StringBuilder](#HowWorks)  
  
-   [Alokacja pamięci](#Memory)  
  
-   [Tworzenie wystąpienia obiektu StringBuilder](#Instantiating)  
  
-   [Wywoływanie metod StringBuilder](#Calling)  
  
-   [Wykonywanie operacji StringBuilder](#Operations)  
  
    -   [Iterowanie znaków StringBuilder](#Iterating)  
  
    -   [Dodawanie tekstu do obiektu StringBuilder](#Adding)  
  
    -   [Usuwanie tekstu z obiektu StringBuilder](#Deleting)  
  
    -   [Modyfikowanie tekstu w obiekcie StringBuilder](#Modifying)  
  
-   [Wyszukiwanie tekstu w obiekcie StringBuilder](#Searching)  
  
-   [Konwertowanie obiektu StringBuilder na ciąg](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Typy ciągów i typy StringBuilder  
 Chociaż <xref:System.Text.StringBuilder> i<xref:System.String> obie reprezentują sekwencje znaków, są one implementowane inaczej. <xref:System.String>jest niezmiennym typem. Oznacza to, że każda operacja, która pojawia się <xref:System.String> w celu zmodyfikowania obiektu, faktycznie tworzy nowy ciąg.  
  
 Na przykład, wywołanie <xref:System.String.Concat%2A?displayProperty=nameWithType> metody w poniższym C# przykładzie pojawia się, aby zmienić wartość zmiennej ciągu o nazwie `value`. W rzeczywistości <xref:System.String.Concat%2A> Metoda `value` zwraca obiekt, który ma inną `value` wartość i adres z obiektu, który został przesłany do metody. Należy zauważyć, że przykład musi być skompilowany przy `/unsafe` użyciu opcji kompilatora.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 W przypadku procedur wykonujących rozbudowane manipulowanie ciągami (takie jak aplikacje modyfikujące ciąg wiele razy w pętli) Modyfikowanie ciągu może znacznie powiększyć znaczący spadek wydajności. Alternatywą jest użycie <xref:System.Text.StringBuilder>metody, która jest klasą ciągów modyfikowalnych. Zmienność oznacza, że po utworzeniu wystąpienia klasy można je zmodyfikować przez dołączanie, usuwanie, zastępowanie lub wstawianie znaków. <xref:System.Text.StringBuilder> Obiekt zachowuje bufor, aby pomieścić rozszerzenia do ciągu. Nowe dane są dołączane do bufora, jeśli jest dostępne pomieszczenie; w przeciwnym razie przydzielono nowy, większy bufor, dane z oryginalnego buforu są kopiowane do nowego buforu, a nowe dane są następnie dołączane do nowego buforu.  
  
> [!IMPORTANT]
>  Mimo że <xref:System.String> <xref:System.String> <xref:System.Text.StringBuilder> Klasa ogólnie oferuje lepszą wydajność niż Klasa, nie należy automatycznie zamieniać przy użyciu, gdy chcesz manipulować ciągami. <xref:System.Text.StringBuilder> Wydajność zależy od rozmiaru ciągu, ilości pamięci, która ma zostać przypisana do nowego ciągu, systemu, w którym aplikacja jest wykonywana, oraz typu operacji. Należy przygotować się do przetestowania aplikacji, aby określić <xref:System.Text.StringBuilder> , czy w rzeczywistości oferuje znaczącą poprawę wydajności.  
  
 Rozważ użycie <xref:System.String> klasy w następujących warunkach:  
  
-   Gdy liczba zmian wprowadzonych w aplikacji w ciągu jest mała. W takich przypadkach <xref:System.Text.StringBuilder> może oferować nieznaczną wydajność lub <xref:System.String>zwiększenie wydajności.  
  
-   Gdy wykonujesz stałą liczbę operacji łączenia, szczególnie w przypadku literałów ciągów. W takim przypadku kompilator może połączyć operacje łączenia w jedną operację.  
  
-   Gdy musisz wykonać rozbudowane operacje wyszukiwania podczas kompilowania ciągu. Klasa <xref:System.Text.StringBuilder> nie ma metod wyszukiwania, takich jak `IndexOf` lub `StartsWith`. Konieczne będzie przekonwertowanie <xref:System.Text.StringBuilder> obiektu <xref:System.String> na dla tych operacji. może to Negate korzyść użycia <xref:System.Text.StringBuilder>. Więcej informacji znajduje się w sekcji [Wyszukiwanie tekstu w obiekcie StringBuilder](#Searching) .  
  
 Rozważ użycie <xref:System.Text.StringBuilder> klasy w następujących warunkach:  
  
-   Gdy oczekujesz, że aplikacja będzie zawierać nieznaną liczbę zmian w ciągu w czasie projektowania (na przykład w przypadku używania pętli do łączenia losowej liczby ciągów zawierających dane wejściowe użytkownika).  
  
-   Gdy oczekujesz, że aplikacja wprowadzi znaczną liczbę zmian w ciągu.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Jak działa StringBuilder  
 Właściwość wskazuje liczbę znaków, które <xref:System.Text.StringBuilder> aktualnie zawiera obiekt. <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Jeśli dodasz znaki do <xref:System.Text.StringBuilder> obiektu, jego długość zwiększy się, dopóki nie będzie równa rozmiarowi <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> właściwości, która definiuje liczbę znaków, które może zawierać obiekt. Jeśli liczba dodanych znaków powoduje, że długość <xref:System.Text.StringBuilder> obiektu przekracza jego bieżącą pojemność, przydzielono nową pamięć, wartość <xref:System.Text.StringBuilder.Capacity%2A> właściwości jest podwójna, nowe <xref:System.Text.StringBuilder> znaki są dodawane do obiektu i jego <xref:System.Text.StringBuilder.Length%2A>właściwość jest ustawiona. Dodatkowa pamięć dla <xref:System.Text.StringBuilder> obiektu jest przydzielana dynamicznie, dopóki nie osiągnie wartości zdefiniowanej <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> przez właściwość. Po osiągnięciu maksymalnej pojemności nie można przydzielić kolejnej pamięci dla <xref:System.Text.StringBuilder> obiektu i próbować dodać znaków lub rozszerzyć go poza maksymalną pojemność <xref:System.ArgumentOutOfRangeException> <xref:System.OutOfMemoryException> , wyrzuca albo wyjątek.  
  
 Poniższy przykład ilustruje, jak <xref:System.Text.StringBuilder> Obiekt przydziela nową pamięć i zwiększa jego pojemność dynamicznie, gdy ciąg przypisany do obiektu zostanie rozwinięty. Kod tworzy <xref:System.Text.StringBuilder> obiekt przez wywołanie jego domyślnego (bezparametrowego) konstruktora. Domyślna pojemność tego obiektu to 16 znaków, a maksymalna pojemność przekracza 2 000 000 000 znaków. Dołączanie ciągu "to jest zdanie". powoduje nowe przydzielanie pamięci, ponieważ długość ciągu (19 znaków) przekracza domyślną pojemność <xref:System.Text.StringBuilder> obiektu. Pojemność obiektu jest podwajana do 32 znaków, nowy ciąg zostanie dodany, a długość obiektu jest teraz równa 19 znaków. Następnie kod dołącza ciąg "to jest dodatkowe zdanie". do wartości <xref:System.Text.StringBuilder> obiektu 11 razy. Za każdym razem, gdy operacja dołączania <xref:System.Text.StringBuilder> powoduje, że długość obiektu przekracza jego pojemność, jego istniejąca pojemność jest <xref:System.Text.StringBuilder.Append%2A> podwójna i operacja zakończy się pomyślnie.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Alokacja pamięci  
 Domyślna pojemność <xref:System.Text.StringBuilder> obiektu to 16 znaków, a jego domyślna maksymalna pojemność to <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Te wartości domyślne są używane w <xref:System.Text.StringBuilder.%23ctor> przypadku wywołania konstruktorów i. <xref:System.Text.StringBuilder.%23ctor%28System.String%29>  
  
 Można jawnie zdefiniować początkową pojemność <xref:System.Text.StringBuilder> obiektu w następujący sposób:  
  
-   Wywoływanie któregokolwiek z <xref:System.Text.StringBuilder> konstruktorów, które `capacity` zawierają parametr podczas tworzenia obiektu.  
  
-   Przez jawne przypisanie nowej wartości do <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> właściwości w celu rozszerzenia istniejącego <xref:System.Text.StringBuilder> obiektu. Należy zauważyć, że właściwość zgłasza wyjątek, jeśli nowa pojemność jest mniejsza niż istniejąca pojemność lub większa niż <xref:System.Text.StringBuilder> Maksymalna pojemność obiektu.  
  
-   Przez wywołanie <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> metody z nową pojemnością. Nowa pojemność nie może być większa niż <xref:System.Text.StringBuilder> Maksymalna pojemność obiektu. Jednak, w przeciwieństwie do przypisania do <xref:System.Text.StringBuilder.Capacity%2A> właściwości, <xref:System.Text.StringBuilder.EnsureCapacity%2A> nie zgłasza wyjątku, jeśli żądana Nowa pojemność jest mniejsza niż istniejąca pojemność; w tym przypadku wywołanie metody nie ma żadnego wpływu.  
  
 Jeśli długość ciągu przypisanego do <xref:System.Text.StringBuilder> obiektu w wywołaniu konstruktora przekracza domyślną pojemność lub określoną pojemność <xref:System.Text.StringBuilder.Capacity%2A> , właściwość jest ustawiona na długość ciągu określonego za pomocą `value` parametru.  
  
 Można jawnie zdefiniować maksymalną pojemność <xref:System.Text.StringBuilder> obiektu przez <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> wywołanie konstruktora. Nie można zmienić maksymalnej pojemności, przypisując nową wartość do <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości, ponieważ jest tylko do odczytu.  
  
 Jak przedstawiono w poprzedniej sekcji, gdy istniejąca pojemność jest niewystarczająca, przydzielono dodatkową pamięć, a pojemność <xref:System.Text.StringBuilder> obiektu jest podwajana do wartości zdefiniowanej <xref:System.Text.StringBuilder.MaxCapacity%2A> przez właściwość.  
  
 Ogólnie rzecz biorąc, domyślna pojemność i Maksymalna pojemność są odpowiednie dla większości aplikacji. Można rozważyć ustawienie tych wartości w następujących warunkach:  
  
-   Jeśli rozmiar <xref:System.Text.StringBuilder> dla obiektu jest prawdopodobnie większy niż duży, zwykle przekracza kilka megabajtów. W takim przypadku może wystąpić pewne korzyści wynikające z wydajności niż ustawienie właściwości początkowej <xref:System.Text.StringBuilder.Capacity%2A> na znacznie wysoką wartość, aby wyeliminować konieczność zbyt wielu ponownych alokacji pamięci.  
  
-   Jeśli aplikacja działa w systemie z ograniczoną ilością pamięci. W takim przypadku warto rozważyć ustawienie <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości na wartość mniejszą niż <xref:System.Int32.MaxValue?displayProperty=nameWithType> Jeśli aplikacja obsługuje duże ciągi, które mogą spowodować wykonanie w środowisku z ograniczoną ilością pamięci.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Utworzenie wystąpienia obiektu StringBuilder  
 Utworzenie wystąpienia <xref:System.Text.StringBuilder> obiektu przez wywołanie jednego z sześciu przeciążonych konstruktorów klas, które są wymienione w poniższej tabeli. Trzy z konstruktorów tworzy <xref:System.Text.StringBuilder> wystąpienie obiektu, którego wartość jest pustym ciągiem, ale <xref:System.Text.StringBuilder.Capacity%2A> ustawia wartości <xref:System.Text.StringBuilder.MaxCapacity%2A> i w różny sposób. Pozostałe trzy konstruktory definiują <xref:System.Text.StringBuilder> obiekt z określoną wartością ciągu i pojemnością. Dwa z trzech konstruktorów używają domyślnej maksymalnej pojemności <xref:System.Int32.MaxValue?displayProperty=nameWithType>, podczas gdy trzecia pozwala ustawić maksymalną pojemność.  
  
|Konstruktor|Wartość ciągu|Pojemność|Maksymalna pojemność|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Zdefiniowane przez `capacity` parametr|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Zdefiniowane przez `capacity` parametr|Zdefiniowane przez `maxCapacity` parametr|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Zdefiniowane przez `value` parametr|16 lub `value`. <xref:System.String.Length%2A>, w zależności od tego, kto jest większy|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Zdefiniowane przez `value` parametr|Zdefiniowane przez `capacity` parametr lub `value`. <xref:System.String.Length%2A>, w zależności od tego, co jest większe.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Zdefiniowane przez `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Zdefiniowane przez `capacity` parametr lub `value`. <xref:System.String.Length%2A>, w zależności od tego, co jest większe.|Zdefiniowane przez `maxCapacity` parametr|  
  
 W poniższym przykładzie zastosowano trzy z tych przeciążeń <xref:System.Text.StringBuilder> konstruktora, aby utworzyć wystąpienie obiektów.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Wywołanie metod StringBuilder  
 Większość metod modyfikujących ciąg w <xref:System.Text.StringBuilder> wystąpieniu zwraca odwołanie do tego samego wystąpienia. Umożliwia to wywoływanie <xref:System.Text.StringBuilder> metod na dwa sposoby:  
  
-   Można wykonać poszczególne wywołania metod i zignorować wartość zwracaną, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   W jednej instrukcji można wykonać serię wywołań metod. Może to być wygodne, jeśli chcesz napisać pojedynczą instrukcję, która tworzy łańcuch kolejnych operacji. Poniższy przykład konsoliduje trzy wywołania metody z poprzedniego przykładu w jeden wiersz kodu.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Przeprowadzanie operacji StringBuilder  
 Metody <xref:System.Text.StringBuilder> klasy służą do iteracji, dodawania, usuwania lub modyfikowania znaków <xref:System.Text.StringBuilder> w obiekcie.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Iterowanie znaków StringBuilder  
 Dostęp do znaków w <xref:System.Text.StringBuilder> obiekcie można uzyskać za <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> pomocą właściwości. W C#, <xref:System.Text.StringBuilder.Chars%2A> jest indeksatorem; w Visual Basic jest to właściwość <xref:System.Text.StringBuilder> domyślna klasy. Pozwala to na ustawienie lub pobranie pojedynczych znaków przy użyciu tylko ich indeksu, bez jawnego odwoływania <xref:System.Text.StringBuilder.Chars%2A> się do właściwości. Znaki w <xref:System.Text.StringBuilder> obiekcie zaczynają się od indeksu 0 (zero) i przejdź do <xref:System.Text.StringBuilder.Length%2A> indeksu-1.  
  
 Poniższy przykład ilustruje <xref:System.Text.StringBuilder.Chars%2A> właściwość. Dodaje dziesięć liczb losowych do <xref:System.Text.StringBuilder> obiektu, a następnie iteruje każdy znak. Jeśli kategoria Unicode znaku jest <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, zmniejsza liczbę o 1 (lub zmienia liczbę na 9, jeśli jej wartość jest równa 0). Przykład wyświetla zawartość <xref:System.Text.StringBuilder> obiektu przed i po zmianie wartości poszczególnych znaków.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Dodawanie tekstu do obiektu StringBuilder  
 Klasa zawiera następujące metody rozszerzania zawartości <xref:System.Text.StringBuilder> obiektu: <xref:System.Text.StringBuilder>  
  
-   Metoda dołącza ciąg, podciąg, tablicę znaków, część tablicy znaków, pojedynczy znak wielokrotnie powtórzony lub ciąg reprezentujący typ danych pierwotnych <xref:System.Text.StringBuilder> do obiektu. <xref:System.Text.StringBuilder.Append%2A>  
  
-   Metoda dołącza terminator wiersza lub ciąg wraz z terminatorem wiersza <xref:System.Text.StringBuilder> do obiektu. <xref:System.Text.StringBuilder.AppendLine%2A>  
  
-   Metoda dołącza do <xref:System.Text.StringBuilder> obiektu [ciąg formatu złożonego.](~/docs/standard/base-types/composite-formatting.md) <xref:System.Text.StringBuilder.AppendFormat%2A> Reprezentacje ciągów obiektów uwzględnionych w ciągu wynikowym mogą odzwierciedlać konwencje formatowania bieżącej kultury systemowej lub określoną kulturę.  
  
-   Metoda wstawia ciąg, podciąg, wiele powtórzeń ciągu, tablicę znaków, część tablicy znaków lub ciąg reprezentujący typ danych pierwotnych w określonej pozycji <xref:System.Text.StringBuilder> w obiekcie. <xref:System.Text.StringBuilder.Insert%2A> Pozycja jest definiowana przez indeks (liczony od zera).  
  
 W poniższym przykładzie zastosowano <xref:System.Text.StringBuilder.Append%2A>metody <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>,, <xref:System.Text.StringBuilder.Insert%2A> <xref:System.Text.StringBuilder> i, aby rozwinąć tekst obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Usuwanie tekstu z obiektu StringBuilder  
 Klasa zawiera metody, które mogą zmniejszyć rozmiar bieżącego <xref:System.Text.StringBuilder> wystąpienia. <xref:System.Text.StringBuilder> Metoda usuwa wszystkie znaki i <xref:System.Text.StringBuilder.Length%2A> ustawia właściwość na zero. <xref:System.Text.StringBuilder.Clear%2A> <xref:System.Text.StringBuilder.Remove%2A> Metoda usuwa określoną liczbę znaków, zaczynając od określonej pozycji indeksu. Ponadto można usunąć znaki z końca <xref:System.Text.StringBuilder> obiektu przez ustawienie jego <xref:System.Text.StringBuilder.Length%2A> właściwości na wartość, która jest mniejsza niż długość bieżącego wystąpienia.  
  
 Poniższy przykład usuwa część tekstu z <xref:System.Text.StringBuilder> obiektu, wyświetla jego wyniki, maksymalną pojemność i długość wartości właściwości, a następnie <xref:System.Text.StringBuilder.Clear%2A> wywołuje metodę w celu usunięcia <xref:System.Text.StringBuilder> wszystkich znaków z obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Modyfikowanie tekstu w obiekcie StringBuilder  
 Metoda zastępuje wszystkie wystąpienia znaku lub ciągu w całym <xref:System.Text.StringBuilder> obiekcie lub w określonym zakresie znaków. <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> W poniższym przykładzie użyto metody <xref:System.Text.StringBuilder.Replace%2A> , aby zamienić wszystkie wykrzykniki (!) na znaki zapytania (?) <xref:System.Text.StringBuilder> w obiekcie.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Wyszukiwanie tekstu w obiekcie StringBuilder  
 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> <xref:System.String.Contains%2A?displayProperty=nameWithType> <xref:System.String> <xref:System.String.StartsWith%2A?displayProperty=nameWithType> Klasa nie obejmuje metod podobnych do metod,, i dostarczonych przez klasę, które umożliwiają przeszukiwanie obiektu pod kątem określonego znaku lub podciągu. <xref:System.Text.StringBuilder> Określenie obecności lub początkowego położenia znaku podciągu wymaga przeszukiwania <xref:System.String> wartości przy użyciu metody wyszukiwania ciągów lub metody wyrażenia regularnego. Istnieją cztery sposoby implementacji takich wyszukiwań, jak pokazano w poniższej tabeli.  
  
|Zajmuje|Specjaliści|Wady|  
|---------------|----------|----------|  
|Wyszukaj wartości ciągu przed dodaniem ich do <xref:System.Text.StringBuilder> obiektu.|Przydatne do określania, czy podciąg istnieje.|Nie można użyć, gdy pozycja indeksu podciągu jest ważna.|  
|Wywołaj <xref:System.Text.StringBuilder.ToString%2A> i Przeszukaj <xref:System.String> zwrócony obiekt.|Łatwe w użyciu, Jeśli przypiszesz cały tekst do <xref:System.Text.StringBuilder> obiektu, a następnie zaczniesz go modyfikować.|Nieskomplikowany do <xref:System.Text.StringBuilder.ToString%2A> wielokrotnego wywołania, jeśli musisz wprowadzić modyfikacje przed dodaniem <xref:System.Text.StringBuilder> całego tekstu do obiektu.<br /><br /> Należy pamiętać, aby zacząć od końca <xref:System.Text.StringBuilder> tekstu obiektu, jeśli wprowadzasz zmiany.|  
|Użyj właściwości <xref:System.Text.StringBuilder.Chars%2A> , aby sekwencyjnie przeszukiwać zakres znaków.|Przydatne w przypadku, gdy użytkownik korzysta z pojedynczych znaków lub małego podciągu.|Nieskomplikowany, jeśli liczba znaków do wyszukania jest duża lub jeśli logika wyszukiwania jest złożona.<br /><br />Wynikiem jest bardzo niska wydajność dla obiektów, które są bardzo duże przez powtarzające się wywołania metod.  |  
|Przekonwertuj <xref:System.String> <xref:System.String> obiekt na obiekt i wykonaj modyfikacje obiektu. <xref:System.Text.StringBuilder>|Przydatne, jeśli liczba modyfikacji jest mała.|Wyklucza korzyść wydajności klasy, <xref:System.Text.StringBuilder> Jeśli liczba modyfikacji jest duża.|  
  
 Sprawdźmy, czy te techniki są bardziej szczegółowe.  
  
-   Jeśli celem wyszukiwania jest określenie, czy określony podciąg istnieje (to znaczy, jeśli nie interesują się pozycja podciągu), można wyszukiwać ciągi przed ich zapisaniem w <xref:System.Text.StringBuilder> obiekcie. W poniższym przykładzie przedstawiono jedną możliwą implementację. Definiuje `StringBuilderFinder` klasę, której Konstruktor przeszedł odwołanie <xref:System.Text.StringBuilder> do obiektu i podciągu, który ma zostać znaleziony w ciągu. W takim przypadku przykład próbuje określić, czy zarejestrowane temperatury są w liczbie Fahrenheita lub Celsjusza, i dodaje odpowiedni tekst wprowadzający na początku <xref:System.Text.StringBuilder> obiektu. Generator liczb losowych służy do wybierania tablicy zawierającej dane w stopniach Celsjusza lub stopni Fahrenheita.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Wywołaj <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby <xref:System.Text.StringBuilder> przekonwertować obiekt na <xref:System.String> obiekt. Możesz przeszukać ciąg za pomocą metod, takich <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> jak <xref:System.String.StartsWith%2A?displayProperty=nameWithType>lub, lub <xref:System.Text.RegularExpressions.Regex> użyć wyrażeń regularnych i klasy do wyszukiwania wzorców. Ponieważ oba <xref:System.Text.StringBuilder> obiekty <xref:System.String> i są używane w kodowaniu UTF-16 do przechowywania znaków, pozycje indeksu znaków, podciągów i wyrażenia regularne są takie same w obu obiektach. Dzięki temu można użyć <xref:System.Text.StringBuilder> metod, aby wprowadzić zmiany w tym samym miejscu, w którym tekst zostanie znaleziony <xref:System.String> w obiekcie.  
  
    > [!NOTE]
    >  W przypadku zastosowania tego podejścia należy wykonać od końca <xref:System.Text.StringBuilder> obiektu do jego początku, aby nie trzeba wielokrotnie <xref:System.Text.StringBuilder> skonwertować obiekt na ciąg.  
  
     To podejście pokazano w poniższym przykładzie. Przechowuje cztery wystąpienia każdej litery alfabetu angielskiego w <xref:System.Text.StringBuilder> obiekcie. Następnie konwertuje tekst do <xref:System.String> obiektu i używa wyrażenia regularnego do identyfikowania pozycji początkowej każdej sekwencji zawierającej cztery znaki. Na koniec dodaje znak podkreślenia przed każdą sekwencją czterech znaków z wyjątkiem pierwszej sekwencji i konwertuje pierwszy znak sekwencji na wielkie litery.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Użyj właściwości do sekwencyjnego przeszukiwania zakresu znaków <xref:System.Text.StringBuilder> w obiekcie. <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> Takie podejście może nie być praktyczne, jeśli liczba znaków do przeszukania jest duża lub logika wyszukiwania jest szczególnie złożona. Aby uzyskać wpływ na wydajność dla bardzo dużych, <xref:System.Text.StringBuilder> rozbudowanych obiektów, należy zapoznać się z dokumentacją <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwości. 
  
     Poniższy przykład jest identyczny w funkcji w poprzednim przykładzie, ale różni się w implementacji. Używa <xref:System.Text.StringBuilder.Chars%2A> właściwości, aby wykryć, kiedy wartość znaku została zmieniona, wstawia podkreślenie w tym miejscu i konwertuje pierwszy znak w nowej sekwencji na wielkie litery.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Przechowuj cały <xref:System.Text.StringBuilder> niezmodyfikowany tekst w obiekcie, <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> Wywołaj metodę, aby <xref:System.String> przekonwertować <xref:System.Text.StringBuilder> obiekt na obiekt, i przeprowadź modyfikacje <xref:System.String> obiektu. Możesz użyć tej metody, jeśli masz tylko kilka modyfikacji: w przeciwnym razie koszt pracy z niezmiennymi ciągami może Negate korzyści wynikające z użycia <xref:System.Text.StringBuilder> obiektu.  
  
     Poniższy przykład jest identyczny w funkcji z poprzednimi dwoma przykładami, ale różni się w implementacji. Tworzy <xref:System.Text.StringBuilder> obiekt, konwertuje go <xref:System.String> na obiekt, a następnie używa wyrażenia regularnego do wykonywania wszystkich pozostałych modyfikacji ciągu. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda używa wyrażenia lambda do przeprowadzenia zamiany dla każdego dopasowania.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Konwersja obiektu StringBuilder na ciąg  
 Przed przekazaniem <xref:System.Text.StringBuilder> ciągu reprezentowanego <xref:System.String> przez <xref:System.Text.StringBuilder> obiekt do metody, która ma <xref:System.String> parametr lub wyświetlenie go w interfejsie użytkownika, należy przekonwertować obiekt na obiekt. Tę konwersję wykonuje się <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> , wywołując metodę. Aby zapoznać się z ilustracją, zobacz poprzedni przykład, który <xref:System.Text.StringBuilder.ToString%2A> wywołuje metodę, aby <xref:System.Text.StringBuilder> przekonwertować obiekt na ciąg, tak aby można go było przesłać do metody wyrażenia regularnego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać wiele metod zdefiniowanych przez <xref:System.Text.StringBuilder> klasę.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość ciągu tego wystąpienia jest ustawiona na <xref:System.String.Empty?displayProperty=nameWithType>, a pojemność jest ustawiona na wydajność domyślną specyficzną dla implementacji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora bez parametrów.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerowany rozmiar początkowy tego wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.StringBuilder" /> klasy przy użyciu określonej pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jej wartość jest przypisana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków <xref:System.Text.StringBuilder> , które mają być przechowywane w bieżącym wystąpieniu, przekracza tę `capacity` wartość, Obiekt przydziela dodatkową pamięć do przechowywania.  
  
 Wartość ciągu tego wystąpienia jest ustawiona na <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli `capacity` wartość jest równa zero, używana jest domyślna pojemność określona dla implementacji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określoną pojemnością.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza od zera.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg używany do zainicjowania wartości wystąpienia. Jeśli <paramref name="value" /> <see cref="T:System.Text.StringBuilder" /> <see cref="F:System.String.Empty" />ma <see langword="null" />wartość, Nowa będzie zawierać pusty ciąg (czyli zawiera).</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.StringBuilder" /> klasy przy użyciu określonego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` <xref:System.Text.StringBuilder> <xref:System.String.Empty>ma `null`wartość, Nowa będzie zawierać pusty ciąg (czyli zawiera).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określonym ciągiem.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerowany rozmiar <see cref="T:System.Text.StringBuilder" />początkowy.</param>
        <param name="maxCapacity">Maksymalna liczba znaków, jaką może zawierać bieżący ciąg.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.StringBuilder" /> klasy, która rozpoczyna się od określonej pojemności i może zostać powiększone do określonej wartości maksymalnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jej wartość jest przypisana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków <xref:System.Text.StringBuilder> , które mają być przechowywane w bieżącym wystąpieniu, przekracza tę `capacity` wartość, Obiekt przydziela dodatkową pamięć do przechowywania.  
  
 Jeśli `capacity` wartość jest równa zero, używana jest domyślna pojemność określona dla implementacji.  
  
 `maxCapacity` Właściwość określa maksymalną liczbę znaków, które mogą być przechowywane w bieżącym wystąpieniu. Jej wartość jest przypisana do <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości. Jeśli liczba znaków `maxCapacity` <xref:System.Text.StringBuilder> , które mają być przechowywane w bieżącym wystąpieniu przekracza tę wartość, obiekt nie przydziela dodatkowej pamięci, ale zamiast tego zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywoływania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określoną pojemnością i maksymalną pojemnością.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" />jest mniej niż jeden, <paramref name="capacity" /> jest mniejszy od zera lub <paramref name="capacity" /> jest większy niż <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg używany do zainicjowania wartości wystąpienia. Jeśli <paramref name="value" /> <see cref="T:System.Text.StringBuilder" /> <see cref="F:System.String.Empty" />ma <see langword="null" />wartość, Nowa będzie zawierać pusty ciąg (czyli zawiera).</param>
        <param name="capacity">Sugerowany rozmiar <see cref="T:System.Text.StringBuilder" />początkowy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.StringBuilder" /> klasy przy użyciu określonego ciągu i pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jej wartość jest przypisana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków <xref:System.Text.StringBuilder> , które mają być przechowywane w bieżącym wystąpieniu, przekracza tę `capacity` wartość, Obiekt przydziela dodatkową pamięć do przechowywania.  
  
 Jeśli `capacity` wartość jest równa zero, używana jest domyślna pojemność określona dla implementacji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z początkowym ciągiem i określoną pojemnością.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza od zera.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który zawiera podciąg używany do zainicjowania wartości tego wystąpienia. Jeśli <paramref name="value" /> <see cref="T:System.Text.StringBuilder" /> <see cref="F:System.String.Empty" />ma <see langword="null" />wartość, Nowa będzie zawierać pusty ciąg (czyli zawiera).</param>
        <param name="startIndex">Pozycja w miejscu <paramref name="value" /> , w którym rozpoczyna się podciąg.</param>
        <param name="length">Liczba znaków w podciągu.</param>
        <param name="capacity">Sugerowany rozmiar <see cref="T:System.Text.StringBuilder" />początkowy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Text.StringBuilder" /> klasy z określonego podciągu i pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jej wartość jest przypisana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków <xref:System.Text.StringBuilder> , które mają być przechowywane w bieżącym wystąpieniu, przekracza tę `capacity` wartość, Obiekt przydziela dodatkową pamięć do przechowywania.  
  
 Jeśli `capacity` wartość jest równa zero, używana jest domyślna pojemność określona dla implementacji.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określonym ciągiem.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />znak <paramref name="length" /> Plus nie jest pozycją <paramref name="value" />w obrębie elementu.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ciąg reprezentujący określony obiekt do tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość logiczna do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną wartość logiczną do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Metoda wywołuje metodę, <xref:System.Boolean.ToString?displayProperty=nameWithType> aby `value`uzyskać ciąg reprezentujący. <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 8-bitową liczbę całkowitą bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.Byte.ToString%28System.IFormatProvider%29> <xref:System.Text.StringBuilder.Append%28System.Byte%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Jednostka kodu zakodowana w formacie UTF-16 do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określony <see cref="T:System.Char" /> obiekt do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący znaki Unicode w określonej tablicy do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza wszystkie znaki w określonej tablicy do bieżącego wystąpienia w tej samej kolejności, w jakiej występują w `value`. Jeśli `value` tak`null`, nie są wprowadzane żadne zmiany.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną liczbę dziesiętną do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną liczbę zmiennoprzecinkową o podwójnej precyzji do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Double%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 16-bitową liczbę całkowitą ze znakiem do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Int16%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 32-bitową liczbę całkowitą ze znakiem do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Int32%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 64-bitową liczbę całkowitą ze znakiem do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 Metoda wywołuje metodę w `value` celu uzyskania ciągu reprezentującego reprezentację dla bieżącej kultury. <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Int64%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określony obiekt do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie. Definiuje `Dog` klasę, `Dog` tworzy obiekt i <xref:System.Text.StringBuilder.Append%2A> wykonuje trzy wywołania metody, aby utworzyć ciąg, który zawiera nazwę i rasę tego Dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 Metoda wywołuje metodę, <xref:System.Object.ToString%2A?displayProperty=nameWithType> aby `value`uzyskać ciąg reprezentujący. <xref:System.Text.StringBuilder.Append%28System.Object%29> Jeśli `value` <xref:System.Text.StringBuilder> tak `null`, nie są wprowadzane żadne zmiany w obiekcie.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Region pamięci tylko do odczytu do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określony region pamięci tylko do odczytu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Zakres znaków tylko do odczytu do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określony zakres znaków tylko do odczytu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 8-bitową liczbę całkowitą ze znakiem do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.SByte%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną liczbę zmiennoprzecinkową o pojedynczej precyzji do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.Single.ToString%2A?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Single%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dołączenia.</param>
        <summary>Dołącza kopię określonego ciągu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Jeśli `value` tak`null`, nie są wprowadzane żadne zmiany.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Konstruktor ciągów do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określony Konstruktor ciągów do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 16-bitową liczbę całkowitą bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 Metoda wywołuje metodę, <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> aby `value`uzyskać ciąg reprezentujący. <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 32-bitową liczbę całkowitą bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 Wywołuje metodę, <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> Aby`value` uzyskać ciąg reprezentujący dla bieżącej kultury. <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną 64-bitową liczbę całkowitą bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 Metoda wywołuje metodę w celu pobrania ciągu reprezentującego `value` dla bieżącej kultury. <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Aby kontrolować formatowanie `value`, <xref:System.Text.StringBuilder.AppendFormat%2A> Wywołaj metodę.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak do dołączenia.</param>
        <param name="repeatCount">Liczba dołączeń <paramref name="value" />.</param>
        <summary>Dołącza określoną liczbę kopii ciągu reprezentującego znak Unicode do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" />jest mniejsza od zera.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków.</param>
        <param name="valueCount">Liczba znaków w tablicy.</param>
        <summary>Dołącza tablicę znaków Unicode, zaczynając od określonego adresu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza `valueCount` znaki, zaczynając od adresu `value` do bieżącego wystąpienia.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" />jest mniejsza od zera.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" />jest wskaźnikiem o wartości null.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków.</param>
        <param name="startIndex">Pozycja początkowa w <paramref name="value" />.</param>
        <param name="charCount">Liczba znaków do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną podtablicę znaków Unicode do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza określony zakres znaków `value` do bieżącego wystąpienia. Jeśli `value` ma `null` wartość i`startIndex` i`count` jest równa zero, nie są wprowadzane żadne zmiany.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />is <see langword="null" />i i<paramref name="charCount" />nie są równe zero. <paramref name="startIndex" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" /> + <paramref name="charCount" />jest większa niż długość <paramref name="value" />.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg, który zawiera podciąg do dołączenia.</param>
        <param name="startIndex">Pozycja początkowa podciągu w elemencie <paramref name="value" />.</param>
        <param name="count">Liczba znaków w <paramref name="value" /> do dołączenia.</param>
        <summary>Dołącza kopię określonego podciągu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza określony zakres znaków `value` do bieżącego wystąpienia. Jeśli `value` ma `null` wartość i`startIndex` i`count` jest równa zero, nie są wprowadzane żadne zmiany.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowego wystąpienia klasy. W związku z tym można wywołać metodę lub właściwość w istniejącym odwołaniu i nie trzeba przypisywać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />is <see langword="null" />i i<paramref name="count" />nie są równe zero. <paramref name="startIndex" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />mniejsze od zera.  
  
—lub— 
 <paramref name="startIndex" />mniejsze od zera.  
  
—lub— 
 <paramref name="startIndex" /> + <paramref name="count" />jest większa niż długość <paramref name="value" />.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Konstruktor ciągów, który zawiera podciąg do dołączenia.</param>
        <param name="startIndex">Pozycja początkowa podciągu w elemencie <paramref name="value" />.</param>
        <param name="count">Liczba znaków w <paramref name="value" /> do dołączenia.</param>
        <summary>Dołącza kopię podciągu w określonym konstruktorze ciągów do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący odpowiedni argument obiektu.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący pojedynczy argument.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączonym. Każdy element formatu w <paramref name="format" /> programie jest zamieniany na ciąg <paramref name="arg0" />reprezentujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych o nazwie elementy formatu. Indeks elementów formatu musi mieć wartość 0, aby odpowiadać `arg0`, pojedynczemu obiektowi na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu na ciąg reprezentujący `arg0`.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`reprezentuje obiekt do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem `arg0`reprezentującym. Jeśli element formatu `formatString` zawiera i `arg0` <xref:System.IFormattable> implementujeinterfejs,definiujeformatowanie.`arg0.ToString(formatString, null)` W przeciwnym razie definiuje formatowanie. `arg0.ToString()`  
  
 Jeśli ciąg przypisany do `format` to "Dziękujemy za darowiznę {0: # # #} puszek żywności do naszej organizacji charytatywnej". i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za oddanie 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.AppendFormat%2A> metodę.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="args">Tablica obiektów do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący odpowiadający argument w tablicy parametrów.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączonym. Każdy element formatu w <paramref name="format" /> jest zamieniany na ciąg reprezentujący odpowiedni argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych o nazwie elementy formatu, które odpowiadają obiektom na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu na ciąg reprezentujący odpowiadający obiekt.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args`reprezentuje obiekty do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem reprezentującym odpowiedni obiekt w. `args` Jeśli element formatu `formatString` zawiera i odpowiadający obiekt w `args` `args[index].ToString(formatString, provider)` implementuje <xref:System.IFormattable> interfejs, definiuje formatowanie. W przeciwnym razie definiuje formatowanie. `args[index].ToString()`  
  
 Jeśli ciąg przypisany do `format` to "Dziękujemy za darowiznę {0: # # #} puszek żywności do naszej organizacji charytatywnej". i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za oddanie 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.AppendFormat%2A> metodę.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy długości <paramref name="args" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący pojedynczy argument przy użyciu określonego dostawcy formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania. Po operacji dołączania to wystąpienie zawiera wszystkie dane, które istniały przed operacją, poprzedzone przez kopię <paramref name="format" /> , w której każda specyfikacja formatu jest zamieniana na ciąg <paramref name="arg0" />reprezentujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) w .NET Framework, aby przekonwertować wartość `arg0` na jej reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych o nazwie elementy formatu. Indeks każdego elementu formatu musi mieć wartość zero (0), ponieważ ta metoda zawiera listę argumentów z pojedynczym argumentem. Proces formatowania zamienia każdy element formatu na ciąg reprezentujący `arg0`.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. W tym przypadku, ponieważ <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> Metoda ma jeden argument na liście argumentów, wartość *indeksu* musi być zawsze równa 0. Jeśli tak nie jest, <xref:System.FormatException> jest zgłaszany.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Parametr określa implementację, która może dostarczyć informacji o formatowaniu obiektów w `args`. `provider` <xref:System.IFormatProvider> `provider`może to być dowolny z następujących elementów:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla `arg0` kultury, jeśli jest wartością numeryczną. <xref:System.Globalization.NumberFormatInfo>  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla `arg0` kultury dla, jeśli jest to wartość daty i godziny. <xref:System.Globalization.DateTimeFormatInfo>  
  
-   Implementacja niestandardowa <xref:System.IFormatProvider> , która zawiera informacje `arg0`o formatowaniu dla programu. Zazwyczaj takie wdrożenie implementuje <xref:System.ICustomFormatter> także interfejs.  
  
 Jeśli parametr jest `null`, informacje o formatowaniu są uzyskiwane z bieżącej kultury. `provider`  
  
 `arg0`reprezentuje obiekt do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem `arg0`reprezentującym. Jeśli element formatu `formatString` zawiera i `arg0` <xref:System.IFormattable> implementujeinterfejs,definiujeformatowanie.`arg0.ToString(formatString, provider)` W przeciwnym razie definiuje formatowanie. `arg0.ToString()`  
  
   
  
## Examples  
 Poniżej znajdują się <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> dwa wywołania metody. Obie używają Konwencji formatowania kultury angielskiej — Wielka Brytania (en-GB). Najpierw wstawia ciąg reprezentujący <xref:System.Decimal> wartość waluty wartości w ciągu wynikowym. Druga wstawia <xref:System.DateTime> wartość w dwóch miejscach w ciągu wynikowym, a pierwszy zawiera tylko krótki ciąg daty i drugi ciąg godziny krótkiej.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy jeden (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Instrukcje: Definiowanie i używanie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="args">Tablica obiektów do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący odpowiadający argument w tablicy parametrów przy użyciu określonego dostawcy formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania. Po operacji dołączania to wystąpienie zawiera wszystkie dane, które istniały przed operacją, poprzedzone przez kopię <paramref name="format" /> , gdzie jakakolwiek specyfikacja formatu jest zastępowana przez ciąg reprezentujący odpowiadający mu argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych o nazwie elementy formatu, które odpowiadają obiektom na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu na ciąg reprezentujący odpowiadający obiekt.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Parametr określa implementację, która może dostarczyć informacji o formatowaniu obiektów w `args`. `provider` <xref:System.IFormatProvider> `provider`może to być dowolny z następujących elementów:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury dla wartości liczbowych w `args`. <xref:System.Globalization.NumberFormatInfo>  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury dla wartości daty i `args`godziny w. <xref:System.Globalization.DateTimeFormatInfo>  
  
-   Implementacja niestandardowa <xref:System.IFormatProvider> , która zapewnia informacje o formatowaniu dla co najmniej jednego `args`obiektu w. Zazwyczaj takie wdrożenie implementuje <xref:System.ICustomFormatter> także interfejs. Drugi przykład w następnej sekcji ilustruje <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> wywołanie metody z implementacją niestandardową. <xref:System.IFormatProvider>  
  
 Jeśli parametr ma `null`wartość, format informacji o dostawcy jest uzyskiwany z bieżącej kultury. `provider`  
  
 `args`reprezentuje obiekty do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem reprezentującym odpowiedni obiekt w. `args` Jeśli element formatu `formatString` zawiera i odpowiadający obiekt w `args` `args[index].ToString(formatString, provider)` implementuje <xref:System.IFormattable> interfejs, definiuje formatowanie. W przeciwnym razie definiuje formatowanie. `args[index].ToString()`  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.AppendFormat%2A> metodę.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 W poniższym przykładzie zdefiniowano implementację niestandardową <xref:System.IFormatProvider> o nazwie `CustomerFormatter` , która formatuje 10-cyfrowy numer klienta z łącznikami po czwartej i siódmej cyfr. Jest ona przenoszona do <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metody w celu utworzenia ciągu zawierającego sformatowany numer klienta i nazwę klienta.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy długości <paramref name="args" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Instrukcje: Definiowanie i używanie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący jeden z dwóch argumentów.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączonym. Każdy element formatu w <paramref name="format" /> jest zamieniany na ciąg reprezentujący odpowiedni argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych, nazywanych elementami `arg0` formatu `arg1`, które odpowiadają i, dwa obiekty na liście parametrów tej metody. `format` Proces formatowania zamienia każdy element formatu na ciąg reprezentujący odpowiadający obiekt.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`i `arg1` reprezentuje obiekty do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem reprezentującym jedną `arg0` lub `arg1`. `formatString` Jeśli element formatu zawiera i odpowiadający mu obiekt <xref:System.IFormattable> implementuje interfejs, wówczas `arg` *x* `.ToString(formatString, provider)` definiuje formatowanie, gdzie *x* jest indeksem argumentu. W przeciwnym razie *x* `.ToString()` definiuje formatowanie. `arg`  
  
 Jeśli ciąg przypisany do `format` to "Dziękujemy za darowiznę {0: # # #} puszek żywności do naszej organizacji charytatywnej". i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za oddanie 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.AppendFormat%2A> metodę.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący jeden z dwóch argumentów przy użyciu określonego dostawcy formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania. Po operacji dołączania to wystąpienie zawiera wszystkie dane, które istniały przed operacją, poprzedzone przez kopię <paramref name="format" /> , gdzie jakakolwiek specyfikacja formatu jest zastępowana przez ciąg reprezentujący odpowiadający mu argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych o nazwie elementy formatu, które odpowiadają obiektom na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu na ciąg reprezentujący odpowiadający obiekt.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Parametr określa implementację, która może dostarczyć informacji o formatowaniu `arg1`dla `arg0`i. `provider` <xref:System.IFormatProvider> `provider`może to być dowolny z następujących elementów:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla `arg0` kultury `arg1` dla lub, jeśli są wartościami liczbowymi. <xref:System.Globalization.NumberFormatInfo>  
  
-   Obiekt, który zawiera informacje o formatowaniu specyficzne dla `arg0` kultury `arg1` dla lub, jeśli są wartościami daty i godziny. <xref:System.Globalization.DateTimeFormatInfo>  
  
-   Implementacja niestandardowa <xref:System.IFormatProvider> , która udostępnia informacje o `arg1`formatowaniu dla `arg0` i. Zazwyczaj takie wdrożenie implementuje <xref:System.ICustomFormatter> także interfejs.  
  
 Jeśli parametr ma `null`wartość, format informacji o dostawcy jest uzyskiwany z bieżącej kultury. `provider`  
  
 `arg0`i `arg1` reprezentuje obiekty do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem reprezentującym obiekt, który ma odpowiadający indeks. Jeśli element formatu zawiera `formatString` i odpowiadający mu argument <xref:System.IFormattable> implementuje interfejs `ToString(formatString, provider)` , Metoda argumentu definiuje formatowanie. W przeciwnym razie `ToString()` Metoda argumentu definiuje formatowanie.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> metody do wyświetlania danych czasowych i temperatury przechowywanych w obiekcie ogólnym <xref:System.Collections.Generic.Dictionary%602> . Należy zauważyć, że ciąg formatu ma trzy elementy formatu, chociaż istnieją tylko obiekty do sformatowania. Wynika to z faktu, że pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy formatu: Pierwszy element formatu wyświetla godzinę, a druga wyświetla datę.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy 2 (dwa).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>Profilowanie .NET Core i w .NET Framework 4,0 i nowszych wersji, <see cref="T:System.Text.StringBuilder" /> podczas tworzenia wystąpienia obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, zarówno długość, <see cref="T:System.Text.StringBuilder" /> jak i pojemność <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wystąpienia mogą rosnąć poza wartością wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Instrukcje: Definiowanie i używanie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący jeden z trzech argumentów.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączonym. Każdy element formatu w <paramref name="format" /> jest zamieniany na ciąg reprezentujący odpowiedni argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerem lub więcej indeksowanych symboli zastępczych, nazywanych elementami formatu `arg0` , `arg2`które odpowiadają przez, obiekty na liście parametrów tej metody. `format` Proces formatowania zamienia każdy element formatu na ciąg reprezentujący odpowiadający obiekt.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1` i`arg2` reprezentuje obiekty do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem reprezentującym `arg1`jedną `arg0`lub, lub `arg2`, w zależności od indeksu elementu formatu. Jeśli element `formatString` formatu zawiera i odpowiadający obiekt w`.ToString(formatString, null)` <xref:System.IFormattable> `args` implementuje interfejs, wówczas `arg` *x* definiuje formatowanie, gdzie *x* jest indeksem argumentu. W przeciwnym razie *x* `.ToString()` definiuje formatowanie. `arg`  
  
 Jeśli ciąg przypisany do `format` to "Dziękujemy za darowiznę {0: # # #} puszek żywności do naszej organizacji charytatywnej". i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za oddanie 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.AppendFormat%2A> metodę.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciągu formatu złożonego, który zawiera zero lub więcej elementów formatu, do tego wystąpienia. Każdy element formatu jest zamieniany na ciąg reprezentujący jeden z trzech argumentów przy użyciu określonego dostawcy formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania. Po operacji dołączania to wystąpienie zawiera wszystkie dane, które istniały przed operacją, poprzedzone przez kopię <paramref name="format" /> , gdzie jakakolwiek specyfikacja formatu jest zastępowana przez ciąg reprezentujący odpowiadający mu argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcji formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) .NET Framework, aby przekonwertować wartość obiektu na jego reprezentację tekstową i osadzić tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiekcie.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszanych z zerami lub więcej indeksowanych symboli zastępczych o nazwie elementy formatu, które odpowiadają obiektom na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu na ciąg reprezentujący odpowiadający obiekt.  
  
 Składnia elementu format jest następująca:  
  
 {*index*[,*Length*] [:*FormatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Pozycja od zera na liście parametrów obiektu do sformatowania. Jeśli obiekt określony przez *indeks* to `null`, element formatu jest zastępowany przez <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli w położeniu *indeksu* nie ma parametru, <xref:System.FormatException> zostanie zgłoszony.|  
|,*Długość*|Minimalna liczba znaków w ciągu reprezentującym parametr. W przypadku wartości dodatnich parametr jest wyrównany do prawej; w przypadku wartości ujemnej jest wyrównany do lewej.|  
|:*FormatString*|Standardowy lub niestandardowy ciąg formatu obsługiwany przez parametr.|  
  
> [!NOTE]
>  W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami daty i godziny Zobacz ciągi [standardowego formatu daty i godziny](~/docs/standard/base-types/standard-date-and-time-format-strings.md) oraz [Niestandardowe ciągi formatujące datę i godzinę](~/docs/standard/base-types/custom-date-and-time-format-strings.md). W przypadku ciągów formatu standardowego i niestandardowego używanych z wartościami liczbowymi zobacz [Standardowe ciągi formatujące liczbowe](~/docs/standard/base-types/standard-numeric-format-strings.md) i [ciągi formatujące niestandardowe](~/docs/standard/base-types/custom-numeric-format-strings.md). W przypadku ciągów formatu standardowego używanych z wyliczeniami zobacz [ciągi formatujące Wyliczenie](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 Parametr określa implementację, która może dostarczyć informacji o formatowaniu `arg1`dla `arg0`i. `provider` <xref:System.IFormatProvider> `provider`może to być dowolny z następujących elementów:  
  
-   <xref:System.Globalization.CultureInfo> Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla `arg0` kultury `arg1` dla lub, jeśli są wartościami liczbowymi. <xref:System.Globalization.NumberFormatInfo>  
  
-   Obiekt, który dostarcza informacje o formatowaniu specyficzne dla `arg0`kultury `arg1`dla, `arg2` lub jeśli są wartościami daty i godziny. <xref:System.Globalization.DateTimeFormatInfo>  
  
-   Implementacja niestandardowa <xref:System.IFormatProvider> , która zapewnia informacje o formatowaniu `arg2`dla `arg0`, `arg1`i. Zazwyczaj takie wdrożenie implementuje <xref:System.ICustomFormatter> także interfejs.  
  
 Jeśli parametr ma `null`wartość, format informacji o dostawcy jest uzyskiwany z bieżącej kultury. `provider`  
  
 `arg0`, `arg1` i`arg2` reprezentuje obiekty do sformatowania. Każdy element formatu w `format` programie jest zastępowany ciągiem reprezentującym obiekt, który ma odpowiadający indeks. Jeśli element formatu zawiera `formatString` i odpowiadający mu argument <xref:System.IFormattable> implementuje interfejs `ToString(formatString, provider)` , Metoda argumentu definiuje formatowanie. W przeciwnym razie `ToString()` Metoda argumentu definiuje formatowanie.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodę, aby zilustrować wynik operacji logicznej `And` z wartościami całkowitymi. Należy zauważyć, że ciąg formatu zawiera sześć elementów formatu, ale metoda ma tylko trzy elementy na liście argumentów, ponieważ każdy element jest sformatowany na dwa różne sposoby.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" />jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejszy niż 0 (zero) lub większy lub równy 3 (trzy).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekroczono <see cref="P:System.Text.StringBuilder.MaxCapacity" />długość rozwiniętego ciągu.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatowanie typów w programie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Instrukcje: Definiowanie i używanie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza domyślny terminator wiersza lub kopię określonego ciągu oraz terminatora wiersza domyślnego na końcu tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza domyślny terminator wiersza do końca bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny terminator wiersza jest bieżącą wartością <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.AppendLine%2A> metodę.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dołączenia.</param>
        <summary>Dołącza kopię określonego ciągu, a następnie domyślny terminator linii do końca bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny terminator wiersza jest bieżącą wartością <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <see cref="T:System.Text.StringBuilder" /> gdy tworzysz wystąpienie obiektu przez <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> wywołanie konstruktora, długość <see cref="T:System.Text.StringBuilder" /> i pojemność wystąpienia może wzrosnąć poza wartość jej <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartość. Może się to zdarzyć w szczególności w <see cref="M:System.Text.StringBuilder.Append(System.String)" /> przypadku wywołania metod i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> dołączenia małych ciągów.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę znaków, które mogą być zawarte w pamięci przydzielonej przez bieżące wystąpienie.</summary>
        <value>Maksymalna liczba znaków, które mogą być zawarte w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość może nawiązać <see cref="P:System.Text.StringBuilder.Length" /> się <see cref="P:System.Text.StringBuilder.MaxCapacity" />z zakresu od do.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A>nie ma wpływu na wartość ciągu bieżącego wystąpienia. <xref:System.Text.StringBuilder.Capacity%2A>można zmniejszyć, o ile nie jest mniejszy niż <xref:System.Text.StringBuilder.Length%2A>.  
  
 Dynamicznie <xref:System.Text.StringBuilder> przydziela więcej miejsca w razie potrzeby i odpowiednio rośnie <xref:System.Text.StringBuilder.Capacity%2A> . Ze względu na wydajność <xref:System.Text.StringBuilder> może przydzielić więcej pamięci niż jest to konieczne. Przydzieloną ilość pamięci jest specyficzna dla implementacji.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Capacity%2A> właściwość.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż bieżąca długość tego wystąpienia.  
  
 —lub—  
  
 Wartość określona dla operacji zestawu jest większa niż maksymalna pojemność.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja znaku.</param>
        <summary>Pobiera lub ustawia znak w podanej pozycji znaku w tym wystąpieniu.</summary>
        <value>Znak Unicode na pozycji <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr jest pozycją znaku <xref:System.Text.StringBuilder>w elemencie. `index` Pierwszy znak w ciągu jest indeksem 0. Długość ciągu jest liczbą znaków, które zawiera. Ostatni dostępny znak <xref:System.Text.StringBuilder> wystąpienia ma wartość index <xref:System.Text.StringBuilder.Length%2A> -1.  
  
 <xref:System.Text.StringBuilder.Chars%2A>jest domyślną właściwością <xref:System.Text.StringBuilder> klasy. W C#programie jest to indeksator. Oznacza to, że poszczególne znaki mogą być pobierane z <xref:System.Text.StringBuilder.Chars%2A> właściwości, jak pokazano w poniższym przykładzie, która zlicza liczbę znaków alfabetycznych, białych i interpunkcyjnych w ciągu.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Indeksowanie na podstawie wydajności i znaków

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza granicami tego wystąpienia podczas ustawiania znaku.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" />znajduje się poza granicami tego wystąpienia podczas pobierania znaku.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie znaki z bieżącego <see cref="T:System.Text.StringBuilder" /> wystąpienia.</summary>
        <returns>Obiekt, którego <see cref="P:System.Text.StringBuilder.Length" /> wartość to 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A>jest wygodną metodą, która jest równoważna ustawieniu <xref:System.Text.StringBuilder.Length%2A> właściwości bieżącego wystąpienia na 0 (zero).  
  
## Examples

Poniższy przykład tworzy wystąpienie <xref:System.Text.StringBuilder> obiektu za pomocą ciągu, <xref:System.Text.StringBuilder.Clear%2A> wywołuje metodę, a następnie dołącza nowy ciąg.  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Pozycja początkowa w tym wystąpieniu, z której zostaną skopiowane znaki. Jest to indeks zaczynający się od zera.</param>
        <param name="destination">Tablica, w której zostaną skopiowane znaki.</param>
        <param name="destinationIndex">Pozycja początkowa w miejscu <paramref name="destination" /> , w którym zostaną skopiowane znaki. Jest to indeks zaczynający się od zera.</param>
        <param name="count">Liczba znaków, które mają zostać skopiowane.</param>
        <summary>Kopiuje znaki z określonego segmentu tego wystąpienia do określonego segmentu tablicy docelowej <see cref="T:System.Char" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest przeznaczona do użycia w rzadkich sytuacjach, gdy trzeba efektywnie skopiować kolejne sekcje <xref:System.Text.StringBuilder> obiektu do tablicy. <xref:System.Text.StringBuilder.CopyTo%2A> Tablica powinna być ustalonym rozmiarem, wstępnie przydzielonym, do ponownego użycia i prawdopodobnie dostępnym globalnie.  
  
 Na przykład aplikacja może wypełnić <xref:System.Text.StringBuilder> obiekt o dużej liczbie znaków, a następnie <xref:System.Text.StringBuilder.CopyTo%2A> użyć metody do kopiowania małych, <xref:System.Text.StringBuilder> kolejnych fragmentów obiektu do tablicy, w której są przetwarzane elementy. Gdy wszystkie dane w <xref:System.Text.StringBuilder> obiekcie są przetwarzane, rozmiar <xref:System.Text.StringBuilder> obiektu jest ustawiany na zero, a cykl jest powtarzany.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.CopyTo%2A> metodę.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" />, jest mniejsza od zera.  
  
—lub— 
 <paramref name="sourceIndex" />jest większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" />jest większa niż długość tego wystąpienia.  
  
—lub— 
 <paramref name="destinationIndex" /> + <paramref name="count" />jest większa niż długość <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Minimalna pojemność do zapewnienia.</param>
        <summary>Zapewnia, że pojemność tego wystąpienia <see cref="T:System.Text.StringBuilder" /> jest równa co najmniej określonej wartości.</summary>
        <returns>Nowa pojemność tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pojemność jest mniejsza niż wartość `capacity` parametru, pamięć dla tego wystąpienia zostanie ponownie przyalokowana, aby pomieścić co najmniej `capacity` liczbę znaków; w przeciwnym razie żadna pamięć nie zostanie zmieniona.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.EnsureCapacity%2A> metodę.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza od zera.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="span">Zakres znaków do porównania z bieżącym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy znaki w tym wystąpieniu są równe znakom w określonym zakresie znaków tylko do odczytu.</summary>
        <returns><see langword="true" />Jeśli znaki w tym wystąpieniu i <paramref name="span" /> są takie same; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Metoda wykonuje porównanie porządkowe, aby określić, czy znaki w bieżącym wystąpieniu i `span` są równe. `Equals`

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Obiekt, <see langword="null" />który ma zostać porównany z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns><see langword="true" />Jeśli to wystąpienie i <paramref name="sb" /> ma taki sam ciąg <see cref="P:System.Text.StringBuilder.Capacity" />, i <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartości; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET Framework i .NET Core 2,2 i poprzednie wersje:** Bieżące wystąpienie i `sb` są równe, jeśli mają równe ciągi, <xref:System.Text.StringBuilder.Capacity>i <xref:System.Text.StringBuilder.MaxCapacity> wartości. `Equals` Metoda używa porównania porządkowego, aby określić, czy ciągi są równe.

**.NET Core 3,0 i nowsze wersje:** Bieżące wystąpienie i `sb` jest równe, jeśli ciągi przypisane do obu <xref:System.Text.StringBuilder> obiektów są takie same.  Aby określić równość, `Equals` Metoda używa porównania porządkowego. Wartości właściwości <xref:System.Text.StringBuilder.MaxCapacity> i nie są używane w porównaniu. <xref:System.Text.StringBuilder.Capacity>

## Examples  
 Poniższy kod używa metody, <xref:System.Text.StringBuilder.Equals%2A> aby sprawdzić, czy dwa <xref:System.Text.StringBuilder> obiekty są równe. Metoda jest wywoływana wielokrotnie po wprowadzeniu niewielkich zmian do każdego obiektu, a wyniki są wyświetlane w konsoli programu.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, który może służyć do iteracji przez fragmenty znaków reprezentowane w <see langword="ReadOnlyMemory&lt;Char&gt;" /> utworzonym z tego <see cref="T:System.Text.StringBuilder" /> wystąpienia.</summary>
        <returns>Moduł wyliczający dla fragmentów w <see langword="ReadOnlyMemory&lt;Char&gt;" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Fragmenty można powtórzyć w zakresie pamięci, korzystając z kodu, takiego jak: 

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```
            
Celem tej metody jest wydajne wyodrębnienie danych *stałej* <xref:System.Text.StringBuilder>. <xref:System.Text.StringBuilder> Jeśli zostanie zmodyfikowany, gdy Wyliczenie fragmentów jest niekompletne, wynik jest niezdefiniowany. <xref:System.Text.StringBuilder>nie jest również bezpieczne wątkowo, dlatego działające na nim współbieżne wątki jest niedozwolone.

Zwracane fragmenty nie są gwarantowane, aby pozostały bez zmian, <xref:System.Text.StringBuilder> jeśli są modyfikowane, więc nie Buforuj ich do późniejszego użycia. <xref:System.ReadOnlyMemory%601>
             
Tworzenie na <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType> podstawie (jak metoda w poprzednim przykładzie jest kosztowne, dlatego należy utworzyć zmienną lokalną dla zakresu, jeśli trzeba jej używać w instrukcji zagnieżdżonej `for`. <xref:System.ReadOnlyMemory%601> Na przykład: 

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    { 
        /* operations on span[i] */ 
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia ciąg reprezentujący określony obiekt w tym wystąpieniu w określonej pozycji znaku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący wartość logiczną do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określoną 8-bitową liczbę całkowitą bez znaku w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określony znak Unicode do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Tablica znaków do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określoną tablicę znaków Unicode w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 Jeśli `value` ma `null`wartość ,<xref:System.Text.StringBuilder> nie jest zmieniana.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący liczbę dziesiętną do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący liczbę zmiennoprzecinkową o podwójnej precyzji w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określoną 16-bitową liczbę całkowitą ze znakiem w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określony 32-bitową liczbę całkowitą ze znakiem w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący 64-bitową liczbę całkowitą ze znakiem w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Obiekt do wstawienia lub <see langword="null" />.</param>
        <summary>Wstawia ciąg reprezentujący obiekt w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 Jeśli `value` jest`null`, wartość tego wystąpienia jest niezmieniona.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określoną 8-bitową liczbę całkowitą ze znakiem w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący liczbę zmiennoprzecinkową o pojedynczej precyzji do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <summary>Wstawia ciąg do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność jest dostosowywana odpowiednio do wymagań.  
  
 To wystąpienie <xref:System.Text.StringBuilder> nie jest zmieniane, `value` Jeśli `null`jest lub `value` nie `null` jest, ale jego długość wynosi zero.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż bieżąca długość tego wystąpienia.  
  
—lub— 
Bieżąca długość tego <see cref="T:System.Text.StringBuilder" /> obiektu oraz <paramref name="value" /> długość przekraczania <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący 16-bitową liczbę całkowitą bez znaku w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący 32-bitową liczbę całkowitą bez znaku w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący 64-bitową liczbę całkowitą bez znaku w tym wystąpieniu w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType>służy do pobierania ciągu znaków `value`. Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W programie <see cref="T:System.ArgumentOutOfRangeException" /> <paramref name="value" /> <see cref="P:System.Text.StringBuilder.MaxCapacity" />i starszych wersjach wywołania tej metody zgłosiły, że Wstawianie spowodowałoby przekroczenie całkowitej długości obiektu. [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] Począwszy od <see cref="T:System.OutOfMemoryException" />, Metoda generuje. [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <param name="count">Liczba godzin do wstawienia <paramref name="value" />.</param>
        <summary>Wstawia co najmniej jedną kopię określonego ciągu do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
 Ten <xref:System.Text.StringBuilder> obiekt nie jest zmieniany `value` , `null`Jeśli `value` ma wartość `null` , nie jest, ale jego długość `count` wynosi zero lub jest równa zero.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż bieżąca długość tego wystąpienia.  
  
—lub— 
 <paramref name="count" />jest mniejsza od zera.</exception>
        <exception cref="T:System.OutOfMemoryException">Bieżąca długość tego <see cref="T:System.Text.StringBuilder" /> obiektu oraz <paramref name="value" /> długość <paramref name="count" /> przekroczeń <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, gdzie rozpoczyna się Wstawianie.</param>
        <param name="value">Tablica znaków.</param>
        <param name="startIndex">Początkowy indeks w <paramref name="value" />.</param>
        <param name="charCount">Liczba znaków do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący określoną podtablicę znaków Unicode do tego wystąpienia w podanej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane w celu zapewnienia pokoju dla nowego tekstu. Pojemność tego wystąpienia jest dostosowywana odpowiednio do wymagań.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Insert%2A> metodę.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" />is <see langword="null" />i i<paramref name="charCount" />nie są równe zero. <paramref name="startIndex" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" />, lub <paramref name="charCount" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />jest większa niż długość tego wystąpienia.  
  
—lub— 
 <paramref name="startIndex" />znak <paramref name="charCount" /> Plus nie jest pozycją <paramref name="value" />w obrębie elementu.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia długość bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <value>Długość tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość <xref:System.Text.StringBuilder> obiektu jest definiowana przez <xref:System.Char> liczbę obiektów.  
  
 Podobnie jak <xref:System.Text.StringBuilder.Length%2A> właściwość, właściwość wskazuje długość bieżącego obiektu ciągu. <xref:System.String.Length%2A?displayProperty=nameWithType> W <xref:System.String.Length%2A?displayProperty=nameWithType> <xref:System.Text.StringBuilder> przeciwieństwie do właściwości, która jest tylko do odczytu, Właściwość pozwala na modyfikowanie długości ciągu przechowywanego w obiekcie. <xref:System.Text.StringBuilder.Length%2A>  
  
 Jeśli określona długość jest mniejsza niż bieżąca długość, bieżący <xref:System.Text.StringBuilder> obiekt zostanie obcięty do określonej długości. Jeśli określona długość jest większa niż bieżąca długość, końcowa wartość ciągu bieżącego <xref:System.Text.StringBuilder> obiektu jest uzupełniona znakiem Unicode o wartości null (U + 0000).  
  
 Jeśli określona długość jest większa niż bieżąca pojemność, <xref:System.Text.StringBuilder.Capacity%2A> zwiększa się tak, aby była większa lub równa określonej długości.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Length%2A> właściwość.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza od zera lub większa niż <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną pojemność tego wystąpienia.</summary>
        <value>Maksymalna liczba znaków, jaką może zawierać to wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna pojemność tej implementacji to <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Jednakże ta wartość jest specyficzna dla implementacji i może być różna w innych lub nowszych implementacjach. Można jawnie ustawić maksymalną pojemność <xref:System.Text.StringBuilder> obiektu przez <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> wywołanie konstruktora.  
  
W programie .NET Core i w .NET Framework 4,0 i nowszych wersjach, <xref:System.Text.StringBuilder> gdy tworzysz wystąpienie obiektu przez <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> wywołanie konstruktora, długość <xref:System.Text.StringBuilder> i pojemność wystąpienia może wzrosnąć poza wartość jej <xref:System.Text.StringBuilder.MaxCapacity> wartość. Może się to zdarzyć w szczególności w <xref:System.Text.StringBuilder.Append(System.String)> przypadku wywołania metod i <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> dołączenia małych ciągów.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja od zera w tym wystąpieniu, w której rozpoczyna się usuwanie.</param>
        <param name="length">Liczba znaków do usunięcia.</param>
        <summary>Usuwa określony zakres znaków z tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po zakończeniu operacji akcyzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca metoda usuwa określony zakres znaków z bieżącego wystąpienia. Znaki`startIndex`w (`length` `length`) są przenoszone do `startIndex`i wartość ciągu bieżącego wystąpienia jest + skracana przez. Nie ma to żadnego oddziaływania na pojemność bieżącego wystąpienia.  
  
> [!NOTE]
>  Metoda modyfikuje wartość bieżącego <xref:System.Text.StringBuilder> wystąpienia i zwraca to wystąpienie. <xref:System.Text.StringBuilder.Remove%2A> Nie tworzy i nie zwraca nowego <xref:System.Text.StringBuilder> obiektu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Remove%2A> metodę.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeśli <paramref name="startIndex" /> <paramref name="startIndex" />  +  lub <paramref name="length" /> jest mniejsza od zera lub<paramref name="length" /> jest większa niż długość tego wystąpienia.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje wszystkie wystąpienia określonego znaku lub ciągu w tym wystąpieniu innym określonym znakiem lub ciągiem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak, który ma zostać zamieniony.</param>
        <param name="newChar">Znak, który zastępuje <paramref name="oldChar" />.</param>
        <summary>Zastępuje wszystkie wystąpienia określonego znaku w tym wystąpieniu innym określonym znakiem.</summary>
        <returns>Odwołanie do tego wystąpienia <paramref name="oldChar" /> zastąpione przez. <paramref name="newChar" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter, aby identyfikować wystąpienia `oldChar` w bieżącym wystąpieniu. Rozmiar bieżącego <xref:System.Text.StringBuilder> wystąpienia jest niezmieniony po zastąpieniu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Replace%2A> metodę.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg, który ma zostać zamieniony.</param>
        <param name="newValue">Ciąg, który zastępuje <paramref name="oldValue" />lub. <see langword="null" /></param>
        <summary>Zastępuje wszystkie wystąpienia określonego ciągu w tym wystąpieniu innym określonym ciągiem.</summary>
        <returns>Odwołanie do tego wystąpienia ze wszystkimi wystąpieniami <paramref name="oldValue" /> zastąpionymi przez. <paramref name="newValue" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter, aby identyfikować wystąpienia `oldValue` w bieżącym wystąpieniu. Jeśli `newValue` jest `null` lub ,<xref:System.String.Empty?displayProperty=nameWithType>wszystkie wystąpienia `oldValue` są usuwane.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Replace%2A> metodę.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="oldValue" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak, który ma zostać zamieniony.</param>
        <param name="newChar">Znak, który zastępuje <paramref name="oldChar" />.</param>
        <param name="startIndex">Pozycja w tym wystąpieniu, w której rozpoczyna się podciąg.</param>
        <param name="count">Długość podciągu.</param>
        <summary>Zastępuje, w ramach podciągu tego wystąpienia, wszystkie wystąpienia określonego znaku z innym określonym znakiem.</summary>
        <returns><paramref name="oldChar" /> Odwołanie do tego wystąpienia zastąpione przez <paramref name="newChar" /> zakres od <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter, aby identyfikować wystąpienia `oldChar` w bieżącym wystąpieniu. Rozmiar bieżącego <xref:System.Text.StringBuilder> obiektu jest niezmieniony po zastąpieniu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Replace%2A> metodę.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" />jest większa niż długość wartości tego wystąpienia.  
  
—lub— 
 <paramref name="startIndex" />lub <paramref name="count" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg, który ma zostać zamieniony.</param>
        <param name="newValue">Ciąg, który zastępuje <paramref name="oldValue" />lub. <see langword="null" /></param>
        <param name="startIndex">Pozycja w tym wystąpieniu, w której rozpoczyna się podciąg.</param>
        <param name="count">Długość podciągu.</param>
        <summary>Zastępuje, w ramach podciągu tego wystąpienia, wszystkie wystąpienia określonego ciągu z innym określonym ciągiem.</summary>
        <returns>Odwołanie do tego wystąpienia ze <paramref name="oldValue" /> wszystkimi wystąpieniami zastąpionymi przez <paramref name="newValue" /> zakres od <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie z rozróżnianiem wielkości liter, aby identyfikować wystąpienia `oldValue` w określonym podciągu. Jeśli `newValue` jest `null` lub ,<xref:System.String.Empty?displayProperty=nameWithType>wszystkie wystąpienia `oldValue` są usuwane.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Text.StringBuilder.Replace%2A> metodę.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="oldValue" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="startIndex" />znak <paramref name="count" /> Plus wskazuje pozycję znaku, która nie znajduje się w tym wystąpieniu.  
  
—lub— 
Powiększenie wartości tego wystąpienia spowodowałoby przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt do wypełnienia informacjami o serializacji.</param>
        <param name="context">Miejsce, w którym mają być przechowywane i pobierane dane serializowane. Zarezerwowane do użytku w przyszłości.</param>
        <summary>Wypełnia obiekt danymi niezbędnymi do deserializacji bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` Parametr jest zarezerwowany do użytku w przyszłości i nie uczestniczy w tej operacji.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość a <see cref="T:System.Text.StringBuilder" /> <see cref="T:System.String" />na.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia na <see cref="T:System.String" />.</summary>
        <returns>Ciąg, którego wartość jest taka sama jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy <xref:System.Text.StringBuilder.ToString%2A> wywołać metodę, aby <xref:System.String> <xref:System.Text.StringBuilder> przekonwertować obiekt na obiekt przed przekazaniem ciągu reprezentowanego przez <xref:System.Text.StringBuilder> obiekt do metody, która ma <xref:System.String> parametr lub wyświetlić ją w interfejsie użytkownika.  
  
   
  
## Examples  
 Poniższy przykład demonstruje wywołanie <xref:System.Text.StringBuilder.ToString%2A> metody. Ten przykład jest częścią większego przykładu dostarczonego dla <xref:System.Text.StringBuilder> klasy.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja początkowa podciągu w tym wystąpieniu.</param>
        <param name="length">Długość podciągu.</param>
        <summary>Konwertuje wartość podciągu tego wystąpienia na <see cref="T:System.String" />.</summary>
        <returns>Ciąg, którego wartość jest taka sama jak określona podciąg tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy <xref:System.Text.StringBuilder.ToString%2A> wywołać metodę, aby <xref:System.String> <xref:System.Text.StringBuilder> przekonwertować obiekt na obiekt przed przekazaniem ciągu reprezentowanego przez <xref:System.Text.StringBuilder> obiekt do metody, która ma <xref:System.String> parametr lub wyświetlić ją w interfejsie użytkownika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />lub <paramref name="length" /> jest mniejsza od zera.  
  
—lub— 
Suma <paramref name="startIndex" /> i<paramref name="length" /> jest większa niż długość bieżącego wystąpienia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

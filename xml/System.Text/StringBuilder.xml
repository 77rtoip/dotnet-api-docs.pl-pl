<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e3c91724ff6dad5916829d444df2a9e5fff19850" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36409202" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje modyfikowalną ciąg znaków. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa reprezentuje obiekt typu ciąg, którego wartość jest modyfikowalna sekwencji znaków.  
  
 W tej sekcji:  
  
-   [Typy String i StringBuilder](#StringAndSB)  
  
-   [Jak działa StringBuilder](#HowWorks)  
  
-   [Alokacja pamięci](#Memory)  
  
-   [Utworzenie wystąpienia obiektu klasy StringBuilder](#Instantiating)  
  
-   [Wywołanie metod klasy StringBuilder](#Calling)  
  
-   [Wykonywanie operacji StringBuilder](#Operations)  
  
    -   [Iteracja StringBuilder znaków](#Iterating)  
  
    -   [Dodawanie tekstu do obiektu StringBuilder](#Adding)  
  
    -   [Usuwanie tekstu z obiektu klasy StringBuilder](#Deleting)  
  
    -   [Modyfikowanie tekstu w obiekcie StringBuilder](#Modifying)  
  
-   [Wyszukiwanie tekstu w obiekcie StringBuilder](#Searching)  
  
-   [Konwertowanie obiektów StringBuilder do ciągu](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Typy ciągów i typy StringBuilder  
 Mimo że <xref:System.Text.StringBuilder> i <xref:System.String> zarówno reprezentowania sekwencji znaków, są one wykonywane inaczej. <xref:System.String> jest niezmiennego typu. Oznacza to, że każdej operacji, który wygląda jak modyfikować <xref:System.String> obiektu faktycznie tworzy nowy ciąg.  
  
 Na przykład wywołanie <xref:System.String.Concat%2A?displayProperty=nameWithType> metoda w poniższym przykładzie C# wydaje się zmienić wartość zmiennej ciągu o nazwie `value`. W rzeczywistości <xref:System.String.Concat%2A> metoda zwraca `value` obiektu, który ma inną wartość i adres z `value` obiektu, który został przekazany do metody. Należy pamiętać, że przykładzie musi być kompilowana przy użyciu `/unsafe` — opcja kompilatora.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Dla procedury, które wykonują manipulowanie ciągami szeroką gamę (takich jak aplikacje, które modyfikują ciąg wiele razy w pętli) wielokrotnie modyfikowanie ciąg można dokładnie zmniejszenie wydajności znaczące. Alternatywą jest użycie <xref:System.Text.StringBuilder>, które jest klasą modyfikowalną ciągu. Zmienność oznacza, że po utworzeniu wystąpienia klasy, możesz to modyfikować, dołączanie, usuwanie, zastępowanie lub wstawianie znaków. A <xref:System.Text.StringBuilder> obiekt zachowuje buforu, aby uwzględnić rozszerzenia do ciągu. Nowe dane jest dołączany do buforu, jeśli jest on dostępny; w przeciwnym razie nowy, większy bufor jest przydzielony, dane z oryginalnej buforu zostaną skopiowane do nowego buforu i nowe dane, następnie jest dołączany do bufor nowego.  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Text.StringBuilder> klasy zwykle zapewnia większą wydajność niż <xref:System.String> klasy, możesz nie powinny automatycznie zastępować <xref:System.String> z <xref:System.Text.StringBuilder> zawsze, gdy chcesz manipulowania ciągami. Wydajność zależy od rozmiaru ciągu ilość pamięci do przydzielenia nowego ciągu, system, na którym jest wykonywany aplikację i typ operacji. Należy przygotować się, aby przetestować aplikację, aby określić, czy <xref:System.Text.StringBuilder> faktycznie zapewnia poprawy wydajności znaczące.  
  
 Należy rozważyć użycie <xref:System.String> klasy w tych warunkach:  
  
-   Podczas zmiany powodujące aplikacji w ciągu jest mała. W takich przypadkach <xref:System.Text.StringBuilder> może być niewielka oferty lub braku poprawy wydajności za pośrednictwem <xref:System.String>.  
  
-   Jeśli wykonywana stałej liczby operacji łączenia, zwłaszcza w przypadku literałów ciągów. W takim przypadku kompilator może łączyć operacje łączenia w ramach jednej operacji.  
  
-   Jeśli użytkownik ma wykonywać operacje zaawansowane wyszukiwanie, podczas tworzenia ciągu. <xref:System.Text.StringBuilder> Klasa nie ma wyszukiwania metod, takich jak `IndexOf` lub `StartsWith`. Należy przekonwertować <xref:System.Text.StringBuilder> do obiektu <xref:System.String> dla tych operacji, a to można odwrócić wydajności korzyści z używania <xref:System.Text.StringBuilder>. Aby uzyskać więcej informacji, zobacz [wyszukiwanie tekstu w obiekcie StringBuilder](#Searching) sekcji.  
  
 Należy rozważyć użycie <xref:System.Text.StringBuilder> klasy w tych warunkach:  
  
-   Jeśli oczekujesz aplikację, aby wprowadzić nieznany liczba zmian w ciągu w czasie projektowania (na przykład w przypadku korzystania z pętli do łączenia liczbę losową ciągów, które zawierają dane wejściowe użytkownika).  
  
-   Jeśli oczekujesz aplikację, aby wprowadzić znaczących zmian w ciągu.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Jak działa StringBuilder  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Właściwość wskazuje liczbę znaków <xref:System.Text.StringBuilder> zawiera już obiekt. Jeśli dodasz znaków <xref:System.Text.StringBuilder> obiekt, jego długość zwiększa, dopóki nie równa się rozmiar <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> właściwość, która definiuje liczbę znaków, które mogą zawierać obiekt. Jeśli liczba dodanych znaków powoduje, że długość <xref:System.Text.StringBuilder> przydzielone obiektu przekroczenie jego obecna pojemność, nowej pamięci, wartość <xref:System.Text.StringBuilder.Capacity%2A> jest podwójny właściwość, nowe znaki zostaną dodane do <xref:System.Text.StringBuilder> obiekt i jego <xref:System.Text.StringBuilder.Length%2A>właściwości zostanie zmieniona. Dodatkową pamięć dla <xref:System.Text.StringBuilder> obiektu jest przydzielany dynamicznie, dopóki nie osiągnie wartość zdefiniowana przez <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> właściwości. Po osiągnięciu maksymalnej pojemności można przydzielić pamięć dalsze <xref:System.Text.StringBuilder> obiektu, a próby dodania znaków lub zajęło ponad jego pojemność maksymalną zgłasza wyjątek, albo <xref:System.ArgumentOutOfRangeException> lub <xref:System.OutOfMemoryException> wyjątku.  
  
 Poniższy przykład przedstawia sposób <xref:System.Text.StringBuilder> obiektu przydziela nowej pamięci i dynamicznie zwiększa możliwości rozszerza ciąg przypisanych do obiektu. Kod tworzy <xref:System.Text.StringBuilder> obiektu przez wywołanie jego domyślnego (bezparametrowego) konstruktora. Wydajność domyślna tego obiektu jest 16 znaków, a maksymalną pojemność jest więcej niż 2 miliardów znaków. Dołączanie ciąg "Jest zdania". wynikiem nowej alokacji pamięci, ponieważ długość ciągu (znaki 19) jest większa niż wydajność domyślna <xref:System.Text.StringBuilder> obiektu. Pojemność obiektu podwaja do 32 znaków, jest dodawany nowy ciąg i długości obiektu jest teraz równe 19 znaków. Kod następnie dołącza ciąg "Jest to dodatkowe zdania". wartość <xref:System.Text.StringBuilder> obiektu 11 razy. Zawsze, gdy operacja dołączania powoduje, że długość <xref:System.Text.StringBuilder> obiektu przekroczenie jego pojemność, jego pojemność istniejących jest podwójny i <xref:System.Text.StringBuilder.Append%2A> operacja zakończy się powodzeniem.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Alokacja pamięci  
 Wydajność domyślna <xref:System.Text.StringBuilder> obiektu ma 16 znaków, a maksymalną pojemność domyślne <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Te wartości domyślne są używane, jeśli wywołujesz <xref:System.Text.StringBuilder.%23ctor> i <xref:System.Text.StringBuilder.%23ctor%28System.String%29> konstruktorów.  
  
 Początkowa pojemność można oznaczyć <xref:System.Text.StringBuilder> obiektu w następujący sposób:  
  
-   Wywołując jedną z <xref:System.Text.StringBuilder> konstruktorów, które obejmuje `capacity` parametru podczas tworzenia obiektu.  
  
-   Przypisując jawnie nową wartość do <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> właściwości, aby rozszerzyć istniejącą <xref:System.Text.StringBuilder> obiektu. Należy pamiętać, że właściwość zgłasza wyjątek, jeśli nowy pojemność jest mniejsza niż istniejące lub większy niż <xref:System.Text.StringBuilder> obiektu maksymalnej pojemności.  
  
-   Wywołując <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> metody za pomocą nowego miejsca. Nowe pojemność nie może być większa niż <xref:System.Text.StringBuilder> obiektu maksymalnej pojemności. Jednak w przeciwieństwie do przypisania do <xref:System.Text.StringBuilder.Capacity%2A> właściwość <xref:System.Text.StringBuilder.EnsureCapacity%2A> nie zgłasza wyjątek, jeśli żądany nowy pojemność jest mniejsza niż pojemność istniejących; w takim przypadku wywołania metody, które nie ma wpływu.  
  
 Jeśli długość ciągu jest przypisany do <xref:System.Text.StringBuilder> obiektu w wywołaniu konstruktora przekracza pojemność domyślnej lub określonej pojemności, <xref:System.Text.StringBuilder.Capacity%2A> wartość właściwości jest równa długości ciągu określony za pomocą `value` parametru.  
  
 Można jawnie określić maksymalną pojemność <xref:System.Text.StringBuilder> obiektu przez wywołanie metody <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora. Nie można zmienić maksymalną pojemność, przypisując nową wartość do <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości, ponieważ jest on tylko do odczytu.  
  
 Jak w poprzedniej sekcji pokazano, w każdym przypadku, gdy istniejące jest nieodpowiednie, dodatkowe pamięci jest przydzielany i pojemności <xref:System.Text.StringBuilder> symulacyjnych do wartości zdefiniowane przez obiekt <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości.  
  
 Ogólnie rzecz biorąc pojemności domyślnej i maksymalną pojemność są odpowiednie dla większości aplikacji. Można rozważyć ustawienie tych wartości w następujących warunkach:  
  
-   Jeśli rozmiar <xref:System.Text.StringBuilder> obiekt jest prawdopodobnie będzie bardziej nadmiernie duży, zwykle poza kilka megabajtów. W takim przypadku mogą być niektóre korzyści wydajności z ustawienia wstępnego <xref:System.Text.StringBuilder.Capacity%2A> właściwości znacznie wysoką wartość, aby wyeliminować potrzebę zbyt wiele przeniesień pamięci.  
  
-   Jeśli aplikacja działa w systemie z ograniczoną pamięcią. W takim przypadku warto rozważyć ustawienie <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości mniej niż <xref:System.Int32.MaxValue?displayProperty=nameWithType> Jeśli aplikacja obsługuje dużych ciągów, które mogą spowodować, że plik do wykonania w środowisku ograniczonej pamięci.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Utworzenie wystąpienia obiektu StringBuilder  
 Można utworzyć wystąpienia <xref:System.Text.StringBuilder> obiektu przez wywoływanie jednej z jego sześciu konstruktorów przeciążonej klasy, które są wymienione w poniższej tabeli. Trzy z konstruktorów wystąpienia <xref:System.Text.StringBuilder> obiektu, którego wartość jest pustym ciągiem, ale są ustawione jego <xref:System.Text.StringBuilder.Capacity%2A> i <xref:System.Text.StringBuilder.MaxCapacity%2A> wartości inaczej. Zdefiniuj pozostałe trzy konstruktorów <xref:System.Text.StringBuilder> obiektu, który ma określony ciąg wartości i pojemność. Dwie z trzech konstruktorów Użyj domyślnej maksymalną pojemność <xref:System.Int32.MaxValue?displayProperty=nameWithType>, natomiast trzeci umożliwia określenie maksymalnej pojemności.  
  
|Konstruktor|Wartość ciągu|Pojemność|Maksymalna pojemność|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Zdefiniowane przez `capacity` parametru|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Zdefiniowane przez `capacity` parametru|Zdefiniowane przez `maxCapacity` parametru|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Zdefiniowane przez `value` parametru|16 lub `value`. <xref:System.String.Length%2A>, w zależności od jest większa|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Zdefiniowane przez `value` parametru|Zdefiniowane przez `capacity` parametru lub `value`. <xref:System.String.Length%2A>, w zależności od jest większa.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Zdefiniowane przez `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Zdefiniowane przez `capacity` parametru lub `value`. <xref:System.String.Length%2A>, w zależności od jest większa.|Zdefiniowane przez `maxCapacity` parametru|  
  
 W poniższym przykładzie użyto trzech przeciążeń konstruktora, te można utworzyć wystąpienia <xref:System.Text.StringBuilder> obiektów.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Wywołanie metod StringBuilder  
 Większość metod, które modyfikują ciąg w <xref:System.Text.StringBuilder> wystąpienia zwraca odwołanie do tego samego wystąpienia. Dzięki temu można wywołać <xref:System.Text.StringBuilder> metod na dwa sposoby:  
  
-   Można wykonywać wywołania metody indywidualnej i Ignoruj wartość zwracaną, tak jak w poniższym przykładzie.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Możesz wprowadzić szereg wywołania metody w jednej instrukcji. Może to być wygodne, jeśli chcesz zapisać jednej instrukcji, którym jest powiązany kolejnych czynności. Poniższy przykład powoduje konsolidowanie trzy wywołania metody z poprzedniego przykładu do pojedynczy wiersz kodu.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Przeprowadzanie operacji StringBuilder  
 Można użyć metody <xref:System.Text.StringBuilder> klasy do iteracji, dodać, usunąć lub zmienić znaków <xref:System.Text.StringBuilder> obiektu.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Iterowanie znaków StringBuilder  
 Można uzyskać dostępu do znaków w <xref:System.Text.StringBuilder> obiektu przy użyciu <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwości. W języku C# <xref:System.Text.StringBuilder.Chars%2A> jest indeksatora; w języku Visual Basic, jest domyślną właściwość <xref:System.Text.StringBuilder> klasy. Dzięki temu można ustawić lub pobrać znaki przy użyciu jej indeksu, bez jawnego odwołania do <xref:System.Text.StringBuilder.Chars%2A> właściwości. Znaki w <xref:System.Text.StringBuilder> obiektu rozpocząć pod indeksem 0 (zero) i przejdź do indeksu <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 Poniższy przykład przedstawia <xref:System.Text.StringBuilder.Chars%2A> właściwości. Dołącza dziesięć liczb losowych do <xref:System.Text.StringBuilder> obiekt, a następnie iteruje po każdym znaku. Jeśli jest znak Unicode kategorii <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, zmniejsza liczbę 1 (lub zmienia numer 9, jeśli jego wartość wynosi 0). Przykład wyświetla zawartość <xref:System.Text.StringBuilder> obiekt zarówno przed i po wartości znaki zostały zmienione.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Dodawanie tekstu do obiektu StringBuilder  
 <xref:System.Text.StringBuilder> Klasa zawiera następujące metody rozszerzania zawartość <xref:System.Text.StringBuilder> obiektu:  
  
-   <xref:System.Text.StringBuilder.Append%2A> Metoda dołącza ciąg, podciąg, tablicy znaków, część tablicy znaków, pojedynczy znak powtarza się wielokrotnie, lub wpisz reprezentację danych pierwotnych do <xref:System.Text.StringBuilder> obiektu.  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> Metody dołącza terminator wiersza lub ciągu wraz z terminator wiersza do <xref:System.Text.StringBuilder> obiektu.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> Metody dołącza do <xref:System.Text.StringBuilder> obiektu. Ciąg reprezentacje obiektów uwzględnionych w ciągu wynik można odzwierciedlać Konwencji formatowania bieżącego ustawienia kulturowego systemu lub określonej kultury.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> Metody wstawia ciąg, podciąg, wiele powtórzeń ciągu tablicy znaków, część tablicy znaków lub reprezentację danych pierwotnych, wpisz w określonej pozycji w <xref:System.Text.StringBuilder> obiektu. Pozycja jest zdefiniowana przez liczony od zera indeks.  
  
 W poniższym przykładzie użyto <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, i <xref:System.Text.StringBuilder.Insert%2A> metod, aby rozwinąć tekst <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Usuwanie tekstu z obiektu StringBuilder  
 <xref:System.Text.StringBuilder> Klasa zawiera metody, które można zmniejszyć rozmiar bieżącego <xref:System.Text.StringBuilder> wystąpienia. <xref:System.Text.StringBuilder.Clear%2A> Metoda usuwa wszystkie znaki i ustawia <xref:System.Text.StringBuilder.Length%2A> właściwości wartość zero. <xref:System.Text.StringBuilder.Remove%2A> Metoda usuwa określoną liczbę znaków, zaczynając od pozycji określonego indeksu. Ponadto możesz usunąć znaków od końca <xref:System.Text.StringBuilder> obiektu przez ustawienie jej <xref:System.Text.StringBuilder.Length%2A> właściwości na wartość, która jest mniejsza niż długość bieżącego wystąpienia.  
  
 Poniższy przykład umożliwia usunięcie części tekstu z <xref:System.Text.StringBuilder> obiektów, wyświetla jego wynikowy pojemności maksymalnej pojemności i długość wartości właściwości, a następnie wywołuje <xref:System.Text.StringBuilder.Clear%2A> metodę, aby usunąć wszystkie znaki od <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Modyfikowanie tekstu w obiekcie StringBuilder  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Metoda zastępuje wszystkie wystąpienia znak lub ciąg w całej <xref:System.Text.StringBuilder> obiektu lub w zakresie określonego znaku. W poniższym przykładzie użyto <xref:System.Text.StringBuilder.Replace%2A> metodę, aby zamienić wszystkie punkty wykrzyknika (!) w znaki zapytania (?) <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Wyszukiwanie tekstu w obiekcie StringBuilder  
 <xref:System.Text.StringBuilder> Klasa nie ma metody podobny do <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, i <xref:System.String.StartsWith%2A?displayProperty=nameWithType> metody udostępniane przez <xref:System.String> klasy, która pozwala na wyszukiwanie obiektu dla określonego znaku lub podciąg. Określanie obecności lub rozpoczęciem znaku na pozycji podciągu wymaga można przeszukać <xref:System.String> wartość przy użyciu metody search ciąg lub metoda wyrażenia regularnego. Istnieją cztery metody implementacji przeszukania takie, jak to pokazano w poniższej tabeli.  
  
|Metoda|Specjaliści|Cons|  
|---------------|----------|----------|  
|Wyszukaj ciąg wartości przed dodaniem ich do <xref:System.Text.StringBuilder> obiektu.|Służy do określania, czy istnieje podciąg.|Nie można użyć, gdy indeks podciągu jest istotna.|  
|Wywołanie <xref:System.Text.StringBuilder.ToString%2A> i wyszukiwania zwróconego <xref:System.String> obiektu.|Łatwy w użyciu przypisania tekst, który <xref:System.Text.StringBuilder> obiekt, a następnie zaczyna do jej modyfikowania.|Trudne wielokrotnie wywoływać <xref:System.Text.StringBuilder.ToString%2A> należy dokonać zmiany przed dodaniem cały tekst do <xref:System.Text.StringBuilder> obiektu.<br /><br /> Należy pamiętać pracować w końcu <xref:System.Text.StringBuilder> tekstu obiektu podczas wprowadzania zmian.|  
|Użyj <xref:System.Text.StringBuilder.Chars%2A> właściwości sekwencyjnie wyszukiwania zakres znaków.|Przydatne w przypadku obaw znaki lub małe podciąg.|Skomplikowane, jeśli jest duża liczba znaków do wyszukiwania lub jest złożona logika wyszukiwania.<br /><br />Wyniki w bardzo niskiej wydajności dla obiektów, które przekroczył bardzo dużych za pośrednictwem wywołania metody powtórzony.  |  
|Konwertuj <xref:System.Text.StringBuilder> do obiektu <xref:System.String> obiektu i wykonywania modyfikacji na <xref:System.String> obiektu.|Przydatne, jeśli liczba zmian jest mała.|Negacja wydajności zaletą <xref:System.Text.StringBuilder> klasy, jeśli liczba zmian jest duży.|  
  
 Przeanalizujmy te techniki większej liczby szczegółów.  
  
-   Jeśli celem wyszukiwania ma na celu określenie, czy danego podciągu istnieje (Jeśli nie chcesz pozycji podciągu), umożliwia wyszukiwanie ciągów przed przekazaniem ich w <xref:System.Text.StringBuilder> obiektu. W poniższym przykładzie przedstawiono jeden wdrażanych. Definiuje `StringBuilderFinder` którego konstruktor jest przekazywany odwołanie do klasy <xref:System.Text.StringBuilder> obiektu i substring można znaleźć w ciągu. W takim przypadku przykładzie próbuje określić, czy temperatury zarejestrowane w f lub c i dodaje odpowiedni tekst wprowadzający do początku <xref:System.Text.StringBuilder> obiektu. Generator liczb losowych służy do wybierania tablicę, która zawiera dane w stopniach c lub f stopni.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Wywołanie <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować <xref:System.Text.StringBuilder> do obiektu <xref:System.String> obiektu. Ciąg można wyszukiwać za pomocą metod, takich jak <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> lub <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, lub za pomocą wyrażeń regularnych i <xref:System.Text.RegularExpressions.Regex> klasy do wyszukania wzorce. Ponieważ oba <xref:System.Text.StringBuilder> i <xref:System.String> obiektów przy użyciu kodowania do przechowywania znaków, pozycji indeksu znaków, podciągów, UTF-16, a zgodny z wyrażeniem regularnym są takie same, w obu obiektów. Dzięki temu można używać <xref:System.Text.StringBuilder> metody, aby wprowadzić zmiany w tym samym miejscu odnaleziono tekst w <xref:System.String> obiektu.  
  
    > [!NOTE]
    >  Jeśli przyjmuje takie podejście, powinny działać na końcu <xref:System.Text.StringBuilder> obiekt na początek, dzięki czemu nie trzeba przekonwertować wielokrotnie <xref:System.Text.StringBuilder> obiektu na ciąg.  
  
     To podejście pokazano w poniższym przykładzie. Przechowuje czterech wystąpień każdej litery alfabetu angielskiego w <xref:System.Text.StringBuilder> obiektu. Następnie konwertuje tekst, który <xref:System.String> obiektu i używa wyrażenia regularnego do identyfikowania pozycji początkowej każdej sekwencji czterech znaków. Na koniec on dodaje podkreślenia przed każdej sekwencji czterech znaków, z wyjątkiem pierwszej sekwencji i konwertuje pierwszy znak sekwencji na wielkie litery.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Użyj <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwości sekwencyjnie wyszukiwania zakres znaków w <xref:System.Text.StringBuilder> obiektu. Tej metody nie może być przydatna, jeśli jest duża liczba znaków, które mają być wyszukiwane lub logika wyszukiwania jest szczególnie złożone. Dla jego wpływu na wydajność dostępu opartego na indeksie znak po znaku dla bardzo dużych, podzielony <xref:System.Text.StringBuilder> obiektów, zobacz dokumentację <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwości. 
  
     W poniższym przykładzie jest identyczne w funkcji z poprzednim przykładzie, ale różni się w implementacji. Używa <xref:System.Text.StringBuilder.Chars%2A> właściwości do wykrycia, gdy zmieniono wartość znaku, wstawia na tej pozycji znaku podkreślenia i konwertuje pierwszy znak w nowej sekwencji na wielkie litery.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Przechowywanie wszystkich bez modyfikacji tekstu w <xref:System.Text.StringBuilder> obiekt, należy wywołać <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować <xref:System.Text.StringBuilder> do obiektu <xref:System.String> obiektu i wykonać wszelkie zmiany na <xref:System.String> obiektu. Można użyć tej metody, jeśli masz tylko kilka zmian; w przeciwnym razie kosztów pracy z ciągami niezmienne może odwrócić wydajności korzyści wynikające ze stosowania <xref:System.Text.StringBuilder> obiektu.  
  
     W poniższym przykładzie jest identyczna w działaniu dwóch poprzednich przykładach, ale różni się w implementacji. Tworzy <xref:System.Text.StringBuilder> obiektów, konwertuje go do <xref:System.String> obiekt, a następnie używa wyrażenia regularnego do wykonywania wszystkich pozostałych modyfikacji na ciąg. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> — Metoda korzysta z wyrażenia lambda do przeprowadzenia zastępowania na każdym dopasowaniu.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Konwersja obiektu StringBuilder na ciąg  
 Przekonwertuj <xref:System.Text.StringBuilder> do obiektu <xref:System.String> obiekt przed można przekazać reprezentowany przez ciąg <xref:System.Text.StringBuilder> obiektu do metody, która ma <xref:System.String> parametru lub wyświetlać go w interfejsie użytkownika. Wykonaj tę konwersję przez wywołanie metody <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metody. Ilustracja, znajduje się w poprzednim przykładzie, który wywołuje <xref:System.Text.StringBuilder.ToString%2A> metodę, aby przekonwertować <xref:System.Text.StringBuilder> obiekt na ciąg, dzięki czemu mogą zostać przekazane do metody wyrażenia regularnego.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania wiele metod zdefiniowane przez <xref:System.Text.StringBuilder> klasy.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
    </block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawiono wartość ciągu tego wystąpienia <xref:System.String.Empty?displayProperty=nameWithType>, i pojemność jest równa pojemności domyślnej implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora bez parametrów.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerowany rozmiar początkowy tego wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> przy użyciu określonej pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiektu przydziela więcej pamięci, aby zapisać je.  
  
 Ustawiono wartość ciągu tego wystąpienia <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli `capacity` wynosi zero, pojemności konkretnej implementacji domyślnej jest używana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora o określonej pojemności.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg używany do inicjowania wartość wystąpienia. Jeśli <c>wartość</c> jest <see langword="null" />, nowe <see cref="T:System.Text.StringBuilder" /> będzie zawierać pustego ciągu (to znaczy zawiera <see cref="F:System.String.Empty" />).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> przy użyciu określonego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest `null`, nowe <xref:System.Text.StringBuilder> będzie zawierać pustego ciągu (to znaczy zawiera <xref:System.String.Empty>).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określonego ciągu.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerowany rozmiar początkowy <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Maksymalna liczba znaków, które mogą zawierać ciąg bieżącego.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> rozpoczynają się od określonej pojemności i mogą rosnąć maksymalnie do określonej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiektu przydziela więcej pamięci, aby zapisać je.  
  
 Jeśli `capacity` wynosi zero, pojemności konkretnej implementacji domyślnej jest używana.  
  
 `maxCapacity` Właściwość określa maksymalną liczbę znaków, które mogą zawierać bieżącego wystąpienia. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `maxCapacity` wartość <xref:System.Text.StringBuilder> obiektu nie przydzielić więcej pamięci, ale zamiast tego zgłasza wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora o określonej pojemności i maksymalnej pojemności.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> jest mniejsza niż jedna <paramref name="capacity" /> jest mniejszy od zera, lub <paramref name="capacity" /> jest większa niż <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg używany do inicjowania wartość wystąpienia. Jeśli <c>wartość</c> jest <see langword="null" />, nowe <see cref="T:System.Text.StringBuilder" /> będzie zawierać pustego ciągu (to znaczy zawiera <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Sugerowany rozmiar początkowy <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> przy użyciu określonego ciągu i pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiektu przydziela więcej pamięci, aby zapisać je.  
  
 Jeśli `capacity` wynosi zero, pojemności konkretnej implementacji domyślnej jest używana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z ciągu początkowej i określonej pojemności.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający podciąg, używaną do inicjalizacji wartość tego wystąpienia. Jeśli <c>wartość</c> jest <see langword="null" />, nowe <see cref="T:System.Text.StringBuilder" /> będzie zawierać pustego ciągu (to znaczy zawiera <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Pozycja w <c>wartość</c> którym rozpoczyna się podciąg.</param>
        <param name="length">Liczba znaków w podciąg.</param>
        <param name="capacity">Sugerowany rozmiar początkowy <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy z wskazany podciąg i pojemność.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiektu przydziela więcej pamięci, aby zapisać je.  
  
 Jeśli `capacity` wynosi zero, pojemności konkretnej implementacji domyślnej jest używana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określonego ciągu.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> plus <paramref name="length" /> nie jest w stanie <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza reprezentację ciągu określonego obiektu do tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość logiczna ma zostać dołączony.</param>
        <summary>Dołącza określony wartość logiczną reprezentację ciągu tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Wywołania metody <xref:System.Boolean.ToString?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value`. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 8-bitową liczbę całkowitą bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Wywołania metody <xref:System.Byte.ToString%28System.IFormatProvider%29> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Jednostka algorytmem UTF-16 kodu, który ma zostać dołączony.</param>
        <summary>Dołącza reprezentację określonej <see cref="T:System.Char" /> obiektu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków do dołączenia.</param>
        <summary>Dołącza znaki Unicode w określonej tablicy reprezentację ciągu tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza wszystkie znaki w określonej tablicy do bieżącego wystąpienia w tej samej kolejności, znajdujące się w `value`. Jeśli `value` jest `null`, są wprowadzane żadne zmiany.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonej liczby dziesiętnej do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Wywołania metody <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza podanej liczbie zmiennoprzecinkowej podwójnej precyzji reprezentację ciągu tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Wywołania metody <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 16-bitową liczbę całkowitą ze znakiem do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Wywołania metody <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego całkowita 32-bitowej do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Wywołania metody <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego całkowita 64-bitowej do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Wywołania metody <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt, który ma zostać dołączony.</param>
        <summary>Dołącza reprezentację ciągu określonego obiektu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie. Definiuje `Dog` klasy, tworzy `Dog` obiekt i sprawia, że trzy wywołania <xref:System.Text.StringBuilder.Append%2A> metodę, aby utworzyć ciąg znaków zawierający nazwę i rasy dog.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Wywołania metody <xref:System.Object.ToString%2A?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value`. Jeśli `value` jest `null`, zostały wprowadzone żadne zmiany <xref:System.Text.StringBuilder> obiektu.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 8-bitową liczbę całkowitą ze znakiem do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Wywołania metody <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza podanej liczbie zmiennoprzecinkowej pojedynczej precyzji reprezentację ciągu tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Wywołania metody <xref:System.Single.ToString%2A?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dołączenia.</param>
        <summary>Dołącza kopię podanego ciągu tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Jeśli `value` jest `null`, są wprowadzane żadne zmiany.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 16-bitową liczbę całkowitą bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Wywołania metody <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value`. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 32-bitowa liczba całkowita bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Wywołania <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 64-bitowa liczba całkowita bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Wywołania metody <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metody, aby uzyskać reprezentację ciągu `value` dla bieżącej kultury. Aby kontrolować formatowanie `value`, wywołania <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak, który ma zostać dołączony.</param>
        <param name="repeatCount">Ile razy można dołączyć <c>wartość</c>.</param>
        <summary>Dołącza określonej liczby kopii reprezentację ciągu znaków Unicode do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> jest mniejsza od zera.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków.</param>
        <param name="valueCount">Liczba znaków w tablicy.</param>
        <summary>Dołącza tablicy znaków Unicode, zaczynając od określonego adresu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza `valueCount` znaków, zaczynając od adresu `value` do bieżącego wystąpienia.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektu.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> jest mniejsza od zera.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> jest wskaźnika o wartości null.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków.</param>
        <param name="startIndex">Położenie początkowe w <c>wartość</c>.</param>
        <param name="charCount">Liczba znaków do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego subarray znaków Unicode do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza określony zakres znaków `value` do bieżącego wystąpienia. Jeśli `value` jest `null` i `startIndex` i `count` są zera, zmiany zostały wprowadzone.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />, i <paramref name="startIndex" /> i <paramref name="charCount" /> nie są zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" />  +  <paramref name="charCount" /> jest większa niż długość <paramref name="value" />.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający podciąg, który ma zostać dołączony.</param>
        <param name="startIndex">Pozycja początkowa podciągu w <c>wartość</c>.</param>
        <param name="count">Liczba znaków w <c>wartość</c> do dołączenia.</param>
        <summary>Dołącza kopię wskazany podciąg do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza określony zakres znaków `value` do bieżącego wystąpienia. Jeśli `value` jest `null` i `startIndex` i `count` są zera, zmiany zostały wprowadzone.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda modyfikuje istniejącego wystąpienia tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejące odwołanie i nie trzeba przypisać wartości zwracanej do <xref:System.Text.StringBuilder> obiektów, jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />, i <paramref name="startIndex" /> i <paramref name="count" /> nie są zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> mniejsze niż zero.  - lub - <paramref name="startIndex" /> mniejsza od zera.  - lub - <paramref name="startIndex" />  +  <paramref name="count" /> jest większa niż długość <paramref name="value" />.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje reprezentację ciągu odpowiedni argument obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do formatu.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje reprezentację ciągu jeden argument.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączane. Każdy element format <paramref name="format" /> zastępuje reprezentację ciągu <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów. Indeksu elementów format musi być równa 0, aby odpowiadały temu `arg0`, pojedynczego obiektu z listy wartości parametru tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu `arg0`.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` reprezentuje obiekt zostanie sformatowany. Każdy element format `format` jest zastępowany reprezentację ciągu `arg0`. Jeśli element formatu zawiera `formatString` i `arg0` implementuje <xref:System.IFormattable> interfejsu, następnie `arg0.ToString(formatString, null)` definiuje formatowania. W przeciwnym razie `arg0.ToString()` definiuje formatowania.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje pobrania elementu {0: ###} puszek żywności do naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za Twoje pobrania 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="args">Tablica obiektów do sformatowania.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje reprezentację ciągu odpowiadającego mu argumentu w tablicy parametrów.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączane. Każdy element format <paramref name="format" /> zastępuje reprezentację ciągu obiektu odpowiadającego mu argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu odpowiedni obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` reprezentuje obiekt zostanie sformatowany. Każdy element format `format` jest zastępowany reprezentację ciągu odpowiedni obiekt w `args`. Jeśli element formatu zawiera `formatString` i odpowiedni obiekt w `args` implementuje <xref:System.IFormattable> interfejsu, następnie `args[index].ToString(formatString, provider)` definiuje formatowania. W przeciwnym razie `args[index].ToString()` definiuje formatowania.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje pobrania elementu {0: ###} puszek żywności do naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za Twoje pobrania 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa długości <paramref name="args" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do formatu.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje reprezentację ciągu pojedynczy argument przy użyciu dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania. Po wykonaniu operacji dołączania tego wystąpienia zawiera wszystkie dane, które istniały przed operacją sufiks przez kopię <paramref name="format" /> zastępuje wszelkie format reprezentację ciągu specyfikacji <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework do konwertowania wartości `arg0` na jej reprezentację tekstową i osadzone reprezentacja tego w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów. Indeks każdego elementu format musi być zero (0), ponieważ ta metoda obejmuje listy argumentów z pojedynczym argumentem. Proces formatowania zamienia każdy element formatu reprezentację ciągu `arg0`.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. W takim przypadku od <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> metoda ma jeden argument w liście argumentów wartość *indeksu* zawsze musi być równa 0. Jeśli nie, <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Określa parametr <xref:System.IFormatProvider> implementację, która może zapewnić informacje dotyczące formatowania dla obiektów w `args`. `provider` może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury dla `arg0` Jeśli jest wartość liczbowa.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury dla `arg0` Jeśli jest to wartość daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje o formatowaniu `arg0`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu.  
  
 Jeśli `provider` parametr jest `null`, formatowania informacje są uzyskiwane z bieżącej kultury.  
  
 `arg0` reprezentuje obiekt zostanie sformatowany. Każdy element format `format` jest zastępowany reprezentację ciągu `arg0`. Jeśli element formatu zawiera `formatString` i `arg0` implementuje <xref:System.IFormattable> interfejsu, następnie `arg0.ToString(formatString, provider)` definiuje formatowania. W przeciwnym razie `arg0.ToString()` definiuje formatowania.  
  
   
  
## Examples  
 Następujące obejmuje dwa wywołań <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> metody. Oba rozwiązania używają Konwencji formatowania kultury angielski — Polska (en-GB). Pierwszy wstawia reprezentację ciągu <xref:System.Decimal> wartości waluty w ciągu wynik. Wstawia drugi <xref:System.DateTime> ciąg znaków wartości w dwóch miejscach w wyniku, pierwszy tym tylko krótkiej daty ciągu, a drugi ciąg krótki czas.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa jeden (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="args">Tablica obiektów do sformatowania.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje reprezentację ciągu odpowiadającego mu argumentu w tablicy parametrów przy użyciu dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania. Po wykonaniu operacji dołączania tego wystąpienia zawiera wszystkie dane, które istniały przed operacją sufiks przez kopię <paramref name="format" /> gdzie żadnych specyfikacji formatu zastępuje reprezentację ciągu obiektu odpowiadającego mu argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu odpowiedni obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Określa parametr <xref:System.IFormatProvider> implementację, która może zapewnić informacje dotyczące formatowania dla obiektów w `args`. `provider` może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o wartości liczbowe w formatowaniu specyficzne dla kultury `args`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje o wartości daty i godziny w formatowaniu specyficzne dla kultury `args`.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje dotyczące formatowania dla jednego lub więcej obiektów w `args`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu. Drugi przykład w następnej sekcji przedstawiono <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> wywołanie metody z niestandardowego <xref:System.IFormatProvider> implementacji.  
  
 Jeśli `provider` parametr jest `null`, format informacji o dostawcy są uzyskiwane z bieżącej kultury.  
  
 `args` reprezentuje obiekt zostanie sformatowany. Każdy element format `format` jest zastępowany reprezentację ciągu odpowiedni obiekt w `args`. Jeśli element formatu zawiera `formatString` i odpowiedni obiekt w `args` implementuje <xref:System.IFormattable> interfejsu, następnie `args[index].ToString(formatString, provider)` definiuje formatowania. W przeciwnym razie `args[index].ToString()` definiuje formatowania.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 W poniższym przykładzie zdefiniowano niestandardowego <xref:System.IFormatProvider> wdrożenia o nazwie `CustomerFormatter` które formatuje klienta 10-cyfrowy numer łączniki po czwartym i siódmego cyfr. Jest przekazywana do <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metodę w celu utworzenia ciąg, który zawiera sformatowany odbiorcy oraz nazwę odbiorcy.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa długości <paramref name="args" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje ciągu reprezentującego jedną z dwóch argumentów.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączane. Każdy element format <paramref name="format" /> zastępuje reprezentację ciągu obiektu odpowiadającego mu argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametru składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odpowiadają `arg0` i `arg1`, dwa obiekty na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu odpowiedni obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` i `arg1` reprezentowała obiekty do sformatowania. Każdy element format `format` jest zastępowany reprezentację ciągu, albo `arg0` lub `arg1`. Jeśli element formatu zawiera `formatString` i implementuje odpowiedni obiekt <xref:System.IFormattable> interfejsu, następnie `arg` *x* `.ToString(formatString, provider)` definiuje formatowania, gdzie *x* jest indeksem argumentu. W przeciwnym razie `arg` *x* `.ToString()` definiuje formatowania.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje pobrania elementu {0: ###} puszek żywności do naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za Twoje pobrania 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje ciągu reprezentującego jedną z dwóch argumentów, za pomocą dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania. Po wykonaniu operacji dołączania tego wystąpienia zawiera wszystkie dane, które istniały przed operacją sufiks przez kopię <paramref name="format" /> gdzie żadnych specyfikacji formatu zastępuje reprezentację ciągu obiektu odpowiadającego mu argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu odpowiedni obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Określa parametr <xref:System.IFormatProvider> implementację, która zapewnia informacje o formatowaniu `arg0` i `arg1`. `provider` może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury dla `arg0` lub `arg1` jeśli są one wartości liczbowych.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury dla `arg0` lub `arg1` przypadku wartości daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje o formatowaniu `arg0` i `arg1`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu.  
  
 Jeśli `provider` parametr jest `null`, format informacji o dostawcy są uzyskiwane z bieżącej kultury.  
  
 `arg0` i `arg1` reprezentowała obiekty do sformatowania. Każdy element format `format` jest zastępowany reprezentację ciągu obiektu, który ma odpowiedni indeks. Jeśli element formatu zawiera `formatString` i implementuje odpowiadającego mu argumentu <xref:System.IFormattable> interfejs, a następnie argumentu `ToString(formatString, provider)` definiuje metodę formatowania. W przeciwnym razie wartość argumentu `ToString()` definiuje metodę formatowania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> metodę w celu wyświetlenia czasu i temperatury danych przechowywanych w ogólnej metodzie <xref:System.Collections.Generic.Dictionary%602> obiektu. Pamiętaj, że ciąg formatu, który ma trzy elementy formatu, chociaż występują tylko do obiektów do formatowania. Wynika to z faktu pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy w formacie: pierwszy wyświetla elementu format czasu, a druga Wyświetla datę.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równe 2 ().</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje ciągu reprezentującego jedną z trzech argumentów.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="format" /> dołączane. Każdy element format <paramref name="format" /> zastępuje reprezentację ciągu obiektu odpowiadającego mu argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametru składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odpowiadają `arg0` za pośrednictwem `arg2`, obiekty na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu odpowiedni obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, i `arg2` reprezentowała obiekty do sformatowania. Każdy element format `format` jest zastępowany reprezentację ciągu, albo `arg0`, `arg1`, lub `arg2`, w zależności od indeks elementu formatu. Jeśli element formatu zawiera `formatString` i odpowiedni obiekt w `args` implementuje <xref:System.IFormattable> interfejsu, następnie `arg` *x* `.ToString(formatString, null)` definiuje formatowania, gdzie * x* jest indeks argumentu. W przeciwnym razie `arg` *x* `.ToString()` definiuje formatowania.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje pobrania elementu {0: ###} puszek żywności do naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10, wartość zwracana będzie "Dziękujemy za Twoje pobrania 10 puszek żywności do naszej organizacji charytatywnej".  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większą lub równą 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwrócony przez przetwarzanie ciąg formatu złożonego, zawierający zero lub więcej elementów format, w tym wystąpieniu. Każdy element formatu zastępuje ciągu reprezentującego jedną z trzech argumentów, za pomocą dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania. Po wykonaniu operacji dołączania tego wystąpienia zawiera wszystkie dane, które istniały przed operacją sufiks przez kopię <paramref name="format" /> gdzie żadnych specyfikacji formatu zastępuje reprezentację ciągu obiektu odpowiadającego mu argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [złożonych funkcji formatowania](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby przekonwertować wartość obiektu do jego reprezentacja tekstowa i osadzanie tego reprezentacja w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się zero lub więcej serii tekstu zmieszać z zero lub więcej symboli zastępczych indeksowanego zwanych formatu elementów, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zamienia każdy element formatu reprezentację ciągu odpowiedni obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt zostanie sformatowany. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli brak parametru w *indeksu* pozycji <xref:System.FormatException> jest generowany.|  
|,*długość*|Minimalna liczba znaków w parametrze reprezentację ciągu. Jeśli jest dodatnia, parametr jest wyrównany do prawej; Jeśli ujemną, jest wyrównany.|  
|:*formatString*|Ciąg formatu standardowych lub niestandardowych, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowych i niestandardowych używane z wartości daty i godziny, zobacz [standardowe ciągi daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowe ciągi daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowych i niestandardowych używane wartości liczbowe, zobacz [standardowe ciągi formatu liczbowego](~/docs/standard/base-types/standard-numeric-format-strings.md) i [niestandardowych ciągów formatu liczbowego](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi standardowy format używany z wyliczenia, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Określa parametr <xref:System.IFormatProvider> implementację, która zapewnia informacje o formatowaniu `arg0` i `arg1`. `provider` może być jedną z następujących czynności:  
  
-   A <xref:System.Globalization.CultureInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury dla `arg0` lub `arg1` jeśli są one wartości liczbowych.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje dotyczące formatowania specyficzne dla kultury dla `arg0`, `arg1`, lub `arg2` przypadku wartości daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje o formatowaniu `arg0`, `arg1`, i `arg2`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu.  
  
 Jeśli `provider` parametr jest `null`, format informacji o dostawcy są uzyskiwane z bieżącej kultury.  
  
 `arg0`, `arg1`, i `arg2` reprezentowała obiekty do sformatowania. Każdy element format `format` jest zastępowany reprezentację ciągu obiektu, który ma odpowiedni indeks. Jeśli element formatu zawiera `formatString` i implementuje odpowiadającego mu argumentu <xref:System.IFormattable> interfejs, a następnie argumentu `ToString(formatString, provider)` definiuje metodę formatowania. W przeciwnym razie wartość argumentu `ToString()` definiuje metodę formatowania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metody w celu zilustrowania wynik wartość logiczną `And` operację, podając wartości będące liczbami całkowitymi. Należy pamiętać, ciąg formatu, który obejmuje sześć elementów format, że metoda ma tylko trzy elementy na liście argumentu, ponieważ każdy element jest sformatowany na dwa różne sposoby.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> jest nieprawidłowy.  - lub - indeks elementu formatu jest mniejsza od 0 (zero), lub większą lub równą 3 (3).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwinięte przekroczyłby <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza terminator wiersza domyślne lub kopię określonego ciągu i terminator wiersza domyślnej na końcu tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza domyślne terminator wiersza na koniec bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślny jest bieżąca wartość <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendLine%2A> metody.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dołączenia.</param>
        <summary>Dołącza kopię podanego ciągu następuje domyślne terminator wiersza na koniec bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślny jest bieżąca wartość <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v40_short](~/includes/NET-V40-Short-MD.MD)] i [! INCLUDE[net_v45](~/includes/NET-V45-MD.MD)], gdy można utworzyć wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, zarówno długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może zwiększyć się poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> właściwości . Taka sytuacja może wystąpić szczególnie podczas wywoływania <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody do dołączenia małych ciągów.</para>
        </block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę znaków, które mogą być zawarte w pamięci przydzielonej przez bieżące wystąpienie.</summary>
        <value>Maksymalna liczba znaków, które mogą być zawarte w pamięci przydzielonej przez bieżące wystąpienie. Wartość może należeć do zakresu od <see cref="P:System.Text.StringBuilder.Length" /> do <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> nie wpływa na wartość ciągu bieżącego wystąpienia. <xref:System.Text.StringBuilder.Capacity%2A> można zmniejszyć, dopóki nie jest mniejsza niż <xref:System.Text.StringBuilder.Length%2A>.  
  
 <xref:System.Text.StringBuilder> Dynamicznie przydziela więcej miejsca na żądanie i zwiększa <xref:System.Text.StringBuilder.Capacity%2A> odpowiednio. Ze względu na wydajność <xref:System.Text.StringBuilder> może przydzielić więcej pamięci niż jest to potrzebne. Ilość pamięci przydzielonej jest konkretnej implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Capacity%2A> właściwości.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji ustawienia jest mniejsza niż bieżąca długość tego wystąpienia.  - lub - jest większa niż wydajność Maksymalna wartość określona dla operacji set.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja znaku.</param>
        <summary>Pobiera lub ustawia znak na pozycji znaku określonego w tym wystąpieniu.</summary>
        <value>Znak Unicode w pozycji <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr to pozycja znaku w <xref:System.Text.StringBuilder>. Pierwszy znak w ciągu znajduje się pod indeksem 0. Długość ciągu jest liczba znaków, które zawiera. Ostatni znak dostępny <xref:System.Text.StringBuilder> wystąpienie znajduje się pod indeksem <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> jest domyślną właściwość <xref:System.Text.StringBuilder> klasy. W języku C# jest indeksatora. Oznacza to, że znaki mogą być pobierane z <xref:System.Text.StringBuilder.Chars%2A> właściwości, jak pokazano w poniższym przykładzie, które zlicza liczbę alfabetyczne, białe i znaków interpunkcyjnych w ciągu.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Wydajność i opartego na znakach indeksowania

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> Podczas ustawiania znak, jest poza granicami tego wystąpienia.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> podczas pobierania znak, jest poza granicami tego wystąpienia.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie znaki od bieżącej <see cref="T:System.Text.StringBuilder" /> wystąpienia.</summary>
        <returns>Obiekt którego <see cref="P:System.Text.StringBuilder.Length" /> jest 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> jest to metoda wygody, która jest odpowiednikiem ustawienia <xref:System.Text.StringBuilder.Length%2A> właściwości bieżącego wystąpienia na 0 (zero).  
  
 Wywoływanie <xref:System.Text.StringBuilder.Clear%2A> — metoda nie modyfikuje bieżącego wystąpienia <xref:System.Text.StringBuilder.Capacity%2A> lub <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Text.StringBuilder> obiektu na ciąg połączenia <xref:System.Text.StringBuilder.Clear%2A> metody, a następnie dołącza nowy ciąg.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Położenie początkowe w tym wystąpieniu której znaki zostaną skopiowane z. Jest to indeks zaczynający się od zera.</param>
        <param name="destination">Tablica której zostaną skopiowane znaków.</param>
        <param name="destinationIndex">Położenie początkowe w <c>docelowego</c> której zostaną skopiowane znaków. Jest to indeks zaczynający się od zera.</param>
        <param name="count">Liczba znaków do skopiowania.</param>
        <summary>Kopiuje znaki z określonego segmentu tego wystąpienia do miejsca docelowego określonego segmentu <see cref="T:System.Char" /> tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A> — Metoda jest przeznaczona do użycia w rzadkich sytuacji gdy potrzebne są wydajne skopiować kolejne sekcje <xref:System.Text.StringBuilder> obiektu do tablicy. Tablica powinna być o stałym rozmiarze, przydzielony wstępnie do ponownego użycia i prawdopodobnie globalnie dostępny.  
  
 Na przykład można wypełnić aplikacji <xref:System.Text.StringBuilder> obiekt z dużej liczby znaków, a następnie użyj <xref:System.Text.StringBuilder.CopyTo%2A> metodę, aby skopiować małe, kolejne części <xref:System.Text.StringBuilder> obiektu do tablicy, której elementy są przetwarzane. Gdy wszystkie dane w <xref:System.Text.StringBuilder> obiekt został przetworzony, rozmiar <xref:System.Text.StringBuilder> obiektu ma ustawioną wartość zero, a ten cykl powtarza się.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.CopyTo%2A> metody.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" />, jest mniejsza od zera.  - lub - <paramref name="sourceIndex" /> jest większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" /> jest większa niż długość tego wystąpienia.  - lub - <paramref name="destinationIndex" />  +  <paramref name="count" /> jest większa niż długość <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Minimalna możliwości zapewnienia.</param>
        <summary>Zapewnia, że pojemność to wystąpienie <see cref="T:System.Text.StringBuilder" /> jest co najmniej określonej wartości.</summary>
        <returns>Nowe pojemności tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest obecna pojemność mniejszej niż `capacity` parametru przydzielić pamięci dla tego wystąpienia co najmniej `capacity` liczbę znaków; w przeciwnym razie zostanie zmieniona Brak pamięci.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.EnsureCapacity%2A> metody.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli to wystąpienie i <paramref name="sb" /> mają takie same parametry <see cref="P:System.Text.StringBuilder.Capacity" />, i <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod używa <xref:System.Text.StringBuilder.Equals%2A> metodę sprawdzania, czy dwa <xref:System.Text.StringBuilder> obiekty są takie same. Metoda jest wywoływana wielokrotnie po znaczących zmian, aby każdy obiekt, a wyniki są wyświetlane w konsoli.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia reprezentację ciągu określonego obiektu do tego wystąpienia na pozycji określony znak.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia wartość logiczną reprezentację ciągu do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego 8-bitową liczbę całkowitą bez znaku do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia określony znak Unicode reprezentację ciągu do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Tablica znaków do wstawienia.</param>
        <summary>Wstawia reprezentację określonej tablicy znaków Unicode do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 Jeśli `value` jest `null`, <xref:System.Text.StringBuilder> nie ulega zmianie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu liczbą dziesiętną do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację liczby zmiennoprzecinkowej podwójnej precyzji do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego 16-bitową liczbę całkowitą ze znakiem do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego całkowita 32-bitowej do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu 64-bitowej podpisanej liczby całkowitej do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Obiekt do wstawienia, lub <see langword="null" />.</param>
        <summary>Wstawia reprezentację ciągu obiektu do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 Jeśli `value` jest `null`, wartość tego wystąpienia jest bez zmian.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego 8-bitową liczbę całkowitą ze znakiem do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu pojedynczej precyzji liczba zmiennoprzecinkowa do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <summary>Wstawia ciąg do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność jest dostosować do własnych potrzeb.  
  
 To wystąpienie <xref:System.Text.StringBuilder> nie ulega zmianie, jeśli `value` jest `null`, lub `value` nie jest `null` , ale jego długość wynosi zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa niż bieżąca długość tego wystąpienia.  - lub - Bieżąca długość <see cref="T:System.Text.StringBuilder" /> obiektów oraz długość <paramref name="value" /> przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu 16-bitową liczbę całkowitą bez znaku do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu 32-bitowej liczby całkowitej bez znaku do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartości do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu 64-bitowej liczby całkowitej bez znaku do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> jest używany do pobierania reprezentację ciągu `value`. Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż długość tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>W [! INCLUDE[net_v35SP1_long](~/includes/NET-v35sp1-Long-MD.MD)] i starszych wersjach, wywołania tej metody zwrócił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [! INCLUDE[net_v40_long](~/includes/NET-V40-Long-MD.MD)] metoda wygeneruje <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <param name="count">Ile razy, aby wstawić <c>wartość</c>.</param>
        <summary>Wstawia jedną lub więcej kopii określonego ciągu do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
 To <xref:System.Text.StringBuilder> obiektu nie ulega zmianie, jeśli `value` jest `null`, `value` nie jest `null` , ale jego długość wynosi zero, lub `count` wynosi zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub większa niż bieżąca długość tego wystąpienia.  - lub - <paramref name="count" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.OutOfMemoryException">Bieżąca długość <see cref="T:System.Text.StringBuilder" /> obiektów oraz długość <paramref name="value" /> razy <paramref name="count" /> przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Tablica znaków.</param>
        <param name="startIndex">Indeks początkowy w <c>wartość</c>.</param>
        <param name="charCount">Liczba znaków do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego subarray znaków Unicode do tego wystąpienia na pozycji określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki zostaną przesunięte, aby zwolnić miejsce dla nowego tekstu. Pojemność to wystąpienie jest dostosować do własnych potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> jest <see langword="null" />, i <paramref name="startIndex" /> i <paramref name="charCount" /> nie są zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" />, lub <paramref name="charCount" /> jest mniejsza od zera.  - lub - <paramref name="index" /> jest większa niż długość tego wystąpienia.  - lub - <paramref name="startIndex" /> plus <paramref name="charCount" /> nie jest w stanie <paramref name="value" />.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia długość bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <value>Długość tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość <xref:System.Text.StringBuilder> obiektu jest zdefiniowana przez jego liczbę <xref:System.Char> obiektów.  
  
 Podobnie jak <xref:System.String.Length%2A?displayProperty=nameWithType> właściwość <xref:System.Text.StringBuilder.Length%2A> właściwość wskazuje długość ciągu bieżącego obiektu. W odróżnieniu od <xref:System.String.Length%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu, <xref:System.Text.StringBuilder.Length%2A> właściwości umożliwia modyfikowanie długość ciągu przechowywane <xref:System.Text.StringBuilder> obiektu.  
  
 Jeśli określona długość jest mniejsza niż bieżąca długość bieżącego <xref:System.Text.StringBuilder> obiekt został obcięty do zadanej długości. Jeśli określona długość jest większa niż bieżąca długość na końcu wartości ciągu bieżącego <xref:System.Text.StringBuilder> obiektu jest uzupełniana znakiem Unicode NULL (U + 0000).  
  
 Jeśli określona długość jest większa niż pojemność bieżąca <xref:System.Text.StringBuilder.Capacity%2A> zwiększa, aby była większa niż lub równa określonej długości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Length%2A> właściwości.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji set jest mniejsza niż zero lub większa niż <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną pojemność tego wystąpienia.</summary>
        <value>Maksymalna liczba znaków, które może przechowywać tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna pojemność dla tej implementacji jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Jednak ta wartość jest konkretnej implementacji i może być różna w implementacjach innych lub nowszej. Należy jawnie ustawić maksymalnej pojemności <xref:System.Text.StringBuilder> obiektu przez wywołanie metody <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora.  
  
 W[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] i [!INCLUDE[net_v45](~/includes/net-v45-md.md)], gdy można utworzyć wystąpienia <xref:System.Text.StringBuilder> obiektu przez wywołanie metody <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora, zarówno długość i pojemność <xref:System.Text.StringBuilder> wystąpienia może zwiększyć się poza wartość jego <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości. Taka sytuacja może wystąpić szczególnie podczas wywoływania <xref:System.Text.StringBuilder.Append%2A> i <xref:System.Text.StringBuilder.AppendFormat%2A> metody do dołączenia małych ciągów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">Liczba znaków do usunięcia.</param>
        <summary>Usuwa określony zakres znaków z tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia po wykonaniu operacji akcyzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca metoda usuwa określony zakres znaków z bieżącego wystąpienia. Znaki na (`startIndex` + `length`) są przenoszone do `startIndex`, i wartość ciągu bieżącego wystąpienia jest obcinana przez `length`. Bieżące wystąpienie jest poza zasięgiem.  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> Metoda Modyfikuje wartość bieżącej klasy <xref:System.Text.StringBuilder> wystąpienia i zwraca tego wystąpienia. Tworzenie i nie zwraca nową <xref:System.Text.StringBuilder> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Remove%2A> metody.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeśli <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejszy od zera, lub <paramref name="startIndex" />  +  <paramref name="length" /> jest większa niż długość tego wystąpienia.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamienia wszystkie wystąpienia określony znak lub ciąg, w tym wystąpieniu z innego określony znak lub ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak do zastąpienia.</param>
        <param name="newChar">Znak zastępujący <c>oldChar</c>.</param>
        <summary>Zamienia wszystkie wystąpienia określony znak w tym wystąpieniu innego określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="oldChar" /> zastępuje <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie liczby porządkowej, z uwzględnieniem wielkości liter do identyfikacji wystąpienia `oldChar` w bieżącego wystąpienia. Rozmiar bieżącego <xref:System.Text.StringBuilder> wystąpienie jest w niezmienionym po wymianie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg do zastąpienia.</param>
        <param name="newValue">Ciąg, który zastępuje <c>oldValue</c>, lub <see langword="null" />.</param>
        <summary>Zamienia wszystkie wystąpienia określonego ciągu w tym wystąpieniu innego określonego ciągu.</summary>
        <returns>Odwołanie do tego wystąpienia ze wszystkimi wystąpieniami <paramref name="oldValue" /> zastępuje <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie liczby porządkowej, z uwzględnieniem wielkości liter do identyfikacji wystąpienia `oldValue` w bieżącego wystąpienia. Jeśli `newValue` jest `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, wszystkie wystąpienia `oldValue` zostaną usunięte.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="oldValue" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak do zastąpienia.</param>
        <param name="newChar">Znak zastępujący <c>oldChar</c>.</param>
        <param name="startIndex">Pozycja w tym wystąpieniu, w którym rozpoczyna się podciąg.</param>
        <param name="count">Długość podciąg.</param>
        <summary>Zamienia w jeden ciąg podrzędny tego wystąpienia, wszystkie wystąpienia określony znak z inną określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia z <paramref name="oldChar" /> zastępuje <paramref name="newChar" /> w zakresie od <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie liczby porządkowej, z uwzględnieniem wielkości liter do identyfikacji wystąpienia `oldChar` w bieżącego wystąpienia. Rozmiar bieżącego <xref:System.Text.StringBuilder> obiekt jest w niezmienionym po wymianie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" /> jest większa niż długość wartości tego wystąpienia.  - lub - <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg do zastąpienia.</param>
        <param name="newValue">Ciąg, który zastępuje <c>oldValue</c>, lub <see langword="null" />.</param>
        <param name="startIndex">Pozycja w tym wystąpieniu, w którym rozpoczyna się podciąg.</param>
        <param name="count">Długość podciąg.</param>
        <summary>Zamienia w jeden ciąg podrzędny tego wystąpienia, wszystkie wystąpienia podanego ciągu na inny określony ciąg.</summary>
        <returns>Odwołanie do tego wystąpienia ze wszystkimi wystąpieniami <paramref name="oldValue" /> zastępuje <paramref name="newValue" /> w zakresie od <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie liczby porządkowej, z uwzględnieniem wielkości liter do identyfikacji wystąpienia `oldValue` w wskazany podciąg. Jeśli `newValue` jest `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, wszystkie wystąpienia `oldValue` zostaną usunięte.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="oldValue" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejsza od zera.  - lub - <paramref name="startIndex" /> plus <paramref name="count" /> wskazuje pozycję znaku, w tym wystąpieniu.  - lub - powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt do wypełnienia informacjami o serializacji.</param>
        <param name="context">Miejsce do przechowywania i pobierania serializacji danych. Zarezerwowane do użytku w przyszłości.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu z danych niezbędnych do deserializacji bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` Parametr jest zarezerwowany do użytku w przyszłości i nie uczestniczy w tej operacji.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość <see cref="T:System.Text.StringBuilder" /> do <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Ciąg, którego wartość jest taka sama, jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.Text.StringBuilder.ToString%2A> metodę, aby przekonwertować <xref:System.Text.StringBuilder> do obiektu <xref:System.String> obiekt przed można przekazać reprezentowany przez ciąg <xref:System.Text.StringBuilder> obiektu do metody, która ma <xref:System.String> parametru lub wyświetlenie go w interfejsie użytkownika.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywołania <xref:System.Text.StringBuilder.ToString%2A> metody. Ten przykład jest częścią większego przykładu udostępnionego dla <xref:System.Text.StringBuilder> klasy.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Położenie początkowe podciągu w tym wystąpieniu.</param>
        <param name="length">Długość podciąg.</param>
        <summary>Konwertuje wartość podciąg tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Ciąg, którego wartość jest taka sama jak określony podciąg tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.Text.StringBuilder.ToString%2A> metodę, aby przekonwertować <xref:System.Text.StringBuilder> do obiektu <xref:System.String> obiekt przed można przekazać reprezentowany przez ciąg <xref:System.Text.StringBuilder> obiektu do metody, która ma <xref:System.String> parametru lub wyświetlenie go w interfejsie użytkownika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera.  - lub - sumę <paramref name="startIndex" /> i <paramref name="length" /> jest większa niż długość bieżącego wystąpienia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
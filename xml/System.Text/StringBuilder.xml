<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d75769fba72ba4165ce31fa609759964ea3d8189" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52607117" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje mutable ciąg znaków. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa reprezentuje obiekt jak ciąg, którego wartością jest modyfikowalną sekwencji znaków.  
  
 W tej sekcji:  
  
-   [Typy parametrów i StringBuilder](#StringAndSB)  
  
-   [Jak działa StringBuilder](#HowWorks)  
  
-   [Alokacja pamięci](#Memory)  
  
-   [Utworzenie wystąpienia obiektu StringBuilder](#Instantiating)  
  
-   [Wywołanie metod StringBuilder](#Calling)  
  
-   [Przeprowadzanie operacji StringBuilder](#Operations)  
  
    -   [Iterowanie znaków StringBuilder](#Iterating)  
  
    -   [Dodawanie tekstu do obiektu StringBuilder](#Adding)  
  
    -   [Usuwanie tekstu z obiektu StringBuilder](#Deleting)  
  
    -   [Modyfikowanie tekstu w obiekcie StringBuilder](#Modifying)  
  
-   [Wyszukiwanie tekstu w obiekcie StringBuilder](#Searching)  
  
-   [Konwersja obiektu StringBuilder na ciąg](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Typy ciągów i typy StringBuilder  
 Mimo że <xref:System.Text.StringBuilder> i <xref:System.String> oba reprezentują sekwencje znaków, są one wykonywane inaczej. <xref:System.String> jest typem niezmienne. Oznacza to, każda operacja, która pojawia się, aby zmodyfikować <xref:System.String> obiektu tworzy nowy ciąg.  
  
 Na przykład, wywołanie <xref:System.String.Concat%2A?displayProperty=nameWithType> metoda w poniższym przykładzie C#, który pojawia się zmienić wartość zmiennej ciągu o nazwie `value`. W rzeczywistości <xref:System.String.Concat%2A> metoda zwraca `value` obiekt, który ma inną wartość, a adres z `value` obiektu, który został przekazany do metody. Należy zauważyć, że przykład musi być skompilowana przy użyciu `/unsafe` — opcja kompilatora.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Dla procedur, które wykonują manipulowanie ciągami rozbudowane (np. aplikacje, które modyfikują ciągu wiele razy w pętli) wielokrotnie modyfikacji ciągu można dokładnie spadek istotnie poprawiającą wydajność. Alternatywą jest użycie <xref:System.Text.StringBuilder>, jest klasa modyfikowalne parametrów. Zmienność oznacza, że po utworzeniu wystąpienia klasy, można go modyfikować, dołączanie, usuwanie, zastępowanie i wstawianie znaków. A <xref:System.Text.StringBuilder> obiekt utrzymuje bufor, aby pomieścić rozszerzenia do ciągu. Nowe dane są dołączane do buforu, jeśli miejsca jest dostępna; w przeciwnym razie nowy, większy bufor jest przydzielany do nowego buforu są kopiowane dane z oryginalnego buforu i nowych danych jest następnie dołączany do bufor nowego.  
  
> [!IMPORTANT]
>  Mimo że <xref:System.Text.StringBuilder> klasy zwykle oferuje lepszą wydajność niż <xref:System.String> klasy, należy nie automatycznie zastąpić <xref:System.String> z <xref:System.Text.StringBuilder> zawsze, gdy chcesz manipulowania ciągami. Wydajność zależy od rozmiaru ciągu, ilość pamięci do przydzielenia dla nowego ciągu znaków, system, na którym jest wykonywany aplikację i typ operacji. Należy być przygotowanym do testowania aplikacji, aby określić, czy <xref:System.Text.StringBuilder> faktycznie oferuje istotnie poprawiającą wydajność.  
  
 Należy rozważyć użycie <xref:System.String> klasy w tych warunkach:  
  
-   Gdy liczba zmiany powodujące aplikację w ciągu jest mała. W takich przypadkach <xref:System.Text.StringBuilder> może oferty niewielki lub nie poprawę wydajności za pośrednictwem <xref:System.String>.  
  
-   Kiedy przeprowadzasz stałą liczbę operacji łączenia, szczególnie przy użyciu literałów ciągów. W tym przypadku kompilator może łączyć operacje łączenia jednej operacji.  
  
-   Gdy trzeba wykonywać operacje zaawansowane wyszukiwanie, gdy tworzysz parametry usługi. <xref:System.Text.StringBuilder> Nie ma klasy wyszukiwanie metod, takiego jak `IndexOf` lub `StartsWith`. Musisz przekonwertować <xref:System.Text.StringBuilder> obiekt <xref:System.String> dla tych operacji, a można odwrócić korzyści w zakresie wydajności z przy użyciu <xref:System.Text.StringBuilder>. Aby uzyskać więcej informacji, zobacz [wyszukiwanie tekstu w obiekcie StringBuilder](#Searching) sekcji.  
  
 Należy rozważyć użycie <xref:System.Text.StringBuilder> klasy w tych warunkach:  
  
-   Jeśli oczekujesz, że aplikację, aby upewnić Nieznana liczba zmian na ciąg w czasie projektowania (na przykład w przypadku korzystania z pętli do łączenia losową liczbę ciągów, które zawierają dane wejściowe użytkownika).  
  
-   Jeśli oczekujesz, że aplikacja, aby wprowadzić znaczną liczbę zmian w ciągu.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Jak działa StringBuilder  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> Właściwość wskazuje liczbę znaków <xref:System.Text.StringBuilder> obecnie zawiera obiekt. Jeśli dodasz znaków <xref:System.Text.StringBuilder> obiektu i zwiększa jego długość, dopóki nie równa się rozmiar <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> właściwość, która określa liczbę znaków, które mogą zawierać obiekt. Jeśli liczba dodanych znaków powoduje, że długość <xref:System.Text.StringBuilder> obiektu przekracza jego bieżąca pojemność, nową pamięć została przydzielona, wartość <xref:System.Text.StringBuilder.Capacity%2A> podwaja się właściwości i nowe znaki są dodawane do <xref:System.Text.StringBuilder> obiekt i jego <xref:System.Text.StringBuilder.Length%2A>właściwość jest dostosowywany. Dodatkowa pamięć dla <xref:System.Text.StringBuilder> obiekt jest przydzielany dynamicznie, dopóki nie osiągnie wartość zdefiniowana przez <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> właściwości. Po osiągnięciu maksymalnej pojemności można przydzielić pamięci dalszych <xref:System.Text.StringBuilder> obiektu i próby dodania znaków lub go rozwinąć po przekroczeniu pojemności maksymalnej zgłasza wyjątek, albo <xref:System.ArgumentOutOfRangeException> lub <xref:System.OutOfMemoryException> wyjątku.  
  
 Poniższy przykład ilustruje sposób <xref:System.Text.StringBuilder> obiekt przydziela nowej pamięci i dynamicznie zwiększa możliwości rozwija ciągu przypisane do obiektu. Ten kod tworzy <xref:System.Text.StringBuilder> obiektu przez wywołanie jego domyślnego (bezparametrowego) konstruktora. Pojemność domyślna tego obiektu jest 16 znaków, a maksymalną pojemność to więcej niż 2 miliardy znaków. Dodając ciąg "Jest zdania". wyników w nowych alokacji pamięci, ponieważ długość ciągu (znaki 19) przekracza pojemność domyślna <xref:System.Text.StringBuilder> obiektu. Pojemność obiektu podwaja się do 32 znaków, jest dodawany nowy ciąg, a długość obiektu jest teraz równa 19 znaków. Kod następnie dołącza ciąg "Jest dodatkowe zdania". wartość <xref:System.Text.StringBuilder> obiektu 11 razy. Zawsze, gdy operacja dołączania powoduje, że długość <xref:System.Text.StringBuilder> obiektu przekroczy zdolność pojemności istniejących jest dwukrotnie i <xref:System.Text.StringBuilder.Append%2A> operacja kończy się powodzeniem.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Alokacja pamięci  
 Wydajność domyślna <xref:System.Text.StringBuilder> obiektu jest 16 znaków, a maksymalną pojemność domyślna <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Te wartości domyślne są używane, jeśli wywołujesz <xref:System.Text.StringBuilder.%23ctor> i <xref:System.Text.StringBuilder.%23ctor%28System.String%29> konstruktorów.  
  
 Można jawnie określić pojemność <xref:System.Text.StringBuilder> obiektu w następujący sposób:  
  
-   Przez wywołanie dowolnego z <xref:System.Text.StringBuilder> konstruktorów, które obejmuje `capacity` parametru podczas tworzenia obiektu.  
  
-   Przypisując jawnie nową wartość do <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> właściwości, aby rozszerzyć istniejące <xref:System.Text.StringBuilder> obiektu. Należy pamiętać, że właściwość zgłasza wyjątek, jeśli nową pojemność jest mniejsza niż istniejący lub większy niż <xref:System.Text.StringBuilder> maksymalną pojemność obiektu.  
  
-   Przez wywołanie metody <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> metody z nową pojemność. Nowe pojemności nie musi być większa niż <xref:System.Text.StringBuilder> maksymalną pojemność obiektu. Jednak w przeciwieństwie do przypisania do <xref:System.Text.StringBuilder.Capacity%2A> właściwości <xref:System.Text.StringBuilder.EnsureCapacity%2A> zgłasza wyjątek, jeśli żądany nową pojemność jest mniejsza niż pojemność istniejącego; w takim przypadku wywołania metody które nie ma wpływu.  
  
 Jeśli długość ciągu jest przypisany do <xref:System.Text.StringBuilder> obiektów w wywołaniu konstruktora przekracza pojemność domyślna lub określoną pojemność <xref:System.Text.StringBuilder.Capacity%2A> właściwość jest ustawiona na długość ciągu określony za pomocą `value` parametru.  
  
 Można jawnie określić maksymalną pojemność wynoszącą <xref:System.Text.StringBuilder> obiektu przez wywołanie metody <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora. Nie można zmienić maksymalną pojemność, przypisując nową wartość do <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości, ponieważ jest on tylko do odczytu.  
  
 Jak w poprzedniej sekcji pokazano, zawsze wtedy, gdy istniejące pojemności pamięci nieodpowiednie, dodatkowe jest przydzielany i pojemność <xref:System.Text.StringBuilder> podwaja się do wartości zdefiniowane przez obiekt <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości.  
  
 Ogólnie rzecz biorąc pojemności domyślnej i maksymalnej pojemności są odpowiednie dla większości aplikacji. Można rozważyć ustawienie tych wartości w następujących warunkach:  
  
-   Jeśli rozmiar <xref:System.Text.StringBuilder> obiekt jest prawdopodobnie powiększać nadmiernie dużych zazwyczaj przekraczające kilku megabajtów. W takim przypadku może być pewne korzyści wydajności z ustawienia wstępnego <xref:System.Text.StringBuilder.Capacity%2A> właściwość zachowaniu wysokiej wartości, aby wyeliminować konieczność stosowania zbyt wiele ponowne alokacje pamięci.  
  
-   Jeśli Twoja aplikacja działa w systemie z ograniczoną ilością pamięci. W takim przypadku warto wziąć pod uwagę ustawienie <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwość mniej niż <xref:System.Int32.MaxValue?displayProperty=nameWithType> Jeśli aplikacja obsługuje dużych ciągów, które mogą spowodować, że do wykonania w środowisku z pamięci.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Utworzenie wystąpienia obiektu StringBuilder  
 Można utworzyć wystąpienia <xref:System.Text.StringBuilder> obiektu przez wywołanie jednej z jego sześciu konstruktorów przeciążonej klasy, które są wymienione w poniższej tabeli. Trzy konstruktory wystąpienia <xref:System.Text.StringBuilder> obiektu, którego wartość jest ciągiem pustym, ale są ustawione jego <xref:System.Text.StringBuilder.Capacity%2A> i <xref:System.Text.StringBuilder.MaxCapacity%2A> wartości w inny sposób. Zdefiniuj pozostałe trzy konstruktory <xref:System.Text.StringBuilder> obiekt, który ma wartość określonego ciągu i pojemności. Użyj dwóch trzy konstruktory domyślne maksymalną pojemność <xref:System.Int32.MaxValue?displayProperty=nameWithType>, natomiast trzeci umożliwia ustawienie maksymalnej pojemności.  
  
|Konstruktor|Wartość ciągu|Pojemność|Maksymalna pojemność|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Zdefiniowane przez `capacity` parametru|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Zdefiniowane przez `capacity` parametru|Zdefiniowane przez `maxCapacity` parametru|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Zdefiniowane przez `value` parametru|16 lub `value`. <xref:System.String.Length%2A>, która kwota jest większa|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Zdefiniowane przez `value` parametru|Zdefiniowane przez `capacity` parametru lub `value`. <xref:System.String.Length%2A>, która kwota jest większa.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Zdefiniowane przez `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Zdefiniowane przez `capacity` parametru lub `value`. <xref:System.String.Length%2A>, która kwota jest większa.|Zdefiniowane przez `maxCapacity` parametru|  
  
 W poniższym przykładzie użyto trzy z tych przeciążeń konstruktora do utworzenia wystąpienia <xref:System.Text.StringBuilder> obiektów.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Wywołanie metod StringBuilder  
 Większość metod, które modyfikują ciąg w <xref:System.Text.StringBuilder> wystąpienia zwrócić odwołanie do tego samego wystąpienia. Dzięki temu można wywołać <xref:System.Text.StringBuilder> metod na dwa sposoby:  
  
-   Można wykonywać poszczególne metody wywołań i Ignoruj zwracanej wartości, tak jak w poniższym przykładzie.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Za wprowadzając szereg wywołań metod w pojedynczej instrukcji. Może to być wygodne, jeśli chcesz zapisać pojedynczej instrukcji, który tworzy powiązanie kolejnych czynności. Poniższy przykład powoduje konsolidowanie trzech wywołań metod z poprzedniego przykładu do jednego wiersza kodu.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Przeprowadzanie operacji StringBuilder  
 Można użyć metody <xref:System.Text.StringBuilder> klasy do iteracji, dodać, usunąć ani zmodyfikować znaków <xref:System.Text.StringBuilder> obiektu.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Iterowanie znaków StringBuilder  
 Możesz uzyskać dostęp w znaki <xref:System.Text.StringBuilder> obiektu za pomocą <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwości. W języku C# <xref:System.Text.StringBuilder.Chars%2A> indeksatora; jest w języku Visual Basic jest domyślna właściwość <xref:System.Text.StringBuilder> klasy. Dzięki temu można ustawić lub pobrać pojedynczych znaków przy użyciu jej indeksu w tylko bez jawnego odwołania do <xref:System.Text.StringBuilder.Chars%2A> właściwości. Znaki w <xref:System.Text.StringBuilder> obiektu rozpocząć pod indeksem 0 (zero) i przejdź do indeksu <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Chars%2A> właściwości. Dołącza dziesięć losowych liczb do <xref:System.Text.StringBuilder> obiektu, a następnie wykonuje iterację każdy znak. Jeśli znak Unicode kategoria jest <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, zmniejsza liczbę 1 (lub zmienia numer do 9, jeśli jego wartość wynosi 0). Przykład wyświetla zawartość <xref:System.Text.StringBuilder> obiektu zarówno przed i po wartości poszczególnych znaków zostały zmienione.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Dodawanie tekstu do obiektu StringBuilder  
 <xref:System.Text.StringBuilder> Klasa zawiera następujące metody rozszerzania zawartość <xref:System.Text.StringBuilder> obiektu:  
  
-   <xref:System.Text.StringBuilder.Append%2A> Metoda dołącza ciąg, podciąg, tablicy znaków, części tablicy znaków, jeden znak powtarza się wielokrotnie, lub wpisz ciąg reprezentujący danych pierwotnych, aby <xref:System.Text.StringBuilder> obiektu.  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A> Metoda dołącza terminatora wiersza lub ciągu wraz z zakończeniem liniowym do <xref:System.Text.StringBuilder> obiektu.  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A> Metoda dołącza do <xref:System.Text.StringBuilder> obiektu. Ciągów reprezentujących obiektów uwzględnionych w ciągu wynikowym może odzwierciedlać konwencje formatowania bieżącej kultury systemu lub określonej kultury.  
  
-   <xref:System.Text.StringBuilder.Insert%2A> Metoda wstawia ciąg, podciąg, wiele powtórzeń ciągu, tablicy znaków, części tablicy znaków lub reprezentację danych pierwotnych, wpisz w określonej pozycji w <xref:System.Text.StringBuilder> obiektu. Pozycja jest definiowany przez liczony od zera indeks.  
  
 W poniższym przykładzie użyto <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, i <xref:System.Text.StringBuilder.Insert%2A> metody, aby rozwinąć tekst <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Usuwanie tekstu z obiektu StringBuilder  
 <xref:System.Text.StringBuilder> Klasa zawiera metody, które można zmniejszyć rozmiar bieżącego <xref:System.Text.StringBuilder> wystąpienia. <xref:System.Text.StringBuilder.Clear%2A> Metoda usuwa wszystkie znaki i ustawia <xref:System.Text.StringBuilder.Length%2A> właściwości wartość zero. <xref:System.Text.StringBuilder.Remove%2A> Metoda usuwa określoną liczbę znaków, zaczynając od pozycji określonego indeksu. Ponadto, możesz usunąć znaków od końca <xref:System.Text.StringBuilder> obiektu przez ustawienie jego <xref:System.Text.StringBuilder.Length%2A> właściwość z wartością, która jest mniejsza niż długość bieżącego wystąpienia.  
  
 Poniższy przykład umożliwia usunięcie części tekstu z <xref:System.Text.StringBuilder> obiektów, wyświetla jego wynikowy pojemności maksymalnej pojemności i długość wartości właściwości, a następnie wywołuje <xref:System.Text.StringBuilder.Clear%2A> metodę, aby usunąć wszystkie znaki od <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Modyfikowanie tekstu w obiekcie StringBuilder  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> Metoda zamienia wszystkie wystąpienia znak lub ciąg w całej <xref:System.Text.StringBuilder> obiektu lub należeć do zakresu określonego znaku. W poniższym przykładzie użyto <xref:System.Text.StringBuilder.Replace%2A> metodę, aby zamienić wszystkie punkty wykrzyknika (!) w znaki zapytania (?) <xref:System.Text.StringBuilder> obiektu.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Wyszukiwanie tekstu w obiekcie StringBuilder  
 <xref:System.Text.StringBuilder> Klasy nie zawiera metod podobnych do <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, i <xref:System.String.StartsWith%2A?displayProperty=nameWithType> metod dostarczonych przez <xref:System.String> klasy, które umożliwiają wyszukiwanie obiektu dla określonego znaku lub podciąg. Określenia obecności lub od pozycji znaku podciągu wymaga, że wyszukiwanie <xref:System.String> wartości za pomocą metodę wyszukiwania ciągów lub metoda wyrażenia regularnego. Istnieją cztery sposoby zaimplementowania takich wyszukiwania w taki sposób, jak pokazano w poniższej tabeli.  
  
|Techniki|Specjaliści|Wady|  
|---------------|----------|----------|  
|Wyszukaj wartości ciągu przed dodaniem ich do <xref:System.Text.StringBuilder> obiektu.|Przydatne do określenia, czy istnieje podciąg.|Nie można użyć, gdy pozycja indeksu podciągu jest istotna.|  
|Wywołaj <xref:System.Text.StringBuilder.ToString%2A> i wyszukiwania zwracanego <xref:System.String> obiektu.|Łatwe w użyciu w przypadku przypisania tekst, który <xref:System.Text.StringBuilder> obiektu, a następnie zaczyna go zmodyfikować.|Kłopotliwe wywoływać wielokrotnie <xref:System.Text.StringBuilder.ToString%2A> Jeśli musisz wprowadzić zmiany przed cały tekst jest dodawany do <xref:System.Text.StringBuilder> obiektu.<br /><br /> Należy pamiętać, aby pracować z końcem <xref:System.Text.StringBuilder> tekstu obiektu, jeśli wprowadzasz zmiany.|  
|Użyj <xref:System.Text.StringBuilder.Chars%2A> właściwość sekwencyjnie wyszukiwania zakres znaków.|Parametr jest przydatne, jeśli dane przy użyciu pojedynczych znaków lub małych podciąg.|Skomplikowane, jeśli liczba znaków do wyszukiwania jest duża lub jeśli logika wyszukiwania jest złożone.<br /><br />Wyniki w bardzo niskiej wydajności dla obiektów, które wzrosła bardzo duże, za pomocą wywołania metody powtórzony.  |  
|Konwertuj <xref:System.Text.StringBuilder> obiekt <xref:System.String> obiektu i wykonać zmiany na <xref:System.String> obiektu.|Parametr jest przydatne, jeśli liczba zmian jest mała.|Neguje korzyści w zakresie wydajności dla <xref:System.Text.StringBuilder> klasy, jeśli liczba zmian jest duży.|  
  
 Przeanalizujmy tych technik bardziej szczegółowo.  
  
-   Jeśli celem wyszukiwania ma na celu określenie, czy podciąg określoną istnieje (to znaczy, jeśli nie jesteś zainteresowany położenie podciągu), możesz wyszukiwać ciągi przechowaniem ich w <xref:System.Text.StringBuilder> obiektu. W poniższym przykładzie przedstawiono jedną możliwą implementację. Definiuje on `StringBuilderFinder` klasy, której Konstruktor jest przekazywany odwołanie do <xref:System.Text.StringBuilder> obiektu i podciąg, który można znaleźć w ciągu. W takim przypadku przykład próbuje określić, czy te znajdują się w Fahrenheita, stopniach Celsjusza zarejestrowane temperatury i dodaje odpowiedni tekst wprowadzający do stanu sprzed <xref:System.Text.StringBuilder> obiektu. Generator liczb losowych jest używany do wybierania tablicę, która zawiera dane w stopniach Celsjusza lub stopni Fahrenheita.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Wywołaj <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować <xref:System.Text.StringBuilder> obiekt <xref:System.String> obiektu. Możesz wyszukiwać ciąg przy użyciu metod, takich jak <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> lub <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, lub użyć wyrażeń regularnych i <xref:System.Text.RegularExpressions.Regex> klasy, aby wyszukać wzorców. Ponieważ zarówno <xref:System.Text.StringBuilder> i <xref:System.String> obiekty używają kodowania do przechowywania znaków, pozycji indeksu znaków podciągów, UTF-16 i dopasowania wyrażenia regularnego są takie same w obu obiektów. Dzięki temu można używać <xref:System.Text.StringBuilder> metody, aby wprowadzić zmiany w tym samym miejscu, w którym ten tekst znajduje się w <xref:System.String> obiektu.  
  
    > [!NOTE]
    >  Jeśli przyjmiesz takie podejście powinien współpracować z końca <xref:System.Text.StringBuilder> obiekt na początek, dzięki czemu nie trzeba wielokrotnie przekonwertować <xref:System.Text.StringBuilder> obiekt na ciąg.  
  
     To podejście pokazano w poniższym przykładzie. Przechowuje czterech wystąpień każdej litery alfabetu angielskiego w <xref:System.Text.StringBuilder> obiektu. Następnie konwertuje tekst, który ma <xref:System.String> obiektu i korzysta z wyrażenia regularnego do identyfikowania pozycji początkowej każdej sekwencji czterech znaków. Na koniec go dodaje znaku podkreślenia przed każdym sekwencją czterech znaków, z wyjątkiem pierwszej sekwencji i konwertuje pierwszy znak w sekwencji na wielkie litery.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Użyj <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwość sekwencyjnie wyszukiwania szeroką gamę znaków <xref:System.Text.StringBuilder> obiektu. Takie podejście może być niepraktyczne, jeśli liczba znaków, które mają być wyszukiwane jest duża lub szczególnie złożony logiki wyszukiwania. Dla wpływ na wydajność dostępu opartego na indeksie znak po znaku dla bardzo dużych, chunked <xref:System.Text.StringBuilder> obiektów, zobacz dokumentację <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> właściwości. 
  
     W poniższym przykładzie jest taka sama w działaniu do poprzedniego przykładu, ale różni się w celu wykonania. Używa ona <xref:System.Text.StringBuilder.Chars%2A> właściwości do wykrycia, gdy zmieniono wartość znaku, wstawia znaku podkreślenia w tej pozycji i konwertuje pierwszy znak w nową sekwencję na wielkie litery.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store cały tekst zostały zmodyfikowane w <xref:System.Text.StringBuilder> obiektu, wywołaj <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metodę, aby przekonwertować <xref:System.Text.StringBuilder> obiekt <xref:System.String> obiektu i wykonać wszelkie zmiany na <xref:System.String> obiektu. Tej metody można użyć, jeśli masz tylko kilka zmian w przeciwnym razie kosztów pracy z ciągami niezmienne może zanegowania wydajności korzyści z używania <xref:System.Text.StringBuilder> obiektu.  
  
     Poniższy przykład jest identyczny w działaniu poprzednich dwóch przykładach, ale różni się w celu wykonania. Tworzy <xref:System.Text.StringBuilder> obiektów, konwertuje ją na <xref:System.String> obiektu, a następnie używa wyrażenia regularnego do wykonywania wszystkich pozostałych modyfikacji na ciąg. <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> Metoda używa wyrażenia lambda do przeprowadzania zastępowania każdego dopasowania.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Konwersja obiektu StringBuilder na ciąg  
 Należy przekonwertować <xref:System.Text.StringBuilder> obiekt <xref:System.String> obiekt przed można przekazać ciągu, reprezentowane przez <xref:System.Text.StringBuilder> obiekt do metody, która ma <xref:System.String> parametru lub wyświetlić ją w interfejsie użytkownika. Wykonaj tę konwersję, wywołując <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> metody. Ilustracja, znajduje się w poprzednim przykładzie, która wywołuje <xref:System.Text.StringBuilder.ToString%2A> metodę, aby przekonwertować <xref:System.Text.StringBuilder> obiekt na ciąg, więc może być przekazywany do metody wyrażeń regularnych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać wiele metod, zdefiniowanych przez <xref:System.Text.StringBuilder> klasy.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość ciągu tego wystąpienia jest równa <xref:System.String.Empty?displayProperty=nameWithType>, a pojemność jest ustawiona na specyficzne dla implementacji domyślnej pojemności.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora bez parametrów.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerowany rozmiar początkowy dla tego wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> przy użyciu określonej pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiekt przydziela dodatkową pamięć do ich przechowywania.  
  
 Wartość ciągu tego wystąpienia jest równa <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli `capacity` wynosi zero, pojemności specyficzne dla implementacji domyślnej jest używana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora o określonej pojemności.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg używany do inicjacji wartości wystąpienia. Jeśli <paramref name="value" /> jest <see langword="null" />, nowe <see cref="T:System.Text.StringBuilder" /> będzie zawierać pusty ciąg (oznacza to, że zawiera <see cref="F:System.String.Empty" />).</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> przy użyciu określonego ciągu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `value` jest `null`, nowe <xref:System.Text.StringBuilder> będzie zawierać pusty ciąg (oznacza to, że zawiera <xref:System.String.Empty>).  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określonego ciągu.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerowany rozmiar początkowy dla <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Maksymalna liczba znaków, które mogą zawierać bieżący ciąg.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasę, która rozpoczyna się od określonej pojemności i może zwiększać się określona wartość maksymalna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiekt przydziela dodatkową pamięć do ich przechowywania.  
  
 Jeśli `capacity` wynosi zero, pojemności specyficzne dla implementacji domyślnej jest używana.  
  
 `maxCapacity` Właściwość definiuje maksymalną liczbę znaków, które mogą pomieścić bieżącego wystąpienia. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `maxCapacity` wartość <xref:System.Text.StringBuilder> obiekt nie przydziela dodatkową pamięć, ale zamiast tego zgłasza wyjątek.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora o określonej pojemności i maksymalnej pojemności.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> jest mniejsza niż jeden <paramref name="capacity" /> jest mniejsza od zera, lub <paramref name="capacity" /> jest większa niż <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg używany do inicjacji wartości wystąpienia. Jeśli <paramref name="value" /> jest <see langword="null" />, nowe <see cref="T:System.Text.StringBuilder" /> będzie zawierać pusty ciąg (oznacza to, że zawiera <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Sugerowany rozmiar początkowy dla <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> przy użyciu określonego ciągu i pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiekt przydziela dodatkową pamięć do ich przechowywania.  
  
 Jeśli `capacity` wynosi zero, pojemności specyficzne dla implementacji domyślnej jest używana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z ciągu początkowe i o określonej pojemności.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż zero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający podciąg, używane do zainicjowania wartość tego wystąpienia. Jeśli <paramref name="value" /> jest <see langword="null" />, nowe <see cref="T:System.Text.StringBuilder" /> będzie zawierać pusty ciąg (oznacza to, że zawiera <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Położenie w obrębie <paramref name="value" /> którym podciąg rozpoczyna się.</param>
        <param name="length">Liczba znaków w podciąg.</param>
        <param name="capacity">Sugerowany rozmiar początkowy dla <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.StringBuilder" /> klasy z podanym podciągiem i pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity` Parametr określa maksymalną liczbę znaków, które mogą być przechowywane w pamięci przydzielonej przez bieżące wystąpienie. Jego wartość jest przypisywana do <xref:System.Text.StringBuilder.Capacity%2A> właściwości. Jeśli liczba znaków, które mają być przechowywane w bieżącym wystąpieniu przekracza to `capacity` wartość <xref:System.Text.StringBuilder> obiekt przydziela dodatkową pamięć do ich przechowywania.  
  
 Jeśli `capacity` wynosi zero, pojemności specyficzne dla implementacji domyślnej jest używana.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób wywołania <xref:System.Text.StringBuilder.%23ctor%2A> konstruktora z określonego ciągu.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> plus <paramref name="length" /> nie jest pozycją w parametrze <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ciąg reprezentujący określony obiekt do tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Wartość logiczna, aby dołączyć.</param>
        <summary>Dołącza określoną wartość logiczną reprezentację ciągu tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> Wywołania metody <xref:System.Boolean.ToString?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value`. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 8-bitowa liczba całkowita bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> Wywołania metody <xref:System.Byte.ToString%28System.IFormatProvider%29> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Jednostka kodu zakodowana UTF-16 do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określonego <see cref="T:System.Char" /> obiektu z tym wystąpieniem.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków do dołączenia.</param>
        <summary>Dołącza znaki Unicode w określonej tablicy reprezentację ciągu dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza wszystkie znaki w wybranej tablicy do bieżącego wystąpienia w tej samej kolejności, w jakiej występują w `value`. Jeśli `value` jest `null`, są wprowadzane żadne zmiany.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określoną liczbę dziesiętną z tym wystąpieniem.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> Wywołania metody <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący podanej liczbie zmiennoprzecinkowej podwójnej precyzji dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29> Wywołania metody <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego całkowita 16-bitowa dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> Wywołania metody <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego całkowita 32-bitowa dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> Wywołania metody <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego całkowita 64-bitowym z tym wystąpieniem.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> Wywołania metody <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> można pobrać reprezentacji w postaci ciągu `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący określony obiekt do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie. Definiuje on `Dog` klasy, tworzy `Dog` obiektu i sprawia, że trzech wywołań <xref:System.Text.StringBuilder.Append%2A> metodę, aby utworzyć ciąg, który zawiera nazwę i na rynku emulatorowi pies.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29> Wywołania metody <xref:System.Object.ToString%2A?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value`. Jeśli `value` jest `null`, są wprowadzane żadne zmiany, aby <xref:System.Text.StringBuilder> obiektu.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego całkowita 8-bitowa dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> Wywołania metody <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący podanej liczbie zmiennoprzecinkowej pojedynczej precyzji z tym wystąpieniem.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29> Wywołania metody <xref:System.Single.ToString%2A?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dołączenia.</param>
        <summary>Dołącza kopię określonego ciągu dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Jeśli `value` jest `null`, są wprowadzane żadne zmiany.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 16-bitowa liczba całkowita bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> Wywołania metody <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value`. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 32-bitowa liczba całkowita bez znaku do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> Wywołania <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do dołączenia.</param>
        <summary>Dołącza reprezentację ciągu określonego 64-bitowej nieoznaczonej liczby całkowitej dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> Wywołania metody <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> metodę, aby uzyskać ciąg reprezentujący `value` dla bieżącej kultury. Aby sterować formatowaniem `value`, wywołanie <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Znak do dołączenia.</param>
        <param name="repeatCount">Ile razy, aby dołączyć <paramref name="value" />.</param>
        <summary>Dołącza określoną liczbę kopii reprezentację ciągu znaków Unicode dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> jest mniejsza niż zero.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało pamięci.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Wskaźnik do tablicy znaków.</param>
        <param name="valueCount">Liczba znaków w tablicy.</param>
        <summary>Dołącza tablicę znaków Unicode, zaczynając od określonego adresu do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza `valueCount` znaków, zaczynając od adresu `value` do bieżącego wystąpienia.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> jest mniejsza niż zero.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> jest wskaźnikiem wartości null.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tablica znaków.</param>
        <param name="startIndex">Pozycja początkowa w <paramref name="value" />.</param>
        <param name="charCount">Liczba znaków do dołączenia.</param>
        <summary>Dołącza ciąg reprezentujący podtablicę o określonej długości, znaków Unicode dla tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza określony zakres znaków `value` do bieżącego wystąpienia. Jeśli `value` jest `null` i `startIndex` i `count` to zero, nie zmian.  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> jest <see langword="null" />, i <paramref name="startIndex" /> i <paramref name="charCount" /> nie mają wartość zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> + <paramref name="charCount" /> jest większa niż długość <paramref name="value" />.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg zawierający podciąg, aby dołączyć.</param>
        <param name="startIndex">Pozycja początkowa podciągu w ramach <paramref name="value" />.</param>
        <param name="count">Liczba znaków w <paramref name="value" /> do dołączenia.</param>
        <summary>Dołącza kopię określony podciąg do tego wystąpienia.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dołącza określony zakres znaków `value` do bieżącego wystąpienia. Jeśli `value` jest `null` i `startIndex` i `count` to zero, nie zmian.  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> Metoda modyfikuje istniejące wystąpienie tej klasy; nie zwraca nowe wystąpienie klasy. W związku z tym można wywołać metody lub właściwości w istniejących odwołań i nie trzeba przypisać wartość zwracaną <xref:System.Text.StringBuilder> obiektu, tak jak pokazano w poniższym przykładzie.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> jest <see langword="null" />, i <paramref name="startIndex" /> i <paramref name="count" /> nie mają wartość zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> + <paramref name="count" /> jest większa niż długość <paramref name="value" />.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący odpowiedni argument obiektu.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący jeden argument.</summary>
        <returns>Odwołanie do tego wystąpienia przy użyciu <paramref name="format" /> dołączane. Każdy element formatu w <paramref name="format" /> zostaje zastąpiona przez ciąg reprezentujący <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu. Indeks elementów formatu musi mieć wartość 0, aby odpowiadać `arg0`, pojedynczy obiekt na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciągu reprezentującego `arg0`.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` reprezentuje obiekt do sformatowania. Każdy element formatu w `format` jest zastępowany ciągiem reprezentującym `arg0`. Jeśli element formatu zawiera `formatString` i `arg0` implementuje <xref:System.IFormattable> interfejsu, następnie `arg0.ToString(formatString, null)` definiuje formatowanie. W przeciwnym razie `arg0.ToString()` definiuje formatowanie.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje oddawania {0: ###} puszek żywności naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10 zwracaną wartością będzie "Dziękujemy darowizn, 10 puszek żywności naszej organizacji charytatywnej."  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="args">Tablica obiektów do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący odpowiedniego argumentu w tablicy parametrów.</summary>
        <returns>Odwołanie do tego wystąpienia przy użyciu <paramref name="format" /> dołączane. Każdy element formatu w <paramref name="format" /> zostaje zastąpiona przez ciąg reprezentujący odpowiadający argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciąg reprezentujący odpowiadający mu obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` reprezentuje obiektów do sformatowania. Każdy element formatu w `format` zostaje zastąpiona opcją ciąg reprezentujący odpowiadający mu obiekt `args`. Jeśli element formatu zawiera `formatString` i odpowiadający mu obiekt `args` implementuje <xref:System.IFormattable> interfejsu, następnie `args[index].ToString(formatString, provider)` definiuje formatowanie. W przeciwnym razie `args[index].ToString()` definiuje formatowanie.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje oddawania {0: ###} puszek żywności naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10 zwracaną wartością będzie "Dziękujemy darowizn, 10 puszek żywności naszej organizacji charytatywnej."  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> lub <paramref name="args" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa długości <paramref name="args" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący pojedynczy argument przy użyciu dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania. Po zakończeniu operacji dołączania, to wystąpienie zawiera żadnych danych, które istniały przed wykonaniem operacji sufiks przez kopię <paramref name="format" /> w których w dowolnym formacie specyfikacji zastępuje ciąg reprezentujący <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework można przekonwertować wartości z `arg0` na jego reprezentację tekstową czym osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu. Indeks każdy element formatu musi mieć wartość zero (0), ponieważ ta metoda obejmuje listy argumentów z pojedynczym argumentem. Proces formatowania zastępuje każdy element formatu ciągu reprezentującego `arg0`.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. W takim przypadku od <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> metoda ma jeden argument na liście argumentów wartość *indeksu* zawsze musi być równa 0. Jeśli nie jest dostępna, <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Parametr określa <xref:System.IFormatProvider> implementację, która może zapewnić informacje o formatowaniu dla obiektów w `args`. `provider` może być dowolny z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury `arg0` Jeśli jest wartością liczbową.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury `arg0` przypadku wartości daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje o formatowaniu `arg0`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu.  
  
 Jeśli `provider` parametr jest `null`, formatowania informacje są uzyskiwane z bieżącej kultury.  
  
 `arg0` reprezentuje obiekt do sformatowania. Każdy element formatu w `format` jest zastępowany ciągiem reprezentującym `arg0`. Jeśli element formatu zawiera `formatString` i `arg0` implementuje <xref:System.IFormattable> interfejsu, następnie `arg0.ToString(formatString, provider)` definiuje formatowanie. W przeciwnym razie `arg0.ToString()` definiuje formatowanie.  
  
   
  
## Examples  
 Następujące obejmuje dwa wywołania do <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> metody. Zarówno użyć konwencji formatowania kultury Angielski — Wielka Brytania (en-GB). Pierwszy wstawi reprezentację ciągu <xref:System.Decimal> wartości waluty w ciągu wynikowym. Drugi wstawia <xref:System.DateTime> ciągu wartości w dwóch miejscach w wyniku pierwsze tym tylko krótkiej daty ciąg, a drugi ciąg godziny krótkiej.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większą lub równą jeden (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Porady: definiowanie i użycie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="args">Tablica obiektów do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący odpowiedniego argumentu w tablicy parametrów przy użyciu dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania. Po zakończeniu operacji dołączania, to wystąpienie zawiera żadnych danych, które istniały przed wykonaniem operacji sufiks przez kopię <paramref name="format" /> gdzie wszelkie specyfikacji formatu jest zastępowana ciąg reprezentujący odpowiadający argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciąg reprezentujący odpowiadający mu obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Parametr określa <xref:System.IFormatProvider> implementację, która może zapewnić informacje o formatowaniu dla obiektów w `args`. `provider` może być dowolny z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiektu, który dostarcza specyficzne dla kultury informacje o formatowaniu dla wartości liczbowych w `args`.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiektu, który dostarcza specyficzne dla kultury informacje o formatowaniu dla wartości daty i godziny w `args`.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która dostarcza informacje o formatowaniu dla jednego lub więcej obiektów w `args`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu. Drugi przykład w następnej sekcji przedstawiono <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> wywołanie metody przy użyciu niestandardowego <xref:System.IFormatProvider> implementacji.  
  
 Jeśli `provider` parametr jest `null`, informacje o dostawcy formatu jest uzyskiwana z bieżącej kultury.  
  
 `args` reprezentuje obiektów do sformatowania. Każdy element formatu w `format` zostaje zastąpiona opcją ciąg reprezentujący odpowiadający mu obiekt `args`. Jeśli element formatu zawiera `formatString` i odpowiadający mu obiekt `args` implementuje <xref:System.IFormattable> interfejsu, następnie `args[index].ToString(formatString, provider)` definiuje formatowanie. W przeciwnym razie `args[index].ToString()` definiuje formatowanie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 W poniższym przykładzie zdefiniowano niestandardową <xref:System.IFormatProvider> wdrożenia o nazwie `CustomerFormatter` klient 10-cyfrowy numer łącznikami, formatuje numeru wewnętrznego po cyfrach czwarty i siódmego. Jest przekazywany do <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> metodę, aby utworzyć ciąg, który zawiera sformatowaną odbiorcy i nazwa klienta.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa długości <paramref name="args" /> tablicy.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Porady: definiowanie i użycie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący jednej z dwóch argumentów.</summary>
        <returns>Odwołanie do tego wystąpienia przy użyciu <paramref name="format" /> dołączane. Każdy element formatu w <paramref name="format" /> zostaje zastąpiona przez ciąg reprezentujący odpowiadający argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametru składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają `arg0` i `arg1`, dwa obiekty na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciąg reprezentujący odpowiadający mu obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` i `arg1` reprezentowania obiektów do sformatowania. Każdy element formatu w `format` jest zastępowany ciągiem reprezentującym albo `arg0` lub `arg1`. Jeśli element formatu zawiera `formatString` i odpowiedni obiekt implementuje <xref:System.IFormattable> interfejsu, następnie `arg` *x* `.ToString(formatString, provider)` definiuje formatowanie, gdzie *x* jest indeksem argumentu. W przeciwnym razie `arg` *x* `.ToString()` definiuje formatowanie.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje oddawania {0: ###} puszek żywności naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10 zwracaną wartością będzie "Dziękujemy darowizn, 10 puszek żywności naszej organizacji charytatywnej."  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równa 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący jednej z dwóch argumentów, za pomocą dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania. Po zakończeniu operacji dołączania, to wystąpienie zawiera żadnych danych, które istniały przed wykonaniem operacji sufiks przez kopię <paramref name="format" /> gdzie wszelkie specyfikacji formatu jest zastępowana ciąg reprezentujący odpowiadający argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciąg reprezentujący odpowiadający mu obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Parametr określa <xref:System.IFormatProvider> implementację, która może zapewnić informacje o formatowaniu `arg0` i `arg1`. `provider` może być dowolny z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury `arg0` lub `arg1` jeśli są one wartości numeryczne.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury `arg0` lub `arg1` przypadku wartości daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje o formatowaniu `arg0` i `arg1`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu.  
  
 Jeśli `provider` parametr jest `null`, informacje o dostawcy formatu jest uzyskiwana z bieżącej kultury.  
  
 `arg0` i `arg1` reprezentowania obiektów do sformatowania. Każdy element formatu w `format` zostaje zastąpiona opcją ciąg reprezentujący obiekt, który ma odpowiedni indeks. Jeśli element formatu zawiera `formatString` i implementuje odnośnego argumentu <xref:System.IFormattable> interfejsu, a następnie argument `ToString(formatString, provider)` metoda definiuje formatowanie. W przeciwnym razie argument `ToString()` metoda definiuje formatowanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> metodę w celu wyświetlenia czasu i temperatury — dane przechowywane w ogólnej metodzie <xref:System.Collections.Generic.Dictionary%602> obiektu. Należy pamiętać, że ciąg formatu, który ma trzy elementy formatu, chociaż występują tylko do obiektów do sformatowania. Jest to spowodowane pierwszy obiekt na liście (wartość daty i godziny) jest używany przez dwa elementy w formacie: pierwszy wyświetla element formatu czasu, a drugi Wyświetla datę.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większa niż lub równe 2 ().</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>Profilowanie platformy .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Porady: definiowanie i użycie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący jednej z trzech argumentów.</summary>
        <returns>Odwołanie do tego wystąpienia przy użyciu <paramref name="format" /> dołączane. Każdy element formatu w <paramref name="format" /> zostaje zastąpiona przez ciąg reprezentujący odpowiadający argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametru składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odpowiadają `arg0` za pośrednictwem `arg2`, obiekty na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciąg reprezentujący odpowiadający mu obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, i `arg2` reprezentowania obiektów do sformatowania. Każdy element formatu w `format` jest zastępowany ciągiem reprezentującym albo `arg0`, `arg1`, lub `arg2`, w zależności od indeks elementu formatu. Jeśli element formatu zawiera `formatString` i odpowiadający mu obiekt `args` implementuje <xref:System.IFormattable> interfejsu, następnie `arg` *x* `.ToString(formatString, null)` definiuje formatowanie, gdzie  *x* jest indeksem argumentu. W przeciwnym razie `arg` *x* `.ToString()` definiuje formatowanie.  
  
 Jeśli ten ciąg jest przypisany do `format` jest "Dziękujemy za Twoje oddawania {0: ###} puszek żywności naszej organizacji charytatywnej." i `arg0` jest liczbą całkowitą o wartości 10 zwracaną wartością będzie "Dziękujemy darowizn, 10 puszek żywności naszej organizacji charytatywnej."  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendFormat%2A> metody.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większą lub równą 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Obiekt, który dostarcza informacje o formatowaniu specyficzne dla kultury.</param>
        <param name="format">Ciąg formatu złożonego.</param>
        <param name="arg0">Pierwszy obiekt do sformatowania.</param>
        <param name="arg1">Drugi obiekt do sformatowania.</param>
        <param name="arg2">Trzeci obiekt do sformatowania.</param>
        <summary>Dołącza ciąg zwracany przez przetwarzanie ciąg formatu złożonego, który zawiera zero lub więcej elementów formatu, z tym wystąpieniem. Każdy element formatu jest zastępowana przez ciąg reprezentujący jednej z trzech argumentów, za pomocą dostawcy określonego formatu.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania. Po zakończeniu operacji dołączania, to wystąpienie zawiera żadnych danych, które istniały przed wykonaniem operacji sufiks przez kopię <paramref name="format" /> gdzie wszelkie specyfikacji formatu jest zastępowana ciąg reprezentujący odpowiadający argument obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa [funkcję formatowania złożonego](~/docs/standard/base-types/composite-formatting.md) programu .NET Framework, aby dokonać konwersji wartości obiektu na jego reprezentację tekstową i osadza tę reprezentację w bieżącym <xref:System.Text.StringBuilder> obiektu.  
  
 `format` Parametr składa się z zera lub więcej przebiegów tekstu zmieszać z zero lub więcej indeksowanymi symbolami zastępczymi zwanymi elementami formatu, które odnoszą się do obiektów na liście parametrów tej metody. Proces formatowania zastępuje każdy element formatu ciąg reprezentujący odpowiadający mu obiekt.  
  
 Składnia elementu format jest następujący:  
  
 {*indeksu*[,*długość*] [:*formatString*]}  
  
 Elementy w nawiasach kwadratowych są opcjonalne. W tabeli poniżej opisano każdy element.  
  
|Element|Opis|  
|-------------|-----------------|  
|*index*|Liczony od zera pozycja na liście parametrów obiekt do sformatowania. Jeśli obiekt określony przez *indeksu* jest `null`, zastępuje element formatu <xref:System.String.Empty?displayProperty=nameWithType>. Jeśli nie ma parametru w *indeksu* pozycji <xref:System.FormatException> zgłaszany.|  
|,*długość*|Minimalna liczba znaków w ciągu reprezentującym parametru. Jeśli jest to dodatnia, parametr jest wyrównany do prawej; Jeśli jest negatywny, jest wyrównany do lewej.|  
|:*formatString*|Ciąg formatu standardowego lub niestandardowego, który jest obsługiwany przez parametr.|  
  
> [!NOTE]
>  Ciągi formatu standardowego i niestandardowego używane z wartości daty i godziny, zobacz [standardowych ciągów daty i godziny Format](~/docs/standard/base-types/standard-date-and-time-format-strings.md) i [niestandardowych ciągów daty i godziny Format](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Ciągi formatu standardowego i niestandardowego używania z wartościami liczbowymi, zobacz [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) i [liczbowe — niestandardowe ciągi formatujące](~/docs/standard/base-types/custom-numeric-format-strings.md). Ciągi formatu standardowego, używany przy użyciu wyliczeń, zobacz [wyliczanie ciągów formatujących](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `provider` Parametr określa <xref:System.IFormatProvider> implementację, która może zapewnić informacje o formatowaniu `arg0` i `arg1`. `provider` może być dowolny z następujących czynności:  
  
-   Element <xref:System.Globalization.CultureInfo> obiektu, który dostarcza informacje o formatowaniu specyficzne dla kultury.  
  
-   A <xref:System.Globalization.NumberFormatInfo> obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury `arg0` lub `arg1` jeśli są one wartości numeryczne.  
  
-   A <xref:System.Globalization.DateTimeFormatInfo> obiekt, który zawiera informacje o formatowaniu specyficzne dla kultury `arg0`, `arg1`, lub `arg2` przypadku wartości daty i godziny.  
  
-   Niestandardowy <xref:System.IFormatProvider> implementację, która zawiera informacje o formatowaniu `arg0`, `arg1`, i `arg2`. Zazwyczaj takie implementację implementuje również <xref:System.ICustomFormatter> interfejsu.  
  
 Jeśli `provider` parametr jest `null`, informacje o dostawcy formatu jest uzyskiwana z bieżącej kultury.  
  
 `arg0`, `arg1`, i `arg2` reprezentowania obiektów do sformatowania. Każdy element formatu w `format` zostaje zastąpiona opcją ciąg reprezentujący obiekt, który ma odpowiedni indeks. Jeśli element formatu zawiera `formatString` i implementuje odnośnego argumentu <xref:System.IFormattable> interfejsu, a następnie argument `ToString(formatString, provider)` metoda definiuje formatowanie. W przeciwnym razie argument `ToString()` metoda definiuje formatowanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> metodę, aby zilustrować wynik atrybut typu wartość logiczna `And` operację, podając wartości całkowitych. Należy pamiętać, ciąg formatu zawiera sześć elementów formatu, że metoda ma tylko trzy elementy w liście argumentów, ponieważ każdy element jest sformatowany na dwa różne sposoby.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> jest nieprawidłowy.  
  
—lub— 
Indeks elementu formatu jest mniejsza od 0 (zero), lub większą lub równą 3 (3).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Długość ciągu rozwiniętej spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Typy formatowania na platformie .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Złożone formatowanie</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Porady: definiowanie i użycie niestandardowych dostawców formatu liczbowego</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Niestandardowe ciągi formatujące liczby</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Standardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Niestandardowe ciągi formatujące datę i godzinę</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Standardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Niestandardowe ciągi formatujące TimeSpan</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Wyliczanie ciągów formatujących</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza terminator wiersza domyślne lub kopię określonego ciągu i terminator wiersza domyślne na końcu tego wystąpienia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza domyślną terminator wiersza na końcu bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślną jest bieżąca wartość <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.AppendLine%2A> metody.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ciąg do dołączenia.</param>
        <summary>Dołącza kopię określonego ciągu następuje domyślny terminator wiersza do końca bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji dołączania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Terminator wiersza domyślną jest bieżąca wartość <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> właściwości.  
  
 Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <see cref="T:System.Text.StringBuilder" /> obiektu przez wywołanie metody <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> konstruktora, długość i pojemność <see cref="T:System.Text.StringBuilder" /> wystąpienia może rosnąć poza wartość jego <see cref="P:System.Text.StringBuilder.MaxCapacity" /> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <see cref="M:System.Text.StringBuilder.Append(System.String)" /> i <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> metody, aby dołączyć ciągi małe.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę znaków, które mogą być zawarte w pamięci przydzielonej przez bieżące wystąpienie.</summary>
        <value>Maksymalna liczba znaków, które mogą być zawarte w pamięci przydzielonej przez bieżące wystąpienie. Wartość może wynosić od <see cref="P:System.Text.StringBuilder.Length" /> do <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> nie ma wpływu na wartość ciągu bieżącego wystąpienia. <xref:System.Text.StringBuilder.Capacity%2A> można zmniejszyć tak długo, jak nie jest mniejsza niż <xref:System.Text.StringBuilder.Length%2A>.  
  
 <xref:System.Text.StringBuilder> Dynamicznie przydziela więcej miejsca w sytuacji, gdy jest to wymagane i zwiększa <xref:System.Text.StringBuilder.Capacity%2A> odpowiednio. Ze względu na wydajność <xref:System.Text.StringBuilder> może przydzielić więcej pamięci niż jest to potrzebne. Ilość pamięci przydzielonej jest specyficzne dla implementacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Capacity%2A> właściwości.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza niż bieżąca długość tego wystąpienia.  
  
—lub— 
Wartość określona dla operacji zestawu jest większa niż wydajność Maksymalna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja znaku.</param>
        <summary>Pobiera lub ustawia znak na pozycji określony znak, w tym wystąpieniu.</summary>
        <value>Znak Unicode w położeniu <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index` Parametr jest pozycja znaku w ciągu <xref:System.Text.StringBuilder>. Pierwszy znak w ciągu jest pod indeksem 0. Długość ciągu jest liczbą znaków zawartych w nim. Ostatni znak dostępny <xref:System.Text.StringBuilder> wystąpienie jest indeksem <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> jest domyślna właściwość <xref:System.Text.StringBuilder> klasy. W języku C# jest indeksator. Oznacza to, że można pobrać pojedynczych znaków z <xref:System.Text.StringBuilder.Chars%2A> właściwości, jak pokazano w poniższym przykładzie, który zlicza alfabetyczne, odstępu oraz znaków interpunkcyjnych, w ciągu.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Wydajność i opartego na znakach indeksowania

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> Podczas ustawiania znak, jest poza granicami tego wystąpienia.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> podczas pobierania znak, jest poza granicami tego wystąpienia.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie znaki od bieżącego <see cref="T:System.Text.StringBuilder" /> wystąpienia.</summary>
        <returns>Obiekt którego <see cref="P:System.Text.StringBuilder.Length" /> ma wartość 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A> jest to wygodna metoda, który jest odpowiednikiem ustawienia <xref:System.Text.StringBuilder.Length%2A> właściwości bieżącego wystąpienia 0 (zero).  
  
 Wywoływanie <xref:System.Text.StringBuilder.Clear%2A> metoda nie powoduje modyfikacji bieżącego wystąpienia <xref:System.Text.StringBuilder.Capacity%2A> lub <xref:System.Text.StringBuilder.MaxCapacity%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Text.StringBuilder> obiektu przy użyciu parametrów, wywołania <xref:System.Text.StringBuilder.Clear%2A> metody, a następnie dołącza nowe parametry.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Pozycja początkowa w tym wystąpieniu której znaki będą kopiowane z. Jest to indeks zaczynający się od zera.</param>
        <param name="destination">Tablica, do której zostaną skopiowane znaków.</param>
        <param name="destinationIndex">Pozycja początkowa w <paramref name="destination" /> której zostaną skopiowane znaków. Jest to indeks zaczynający się od zera.</param>
        <param name="count">Liczba znaków do skopiowania.</param>
        <summary>Kopiuje znaków z określonego segmentu tego wystąpienia określony segment miejsca docelowego <see cref="T:System.Char" /> tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A> Metoda jest przeznaczona do użycia w rzadkich sytuacji, gdy trzeba wydajnie kopiować kolejne sekcje <xref:System.Text.StringBuilder> obiekt jako tablicę. Tablica powinna być o stałym rozmiarze przydzielony wstępnie wielokrotnego użytku i prawdopodobnie globalnie dostępne.  
  
 Na przykład można wypełnić aplikacji <xref:System.Text.StringBuilder> obiektów z dużą liczbą znaków, a następnie użyj <xref:System.Text.StringBuilder.CopyTo%2A> metoda kopiowania małe, kolejne części <xref:System.Text.StringBuilder> obiekt jako tablicę, której elementy są przetwarzane. Gdy wszystkie dane w <xref:System.Text.StringBuilder> obiekt jest przetwarzany, rozmiar <xref:System.Text.StringBuilder> obiektu jest ustawiona na zero, a cykl jest powtarzany.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.CopyTo%2A> metody.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" />, lub <paramref name="count" />, jest mniejsza niż zero.  
  
—lub— 
 <paramref name="sourceIndex" /> jest większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> jest większa od długości tego wystąpienia.  
  
—lub— 
 <paramref name="destinationIndex" /> + <paramref name="count" /> jest większa niż długość <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Minimalne możliwości zapewnienia.</param>
        <summary>Zapewnia, że pojemność to wystąpienie <see cref="T:System.Text.StringBuilder" /> jest co najmniej określonej wartości.</summary>
        <returns>Nową pojemność tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pojemność jest mniejsza niż `capacity` parametru pamięci dla tego wystąpienia są ponownie przydzielane co najmniej `capacity` liczby znaków; w przeciwnym razie pamięć nie zostanie zmieniony.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.EnsureCapacity%2A> metody.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż zero.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Obiekt do porównania z tym wystąpieniem lub <see langword="null" />.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns><see langword="true" /> Jeśli to wystąpienie i <paramref name="sb" /> mają taki sam ciąg <see cref="P:System.Text.StringBuilder.Capacity" />, i <see cref="P:System.Text.StringBuilder.MaxCapacity" /> wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod używa <xref:System.Text.StringBuilder.Equals%2A> metodę sprawdzania, czy dwa <xref:System.Text.StringBuilder> obiekty są sobie równe. Metoda jest wywoływana wielokrotnie po niewielkie zmiany zostały wprowadzone do każdego obiektu, a wyniki są wyświetlane w konsoli.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia ciąg reprezentujący określony obiekt do tego wystąpienia na określonej pozycji znaku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący wartość typu Boolean do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego 8-bitowa liczba całkowita bez znaku do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia określony znak Unicode reprezentację ciągu do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Tablica znaków do wstawienia.</param>
        <summary>Wstawia reprezentację określonej tablicy znaków Unicode do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 Jeśli `value` jest `null`, <xref:System.Text.StringBuilder> nie ulegną zmianie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący liczbę dziesiętną do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący liczbę zmiennoprzecinkową podwójnej precyzji do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego całkowita 16-bitowych do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego całkowita 32-bitowego do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu 64-bitowych całkowita do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Obiekt do wstawienia, lub <see langword="null" />.</param>
        <summary>Wstawia reprezentację ciągu obiektu do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 Jeśli `value` jest `null`, wartość tego wystąpienia jest bez zmian.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu określonego całkowita 8-bitowych do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu pojedynczej precyzji liczbę zmiennoprzecinkową do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <summary>Wstawia ciąg do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność jest dostosowywany zgodnie z potrzebami.  
  
 To wystąpienie <xref:System.Text.StringBuilder> nie ulega zmianie, jeśli `value` jest `null`, lub `value` nie `null` , ale jego długość wynosi zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa niż bieżąca długość tego wystąpienia.  
  
—lub— 
Bieżąca długość <see cref="T:System.Text.StringBuilder" /> obiektu plus długość <paramref name="value" /> przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący 16-bitowa liczba całkowita bez znaku do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia ciąg reprezentujący 32-bitowa liczba całkowita bez znaku do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Wartość do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu 64-bitowej nieoznaczonej liczby całkowitej do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> Służy do uzyskiwania reprezentację ciągu `value`. Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa od długości tego wystąpienia.</exception>
        <exception cref="T:System.OutOfMemoryException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>W [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] i wcześniejszych wersjach, wywołania tej metody zgłosił <see cref="T:System.ArgumentOutOfRangeException" /> Jeśli wstawianie <paramref name="value" /> spowodowałoby obiektu całkowita długość przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], metoda zgłasza <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Ciąg do wstawienia.</param>
        <param name="count">Ile razy, aby wstawić <paramref name="value" />.</param>
        <summary>Wstawia jednego lub większej liczby kopii określonego ciągu do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
 To <xref:System.Text.StringBuilder> obiektu nie jest zmieniane, gdy `value` jest `null`, `value` nie `null` , ale jego długość wynosi zero, lub `count` wynosi zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza od zera lub większa niż bieżąca długość tego wystąpienia.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.OutOfMemoryException">Bieżąca długość <see cref="T:System.Text.StringBuilder" /> obiektu plus długość <paramref name="value" /> razy <paramref name="count" /> przekracza <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w tym wystąpieniu, w którym rozpoczyna się wstawiania.</param>
        <param name="value">Tablica znaków.</param>
        <param name="startIndex">Wartość początkowa indeksu w ramach <paramref name="value" />.</param>
        <param name="charCount">Liczba znaków do wstawienia.</param>
        <summary>Wstawia reprezentację ciągu podtablicę o określonej długości, znaków Unicode do tego wystąpienia na określonej pozycji znaku.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji wstawiania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istniejące znaki są przesuwane aby zwolnić miejsce na nowy tekst. Pojemność to wystąpienie jest dostosowywany zgodnie z potrzebami.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Insert%2A> metody.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> jest <see langword="null" />, i <paramref name="startIndex" /> i <paramref name="charCount" /> nie mają wartość zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" />, lub <paramref name="charCount" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> jest większa od długości tego wystąpienia.  
  
—lub— 
 <paramref name="startIndex" /> plus <paramref name="charCount" /> nie jest pozycją w parametrze <paramref name="value" />.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia długość bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <value>Długość tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość <xref:System.Text.StringBuilder> obiekt jest zdefiniowany przez jego liczbę <xref:System.Char> obiektów.  
  
 Podobnie jak <xref:System.String.Length%2A?displayProperty=nameWithType> właściwości <xref:System.Text.StringBuilder.Length%2A> właściwość wskazuje długość bieżący obiekt ciągu. W odróżnieniu od <xref:System.String.Length%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu, <xref:System.Text.StringBuilder.Length%2A> właściwość umożliwia modyfikowanie długości ciągu przechowywanych <xref:System.Text.StringBuilder> obiektu.  
  
 Jeśli określona długość jest mniejsza niż bieżąca długość bieżącej <xref:System.Text.StringBuilder> obiektu jest obcinana do określonej długości. Jeśli określona długość jest większa niż bieżąca długość, a na końcu wartości ciągu bieżącego <xref:System.Text.StringBuilder> obiektu są dopełniane przy użyciu znaków Unicode o wartości NULL (U + 0000).  
  
 Jeśli określona długość jest większa niż bieżąca pojemność <xref:System.Text.StringBuilder.Capacity%2A> zwiększa się, aby była większa niż lub równa określonej długości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Length%2A> właściwości.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość określona dla operacji zestawu jest mniejsza od zera lub większa niż <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną pojemność to wystąpienie.</summary>
        <value>Maksymalna liczba znaków, które może przechowywać tego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna pojemność dla tej implementacji jest <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Jednak ta wartość jest specyficzne dla implementacji i może różnić się we wdrożeniach innych lub nowszej. Można jawnie ustawić maksymalną pojemność wynoszącą <xref:System.Text.StringBuilder> obiektu przez wywołanie metody <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> konstruktora.  
  
W .NET Core i .NET Framework 4.0 i nowsze wersje, podczas tworzenia wystąpienia <xref:System.Text.StringBuilder> obiektu przez wywołanie metody <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> konstruktora, długość i pojemność <xref:System.Text.StringBuilder> wystąpienia może rosnąć poza wartość jego <xref:System.Text.StringBuilder.MaxCapacity> Właściwość. Taka sytuacja może wystąpić szczególnie, gdy zostanie wywołana <xref:System.Text.StringBuilder.Append(System.String)> i <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> metody, aby dołączyć ciągi małe.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Liczony od zera pozycja w tym wystąpieniu, w którym rozpoczyna się usuwanie.</param>
        <param name="length">Liczba znaków do usunięcia.</param>
        <summary>Usuwa określony zakres znaków, z tym wystąpieniem.</summary>
        <returns>Odwołanie do tego wystąpienia, po zakończeniu operacji akcyzy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżąca metoda usuwa określonego zakresu znaków z bieżącego wystąpienia. Znaki w (`startIndex` + `length`) są przenoszone do `startIndex`, i wartość ciągu bieżącego wystąpienia został skrócony przez `length`. Pojemność bieżące wystąpienie jest nienaruszona.  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> Metoda Modyfikuje wartości bieżącego <xref:System.Text.StringBuilder> wystąpienie i zwraca wartość tego wystąpienia. Tworzenie i nie zwraca nową <xref:System.Text.StringBuilder> obiektu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Remove%2A> metody.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Jeśli <paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza od zera, lub <paramref name="startIndex" />  +  <paramref name="length" /> jest większa od długości tego wystąpienia.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zamienia wszystkie wystąpienia określony znak lub ciąg, w tym wystąpieniu przy użyciu innego określony znak lub ciąg.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak do zastąpienia.</param>
        <param name="newChar">Znak zastępujący <paramref name="oldChar" />.</param>
        <summary>Zamienia wszystkie wystąpienia określonego znaku, w tym wystąpieniu innego określonego znaku.</summary>
        <returns>Odwołanie do tego wystąpienia przy użyciu <paramref name="oldChar" /> zastępuje <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe, wielkość liter do identyfikowania wystąpienia `oldChar` w ramach bieżącego wystąpienia. Rozmiar bieżącego <xref:System.Text.StringBuilder> wystąpienia pozostaje niezmieniony po zastąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg zamieniany.</param>
        <param name="newValue">Ciąg, który zastępuje <paramref name="oldValue" />, lub <see langword="null" />.</param>
        <summary>Zamienia wszystkie wystąpienia określonego ciągu w tym wystąpieniu innego określonego ciągu.</summary>
        <returns>Odwołanie do tego wystąpienia ze wszystkimi wystąpieniami <paramref name="oldValue" /> zastępuje <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe, wielkość liter do identyfikowania wystąpienia `oldValue` w ramach bieżącego wystąpienia. Jeśli `newValue` jest `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, wszystkie wystąpienia `oldValue` są usuwane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="oldValue" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Znak do zastąpienia.</param>
        <param name="newChar">Znak zastępujący <paramref name="oldChar" />.</param>
        <param name="startIndex">Pozycja w tym wystąpieniu, w którym podciąg rozpoczyna się.</param>
        <param name="count">Długość podciągu.</param>
        <summary>Zastępuje w ramach podciąg z tego wystąpienia, wszystkie wystąpienia określony znak na inny określony znak.</summary>
        <returns>Odwołanie do tego wystąpienia przy użyciu <paramref name="oldChar" /> zastępuje <paramref name="newChar" /> w zakresie od <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe, wielkość liter do identyfikowania wystąpienia `oldChar` w ramach bieżącego wystąpienia. Rozmiar bieżącego <xref:System.Text.StringBuilder> obiektu pozostaje niezmieniony po zastąpienia.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> jest większa niż długość wartość tego wystąpienia.  
  
—lub— 
 <paramref name="startIndex" /> lub <paramref name="count" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Ciąg zamieniany.</param>
        <param name="newValue">Ciąg, który zastępuje <paramref name="oldValue" />, lub <see langword="null" />.</param>
        <param name="startIndex">Pozycja w tym wystąpieniu, w którym podciąg rozpoczyna się.</param>
        <param name="count">Długość podciągu.</param>
        <summary>Zastępuje w ramach podciąg z tego wystąpienia, wszystkie wystąpienia określonego ciągu na inny określony ciąg.</summary>
        <returns>Odwołanie do tego wystąpienia ze wszystkimi wystąpieniami <paramref name="oldValue" /> zastępuje <paramref name="newValue" /> w zakresie od <paramref name="startIndex" /> do <paramref name="startIndex" />  +  <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykonuje porównanie porządkowe, wielkość liter do identyfikowania wystąpienia `oldValue` w podanym podciągiem. Jeśli `newValue` jest `null` lub <xref:System.String.Empty?displayProperty=nameWithType>, wszystkie wystąpienia `oldValue` są usuwane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Text.StringBuilder.Replace%2A> metody.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Długość <paramref name="oldValue" /> wynosi zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="startIndex" /> plus <paramref name="count" /> wskazuje pozycję znaku, w tym wystąpieniu.  
  
—lub— 
Powiększanie wartość tego wystąpienia spowoduje przekroczenie <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt do wypełnienia informacjami o serializacji.</param>
        <param name="context">Miejsce do przechowywania i pobierania serializowane dane. Zarezerwowane do użytku w przyszłości.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu z danymi, które są niezbędne do deserializacji bieżącego <see cref="T:System.Text.StringBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context` Parametr jest zarezerwowany do użytku w przyszłości i nie uczestniczy w tej operacji.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje wartość <see cref="T:System.Text.StringBuilder" /> do <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konwertuje wartość tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Ciąg, którego wartość jest taka sama, jak to wystąpienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.Text.StringBuilder.ToString%2A> metodę, aby przekonwertować <xref:System.Text.StringBuilder> obiekt <xref:System.String> obiekt przed można przekazać ciągu, reprezentowane przez <xref:System.Text.StringBuilder> obiekt do metody, która ma <xref:System.String> parametru lub wyświetlić ją w interfejsie użytkownika.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wywołanie <xref:System.Text.StringBuilder.ToString%2A> metody. W tym przykładzie jest częścią większego przykładu przewidzianego dla <xref:System.Text.StringBuilder> klasy.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Pozycja początkowa podciągu w tym wystąpieniu.</param>
        <param name="length">Długość podciągu.</param>
        <summary>Konwertuje wartość podciąg z tego wystąpienia <see cref="T:System.String" />.</summary>
        <returns>Ciąg, którego wartość jest taka sama jak określony podciąg tego wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.Text.StringBuilder.ToString%2A> metodę, aby przekonwertować <xref:System.Text.StringBuilder> obiekt <xref:System.String> obiekt przed można przekazać ciągu, reprezentowane przez <xref:System.Text.StringBuilder> obiekt do metody, która ma <xref:System.String> parametru lub wyświetlić ją w interfejsie użytkownika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> lub <paramref name="length" /> jest mniejsza niż zero.  
  
—lub— 
Suma <paramref name="startIndex" /> i <paramref name="length" /> jest większa niż długość bieżącego wystąpienia.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
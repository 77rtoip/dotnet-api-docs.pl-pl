<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37bb8ffd133cbb1ddd3c3fdd2f593086d39584aa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30580006" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowania UTF-16 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencję bajtów zakodowanego do zestawu znaków Unicode.  
  
 [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) przypisuje do każdego znaku w każdej obsługiwanej skryptu punkt kodu (numer). Format transformacji Unicode (UTF) to sposób kodowania tego punktu kodu. [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) używa następujących UTFs:  
  
-   UTF-8, który reprezentuje każdy punkt kodu sekwencję bajtów 1 do 4.  
  
-   UTF-16, który reprezentuje każdy punkt kodu jako sekwencja jednej do dwóch 16-bitowych liczb całkowitych.  
  
-   UTF-32 reprezentuje każdego punktu kod jako 32-bitową liczbę całkowitą.  
  
 Aby uzyskać więcej informacji o UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Klasa reprezentuje kodowania UTF-16. Koder można użyć albo kolejności bajtów big endian (najbardziej znaczący bajt pierwszy) lub little endian bajtów kolejności (najmniej znaczący bajt pierwszy). Na przykład Wielka litera (punkt kodu U + 0041) jest szeregowana jako zgodna (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian: 00 00 00 41  
  
-   Little endian bajtów kolejności: 41 00 00 00  
  
 Jest to zwykle wydajniejszym rozwiązaniem przechowywania znaków Unicode przy użyciu kolejność bajtów natywnej danej platformy. Na przykład lepiej jest użycie małego kolejność endian bajtów little endian platform, takich jak komputery Intel. <xref:System.Text.UnicodeEncoding> Klasa odpowiada stron kodowych Windows 1200 (little endian bajtów kolejność) i 1201 (kolejności bajtów big endian). Można określić "kolejności bajtów" Architektura określonego przez wywołanie metody <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> metody.  
  
 Opcjonalnie <xref:System.Text.UnicodeEncoding> obiektu zawiera znacznik kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzona do sekwencji bajtów procesu kodowania. Jeśli preambuły zawiera znacznik kolejności bajtów (BOM), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF.  
  
 Jeśli <xref:System.Text.UnicodeEncoding> wystąpienie jest skonfigurowane w celu zapewnienia BOM, mogą być pobierane przez wywołanie metody <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody; w przeciwnym razie metoda zwraca pustą tablicę. Należy zauważyć, że nawet jeśli <xref:System.Text.UnicodeEncoding> obiektu jest skonfigurowany na potrzeby obsługi BOM, musi zawierać BOM na początku strumień bajtów zakodowanego zależnie od potrzeb; kodowania metody <xref:System.Text.UnicodeEncoding> klasy nie należy tego robić automatycznie.  
  
 Aby włączyć wykrywanie błędów i zabezpieczyć wystąpienia klasy, należy utworzyć wystąpienia <xref:System.Text.UnicodeEncoding> obiektu przez wywołanie metody <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`. Z wykrywanie błędów wykrywający nieprawidłową sekwencję znaków lub bajtów metodę <xref:System.ArgumentException>. Bez wykrywanie błędów nie wyjątku i Nieprawidłowa sekwencja jest brany pod uwagę.  
  
 Można utworzyć wystąpienia <xref:System.Text.UnicodeEncoding> obiekt na kilka sposobów, w zależności od tego, czy chcesz go zapewnienie znacznika kolejności bajtów (BOM), czy ma big-endian lub little endian kodowania i określa, czy chcesz włączyć wykrywanie błędów. W poniższej tabeli wymieniono <xref:System.Text.UnicodeEncoding> konstruktory i <xref:System.Text.Encoding> właściwości, które zwracają <xref:System.Text.UnicodeEncoding> obiektu.  
  
|Element członkowski|Kolejności bajtów|BOM|Wykrywanie błędów|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Tak|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little endian|Tak|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little endian|Tak|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Możliwość konfiguracji|Możliwość konfiguracji|(Zastępczy rezerwowe nie)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda określa liczbę bajtów powoduje Kodowanie zestawu znaków Unicode i <xref:System.Text.UnicodeEncoding.GetBytes%2A> metoda przeprowadza rzeczywistym kodowaniem.  
  
 Podobnie <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowania sekwencję bajtów i <xref:System.Text.UnicodeEncoding.GetChars%2A> i <xref:System.Text.UnicodeEncoding.GetString%2A> metody wykonać dekodowanie rzeczywistych.  
  
 Koder i dekoder, który może zapisać informacji o stanie podczas kodowania lub dekodowania danych obejmującej wiele bloków (na przykład ciąg znaków 1 milion zakodowany w segmentach 100 000 znaków), użyj <xref:System.Text.UnicodeEncoding.GetEncoder%2A> i <xref:System.Text.UnicodeEncoding.GetDecoder%2A> właściwości odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób kodowania ciąg znaków Unicode do tablicy typu byte przy użyciu <xref:System.Text.UnicodeEncoding> obiektu. Tablica bajtów jest dekodowany na ciąg, aby wykazać, że jest bez utraty danych.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 W poniższym przykładzie użyto tych samych parametrach jak poprzedni, z wyjątkiem tego, który zapisuje bajty zakodowanym w pliku i prefiksy strumień bajtów z znacznika kolejności bajtów (BOM). Następnie odczytuje plik na dwa sposoby: jako pliku tekstowego za pomocą <xref:System.IO.StreamReader> obiekt; i jako plik binarny. Jak można oczekiwać w przypadku ani BOM znajduje się w ciągu nowo odczytu.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które używa małego kolejności bajtów endian, zawiera znacznik kolejności bajtów Unicode i nie zgłasza wyjątek po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nową <xref:System.Text.UnicodeEncoding> wystąpień i wyświetlanie nazwy kodowania.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> Aby użyć kolejności bajtów big endian (najbardziej znaczący bajt pierwszy), lub <see langword="false" /> do kolejność little endian bajtów (najmniej znaczący bajt pierwszy).</param>
        <param name="byteOrderMark">
          <see langword="true" /> Aby określić, że <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> metoda zwraca znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy. Parametry określają, czy używać kolejności bajtów big endian oraz tego, czy <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> metoda zwraca znacznik kolejności bajtów Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątek po wykryciu Nieprawidłowe kodowanie.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`.  
  
 `byteOrderMark` Parametr steruje działaniem <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą znacznika kolejności bajtów Unicode (BOM) w formacie UTF-16.  Jeśli `false`, zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `byteOrderMark` do `true` nie powoduje <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodę prefiksu BOM na początku tablicy bajtów ani go powoduje <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodę w celu uwzględnienia liczba bajtów w BOM liczba bajtów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć nową <xref:System.Text.UnicodeEncoding> znacznik kolejności wystąpienia określająca, czy do obsługi porządkowanie little endian lub big endian bajt i bajtów Unicode.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> Aby użyć kolejności bajtów big endian (najbardziej znaczący bajt pierwszy); <see langword="false" /> do kolejność little endian bajtów (najmniej znaczący bajt pierwszy).</param>
        <param name="byteOrderMark">
          <see langword="true" /> Aby określić, że <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> metoda zwraca znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> Aby określić, czy wyjątek powinien generowany po wykryciu Nieprawidłowe kodowanie; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy. Parametry określają, czy ma być używany w kolejności bajtów big endian, czy ma zostać udostępniona znacznika kolejności bajtów Unicode i czy należy zgłosić wyjątek, jeśli zostanie wykryte nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `byteOrderMark` Parametr steruje działaniem <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą znacznika kolejności bajtów Unicode (BOM) w formacie UTF-16.  Jeśli `false`, zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `byteOrderMark` do `true` nie powoduje <xref:System.Text.UnicodeEncoding.GetBytes%2A> metodę prefiksu BOM na początku tablicy bajtów ani go powoduje <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodę w celu uwzględnienia liczba bajtów w BOM liczba bajtów.  
  
 Jeśli `throwOnInvalidBytes` parametr jest `true`, zgłasza metodę, która wykrywa sekwencji nieprawidłowy bajt <xref:System.ArgumentException?displayProperty=nameWithType>. W przeciwnym razie metoda nie zgłasza wyjątek i Nieprawidłowa sekwencja jest ignorowana.  
  
> [!NOTE]
>  Ze względów bezpieczeństwa zaleca się aplikacji umożliwiają utworzenie wystąpienia tego konstruktora <xref:System.Text.UnicodeEncoding> klasy i włączyć wykrywanie błędów przez ustawienie `throwOnInvalidBytes` do `true`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zachowanie <xref:System.Text.UnicodeEncoding>, zarówno z włączoną wykrywanie błędów i bez niego.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Reprezentuje wyrażony w bajtach rozmiar znaków Unicode. To pole jest stałą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest stałą podpisem 32-bitowe o wartości 2.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób zwracania wartości <xref:System.Text.UnicodeEncoding.CharSize> i wyświetl ją.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> jest taki sam, jak bieżący <see cref="T:System.Text.UnicodeEncoding" /> obiektu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.UnicodeEncoding" /> i jest taki sam jak bieżący obiekt, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UnicodeEncoding> obiekty są traktowane jako równe, jeśli spełnione są wszystkie poniższe warunki:  
  
-   Oba obiekty używają tej samej kolejności bajtów (little endian lub big endian).  
  
-   Oba obiekty Podaj znacznika kolejności bajtów, lub obie nie.  
  
-   Zarówno do obiektów, użyj tego samego kodera rezerwowego.  
  
-   Oba obiekty Użyj tego samego dekoder rezerwowego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.Equals%2A> metody do testowania czy bieżące <xref:System.Text.UnicodeEncoding> obiekt jest taki sam innej <xref:System.Text.UnicodeEncoding> obiektu. Pięć <xref:System.Text.UnicodeEncoding> obiekty są tworzone i porównać i są wyświetlane wyniki porównania.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera zestaw znaków kodowania.</param>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie znaków w określonym ciągu.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialność i liczba bajtów w preambuły nie zostaną uwzględnione w wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> — metoda.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> i <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metody do obliczenia maksymalnej rzeczywista liczba bajtów potrzebna, aby zakodować ciąg. Wyświetla rzeczywistą liczbę bajtów wymaganą do zapisania strumień bajtów z znacznik kolejności bajtów.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów wyprodukowanych przez kodowanie zestawu znaków, zaczynając od wskaźnika określony znak.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.UnicodeEncoding.GetBytes%2A> wymaga do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialność i liczba bajtów w preambuły nie zostaną uwzględnione w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> — metoda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="count">Liczba znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów utworzonego przez zestaw znaków z określoną tablicę znaków kodowania.</summary>
        <returns>Liczba bajtów wyprodukowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów jest włączone, nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialność i liczba bajtów w preambuły nie zostaną uwzględnione w wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> — metoda.  
  
   
  
## Examples  
 Poniższy przykład powoduje wypełnienie tablicy o Latin wielkich i małych liter oraz wywołania <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę, aby określić liczbę bajtów potrzebne do kodowania znaki małe litery alfabetu łacińskiego. Następnie wyświetla te informacje oraz całkowita liczba bajtów, niezbędny w przypadku dodaniu znacznik kolejności bajtów. Następuje porównanie z wartością zwróconą przez ten numer <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, która określa maksymalną liczbę bajtów potrzebne do kodowania znaki małe litery alfabetu łacińskiego. Poniższy przykład wypełnia tablicę z kombinacją grecki i cyrylicy, znaków i wywołania <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę, aby określić liczbę bajtów potrzebne do kodowania znaków cyrylicy. Następnie wyświetla te informacje oraz całkowita liczba bajtów, niezbędny w przypadku dodaniu znacznik kolejności bajtów. Następuje porównanie z wartością zwróconą przez ten numer <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, która określa maksymalną liczbę bajtów potrzebne do kodowania znaków cyrylicy.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestaw znaków w kolejności bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od wskaźnika określony znak do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określonym bajcie.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.UnicodeEncoding.GetBytes%2A> wymaga do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku jeśli ilości danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczony przez obiekt <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody odpowiednio.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialny za dewelopera. <xref:System.Text.UnicodeEncoding.GetBytes%2A> — Metoda nie dołączy preambuły na początku sekwencji zakodowanego bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
 —lub—  
  
 <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialny za dewelopera. <xref:System.Text.UnicodeEncoding.GetBytes%2A> — Metoda nie dołączy preambuły na początku sekwencji zakodowanego bajtów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.GetBytes%2A> do kodowania zakres znaków z <xref:System.String> i przechowywać zakodowanego bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
 —lub—  
  
 <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku w celu kodowania.</param>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <param name="bytes">Tablica bajtów do zawierają wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks w którym należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć rozmiaru tablicy maksymalna, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!NOTE]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować podczas zapisywania pliku lub strumienia, można prefiks strumień bajtów zakodowanego z preambuły. Wstawianie preambuły na początku strumień bajtów (takich jak na początku serię bajtów do zapisania pliku) jest odpowiedzialny za dewelopera. <xref:System.Text.UnicodeEncoding.GetBytes%2A> — Metoda nie dołączy preambuły na początku sekwencji zakodowanego bajtów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób kodowania zakresu elementów z tablicy znaków Unicode i przechowywania zakodowanego bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="charIndex" /> i <paramref name="charCount" /> określa nieprawidłowy zakres w <paramref name="chars" />.  
  
 —lub—  
  
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  
  
 —lub—  
  
 <paramref name="bytes" /> nie ma wystarczającej wydajności z <paramref name="byteIndex" /> do końca tablicy, tak aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów, licząc od wskaźnika określonym bajcie.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.UnicodeEncoding.GetChars%2A> wymaga, aby przechowywać wynikowe znaki aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków utworzonego przez dekodowania sekwencję bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków utworzone przez użytkownika do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metoda zwraca liczbę znaków utworzonego przez dekodowania szereg elementów w tablicy bajtów przy użyciu <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisu.</param>
        <summary>Dekoduje sekwencję bajtów, licząc od wskaźnika określonym bajcie do zestawu znaków, które są przechowywane, zaczynając od wskaźnika określony znak.</summary>
        <returns>Rzeczywista liczba znaków zapisany w lokalizacji wskazanej przez <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia dokładne tablicy rozmiaru <xref:System.Text.UnicodeEncoding.GetChars%2A> wymaga, aby przechowywać wynikowe znaki aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Jeśli zakres bajtów ma być zdekodowany zawiera znacznika kolejności bajtów (BOM) i Tablica bajtów został zwrócony przez metodę typu pamiętać z systemem innym niż BOM, znak U + FFFE znajduje się w tablicy znaków zwracane przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku jeśli ilości danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczony przez obiekt <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
 —lub—  
  
 <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu zdekodować.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, w którym należy rozpocząć pisanie powstałe w ten sposób zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z określonej tablicy bajtów do określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków w zapisywane <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Jeśli zakres bajtów ma być zdekodowany zawiera znacznika kolejności bajtów (BOM) i Tablica bajtów został zwrócony przez metodę typu pamiętać z systemem innym niż BOM, znak U + FFFE znajduje się w tablicy znaków zwracane przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W takim przypadku lub jeśli ilość danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczonych przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.GetChars%2A> sposób dekodowania zakresu elementów w tablicy bajtowej i zapisać wynik w tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
 —lub—  
  
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="byteindex" /> i <paramref name="byteCount" /> określa nieprawidłowy zakres w <paramref name="bytes" />.  
  
 —lub—  
  
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
 —lub—  
  
 <paramref name="chars" /> nie ma wystarczającej wydajności z <paramref name="charIndex" /> do końca tablicy, tak aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje sekwencję zakodowane UTF-16 bajtów na sekwencję znaków Unicode.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> w sekwencji znaków Unicode, który konwertuje sekwencję zakodowane UTF-16 bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów na bloki kolejnych znaków w sposób podobny do <xref:System.Text.UnicodeEncoding.GetChars%2A>. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami tak on prawidłowo zdekodować sekwencji bajtów, obejmujące bloków. <xref:System.Text.Decoder> Również zachowuje bajtów końcowych na końcu bloki danych i używa bajtów końcowych w następnej operacji dekodowania. W związku z tym <xref:System.Text.UnicodeEncoding.GetDecoder%2A> i <xref:System.Text.UnicodeEncoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
 Jeśli wykrywanie błędów jest włączona, oznacza to, `throwOnInvalidBytes` ustawiono parametr konstruktora `true`, wykrywanie błędów również jest włączone w <xref:System.Text.Decoder> zwracane przez tę metodę. Napotkano nieprawidłową sekwencję wykrywanie błędów jest włączone, stan dekodera jest niezdefiniowane i przetwarzania należy zatrzymać.  
  
   
  
## Examples  
 W poniższym przykładzie użyto koder i dekoder, aby zakodować ciąg na tablicę bajtów, a następnie dekodowania bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencji znaków Unicode do sekwencji zakodowane UTF-16 bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> obiekt, który konwertuje sekwencji znaków Unicode, UTF-16 zakodowane sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków na kolejne bloki bajtów w sposób podobny do <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody tej klasy. Jednak <xref:System.Text.Encoder> obiekt przechowuje informacje o stanie między wywołaniami tak, aby ją poprawnie kodowania sekwencji znaków, które obejmują bloków. <xref:System.Text.Encoder> Obiektu również zachowuje znakami na końcu bloki danych i używa znaki końcowe w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane zastępczym wysokiego poziomu, a pasujące dwuskładnikowego może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.UnicodeEncoding.GetDecoder%2A> i <xref:System.Text.UnicodeEncoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często przeciwdziałania bloków danych zamiast strumienia pełnych danych.  
  
 Jeśli wykrywanie błędów jest włączona, czyli `throwOnInvalidBytes` ustawiono parametr konstruktora `true`, wykrywanie błędów również jest włączone w <xref:System.Text.Encoder> obiektu zwróconego przez tę metodę. Napotkano nieprawidłową sekwencję wykrywanie błędów jest włączone, stan koder jest niezdefiniowane i przetwarzania należy zatrzymać.  
  
   
  
## Examples  
 W poniższym przykładzie użyto koder i dekoder, aby zakodować ciąg na tablicę bajtów, a następnie dekodowania bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Text.UnicodeEncoding" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do kodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów utworzone przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów utworzone przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> pobiera najgorszych numer, tym najgorszego dla aktualnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> może zwrócić dużej wartości.  
  
 W większości przypadków ta metoda pobiera uzasadnione numery dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach przekroczenie bardziej przystępne buforu. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.UnicodeEncoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> nie ma związku <xref:System.Text.UnicodeEncoding.GetChars%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UnicodeEncoding.GetChars%2A>, należy go używać <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, aby zwrócić maksymalną liczbę bajtów wymaganą do kodowania określoną liczbę znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, utworzonego przez dekodowania określoną liczbę bajtów.</summary>
        <returns>Maksymalna liczba znaków utworzonego przez dekodowania określoną liczbę bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczenia rozmiaru tablicy dokładne wymagane przez <xref:System.Text.UnicodeEncoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć rozmiaru tablicy maksymalna, należy używać aplikacji <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metody przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metody zazwyczaj wykonuje szybciej.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> pobiera najgorszych numer, tym najgorszego dla aktualnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> pobiera dużej wartości.  
  
 W większości przypadków ta metoda pobiera uzasadnione numery dla małych ciągów. Dla dużych ciągów może być konieczne wybranie bufory bardzo dużych i przechwytywanie błędy w rzadkich przypadkach przekroczenie bardziej przystępne buforu. Można także wziąć pod uwagę różne podejścia przy użyciu <xref:System.Text.UnicodeEncoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UnicodeEncoding.GetBytes%2A>, należy go używać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` nie jest zawsze taką samą wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodę, aby zwrócić maksymalną liczbę znaków utworzonego przez dekodowania określoną liczbę bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> jest mniejsza od zera.  
  
 —lub—  
  
 Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może być zwracany w postaci liczby całkowitej.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowane w formacie UTF-16, jeśli znacznik kolejności bajtów żąda konstruktora dla tego wystąpienia.</summary>
        <returns>Tablica bajtów zawierająca znacznika kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UnicodeEncoding" /> obiektu jest skonfigurowany do go. W przeciwnym razie ta metoda zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiektu zapewniają preambuły jest tablica bajtów, które mogą być poprzedzona do sekwencji bajtów procesu kodowania. Prefacing sekwencję zakodowanego bajtów z znacznika kolejności bajtów (punkt kodu U + FEFF) pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Znacznika kolejności bajtów Unicode (BOM) jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian: FE FF  
  
-   Little endian bajtów kolejności: FF FE  
  
 Można utworzyć wystąpienia <xref:System.Text.UnicodeEncoding> którego <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metoda zwraca prawidłowe BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UnicodeEncoding> obiektu zwróconego przez <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> lub <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> właściwości.  
  
-   Wywołując bez parametrów <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktor do tworzenia wystąpienia <xref:System.Text.UnicodeEncoding> obiektu.  
  
-   Podając `true` jako wartość `byteOrderMark` argument <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> lub <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktorów.  
  
 Zaleca się, że używasz BOM, ponieważ zapewnia prawie niektórych identyfikacji kodowania plików, które w przeciwnym razie utracić odwołanie do ich kodowania, na przykład nieoznakowanego lub nieprawidłowo oznaczyć danych w sieci web lub losowego tekstu pliki przechowywane, jeśli firma nie miał międzynarodowe problemy. Często problemów użytkowników może można uniknąć, jeśli dane spójnie i odpowiednio oznakowane.  
  
 Standardów, które udostępniają typ kodowania BOM jest nieco nadmiarowy. Jednak można użyć ułatwiające serwer wysłał poprawne kodowania nagłówka. Alternatywnie może służyć jako rezerwowe w przypadku kodowanie, w przeciwnym razie zostaną utracone.  
  
 Dostępne są niektóre wady przy użyciu BOM. Na przykład wiedząc, jak ograniczyć pola bazy danych, które używają BOM może być trudne. Łączenie plików może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebnych może zakończyć środku danych. Mimo kilku wady jednak użycie BOM jest zdecydowanie zalecane.  
  
> [!CAUTION]
>  Aby upewnić się, że zakodowanego bajtów są prawidłowo zdekodować, powinien prefiks początek strumienia bajtów zakodowanego o preambuły. Należy pamiętać, że <xref:System.Text.UnicodeEncoding.GetBytes%2A> — metoda nie dołączy BOM do sekwencji bajtów zakodowanego; podanie BOM na początku strumień bajtów odpowiednie jest odpowiedzialność.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metoda pobierania znacznika kolejności bajtów Unicode w big endian lub małego kolejności bajtów endian dla wystąpienia <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Poniższy przykład tworzy dwa <xref:System.Text.UnicodeEncoding> obiektów, z których pierwszy nie zapewnia BOM, a drugi z których ma. Następnie wywołuje <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody do zapisu pliku BOM przed zapisaniem ciąg kodowany w formacie Unicode. Jak pokazano na dane wyjściowe z przykładu z konsoli, pliku, który zapisuje bajty z drugiego kodera ma trzy więcej bajtów niż pierwszy.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Można także porównać pliki za pomocą `fc` polecenie w oknie konsoli lub należy sprawdzić pliki w edytorze tekstu, zawierającą tryb wyświetlania szesnastkowy. Należy pamiętać, że jeśli plik jest otwarty w edytorze, który obsługuje kodowania UTF-16, BOM nie jest wyświetlana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu zdekodować.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtowej na ciąg.</summary>
        <returns>A <see cref="T:System.String" /> obiektu zawierającego wyniki dekodowania do podanej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykrywanie błędów Nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowe sekwencje są ignorowane, a nie wyjątek.  
  
 Jeśli zakres bajtów ma być zdekodowany zawiera znacznika kolejności bajtów (BOM) i Tablica bajtów został zwrócony przez metodę typu pamiętać z systemem innym niż BOM, znak U + FFFE znajduje się w tablicy znaków zwracane przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane do skonwertowania, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych bloków. W tym przypadku jeśli ilości danych jest tak duża, musi zostać podzielona na mniejsze bloki, należy użyć aplikacji <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczony przez obiekt <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie inicjowane tablicy przez wywołanie metody <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodę, aby określić dokładnie liczbę bajtów są wymagane dla zaszyfrowanym ciągiem, a następnie dodanie rozmiar znacznika kolejności bajtów (BOM). Przykład wywołuje <xref:System.Text.UnicodeEncoding.GetPreamble%2A> przechowywania BOM do tablicy przed wywołaniem metody <xref:System.Text.Encoding.GetBytes%2A> metody do przechowywania zakodowanego bajtów do tablicy. Przykład wywołuje <xref:System.Text.UnicodeEncoding.GetString%2A> metody zdekodować ciągu.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Należy pamiętać, że w takim przypadku Dekodowany ciąg różni się od oryginalnego ciągu, ponieważ rozpoczyna się znacznik kolejności bajtów 16-bitowych U + FFFD. Oznacza to, czy porównuje dwa ciągi jako nierównej i że ciągu w przypadku dane wyjściowe, BOM będzie wyświetlany jako znak zastępczy "?". Aby usunąć BOM na początku ciąg, można wywołać <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> lub <paramref name="count" /> jest mniejsza od zera.  
  
 —lub—  
  
 <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, a <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowania znaków w programie .NET Framework](~/docs/standard/base-types/character-encoding.md) na pełniejsze wyjaśnienie)  
  
 - i -  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0560812bba18045e55e3058f869e952c326d83bf" /><Meta Name="ms.sourcegitcommit" Value="37f75368be2e569ad59341f3fc6261b76b89db9d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/07/2019" /><Meta Name="ms.locfileid" Value="68819225" /></Metadata><TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowanie UTF-16 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode w sekwencję bajtów. Dekodowanie jest procesem przekształcania sekwencji zakodowanych bajtów na zestaw znaków Unicode.  
  
 [Standard Unicode](https://go.microsoft.com/fwlink/?linkid=37123) przypisuje punkt kodu (numer) do każdego znaku w każdym obsługiwanym skrypcie. Format przekształcenia Unicode (UTF) jest sposobem kodowania tego punktu kodu. W [standardzie Unicode](https://go.microsoft.com/fwlink/?linkid=37123) jest stosowany następujący UTFs:  
  
-   UTF-8, który reprezentuje każdy punkt kodu jako sekwencję od 1 do 4 bajtów.  
  
-   UTF-16, który reprezentuje każdy punkt kodu jako sekwencję od 1 do 2 16-bitowych liczb całkowitych.  
  
-   UTF-32, który reprezentuje każdy punkt kodu jako 32-bitową liczbę całkowitą.  
  
 Aby uzyskać więcej informacji na temat UTFs i innych kodowań obsługiwanych przez <xref:System.Text>program, zobacz [kodowanie znaków w .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Klasa reprezentuje kodowanie UTF-16. Koder może korzystać z big endian kolejności bajtów (najpierw z najbardziej znaczącym bajtem) lub z kolejnością bajtów little endian (najpierw znaczący bajt). Na przykład Wielka litera A (punkt kodu U + 0041) jest serializowana w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów big endian: 00 00 00 41  
  
-   Mała kolejność bajtów endian: 41 00 00 00  
  
 Zwykle bardziej wydajne jest przechowywanie znaków Unicode przy użyciu kolejności bajtów natywnych określonej platformy. Na przykład lepiej jest używać kolejności bajtów little endian na platformach little endian, takich jak komputery Intel. <xref:System.Text.UnicodeEncoding> Klasa odnosi się do stron kodowych systemu Windows 1200 (kolejność bajtów little endian) i 1201 (kolejność bajtów big endian). Możesz określić "przydziały" dla określonej architektury, wywołując <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> metodę.  
  
 <xref:System.Text.UnicodeEncoding> Opcjonalnie obiekt zawiera znacznik kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzone sekwencją bajtów w wyniku procesu kodowania. Jeśli Preambuła zawiera znacznik kolejności bajtów (BOM), pomaga dekoderowi określić kolejność bajtów i format transformacji lub UTF.  
  
 Jeśli wystąpienie jest skonfigurowane do dostarczania BOM, można je pobrać, <xref:System.Text.UnicodeEncoding.GetPreamble%2A> wywołując metodę; w przeciwnym razie metoda zwraca pustą tablicę. <xref:System.Text.UnicodeEncoding> Należy pamiętać, że nawet jeśli <xref:System.Text.UnicodeEncoding> dla obiektu jest skonfigurowany do obsługi BOM, należy uwzględnić BOM na początku strumienia zakodowanych bajtów, zgodnie z potrzebami, metody <xref:System.Text.UnicodeEncoding> kodowania klasy nie są automatycznie.  

> [!CAUTION]
> Aby włączyć wykrywanie błędów i uczynić wystąpienie klasy bardziej <xref:System.Text.UnicodeEncoding> bezpieczne, należy utworzyć wystąpienie obiektu przez <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> wywołanie konstruktora i ustawienie jego `throwOnInvalidBytes` argumentu na `true`. W przypadku wykrywania błędów Metoda, która wykrywa nieprawidłową sekwencję znaków lub bajtów zgłasza <xref:System.ArgumentException>. Bez wykrycia błędów nie jest zgłaszany żaden wyjątek, a Nieprawidłowa sekwencja jest zwykle ignorowana.  
  
 Można utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> obiektu na wiele sposobów, w zależności od tego, czy chcesz udostępnić znacznik kolejności bajtów (BOM), czy ma być używane kodowanie big-endian czy little-endian, oraz czy chcesz włączyć wykrywanie błędów. Poniższa tabela zawiera listę <xref:System.Text.UnicodeEncoding> konstruktorów <xref:System.Text.Encoding> i właściwości, które zwracają <xref:System.Text.UnicodeEncoding> obiekt.  
  
|Element członkowski|Endian|BOM|Wykrywanie błędów|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Tak|Nie (alternatywa zamienna)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little-endian|Tak|Nie (alternatywa zamienna)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little-endian|Tak|Nie (alternatywa zamienna)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Możliwość konfiguracji|Możliwość konfiguracji|Nie (alternatywa zamienna)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 Metoda określa, ile bajtów powoduje kodowanie zestawu znaków Unicode, <xref:System.Text.UnicodeEncoding.GetBytes%2A> a metoda wykonuje rzeczywiste kodowanie. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 Podobnie <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda określa, ile znaków powoduje dekodowanie sekwencji bajtów, <xref:System.Text.UnicodeEncoding.GetChars%2A> a metody i <xref:System.Text.UnicodeEncoding.GetString%2A> wykonuje rzeczywiste dekodowanie.  
  
 Dla kodera lub dekodera, który może zapisywać informacje o stanie podczas kodowania lub dekodowania danych obejmujących wiele bloków (takich jak ciąg znaków 1 000 000, który jest zakodowany w segmentach znaków 100 000), <xref:System.Text.UnicodeEncoding.GetEncoder%2A> Użyj <xref:System.Text.UnicodeEncoding.GetDecoder%2A> właściwości i piwo.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób kodowania ciągu znaków Unicode w tablicy bajtowej przy użyciu <xref:System.Text.UnicodeEncoding> obiektu. Tablica bajtów jest zdekodowana do ciągu, aby udowodnić, że dane nie są tracone.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 Poniższy przykład używa tego samego ciągu co poprzedni, z tą różnicą, że zapisuje zakodowane bajty do pliku i prefiksy strumienia bajtów ze znacznikiem kolejności bajtów (BOM). Następnie odczytuje plik na dwa różne sposoby: jako plik tekstowy przy użyciu <xref:System.IO.StreamReader> obiektu oraz jako plik binarny. Zgodnie z oczekiwaniami, żaden nowo odczytany ciąg nie obejmuje BOM.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które używa kolejności bajtów little endian, udostępnia znacznik kolejności bajtów Unicode i nie generuje wyjątku w przypadku wykrycia nieprawidłowego kodowania.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora i ustawienie jego `throwOnInvalidBytes` argumentu na `true`.
  
## Examples  
 Poniższy przykład ilustruje sposób tworzenia nowego <xref:System.Text.UnicodeEncoding> wystąpienia i wyświetlania nazwy kodowania.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" />Aby użyć kolejności bajtów big endian (najpierw najbardziej znaczącego bajtu) lub <see langword="false" /> użyć kolejności bajtów little endian (najpierw znaczący bajt).</param>
        <param name="byteOrderMark"><see langword="true" />Aby określić, że <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> Metoda zwraca znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />,.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy. Parametry określają, czy należy używać kolejności bajtów big endian i czy <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> Metoda zwraca znacznik kolejności bajtów Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątku, gdy wykryto nieprawidłowe kodowanie.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów przez wywołanie <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktora i ustawienie jego `throwOnInvalidBytes` argumentu na `true`.  
  
 Parametr steruje operacją <xref:System.Text.UnicodeEncoding.GetPreamble%2A>metody. `byteOrderMark` Jeśli `true`Metoda zwraca tablicę bajtową zawierającą znacznik kolejności bajtów Unicode (BOM) w formacie UTF-16.  Jeśli `false`zwraca tablicę bajtową o zerowej długości. Jednak ustawienie `byteOrderMark` to `true` nie powoduje, aby <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metoda nie powodowała prefiksu BOM na początku tablicy bajtowej, ani nie powoduje, <xref:System.Text.UnicodeEncoding.GetByteCount%2A> że metoda zawiera liczbę bajtów w BOM w liczniku bajtów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nowe <xref:System.Text.UnicodeEncoding> wystąpienie określające, czy obsługiwać little endian, big endian porządkowanie bajtów i znacznik kolejności bajtów Unicode.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" />Aby użyć kolejności bajtów big endian (najpierw najbardziej znaczący bajt); <see langword="false" /> aby użyć kolejności bajtów little endian (najpierw należy uzyskać co najmniej znaczący bajt).</param>
        <param name="byteOrderMark"><see langword="true" />Aby określić, że <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> Metoda zwraca znacznik kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />,.</param>
        <param name="throwOnInvalidBytes"><see langword="true" />Aby określić, że wyjątek ma być zgłaszany w przypadku wykrycia nieprawidłowego kodowania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy. Parametry określają, czy ma być używana kolejność bajtów big endian, czy ma być podany znacznik kolejności bajtów Unicode, oraz czy zgłaszać wyjątek, gdy zostanie wykryte nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametr steruje operacją <xref:System.Text.UnicodeEncoding.GetPreamble%2A>metody. `byteOrderMark` Jeśli `true`Metoda zwraca tablicę bajtową zawierającą znacznik kolejności bajtów Unicode (BOM) w formacie UTF-16.  Jeśli `false`zwraca tablicę bajtową o zerowej długości. Jednak ustawienie `byteOrderMark` to `true` nie powoduje, aby <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metoda nie powodowała prefiksu BOM na początku tablicy bajtowej, ani nie powoduje, <xref:System.Text.UnicodeEncoding.GetByteCount%2A> że metoda zawiera liczbę bajtów w BOM w liczniku bajtów.  
  
 Jeśli parametrem jest `true`, metoda, która wykrywa nieprawidłowe sekwencje <xref:System.ArgumentException?displayProperty=nameWithType>bajtów. `throwOnInvalidBytes` W przeciwnym razie metoda nie zgłasza wyjątku, a Nieprawidłowa sekwencja jest ignorowana.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy używać tego konstruktora do tworzenia wystąpienia <xref:System.Text.UnicodeEncoding> klasy i włączania wykrywania błędów przez `true`ustawienie `throwOnInvalidBytes` wartości.  
  
## Examples  
 Poniższy przykład ilustruje zachowanie programu <xref:System.Text.UnicodeEncoding>, z włączonym wykrywaniem błędów i bez.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Reprezentuje rozmiar znaku Unicode w bajtach. To pole jest stałą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest 32-bitowej podpisanej stałej o wartości 2.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak zwrócić wartość <xref:System.Text.UnicodeEncoding.CharSize> i wyświetlić ją.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> element jest równy bieżącemu <see cref="T:System.Text.UnicodeEncoding" /> obiektowi.</summary>
        <returns><see langword="true" />Jeśli <paramref name="value" /> jest <see langword="false" />wystąpieniem i jest równe bieżącemu obiektowi; w przeciwnym razie,. <see cref="T:System.Text.UnicodeEncoding" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UnicodeEncoding> obiekty są uważane za równe, jeśli spełnione są wszystkie następujące warunki:  
  
-   Oba obiekty używają tej samej kolejności bajtów (little-endian lub big-endian).  
  
-   Oba obiekty zapewniają znacznik kolejności bajtów lub oba nie.  
  
-   Oba obiekty używają tego samego powrotu do kodera.  
  
-   Oba obiekty używają tego samego powrotu dekodera.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Text.UnicodeEncoding.Equals%2A> metody w celu sprawdzenia, czy bieżący <xref:System.Text.UnicodeEncoding> obiekt jest równy różnemu <xref:System.Text.UnicodeEncoding> obiektowi. Pięć <xref:System.Text.UnicodeEncoding> obiektów jest tworzonych i porównywanych, a wyniki porównań są wyświetlane.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów generowanych przez zakodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera zestaw znaków do kodowania.</param>
        <summary>Oblicza liczbę bajtów wytwarzanych przez zakodowanie znaków w określonym ciągu.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UnicodeEncoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów, a liczba bajtów w preambule nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metodę.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody i <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> , aby obliczyć maksymalną i rzeczywistą liczbę bajtów wymaganą do zakodowania ciągu. Wyświetla również rzeczywistą liczbę bajtów wymaganą do przechowywania strumienia bajtów ze znacznikiem kolejności bajtów.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków, zaczynając od określonego wskaźnika znakowego.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.UnicodeEncoding.GetBytes%2A> jest wymagany do przechowywania powstających bajtów, należy <xref:System.Text.UnicodeEncoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów, a liczba bajtów w preambule nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów wytwarzanych przez zakodowanie zestawu znaków z określonej tablicy znaków.</summary>
        <returns>Liczba bajtów generowanych przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu obliczenia dokładnego rozmiaru tablicy wymaganego <xref:System.Text.UnicodeEncoding.GetBytes%2A> w celu przechowywania powstających bajtów aplikacja będzie używać. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 Po włączeniu wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów, a liczba bajtów w preambule nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę.  
  
   
  
## Examples  
 Poniższy przykład wypełnia tablicę wielkimi literami i małymi literami, a następnie wywołuje <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę w celu określenia liczby bajtów wymaganych do zakodowania małych liter łacińskich. Następnie wyświetla te informacje wraz z łączną liczbą bajtów, które są niezbędne, jeśli zostanie dodany znacznik kolejności bajtów. Porównuje tę liczbę z wartością zwracaną przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, która wskazuje maksymalną liczbę bajtów wymaganą do kodowania małych liter. Poniższy przykład wypełnia tablicę kombinacją znaków greckich i cyrylicy i wywołuje <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę w celu określenia liczby bajtów wymaganych do zakodowania znaków cyrylicy. Następnie wyświetla te informacje wraz z łączną liczbą bajtów, które są niezbędne, jeśli zostanie dodany znacznik kolejności bajtów. Porównuje tę liczbę z wartością zwracaną przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, która wskazuje maksymalną liczbę bajtów wymaganą do zakodowania znaków cyrylicy.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestaw znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której ma zostać rozpoczęte pisanie sekwencji bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od określonego wskaźnika znakowego do sekwencji bajtów, które są przechowywane, zaczynając od określonego wskaźnika bajtu.</summary>
        <returns>Rzeczywista liczba bajtów zapisywana w lokalizacji wskazywanej przez <paramref name="bytes" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.UnicodeEncoding.GetBytes%2A> jest wymagany do przechowywania powstających bajtów, należy <xref:System.Text.UnicodeEncoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub obiekt <xref:System.Text.UnicodeEncoding.GetEncoder%2A> dostarczony odpowiednio przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub metodę.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metoda nie dołącza preambuły do początku sekwencji zakodowanych bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />lub <paramref name="byteCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="byteCount" />jest mniejsza niż liczba bajtów będących wynikiem.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków zawierająca zestaw znaków do kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów, która zawiera wyniki sekwencji bajtów.</param>
        <param name="byteIndex">Indeks, od którego ma zostać rozpoczęte zapisywanie wyniku sekwencji bajtów.</param>
        <summary>Koduje zestaw znaków z określonej tablicy znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów do <paramref name="bytes" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UnicodeEncoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub <xref:System.Text.UnicodeEncoding.GetDecoder%2A> odpowiednio do metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metoda nie dołącza preambuły do początku sekwencji zakodowanych bajtów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody do kodowania zakresu znaków <xref:System.String> z i przechowywania zakodowanych bajtów w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />lub <paramref name="charCount" />jestmniejszaod zera.<paramref name="byteIndex" />  
  
—lub— 
 <paramref name="charIndex" />i <paramref name="charCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" />nie jest prawidłowym indeksem <paramref name="bytes" />w.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" />nie ma wystarczającej pojemności od <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków do kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów, która zawiera wyniki sekwencji bajtów.</param>
        <param name="byteIndex">Indeks, od którego ma zostać rozpoczęte zapisywanie wyniku sekwencji bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów do <paramref name="bytes" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładne rozmiary tablicy wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> program do przechowywania wyników, należy <xref:System.Text.UnicodeEncoding.GetByteCount%2A> wywołać metodę. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub <xref:System.Text.UnicodeEncoding.GetDecoder%2A> odpowiednio do metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, gdy są zapisywane jako plik lub jako strumień, można prefiksować strumień zakodowanych bajtów z preambułą. Wstawianie preambuły na początku strumienia bajtów (na przykład na początku serii bajtów, które mają być zapisywane do pliku) jest odpowiedzialnością dla deweloperów. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metoda nie dołącza preambuły do początku sekwencji zakodowanych bajtów.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak zakodować zakres elementów z tablicy znaków Unicode i przechowywać zakodowane bajty w zakresie elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />lub <paramref name="charCount" />jestmniejszaod zera.<paramref name="byteIndex" />  
  
—lub— 
 <paramref name="charIndex" />i <paramref name="charCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" />nie jest prawidłowym indeksem <paramref name="bytes" />w.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" />nie ma wystarczającej pojemności od <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów, zaczynając od określonego wskaźnika bajtu.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.UnicodeEncoding.GetChars%2A> jest wymagany do przechowywania wyników, aplikacja używa. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza liczbę znaków wytworzonych przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków wytworzonych przez odkodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy wymagany przez <xref:System.Text.UnicodeEncoding.GetChars%2A> program do przechowywania wyników, aplikacja używa. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metody do zwrócenia liczby znaków generowanych przez dekodowanie zakresu elementów w tablicy bajtowej przy użyciu. <xref:System.Text.UnicodeEncoding>  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów do zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do zdekodowania.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której ma zostać rozpoczęte pisanie zestawu znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Dekoduje sekwencję bajtów rozpoczynającą się od określonego wskaźnika Byte do zestawu znaków, które są przechowywane, zaczynając od określonego wskaźnika znakowego.</summary>
        <returns>Rzeczywista liczba znaków zapisywana w lokalizacji wskazywanej przez <paramref name="chars" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy, który <xref:System.Text.UnicodeEncoding.GetChars%2A> jest wymagany do przechowywania wyników, aplikacja używa. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów do zdekodowania obejmuje oznaczenie kolejności bajtów (BOM) i tablicę bajtową zwróconą przez metodę typu nieopartego na BOM, znak U + FFFE jest zawarty w tablicy znaków zwracanej przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub obiekt <xref:System.Text.UnicodeEncoding.GetEncoder%2A> dostarczony odpowiednio przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />lub <paramref name="charCount" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="charCount" />jest mniejsza niż liczba znaków będących wynikiem.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <param name="chars">Tablica znaków, która będzie zawierać zestaw znaków.</param>
        <param name="charIndex">Indeks, od którego należy zacząć pisać zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z określonej tablicy bajtów do określonej tablicy znaków.</summary>
        <returns>Rzeczywista liczba znaków do <paramref name="chars" />zapisania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy wymagany przez <xref:System.Text.UnicodeEncoding.GetChars%2A> program do przechowywania wyników, aplikacja używa. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetCharCount%2A>  
  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów do zdekodowania obejmuje oznaczenie kolejności bajtów (BOM) i tablicę bajtową zwróconą przez metodę typu nieopartego na BOM, znak U + FFFE jest zawarty w tablicy znaków zwracanej przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub <xref:System.Text.UnicodeEncoding.GetDecoder%2A> odpowiednio do metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób używania <xref:System.Text.UnicodeEncoding.GetChars%2A> metody do dekodowania zakresu elementów w tablicy bajtów i przechowywania wyniku w tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="chars" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />lub <paramref name="byteCount" />jestmniejszaod zera.<paramref name="charIndex" />  
  
—lub— 
 <paramref name="byteindex" />i <paramref name="byteCount" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" />nie jest prawidłowym indeksem <paramref name="chars" />w.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="chars" />nie ma wystarczającej pojemności od <paramref name="charIndex" /> do końca tablicy, aby pomieścić wyniki.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje zakodowaną sekwencję bajtów UTF-16 na sekwencję znaków Unicode.</summary>
        <returns><see cref="T:System.Text.Decoder" /> , Który konwertuje zakodowaną sekwencję bajtów UTF-16 na sekwencję znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda konwertuje sekwencyjne bloki bajtów do sekwencyjnych bloków znaków w sposób podobny <xref:System.Text.UnicodeEncoding.GetChars%2A>do. <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> <xref:System.Text.Decoder> Jednak utrzymuje informacje o stanie między wywołaniami, aby można było poprawnie zdekodować sekwencje bajtów, które obejmują bloki. Zachowuje <xref:System.Text.Decoder> również końcowe bajty na końcu bloków danych i używa końcowych bajtów w następnej operacji dekodowania. W związku z <xref:System.Text.UnicodeEncoding.GetEncoder%2A> tym isąprzydatnewprzypadkuoperacjitransmisjiwsieciiplików,ponieważteoperacjeczęstozajmująsięblokamidanych,aniezpełnymstrumieniemdanych.<xref:System.Text.UnicodeEncoding.GetDecoder%2A>  
  
 Jeśli jest włączone wykrywanie błędów, oznacza to, `throwOnInvalidBytes` że parametr konstruktora jest ustawiony na `true`, wykrywanie błędów <xref:System.Text.Decoder> jest również włączone w zwracanym przez tę metodę. W przypadku włączenia wykrywania błędów i napotkania nieprawidłowej sekwencji stan dekodera jest niezdefiniowany i przetwarzanie musi zostać zatrzymane.  
  
   
  
## Examples  
 Poniższy przykład używa kodera i dekodera do kodowania ciągu do tablicy bajtów, a następnie dekodowanie bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje koder, który konwertuje sekwencję znaków Unicode na sekwencję bajtów w formacie UTF-16.</summary>
        <returns><see cref="T:System.Text.Encoder" /> Obiekt, który konwertuje sekwencję znaków Unicode na sekwencję bajtów w formacie UTF-16.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda konwertuje sekwencyjne bloki znaków na bloki sekwencyjne bajtów w sposób podobny <xref:System.Text.UnicodeEncoding.GetBytes%2A> do metody tej klasy. <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> <xref:System.Text.Encoder> Jednak obiekt przechowuje informacje o stanie między wywołaniami, dzięki czemu może poprawnie kodować sekwencje znaków, które obejmują bloki. <xref:System.Text.Encoder> Obiekt zachowuje również końcowe znaki na końcu bloków danych i używa znaków końcowych w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowanym surogatem, a zgodny z niską surogatem może znajdować się w następnym bloku danych. W związku z <xref:System.Text.UnicodeEncoding.GetEncoder%2A> tym isąprzydatnewprzypadkuoperacjitransmisjiwsieciiplików,ponieważteoperacjeczęstozajmująsięblokamidanych,aniezpełnymstrumieniemdanych.<xref:System.Text.UnicodeEncoding.GetDecoder%2A>  
  
 Jeśli jest włączone wykrywanie błędów, oznacza to, `throwOnInvalidBytes` że parametr konstruktora jest ustawiony na `true`, wykrywanie błędów <xref:System.Text.Encoder> jest również włączone w obiekcie zwracanym przez tę metodę. W przypadku włączenia wykrywania błędów i napotkania nieprawidłowej sekwencji stan kodera jest niezdefiniowany i przetwarzanie musi zostać zatrzymane.  
  
   
  
## Examples  
 Poniższy przykład używa kodera i dekodera do kodowania ciągu do tablicy bajtów, a następnie dekodowanie bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Informacje o kodowaniu</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kod skrótu dla bieżącego wystąpienia.</summary>
        <returns>Kod skrótu dla bieżącego <see cref="T:System.Text.UnicodeEncoding" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów wyprodukowanych przez zakodowanie określonej liczby znaków.</summary>
        <returns>Maksymalna liczba bajtów wygenerowanych przez kodowanie określonej liczby znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu obliczenia dokładnego rozmiaru tablicy wymaganego <xref:System.Text.UnicodeEncoding.GetBytes%2A> w celu przechowywania powstających bajtów aplikacja będzie używać. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetByteCount%2A>  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>Pobiera najgorszą liczbę przypadków, w tym najgorszy przypadek dla aktualnie wybranego <xref:System.Text.EncoderFallback>elementu. W przypadku wybrania rezerwy z potencjalnie dużym ciągiem <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> może zwracać duże wartości.  
  
 W większości przypadków ta metoda pobiera rozsądne liczby dla małych ciągów. W przypadku dużych ciągów może zajść potrzeba wyboru między użyciem bardzo dużych buforów i przechwycenia błędów w rzadkich przypadkach, gdy zostanie przekroczony bardziej rozsądny bufor. Warto również rozważyć inne podejście przy użyciu <xref:System.Text.UnicodeEncoding.GetByteCount%2A> lub. <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>nie ma relacji do <xref:System.Text.UnicodeEncoding.GetChars%2A>. Jeśli aplikacja wymaga użycia <xref:System.Text.UnicodeEncoding.GetChars%2A>funkcji podobnej do, należy użyć. <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>  
  
> [!NOTE]
>  `GetMaxByteCount(N)`nie musi być taka sama jak `N* GetMaxByteCount(1)`wartość.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody do zwrócenia maksymalnej liczby bajtów wymaganych do zakodowania określonej liczby znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" />jest ustawiony na <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do zdekodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków wyprodukowanych przez dekodowanie określonej liczby bajtów.</summary>
        <returns>Maksymalna liczba znaków wytworzonych przez odkodowanie określonej liczby bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć dokładny rozmiar tablicy wymagany przez <xref:System.Text.UnicodeEncoding.GetChars%2A> program do przechowywania wyników, aplikacja używa. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. Metoda ogólnie przydziela mniejszą ilość pamięci, podczas gdy metoda <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> zazwyczaj wykonuje się szybciej. <xref:System.Text.UnicodeEncoding.GetCharCount%2A>  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>Pobiera najgorszą liczbę przypadków, w tym najgorszy przypadek dla aktualnie wybranego <xref:System.Text.DecoderFallback>elementu. W przypadku wybrania rezerwy z potencjalnie dużym ciągiem <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> pobiera duże wartości.  
  
 W większości przypadków ta metoda pobiera rozsądne liczby dla małych ciągów. W przypadku dużych ciągów może zajść potrzeba wyboru między użyciem bardzo dużych buforów i przechwycenia błędów w rzadkich przypadkach, gdy zostanie przekroczony bardziej rozsądny bufor. Warto również rozważyć inne podejście przy użyciu <xref:System.Text.UnicodeEncoding.GetCharCount%2A> lub. <xref:System.Text.Decoder.Convert%2A>  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>nie ma relacji do <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Jeśli aplikacja wymaga użycia <xref:System.Text.UnicodeEncoding.GetBytes%2A>funkcji podobnej do, należy użyć. <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>  
  
> [!NOTE]
>  `GetMaxCharCount(N)`nie musi być taka sama jak `N* GetMaxCharCount(1)`wartość.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metody do zwrócenia maksymalnej liczby znaków wygenerowanych przez dekodowanie określonej liczby bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" />jest mniejsza od zera.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, która może zostać zwrócona jako liczba całkowita.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowany w formacie UTF-16, jeśli Konstruktor dla tego wystąpienia żąda znacznika kolejności bajtów.</summary>
        <returns>Tablica bajtowa zawierająca znacznik kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UnicodeEncoding" /> obiekt jest skonfigurowany do dostarczania jednego. W przeciwnym razie ta metoda zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiekt może dostarczyć preambułę, która jest tablicą bajtową, która może być poprzedzona sekwencją bajtów w wyniku procesu kodowania. Poprzednia sekwencja zakodowanych bajtów ze znacznikiem kolejności bajtów (punkt kodu U + FEFF) pomaga dekoderowi określić kolejność bajtów i format transformacji lub UTF. Znacznik kolejności bajtów (BOM) Unicode jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów big endian: FE FF  
  
-   Mała kolejność bajtów endian: FRF FE  
  
 Można utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> obiektu, którego <xref:System.Text.UnicodeEncoding.GetPreamble%2A> Metoda zwraca prawidłowy BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UnicodeEncoding> obiekt zwrócony <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> przez lub <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> właściwość.  
  
-   Wywołując <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktor bez parametrów, aby <xref:System.Text.UnicodeEncoding> utworzyć wystąpienie obiektu.  
  
-   Dostarczając `true` jako wartość `byteOrderMark` argumentu <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> lub konstruktorów.<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>  
  
 Zalecamy korzystanie z BOM, ponieważ zapewnia niemal pewne identyfikatory kodowania dla plików, które w przeciwnym razie utraciły odwołanie do kodowania, takie jak nieoznakowane lub niewłaściwie oznakowane dane sieci Web lub losowe pliki tekstowe przechowywane, gdy firma nie miała zagadnienia międzynarodowe. Często można uniknąć problemów z użytkownikami, jeśli dane są spójne i poprawnie oznakowane.  
  
 W przypadku standardów, które zapewniają typ kodowania, BOM jest nieco nadmiarowy. Można go jednak użyć, aby ułatwić serwerowi wysyłanie poprawnego nagłówka kodowania. Alternatywnie, może być używany jako rezerwa w przypadku, gdy kodowanie jest tracone.  
  
 Istnieją pewne wady dotyczące korzystania z BOM. Na przykład poznanie sposobu ograniczania pól bazy danych, które używają BOM, może być trudne. Łączenie plików może być również problemem, na przykład podczas scalania plików w taki sposób, że niezbędny znak może kończyć się w danych. Pomimo tego, że użycie BOM jest zdecydowanie zalecane.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, należy prefiksować początek strumienia zakodowanych bajtów z preambuły. Należy zauważyć, <xref:System.Text.UnicodeEncoding.GetBytes%2A> że metoda nie dołącza BOM do sekwencji zakodowanych bajtów; dostarczenie BOM na początku odpowiedniego strumienia bajtów jest odpowiedzialnością dla deweloperów.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody do pobierania znacznika kolejności bajtów Unicode w big endian lub little endian kolejności bajtów dla wystąpienia <xref:System.Text.UnicodeEncoding>obiektu.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 W poniższym przykładzie tworzone są dwa <xref:System.Text.UnicodeEncoding> obiekty, z których pierwszy nie zawiera BOM, a drugi to. Następnie wywołuje <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodę, aby napisać BOM do pliku przed zapisaniem ciągu zakodowanego w formacie Unicode. Jak widać dane wyjściowe konsoli z przykładu, plik, który zapisuje bajty z drugiego kodera, ma trzy więcej bajtów niż pierwszy.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Pliki można także porównać przy użyciu `fc` polecenia w oknie konsoli lub można sprawdzić pliki w edytorze tekstów zawierający tryb widoku szesnastkowego. Należy pamiętać, że gdy plik zostanie otwarty w edytorze, który obsługuje kodowanie UTF-16, nie jest wyświetlany BOM.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtowa zawierająca sekwencję bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do zdekodowania.</param>
        <param name="count">Liczba bajtów do zdekodowania.</param>
        <summary>Dekoduje zakres bajtów z tablicy bajtowej do ciągu.</summary>
        <returns><see cref="T:System.String" /> Obiekt zawierający wyniki dekodowania określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wykrywania błędów Nieprawidłowa sekwencja powoduje, że <xref:System.ArgumentException>ta metoda wygeneruje. Bez wykrywania błędów nieprawidłowe sekwencje są ignorowane i nie jest zgłaszany żaden wyjątek.  
  
 Jeśli zakres bajtów do zdekodowania obejmuje oznaczenie kolejności bajtów (BOM) i tablicę bajtową zwróconą przez metodę typu nieopartego na BOM, znak U + FFFE jest zawarty w tablicy znaków zwracanej przez tę metodę. Można go usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 Dane do przekonwertowania, takie jak dane odczytane ze strumienia, mogą być dostępne tylko w blokach sekwencyjnych. W tym przypadku lub, jeśli ilość danych jest tak duża, że musi <xref:System.Text.Decoder> być podzielona na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Encoder> lub obiekt <xref:System.Text.UnicodeEncoding.GetEncoder%2A> dostarczony odpowiednio przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub metodę.  
  
   
  
## Examples  
 W poniższym przykładzie jest inicjowana tablica przez wywołanie <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody w celu określenia dokładnie liczby bajtów wymaganych przez zakodowany ciąg, a następnie dodania rozmiaru znacznika kolejności bajtów (BOM). Przykład następnie wywołuje <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodę w celu zapisania BOM do tablicy przed <xref:System.Text.Encoding.GetBytes%2A> wywołaniem metody w celu zapisania zakodowanych bajtów do tablicy. Przykład następnie wywołuje metodę, <xref:System.Text.UnicodeEncoding.GetString%2A> Aby zdekodować ciąg.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Należy zauważyć, że w tym przypadku zdekodowany ciąg różni się od oryginalnego ciągu, ponieważ zaczyna się od 16-bitowego znaku kolejności bajtów U + FFFD. Oznacza to, że dwa ciągi będą porównywane jako nierówne i że jeśli ciąg jest wyprowadzany, będzie on wyświetlany jako znak zastępczy "?". Aby usunąć BOM na początku ciągu, można wywołać <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metodę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" />is <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />lub <paramref name="count" /> jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpiła rezerwa (zobacz [kodowanie znaków w .NET Framework,](~/docs/standard/base-types/character-encoding.md) Aby uzyskać pełne wyjaśnienie) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" />jest ustawiony na <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public override ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.UnicodeEncoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.UnicodeEncoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera znacznik kolejności bajtów Unicode zakodowany w formacie UTF-16, jeśli ten obiekt jest skonfigurowany do jego dostarczania.</summary>
        <value>Zakres bajtów zawierający znacznik kolejności bajtów Unicode, jeśli ten obiekt jest skonfigurowany do jego dostarczania; w przeciwnym razie domyślnym zakresem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiekt może dostarczyć preambuły, który jest zakresem bajtów, który można dołączać do sekwencji bajtów wynikających z procesu kodowania. Poprzednia sekwencja zakodowanych bajtów ze znacznikiem kolejności bajtów (punkt `U+FEFF`kodowy) pomaga dekoderowi określić kolejność bajtów i format transformacji lub UTF. Znacznik kolejności bajtów (BOM) Unicode jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejność bajtów big endian:`FE FF`  
  
-   Mała kolejność bajtów endian:`FF FE`  
  
 Można utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> obiektu, którego <xref:System.Text.UnicodeEncoding.Preamble> jest prawidłowym BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UnicodeEncoding> obiekt zwrócony <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> przez lub <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> właściwość.  
  
-   Wywołując <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktor bez parametrów, aby <xref:System.Text.UnicodeEncoding> utworzyć wystąpienie obiektu.  
  
-   Dostarczając `true` jako wartość `byteOrderMark` argumentu <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> lub konstruktorów.<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29>  
  
 Zalecamy korzystanie z BOM, ponieważ zapewnia niemal pewne identyfikatory kodowania dla plików, które w przeciwnym razie utraciły odwołanie do kodowania, takie jak nieoznakowane lub niewłaściwie oznakowane dane sieci Web lub losowe pliki tekstowe przechowywane, gdy firma nie miała zagadnienia międzynarodowe. Często można uniknąć problemów z użytkownikami, jeśli dane są spójne i poprawnie oznakowane.  
  
 W przypadku standardów, które zapewniają typ kodowania, BOM jest nieco nadmiarowy. Można go jednak użyć, aby ułatwić serwerowi wysyłanie poprawnego nagłówka kodowania. Alternatywnie, może być używany jako rezerwa w przypadku, gdy kodowanie jest tracone.  
  
 Istnieją pewne wady dotyczące korzystania z BOM. Na przykład poznanie sposobu ograniczania pól bazy danych, które używają BOM, może być trudne. Łączenie plików może być również problemem, na przykład podczas scalania plików w taki sposób, że niezbędny znak może kończyć się w danych. Pomimo tego, że użycie BOM jest zdecydowanie zalecane.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowane bajty są zdekodowane prawidłowo, należy prefiksować początek strumienia zakodowanych bajtów z preambuły. Należy zauważyć, <xref:System.Text.UnicodeEncoding.GetBytes%2A> że metoda nie dołącza BOM do sekwencji zakodowanych bajtów; dostarczenie BOM na początku odpowiedniego strumienia bajtów jest odpowiedzialnością dla deweloperów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5d2ec214f93cb27c6af80a6fcdc63bc0bb415411" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58714086" /></Metadata><TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kodowanie UTF-16 znaków Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kodowanie jest procesem przekształcania zestawu znaków Unicode do sekwencji bajtów. Dekodowanie jest procesem przekształcania sekwencji bajtów zakodowany zestaw znaków Unicode.  
  
 [Standardu Unicode](https://go.microsoft.com/fwlink/?linkid=37123) przypisuje punkt kodowy (liczba) do każdego znaku w każdej obsługiwanej skryptu. Format przekształcenia Unicode (UTF) to sposób kodowania tego punktu kodu. [Standardu Unicode](https://go.microsoft.com/fwlink/?linkid=37123) używa następujących UTFs:  
  
-   UTF-8, która reprezentuje każdy punkt kodu jako sekwencja jednej do czterech bajtów.  
  
-   UTF-16, co reprezentuje każdy punkt kodu jako sekwencję liczb całkowitych, jednej do dwóch 16-bitowych.  
  
-   UTF-32, co reprezentuje każdy punkt kodowy jako liczba całkowita 32-bitowych.  
  
 Aby uzyskać więcej informacji na temat UTFs i inne kodowanie obsługiwane przez <xref:System.Text>, zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 <xref:System.Text.UnicodeEncoding> Klasa reprezentuje kodowanie UTF-16. Koder można użyć albo kolejności bajtów big endian (najbardziej znaczący bajt pierwszy) lub nieco kolejności bajtów endian (najmniej znaczący bajt pierwszy). Na przykład Wielka litera (punkt kodowy 0041 U +) jest serializowany jako następujące (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian: 00 00 00 41  
  
-   Little endian bajt kolejność: 41 00 00 00  
  
 Jest to zazwyczaj wydajniejsze do przechowywania znaki Unicode przy użyciu kolejność bajtów natywnej danej platformy. Na przykład lepiej jest używać nieco kolejności bajtów endian na little endian platform, takich jak komputery z technologią Intel. <xref:System.Text.UnicodeEncoding> Klasa odnosi się do stron kodowych Windows 1200 (mały kolejności bajtów endian) i 1201 (kolejności bajtów big endian). Możesz określić "kolejność bajtów" szczególna architektura, wywołując <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> metody.  
  
 Opcjonalnie <xref:System.Text.UnicodeEncoding> obiekt zawiera znacznika kolejności bajtów (BOM), który jest tablicą bajtów, które mogą być poprzedzone sekwencji bajtów wynikające z procesu kodowania. Jeśli Preambuła zawiera znacznik kolejności bajtów (BOM), pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF.  
  
 Jeśli <xref:System.Text.UnicodeEncoding> wystąpienia jest skonfigurowana do dostarczania znak BOM, można go pobrać, wywołując <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody; w przeciwnym razie metoda zwraca pustą tablicę. Należy zauważyć, że nawet wtedy, gdy <xref:System.Text.UnicodeEncoding> obiektu jest skonfigurowany na potrzeby obsługi BOM, musi zawierać znak BOM na początku strumienia bajtów zakodowany zgodnie z potrzebami; metody kodowania <xref:System.Text.UnicodeEncoding> klasy nie należy tego robić automatycznie.  

> [!CAUTION]
> Umożliwiające wykrywanie błędów i zabezpieczyć wystąpienia klasy, należy utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> obiektu przez wywołanie metody <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`. Za pomocą wykrywania błędów zgłasza metodę, która wykrywa nieprawidłową sekwencję znaków lub bajtów <xref:System.ArgumentException>. Bez wykrycia błąd jest zgłaszany żaden wyjątek, a nieprawidłowa sekwencja jest brany pod uwagę.  
  
 Można utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> obiektu na różne sposoby w zależności od tego, czy chcesz go zapewnienie znacznika kolejności bajtów (BOM), czy ma little-endian lub big-endian kodowania i tego, czy chcesz włączyć wykrywanie błędów. W poniższej tabeli wymieniono <xref:System.Text.UnicodeEncoding> konstruktorów i <xref:System.Text.Encoding> właściwości, które zwracają <xref:System.Text.UnicodeEncoding> obiektu.  
  
|Element członkowski|Kolejność bajtów|BOM|Wykrywanie błędów|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Tak|Nie (rezerwowe wymiany)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little-endian|Tak|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little-endian|Tak|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Możliwość konfiguracji|Możliwość konfiguracji|Nie (rezerwowe wymiany)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Możliwość konfiguracji|Możliwość konfiguracji|Możliwość konfiguracji|  
  
 <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda określa liczbę bajtów spowodować Kodowanie zestawu znaków Unicode i <xref:System.Text.UnicodeEncoding.GetBytes%2A> metoda wykonuje rzeczywistego kodowania.  
  
 Podobnie <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda określa, ile znaków spowodować dekodowanie sekwencji bajtów, a <xref:System.Text.UnicodeEncoding.GetChars%2A> i <xref:System.Text.UnicodeEncoding.GetString%2A> metody wykonywania rzeczywiste dekodowania.  
  
 Dla koder i dekoder, który jest w stanie zapisać informacje o stanie podczas kodowania lub dekodowania danych, która obejmuje wiele bloków (na przykład ciąg 1 milion znaków, który jest kodowany w segmentach 100 000 znaków), użyj <xref:System.Text.UnicodeEncoding.GetEncoder%2A> i <xref:System.Text.UnicodeEncoding.GetDecoder%2A> właściwości odpowiednio.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak kodować ciągów znaków Unicode w tablicy bajtów przy użyciu <xref:System.Text.UnicodeEncoding> obiektu. Tablica bajtowej jest dekodowana na ciąg w celu zademonstrowania, że istnieje bez utraty danych.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 W poniższym przykładzie użyto tych samych parametrach jak poprzedni, z tą różnicą, że zapisuje zakodowany bajtów do pliku, a prefiksy strumień bajtów przy użyciu znacznika kolejności bajtów (BOM). Następnie odczytuje plik na dwa sposoby: jako plik tekstowy przy użyciu <xref:System.IO.StreamReader> obiektu; i jako plik binarny. Jak można oczekiwać, ani nowo odczytu ciąg zawiera znak BOM.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które używa kolejności bajtów endian mały, zawiera znacznik kolejności bajtów Unicode i nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`.
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nową <xref:System.Text.UnicodeEncoding> wystąpienia i nazwę wyświetlaną dla kodowania.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> do użycia w kolejności bajtów big endian (najbardziej znaczący bajt pierwszy), lub <see langword="false" /> do kolejność little endian bajtów (najmniej znaczący bajt pierwszy).</param>
        <param name="byteOrderMark"><see langword="true" /> Aby określić, że <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> metoda zwróci wartość znacznika kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy. Parametry określają, czy ma być używany w kolejności bajtów big endian oraz tego, czy <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> metoda zwróci wartość znacznika kolejności bajtów Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy wystąpienie, które nie zgłasza wyjątku po wykryciu Nieprawidłowe kodowanie.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy włączyć wykrywanie błędów, wywołując <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i ustawienie jej `throwOnInvalidBytes` argument `true`.  
  
 `byteOrderMark` Parametr steruje działaniem <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą Unicode znacznik kolejności bajtów (BOM) w formacie UTF-16.  Jeśli `false`, funkcja zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `byteOrderMark` do `true` nie powoduje <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody jako prefiks BOM na początku tablicy bajtowej, ani nie powoduje ona, że <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodę, aby uwzględnić liczbę bajtów w BOM liczba bajtów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć nową <xref:System.Text.UnicodeEncoding> znacznik kolejności wystąpienia określająca, czy obsługuje określania kolejności little endian lub big endian bajtów i bajtów Unicode.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> Aby użyć kolejności bajtów big endian (najbardziej znaczący bajt pierwszy); <see langword="false" /> do kolejność little endian bajtów (najmniej znaczący bajt pierwszy).</param>
        <param name="byteOrderMark"><see langword="true" /> Aby określić, że <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> metoda zwróci wartość znacznika kolejności bajtów Unicode; w przeciwnym razie <see langword="false" />.</param>
        <param name="throwOnInvalidBytes"><see langword="true" /> Aby określić, czy należy zgłosić wyjątek po wykryciu Nieprawidłowe kodowanie; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Text.UnicodeEncoding" /> klasy. Parametry określają, czy ma być używany w kolejności bajtów big endian, czy zapewnienie znacznika kolejności bajtów Unicode i czy chcesz zgłosić wyjątek po wykryciu Nieprawidłowe kodowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `byteOrderMark` Parametr steruje działaniem <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metody. Jeśli `true`, metoda zwraca tablicę bajtów zawierającą Unicode znacznik kolejności bajtów (BOM) w formacie UTF-16.  Jeśli `false`, funkcja zwraca tablicę bajtów o zerowej długości. Jednak ustawienie `byteOrderMark` do `true` nie powoduje <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody jako prefiks BOM na początku tablicy bajtowej, ani nie powoduje ona, że <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodę, aby uwzględnić liczbę bajtów w BOM liczba bajtów.  
  
 Jeśli `throwOnInvalidBytes` parametr jest `true`, zgłasza wyjątek w metodzie, która wykrywa sekwencji nieprawidłowy bajt <xref:System.ArgumentException?displayProperty=nameWithType>. W przeciwnym razie metoda nie zgłasza wyjątku, i jest ignorowana nieprawidłową sekwencję.  
  
> [!CAUTION]
>  Ze względów bezpieczeństwa należy użyć tego konstruktora, aby utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> klasy, a następnie Włącz wykrywanie błędów, ustawiając `throwOnInvalidBytes` do `true`.  
  
## Examples  
 Poniższy przykład demonstruje działanie <xref:System.Text.UnicodeEncoding>, zarówno za pomocą wykrywania błędów włączona, jak i bez.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Reprezentuje rozmiar znaków Unicode, w bajtach. To pole jest stałą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tego pola jest 32-bitowe podpisane stałą o wartości 2.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób zwracania wartości <xref:System.Text.UnicodeEncoding.CharSize> i wyświetlania ich.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Obiekt do porównania z bieżącym obiektem.</param>
        <summary>Określa, czy określony <see cref="T:System.Object" /> jest taki sam, jak bieżący <see cref="T:System.Text.UnicodeEncoding" /> obiektu.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="value" /> jest wystąpieniem <see cref="T:System.Text.UnicodeEncoding" /> i jest taki sam jak bieżący obiekt; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa <xref:System.Text.UnicodeEncoding> obiekty są traktowane jako równe, jeśli spełnione są wszystkie następujące warunki:  
  
-   Oba obiekty używają tej samej kolejności bajtów (little-endian lub big-endian).  
  
-   Oba obiekty zapewniają znacznika kolejności bajtów lub oba nie obsługują.  
  
-   Oba obiekty, użyj tego samego kodera rezerwowego.  
  
-   Oba obiekty, użyj tego samego dekoder rezerwowego.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.Equals%2A> metody do testowania czy bieżący <xref:System.Text.UnicodeEncoding> obiekt jest taki sam na inne <xref:System.Text.UnicodeEncoding> obiektu. Pięć <xref:System.Text.UnicodeEncoding> obiekty są tworzone i porównywane, a wyniki porównania są wyświetlane.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg, który zawiera zestaw znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie znaków w określonym stringu.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metody.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> i <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> metody służące do obliczania maksymalnej rzeczywista liczba bajtów potrzebnych do zakodowania ciąg. Wyświetla również rzeczywista liczba bajtów potrzebnych do przechowania strumień bajtów przy użyciu znacznika kolejności bajtów.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.UnicodeEncoding.GetBytes%2A> wymaga, aby przechowywać wynikowy bajty, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UTF8Encoding.GetByteCount%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="index">Indeks pierwszego znaku do zakodowania.</param>
        <param name="count">Liczba znaków do zakodowania.</param>
        <summary>Oblicza liczbę bajtów produkowane przez kodowanie zestawu znaków, z określoną tablicę znaków.</summary>
        <returns>Liczba bajtów produkowane przez kodowanie określonych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów jest włączone, nieprawidłowa sekwencja powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora i liczbę bajtów w preambuły nie jest odzwierciedlana w wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metody.  
  
   
  
## Examples  
 Poniższy przykład powoduje wypełnienie tablicy o liczbie łaciński, wielkie i małe litery i wywołania <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę pozwala ustalić liczbę bajtów potrzebnych do zakodowania znaki małe litery alfabetu łacińskiego. Następnie wyświetla te informacje wraz z całkowitą liczbą bajtów potrzebnych Jeśli znacznik kolejności bajtów jest dodawany. Porównuje tę liczbę za pomocą wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody, która określa maksymalną liczbę bajtów potrzebnych do zakodowania znaki małe litery alfabetu łacińskiego. Poniższy przykład wypełnia tablicę przy użyciu kombinacji znaków alfabetu greckiego i cyrylica i wywołania <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metodę pozwala ustalić liczbę bajtów potrzebnych do kodowania znaków cyrylicy. Następnie wyświetla te informacje wraz z całkowitą liczbą bajtów potrzebnych Jeśli znacznik kolejności bajtów jest dodawany. Porównuje tę liczbę za pomocą wartości zwracanej przez <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody, która określa maksymalną liczbę bajtów potrzebnych do kodowania znaków cyrylicy.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Koduje zestawu znaków w sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">Wskaźnik do pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <param name="byteCount">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Koduje zestaw znaków, zaczynając od określonego znaku wskaźnika do sekwencji bajtów, które są przechowywane, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych w lokalizacji wskazanej przez <paramref name="bytes" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania tablicy dokładny rozmiar <xref:System.Text.UnicodeEncoding.GetBytes%2A> wymaga, aby przechowywać wynikowy bajty, należy wywołać <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> obiekt udostępniany przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> lub <paramref name="byteCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="byteCount" /> jest mniejsza niż wynikowa liczba bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Tablica znaków, zawierającą zestaw znaków kodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków, z określoną tablicę znaków w określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody do zakodowania zakresu znaków z <xref:System.String> i przechowywać zakodowany bajtów w zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="chars" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Ciąg zawierający zestaw znaków do zakodowania.</param>
        <param name="charIndex">Indeks pierwszego znaku do zakodowania.</param>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <param name="bytes">Tablica bajtów ma zawierać wynikowa sekwencja bajtów.</param>
        <param name="byteIndex">Indeks, od którego należy rozpocząć pisanie wynikowa sekwencja bajtów.</param>
        <summary>Koduje zestaw znaków z określonego <see cref="T:System.String" /> do określonej tablicy bajtów.</summary>
        <returns>Rzeczywista liczba bajtów zapisanych na <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, wywołanie <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metody. Aby obliczyć maksymalny rozmiar tablicy, należy wywołać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metody. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowany bajtów są prawidłowo dekodowana, gdy są zapisywane jako pliku lub strumienia, może prefiks strumień zakodowany w bajtach od preambuły. Wstawianie Preambuła na początku strumienia bajtów (takich jak na początku serii bajtów, które mają być zapisywane w pliku) to obowiązek autora. <xref:System.Text.UnicodeEncoding.GetBytes%2A> Metody nie dołączy Preambuła na początku sekwencji bajtów zakodowany.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak kodować zakres elementów w tablicy znaków Unicode i przechowywać zakodowany bajtów w zakres elementów w tablicy bajtów.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> lub <paramref name="charCount" /> lub <paramref name="byteIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="charIndex" /> i <paramref name="charCount" /> nie określa prawidłowego zakresu <paramref name="chars" />.  
  
—lub— 
 <paramref name="byteIndex" /> nie jest prawidłowym indeksem w <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="s" /> zawiera nieprawidłową sekwencję znaków.  
  
—lub— 
 <paramref name="bytes" /> nie ma za małą pojemność z <paramref name="byteIndex" /> do końca tablicy, aby pomieścić wynikowy bajtów.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć tablicy dokładny rozmiar <xref:System.Text.UnicodeEncoding.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza liczbę znaków, generowane przez dekodowanie sekwencji bajtów z określonej tablicy bajtów.</summary>
        <returns>Liczba znaków, generowane przez dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.GetCharCount%2A> metodę, aby zwrócić liczbę znaków, generowane przez dekodowanie zakres elementów w tablicy bajtów przy użyciu <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dekoduje sekwencję bajtów w zestawie znaków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Wskaźnik do pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Wskaźnik do lokalizacji, w której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <param name="charCount">Maksymalna liczba znaków do zapisania.</param>
        <summary>Dekoduje sekwencji bajtów, zaczynając od wskaźnika określoną liczbę bajtów do zestawu znaków, które są przechowywane, zaczynając od określonego znaku wskaźnika.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w lokalizacji wskazanej przez <paramref name="chars" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby obliczyć tablicy dokładny rozmiar <xref:System.Text.UnicodeEncoding.GetChars%2A> wymaga, aby przechowywać wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> obiekt udostępniany przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> lub <paramref name="charCount" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="charCount" /> jest mniejsza niż wynikowa liczba znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="byteIndex">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <param name="chars">Tablica znaków, zawierać wynikowy zestaw znaków.</param>
        <param name="charIndex">Indeks, od której należy rozpocząć pisanie, wynikowy zestaw znaków.</param>
        <summary>Dekoduje sekwencję bajtów z tablicy określoną liczbę bajtów na określoną tablicę znaków.</summary>
        <returns>Rzeczywista liczba znaków zapisanych w <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> dostarczone przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> metody lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.GetChars%2A> metody dekodowania zakres elementów w tablicy bajtów i zapisać wynik w tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).  
  
—lub— 
 <paramref name="chars" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> lub <paramref name="byteCount" /> lub <paramref name="charIndex" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="byteindex" /> i <paramref name="byteCount" /> nie określa prawidłowego zakresu <paramref name="bytes" />.  
  
—lub— 
 <paramref name="charIndex" /> nie jest prawidłowym indeksem w <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.  
  
—lub— 
 <paramref name="chars" /> nie ma za małą pojemność z <paramref name="charIndex" /> do końca tablicy, aby pomieścić wynikowy znaków.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje dekoder, który konwertuje sekwencję zakodowane UTF-16 bajtów do sekwencji znaków Unicode.</summary>
        <returns>A <see cref="T:System.Text.Decoder" /> konwertuje sekwencję zakodowane UTF-16 bajtów do sekwencji znaków Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków bajtów do kolejnych bloków znaków, w sposób podobny do <xref:System.Text.UnicodeEncoding.GetChars%2A>. Jednak <xref:System.Text.Decoder> przechowuje informacje o stanie między wywołaniami, aby go można prawidłowo zdekodować sekwencji bajtów, które rozciągają się bloki. <xref:System.Text.Decoder> Także zachowuje końcowe bajty na końcu bloków danych i używa końcowe bajty w następnej operacji dekodowania. W związku z tym <xref:System.Text.UnicodeEncoding.GetDecoder%2A> i <xref:System.Text.UnicodeEncoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 Jeśli błędów jest włączone wykrywanie, oznacza to, `throwOnInvalidBytes` parametr konstruktora jest ustawiony na `true`, również jest włączone wykrywanie błędów w <xref:System.Text.Decoder> zwracanego przez tę metodę. Jeśli napotka nieprawidłową sekwencję wykrywanie błędów jest włączone, stan dekodera jest niezdefiniowana, i należy zatrzymać przetwarzanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto koder i dekoder, aby zakodować ciąg na tablicę bajtów, a następnie dekodowania bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera koder, który konwertuje sekwencję znaków Unicode do sekwencji zakodowane UTF-16 bajtów.</summary>
        <returns>A <see cref="T:System.Text.Encoder" /> obiekt, który konwertuje sekwencję znaków Unicode na UTF-16 zakodowane sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> Metoda konwertuje kolejnych bloków znaków na kolejne bloki bajtów w sposób podobny do <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody tej klasy. Jednak <xref:System.Text.Encoder> obiekt przechowuje informacje o stanie między wywołaniami tak, aby go jest poprawne kodowanie sekwencje znaków, które rozciągają się bloki. <xref:System.Text.Encoder> Obiektu również zachowuje końcowe znaki na końcu bloków danych i korzysta z nieprawidłowymi znakami w następnej operacji kodowania. Na przykład blok danych może kończyć się niedopasowane znakiem zastępczym wysokiego poziomu, a pasujące znak zastępczy niskiego poziomu może znajdować się w następnym bloku danych. W związku z tym <xref:System.Text.UnicodeEncoding.GetDecoder%2A> i <xref:System.Text.UnicodeEncoding.GetEncoder%2A> są przydatne w przypadku przesyłania w sieci i operacji na plikach, ponieważ te operacje często dotyczy bloki danych, zamiast strumienia kompletne dane.  
  
 Jeśli błędów jest włączone wykrywanie, oznacza to, `throwOnInvalidBytes` parametr konstruktora jest ustawiony na `true`, również jest włączone wykrywanie błędów w <xref:System.Text.Encoder> obiektu zwróconego przez tę metodę. Jeśli napotka nieprawidłową sekwencję wykrywanie błędów jest włączone, stan kodera jest niezdefiniowana, i należy zatrzymać przetwarzanie.  
  
   
  
## Examples  
 W poniższym przykładzie użyto koder i dekoder, aby zakodować ciąg na tablicę bajtów, a następnie dekodowania bajtów do tablicy znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Opis kodowania</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość skrótu dla bieżącego wystąpienia.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Text.UnicodeEncoding" /> obiektu.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Liczba znaków do zakodowania.</param>
        <summary>Oblicza maksymalną liczbę bajtów, generowane przez określoną liczbę znaków kodowania.</summary>
        <returns>Maksymalna liczba bajtów, generowane przez określoną liczbę znaków kodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetBytes%2A> do przechowywania wynikowy bajtów, aplikacja używa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. <xref:System.Text.UnicodeEncoding.GetByteCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> pobiera numer najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.EncoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> może zwracać dużej wartości.  
  
 W większości przypadków ta metoda pobiera uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Można także rozważyć użycie innego podejścia <xref:System.Text.UnicodeEncoding.GetByteCount%2A> lub <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> nie ma związku <xref:System.Text.UnicodeEncoding.GetChars%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UnicodeEncoding.GetChars%2A>, powinna korzystać <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> metodę, aby zwrócić maksymalną liczbę bajtów wymaganych do kodowania określoną liczbę znaków.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> ustawiono <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Liczba bajtów do odkodowania.</param>
        <summary>Oblicza maksymalną liczbę znaków, generowane przez określoną liczbę bajtów do zdekodowania.</summary>
        <returns>Maksymalna liczba znaków, generowane przez określoną liczbę bajtów do zdekodowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do obliczania rozmiaru tablicy dokładnie wymagane przez <xref:System.Text.UnicodeEncoding.GetChars%2A> do przechowywania wynikowy znaków, aplikacja używa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Aby obliczyć maksymalny rozmiar tablicy, aplikacja powinna użyć <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. <xref:System.Text.UnicodeEncoding.GetCharCount%2A> Metoda przydziela zazwyczaj mniej pamięci podczas <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Metoda ogólnie jest wykonywany szybciej.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> pobiera numer najgorszego przypadku, w tym najgorszego przypadku obecnie wybranego <xref:System.Text.DecoderFallback>. Jeśli wybrano rezerwowe z ciągiem potencjalnie dużą <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> pobiera dużych wartościach.  
  
 W większości przypadków ta metoda pobiera uzasadnione liczby małych ciągów. Dla dużych ciągów trzeba wybrać między za pomocą bardzo dużych buforów i przechwytywania błędów w rzadkich przypadkach przekroczenia buforu bardziej przystępne. Można także rozważyć użycie innego podejścia <xref:System.Text.UnicodeEncoding.GetCharCount%2A> lub <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> nie ma związku <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Jeśli aplikacja wymaga podobną funkcję do użycia z <xref:System.Text.UnicodeEncoding.GetBytes%2A>, powinna korzystać <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` niekoniecznie jest taka sama wartość jak `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> metodę, aby zwrócić maksymalną liczbę znaków generowane przez określoną liczbę bajtów dekodowania.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> jest mniejsza niż zero.  
  
—lub— 
Wynikowa liczba bajtów jest większa niż maksymalna liczba, które mogą być zwrócone jako liczba całkowita.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca znacznik kolejności bajtów Unicode zakodowane w formacie UTF-16, jeśli Konstruktor dla tego wystąpienia żądań znacznika kolejności bajtów.</summary>
        <returns>Tablica bajtów zawierająca znacznika kolejności bajtów Unicode, jeśli <see cref="T:System.Text.UnicodeEncoding" /> obiektu jest skonfigurowany do Podaj profil. W przeciwnym razie metoda ta zwraca tablicę bajtów o zerowej długości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding> Obiektu może zapewnić preambuły jest tablica bajtów, która może być poprzedzona sekwencji bajtów wynikające z procesu kodowania. Prefacing sekwencji bajtów zakodowany za pomocą znacznika kolejności bajtów (punkt kodowy U + FEFF) pomaga dekodera określanie kolejności bajtów i format transformacji lub UTF. Znacznika kolejności bajtów Unicode (BOM) jest serializowany w następujący sposób (w formacie szesnastkowym):  
  
-   Kolejności bajtów big endian: FE FF  
  
-   Little endian bajt kolejność: FF FE  
  
 Można utworzyć wystąpienie <xref:System.Text.UnicodeEncoding> którego <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metoda zwraca prawidłowy znak BOM w następujący sposób:  
  
-   Pobierając <xref:System.Text.UnicodeEncoding> obiektu zwróconego przez <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> lub <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> właściwości.  
  
-   Przez wywołanie metody bez parametrów <xref:System.Text.UnicodeEncoding.%23ctor> Konstruktor do tworzenia wystąpienia <xref:System.Text.UnicodeEncoding> obiektu.  
  
-   Podając `true` jako wartość `byteOrderMark` argument <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> lub <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> konstruktorów.  
  
 Zaleca się, że używasz BOM, ponieważ zapewnia niemal niektórych Identyfikacja kodowania dla plików, które w przeciwnym razie utracić odwołanie do ich kodowania, takich jak tagów lub niepoprawnie oznakowane danych w sieci web lub pliki losowego tekstu, zapisana, gdy firma nie miał międzynarodowe uwagi. Może być można uniknąć często problemów użytkowników, jeśli dane spójne i odpowiednio oznaczone.  
  
 Pod kątem obsługi standardów, które udostępniają typ kodowania znak BOM jest nieco nadmiarowe. Jednak może służyć ułatwiające serwera wysyłaj poprawny nagłówek kodowania. Alternatywnie może służyć jako rezerwowe w przypadku, gdy kodowanie, w przeciwnym razie zostaną utracone.  
  
 Istnieją pewne wady za pomocą znak BOM. Na przykład jak ograniczyć polach bazy danych, które używają znak BOM, wiedząc, może być trudne. Łączenie plików, może to stanowić problem również, na przykład, gdy pliki są scalane w taki sposób, który znak niepotrzebne obydwie mogą znaleźć się w trakcie wykonywania danych. Mimo kilku wady jednak użycie znak BOM jest zdecydowanie zaleca się.  
  
> [!IMPORTANT]
>  Aby upewnić się, że zakodowany bajtów są poprawnie dekodowane, powinien prefiks początku strumień zakodowany w bajtach od preambuły. Należy pamiętać, że <xref:System.Text.UnicodeEncoding.GetBytes%2A> metody nie poprzedzić znak BOM sekwencji bajtów zakodowany; BOM na początku strumienia bajtów odpowiednie dostarczenie jest odpowiedzialność deweloperów.  
  
   
  
## Examples  
 Poniższy przykład pokazuje sposób użycia <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodę, która pobierze znacznika kolejności bajtów Unicode w big endian lub nieco kolejności bajtów endian dla wystąpienia <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 Poniższy przykład tworzy dwie <xref:System.Text.UnicodeEncoding> obiektów, pierwszy z nich nie zawiera znak BOM, a druga która. Następnie wywołuje <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodę, aby zapisać BOM do pliku przed napisaniem ciąg kodowany w formacie Unicode. Konsola danych wyjściowych z przykładu pokazują, plik który zapisuje bajty z kodera drugi ma trzy bajty więcej niż pierwszy.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 Można również porównać plików za pomocą `fc` polecenie w oknie konsoli, lub można sprawdzić pliki w edytorze tekstu, który zawiera trybu widoku szesnastkowy. Należy pamiętać, że jeśli plik jest otwarty w edytorze, który obsługuje kodowanie UTF-16, znak BOM nie jest wyświetlana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Tablica bajtów zawierająca sekwencji bajtów do zdekodowania.</param>
        <param name="index">Indeks pierwszego bajtu do odkodowania.</param>
        <param name="count">Liczba bajtów do odkodowania.</param>
        <summary>Dekoduje zakresu bajtów z tablicy bajtów na ciąg.</summary>
        <returns>Element <see cref="T:System.String" /> obiektu zawierającego wyniki dekodowanie określonej sekwencji bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykrywanie błędów nieprawidłową sekwencję powoduje, że tę metodę, aby zgłosić <xref:System.ArgumentException>. Bez wykrywanie błędów nieprawidłowych sekwencji są ignorowane i jest zgłaszany żaden wyjątek.  
  
 Jeśli tablica bajtów został zwrócony przez metodę typu pamiętać-BOM zakresu bajtów, które ma być zdekodowany, zawiera znacznik kolejności bajtów (BOM), znaku U + FFFE znajduje się w tablicy znaków zwracanego przez tę metodę. Możesz je usunąć, wywołując <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 Dane, które ma zostać przekonwertowany, takich jak dane odczytane ze strumienia, mogą być dostępne tylko w kolejnych blokach. W tym przypadku lub gdy ilość danych jest tak duża, że musi być dzielone na mniejsze bloki, aplikacja powinna używać <xref:System.Text.Decoder> lub <xref:System.Text.Encoder> obiekt udostępniany przez <xref:System.Text.UnicodeEncoding.GetDecoder%2A> lub <xref:System.Text.UnicodeEncoding.GetEncoder%2A> metody, odpowiednio.  
  
   
  
## Examples  
 Poniższy przykład Inicjuje tablicę, wywołując <xref:System.Text.UnicodeEncoding.GetByteCount%2A> metodę, aby określić dokładnie liczbę bajtów są wymagane dla zakodowany ciąg, a następnie dodając rozmiar znacznika kolejności bajtów (BOM). Przykład następnie wywołuje <xref:System.Text.UnicodeEncoding.GetPreamble%2A> metodę, aby przechowywać BOM do tablicy przed wywołaniem <xref:System.Text.Encoding.GetBytes%2A> metodę, aby przechowywać zakodowany bajtów do tablicy. Przykład następnie wywołuje <xref:System.Text.UnicodeEncoding.GetString%2A> metoda zdekodować ciągu.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Należy pamiętać, że w tym przypadku Dekodowany ciąg różni się od oryginalnego ciągu, ponieważ rozpoczyna się znacznik kolejności bajtów 16-bitowych U + FFFD. Oznacza to, czy dwa ciągi zostanie porównany ich nierówność i, jeśli ciąg jest dane wyjściowe, BOM będą wyświetlane jako znaku zastępczego "?". Aby usunąć znak BOM na początku ciągu, można wywołać <xref:System.String.TrimStart%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> jest <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> lub <paramref name="count" /> jest mniejsza niż zero.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Wykrywanie błędów jest włączone, i <paramref name="bytes" /> zawiera nieprawidłową sekwencję bajtów.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Wystąpił rezerwowe (zobacz [kodowanie znaków na platformie .NET Framework](~/docs/standard/base-types/character-encoding.md) wyjaśnienie większy) 
- i - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> ustawiono <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>
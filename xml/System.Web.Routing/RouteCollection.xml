<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cf5ff60b46deeeccf60512f17fb902ace47c66d5" />
    <Meta Name="ms.sourcegitcommit" Value="1b899505ed6d42225f2b3c9150bfdc080d0d1f9b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/28/2018" />
    <Meta Name="ms.locfileid" Value="32089311" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia kolekcję tras routingu platformy ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection> Klasa udostępnia metody umożliwiające zarządzanie kolekcją obiektów wyprowadzonych z <xref:System.Web.Routing.RouteBase> klasy.  
  
 Zazwyczaj będzie używać `static` <xref:System.Web.Routing.RouteTable.Routes%2A> właściwość <xref:System.Web.Routing.RouteTable> klasy można pobrać <xref:System.Web.Routing.RouteCollection> obiektu. <xref:System.Web.Routing.RouteTable.Routes%2A> Właściwość przechowuje wszystkich tras dla aplikacji ASP.NET. Proces routingu platformy ASP.NET iteruje trasy w <xref:System.Web.Routing.RouteTable.Routes%2A> właściwości można znaleźć trasy, która odpowiada adresowi URL.  
  
 Aby utworzyć adres URL, należy wywołać <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> — metoda i przekaż zbiór wartości. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> Metoda znajdzie pierwszy trasy z parametrami, które odpowiadają wartościom, które przekazano i zwraca <xref:System.Web.Routing.VirtualPathData> obiektu, który zawiera informacje o pasującej trasy. Pobieranie adresu URL za pośrednictwem <xref:System.Web.Routing.VirtualPathData.VirtualPath%2A> właściwość <xref:System.Web.Routing.VirtualPathData> obiektu.  
  
 Możesz dodać trasy o nazwie lub bez nazwy. W tym nazwę umożliwia rozróżnienia podobne tras, gdy adresy URL są wykonane. Jeśli nie określisz nazwy, proces routingu platformy ASP.NET używa pierwszego pasującej trasy w kolekcji do konstruowania adresu URL.  
  
 Po dodaniu nazwy trasy do <xref:System.Web.Routing.RouteCollection> obiektu, nie można dodać trasy, który jest już w kolekcji. Po dodaniu nazwanej trasy, nie można użyć nazwy, która już identyfikuje trasy w kolekcji.  
  
 Możesz użyć <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
 Aby uzyskać więcej informacji o sposobie dodawania trasy do kolekcji tras, zobacz [routingu platformy ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Routing.RouteCollection" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Routing.RouteCollection" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">Dostawcy do pobierania zasobów z wirtualnym systemie plików.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Routing.RouteCollection" /> przy użyciu dostawcy określonej ścieżki wirtualnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">Wartość, która identyfikuje trasy. Wartość może być <see langword="null" /> lub ciąg pusty.</param>
        <param name="item">Trasy do dodania do końca kolekcji.</param>
        <summary>Dodaje trasę do końca <see cref="T:System.Web.Routing.RouteCollection" /> obiektów i przypisuje określonej nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection.Add%2A> Metody umożliwia zdefiniowanie nazwę trasy, po dodaniu go do kolekcji tras. Definiując nazwę trasy, można określić określonej trasy do użycia podczas używać routingu do konstruowania adresu URL. Określenie określonej trasy jest ważne, gdy więcej niż jedna trasa odpowiada wartości, które są przekazywane do <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> metody. Jeśli nie określisz nazwanej trasy, proces routingu platformy ASP.NET użyje pierwszego trasy w kolekcji, która odpowiada wartości. Aby uzyskać więcej informacji, zobacz [jak: utworzyć adresy URL z tras](http://msdn.microsoft.com/library/1ffd4085-71f6-4822-be8f-f682ca638650).  
  
 Nazwa może być używana tylko raz w <xref:System.Web.Routing.RouteCollection> obiektu.  
  
 Jeśli trzeba określić nazwę trasy, możesz dodać trasy przez wywołanie metody <xref:System.Collections.ObjectModel.Collection%601.Add%2A> metody.  
  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodać trasę do <xref:System.Web.Routing.RouteCollection> obiektu i przypisz nazwę do trasy.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest już używana w kolekcji.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy końcowe ukośniki są dodawane, gdy są znormalizowany ścieżek wirtualnych.</summary>
        <value>
          <see langword="true" /> Jeśli końcowe ukośniki są dodawane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Web.Routing.RouteCollection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiera obiekt zarządzania bezpieczeństwo wątków podczas pobierania obiektu z kolekcji.</summary>
        <returns>Obiekt, który zarządza bezpieczeństwa wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection> Obiekt jest dostępny do wielu procesów w aplikacji. W związku z tym, jeśli należy pobrać trasy, gdy aplikacja jest uruchomiona, użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody w celu zagwarantowania bezpieczeństwa wątków. Uzyskując blokady odczytu w kolekcji tras, należy upewnić się, że kolekcja nie zostaną zmodyfikowane podczas próby pobrania jej.  
  
 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> Metoda zatrzymuje wątek przed kontynuowaniem, dopóki nie można uzyskać blokady. Jeśli blokady zapisu znajduje się w miejscu, wątek oczekuje, aż zostanie ukończona i zwolnienia blokady zapisu. Zwolnienia blokady odczytu w kolekcji tras podczas <xref:System.IDisposable> jest usunięty obiekt, który jest zwracany przez tę metodę.  
  
 Jeśli nie używasz <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>, można uzyskać wystąpił błąd podczas odczytywania za pośrednictwem <xref:System.Web.Routing.RouteCollection> kolekcji. Załóżmy na przykład, pętla za pośrednictwem obiektów w <xref:System.Web.Routing.RouteCollection> kolekcji do odczytania, bez wywoływania elementu <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>. Podczas czynności które może wywołać inny wątek z innego żądania <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> i dodać trasę do kolekcji. Pierwszym wątkiem następnie zakończy się niepowodzeniem z powodu błędu.  
  
 Istnieją dwa scenariusze, w których nie trzeba wywołać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>:  
  
-   Metody publiczne <xref:System.Web.Routing.RouteCollection> klas takich jak <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> i <xref:System.Web.Routing.RouteCollection.GetRouteData%2A> wywołać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> wewnętrznie. W związku z tym nie trzeba jawnie wywołać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> podczas wywołania metody publicznej z <xref:System.Web.Routing.RouteCollection> klasy można pobrać danych z kolekcji.  
  
-   Gdy aplikacja jest uruchamiana i nie jeszcze przetwarza żądań, takich jak w `Application_Start` program obsługi zdarzeń, tylko jeden wątek jest uruchomiony. Ponieważ nie zawiera żadnych innych wątków, które może aktualizować kolekcji podczas jej odczytywania, nie trzeba wywołać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody podczas pobierania trasy, gdy aplikacja jest uruchomiona. `Using` Instrukcji gwarantuje, że niezależnie od tego, co się stanie w czasie wykonywania, gdy przeczytanie z kolekcji (czy normalnie kończy działanie kodu lub jest zgłaszany wyjątek) blokady zostaną bezpiecznie wydane na końcu `Using` blok kodu.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">Obiekt hermetyzujący informacje o żądaniu HTTP.</param>
        <summary>Zwraca informacje dotyczące trasy w kolekcji, zgodny z określonymi wartościami.</summary>
        <returns>Obiekt zawierający wartości z definicji trasy.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.HttpContextBase.Request" /> Właściwości obiektu w <paramref name="context" /> parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca informacje o ścieżce URL, który jest skojarzony z trasą.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Obiekt, który hermetyzuje informacje o trasie.</param>
        <param name="values">Obiekt zawierający parametry trasy.</param>
        <summary>Zwraca informacje o ścieżce URL, który jest skojarzony z trasy, podane wartości określonego kontekstu i parametru.</summary>
        <returns>Obiekt zawierający informacje o ścieżce URL, który jest skojarzony z trasą.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Obiekt, który hermetyzuje informacje o trasie.</param>
        <param name="name">Nazwa trasy do użycia po pobraniu informacji o ścieżce URL.</param>
        <param name="values">Obiekt zawierający parametry trasy.</param>
        <summary>Zwraca informacje o ścieżce URL, który jest skojarzony z nazwanej trasy danej określonego kontekstu, nazwy trasy i wartości parametrów.</summary>
        <returns>Obiekt zawierający informacje o ścieżce URL, który jest skojarzony z trasą.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Żadna trasa nie odnaleziono mający nazwa określona w <paramref name="name" /> parametru.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiera obiekt zarządzania bezpieczeństwo wątków po dodaniu lub usunięciu elementów w kolekcji.</summary>
        <returns>Obiekt, który zarządza bezpieczeństwa wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane podejście do definiowania trasy w aplikacji ASP.NET jest dodanie trasy do <xref:System.Web.Routing.RouteTable.Routes%2A> właściwości w obsłudze zdarzeń dla `Application_Start` zdarzenia w pliku Global.asax. Aby uzyskać więcej informacji, zobacz <xref:System.Web.Routing.RouteCollection>.  
  
 Jeśli trzeba dodać trasy, jeśli aplikacja jest uruchomiona, możesz użyć <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody w celu zagwarantowania bezpieczeństwa wątków. Zwolnienia blokady zapisu w kolekcji tras podczas <xref:System.IDisposable> jest usunięty obiekt, który jest zwracany przez tę metodę.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metodą podczas Dodaj trasę, gdy aplikacja jest uruchomiona.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje wzorca adresu URL, który nie mają być wyszukiwane dopasowania dla trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy trasy, który jest zamapowany na <xref:System.Web.Routing.StopRoutingHandler> obsługi trasy. Po wywołaniu tej metody nie można przetworzyć żądania zgodne z określonym wzorcem adresu URL jako żądania trasy.  
  
 Automatycznie routingu platformy ASP.NET ignoruje żądania, gdy adres URL jest zgodna z pliku fizycznego, takich jak plik obrazu. W niektórych przypadkach można także routingu do ignorowania żądań, gdy plik fizyczne nie istnieje. Na przykład żądania, które ASP.NET automatycznie sprawia, że pliki .axd powinien nie będzie traktowane jako trasy żądania, nawet jeśli nie wystąpi Brak pliku fizycznego, umożliwiająca .axd rozszerzenia nazwy pliku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Wzorzec URL mają być ignorowane.</param>
        <summary>Definiuje wzorca adresu URL, który nie mają być wyszukiwane dopasowania dla trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy trasy, który jest zamapowany na <xref:System.Web.Routing.StopRoutingHandler> obsługi trasy. Po wywołaniu tej metody nie można przetworzyć żądania zgodne z określonym wzorcem adresu URL jako żądania trasy.  
  
 Automatycznie routingu platformy ASP.NET ignoruje żądania, gdy adres URL jest zgodna z pliku fizycznego, takich jak plik obrazu. W niektórych przypadkach można także routingu do ignorowania żądań, gdy plik fizyczne nie istnieje. Na przykład żądania, które ASP.NET automatycznie sprawia, że pliki .axd powinien nie będzie traktowane jako trasy żądania, nawet jeśli nie wystąpi Brak pliku fizycznego, umożliwiająca .axd rozszerzenia nazwy pliku.  
  
   
  
## Examples  
 Domyślny szablon dla projektów MVC używa tej metody do wykluczenia plików .axd routingu, jak pokazano w poniższym przykładzie:  
  
 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="constraints" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="url">Wzorzec URL mają być ignorowane.</param>
        <param name="constraints">Dodatkowe kryteria określające, czy żądanie, która odpowiada wzorcowi URL zostanie zignorowane.</param>
        <summary>Definiuje wzorca adresu URL, który nie powinna być sprawdzana dla odpowiedników trasy, jeśli adres URL żądania spełnia określonych warunków ograniczających.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy trasy, który jest zamapowany na <xref:System.Web.Routing.StopRoutingHandler> obsługi trasy. Po wywołaniu tej metody nie można przetworzyć żądania zgodne z określonym wzorcem adresu URL jako żądania trasy.  
  
 Automatycznie routingu platformy ASP.NET ignoruje żądania, gdy adres URL jest zgodna z pliku fizycznego, takich jak plik obrazu. W niektórych przypadkach można także routingu do ignorowania żądań, gdy plik fizyczne nie istnieje. Na przykład żądania, które ASP.NET automatycznie sprawia, że pliki .axd powinien nie będzie traktowane jako trasy żądania, nawet jeśli nie wystąpi Brak pliku fizycznego, umożliwiająca .axd rozszerzenia nazwy pliku.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tej metody ignoruje wszystkie adresy URL, które mają rozszerzenie aspx. Można to zrobić po zarejestrowaniu niestandardowego programu obsługi HTTP do obsługi wszystkich adresów URL dla plików z rozszerzeniem ".aspx". Pojedynczy wzorzec adres URL, który umożliwi dopasowanie wszystkich żądań .aspx wymaga dwóch parametrów przechwytywania wszystkich elementów takich jak `{*path}.aspx/{*pathinfo}`. (Ten wzorzec umożliwi dopasowanie dowolny adres URL, który kończy się .aspx, łącznie z tymi, które mają parametry ciągu zapytania). Jednak routingu umożliwia tylko jeden parametr przechwytywania wszystkich elementów na końcu. Alternatywnie można określić wzorca adresu URL, który ma jeden parametr przechwytywania wszystkich elementów, który dopasowuje wszystkie adresy URL, a następnie określ ograniczenia, które wykluczyć wszystkie czynności, które nie ma rozszerzenia aspx, jak pokazano w poniższym przykładzie:  
  
```vb  
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})  
```  
  
```csharp  
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});  
```  
  
 W poprzednim wierszu kodu zwykle zostanie dodany do metody, która jest wywoływana z `Application_Start` metody w pliku Global.asax, jak pokazano w przykładzie dla <xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <c>elementu</c> jest wstawiany.</param>
        <param name="item">Trasy do wstawienia.</param>
        <summary>Wstawia określoną trasę do <see cref="T:System.Web.Routing.RouteCollection" /> obiektu pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dodaniu nazwy trasy do <xref:System.Web.Routing.RouteCollection> obiektu, nie można dodać trasy, który jest już w kolekcji.  
  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest już w kolekcji.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Wartość, która identyfikuje trasy do pobrania.</param>
        <summary>Pobiera trasę w kolekcji, która ma określoną nazwę.</summary>
        <value>Obiekt o określonej nazwie lub <see langword="null" /> Jeśli <paramref name="name" /> jest <see langword="null" />, to ciąg pusty lub nie pasuje do żadnej trasy w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy adresy URL są konwertowane na małe litery, podczas są znormalizowany ścieżek wirtualnych.</summary>
        <value>
          <see langword="true" /> Aby przekonwertować adresy URL na małe litery; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli adres URL zawiera ciąg zapytania, część adresu URL nie jest konwertowany na małe litery.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Udostępnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.Routing.RouteCollection.Add%2A> — metoda i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras dla aplikacji formularzy sieci Web za pomocą tej metody. W przykładzie pokazano metodę o nazwie `RegisterRoutes` który jest wywoływany z `Application_Start` w pliku Global.asax. Metoda używa do każdego przeciążenia <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> było dodać trasę do aplikacji. Aby uzyskać więcej informacji na temat definiowania tras dla aplikacji formularzy sieci Web, zobacz [porady: Definiowanie tras dla aplikacji formularzy sieci Web](http://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678).  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL trasy.</param>
        <summary>Udostępnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.Routing.RouteCollection.Add%2A> — metoda i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras za pomocą tej metody. Pierwsza instrukcja określa trasę, która nie ma nazwy. Druga instrukcja definiuje nazwanej trasy. Ten przykład jest częścią większego przykładu dostępnego w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> Omówienie metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia dostępu do fizycznego adresu URL (trasy adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <summary>Udostępnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.Routing.RouteCollection.Add%2A> — metoda i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras za pomocą tej metody. Ten przykład jest częścią większego przykładu dostępnego w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> Omówienie metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia dostępu do fizycznego adresu URL (trasy adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <param name="defaults">Wartości domyślne dla parametrów trasy.</param>
        <summary>Udostępnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.Routing.RouteCollection.Add%2A> — metoda i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras za pomocą tej metody. Ten przykład jest częścią większego przykładu dostępnego w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> Omówienie metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia dostępu do fizycznego adresu URL (trasy adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <param name="defaults">Wartości domyślne dla trasy.</param>
        <param name="constraints">Ograniczenia, które żądanie adresu URL musi spełniać w celu przetworzenia jako tej trasy.</param>
        <summary>Udostępnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.Routing.RouteCollection.Add%2A> — metoda i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras za pomocą tej metody. Ten przykład jest częścią większego przykładu dostępnego w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> Omówienie metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia dostępu do fizycznego adresu URL (trasy adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <param name="defaults">Wartości domyślne dla parametrów trasy.</param>
        <param name="constraints">Ograniczenia, które żądanie adresu URL musi spełniać w celu przetworzenia jako tej trasy.</param>
        <param name="dataTokens">Wartości, które są skojarzone z nie są używane do określenia, czy trasa pasuje wzorzec URL trasy.</param>
        <summary>Udostępnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest dostępna dla wygody kodowania. Jest to odpowiednik wywołania <xref:System.Web.Routing.RouteCollection.Add%2A> — metoda i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras za pomocą tej metody. Ten przykład jest częścią większego przykładu dostępnego w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> Omówienie metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="routeUrl" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks trasy do usunięcia.</param>
        <summary>Usuwa trasy z <see cref="T:System.Web.Routing.RouteCollection" /> obiektu pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy Proces routingu platformy ASP.NET powinna obsługiwać adresy URL, które pasują do istniejącego pliku.</summary>
        <value>
          <see langword="true" /> Proces routingu platformy ASP.NET obsługuje wszystkie żądania, nawet te, które odpowiada istniejący plik; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że tę wartość można zmienić dynamicznie, wszelkie zmiany dokonane po aktywowaniu usługi zostanie zignorowany, gdy przy użyciu integracji routingu programu ASP.NET. Aby uzyskać więcej informacji, zobacz [integracji routingu programu ASP.NET](http://go.microsoft.com/fwlink/?LinkId=195235).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks trasy do zastąpienia.</param>
        <param name="item">Trasy do dodania w określonym indeksie.</param>
        <summary>Zastępuje trasy pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dodaniu nazwy trasy do <xref:System.Web.Routing.RouteCollection> obiektu, nie można dodać trasy, który jest już w kolekcji.  
  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> — metoda i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że interakcję z kolekcji bez powoduje konflikt z innymi procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest już w kolekcji.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="71c8f23d2a321f2619c22cefbc0568682f299389" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51917064" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <TypeSignature Language="F#" Value="type RouteCollection = class&#xA;    inherit Collection&lt;RouteBase&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Routing</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zawiera kolekcję tras routingu platformy ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection> Klasa dostarcza metody umożliwiające zarządzanie kolekcją obiektów wyprowadzonych z <xref:System.Web.Routing.RouteBase> klasy.  
  
 Zazwyczaj można użyć `static` <xref:System.Web.Routing.RouteTable.Routes%2A> właściwość <xref:System.Web.Routing.RouteTable> klasy do pobrania <xref:System.Web.Routing.RouteCollection> obiektu. <xref:System.Web.Routing.RouteTable.Routes%2A> Właściwość przechowuje wszystkie trasy dla aplikacji ASP.NET. Routingu platformy ASP.NET iterację trasy w <xref:System.Web.Routing.RouteTable.Routes%2A> właściwości w celu znajdowania trasy, który odpowiada adresu URL.  
  
 Aby skonstruować adres URL, należy wywołać <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> metody i przekazać w zbiorze wartości. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> Metoda znajdzie pierwszy trasy z parametrami, które odpowiadają wartości, które są przekazywane do, a funkcja zwraca <xref:System.Web.Routing.VirtualPathData> obiektu, który zawiera informacje o pasującej trasy. Pobieranie adresu URL za pośrednictwem <xref:System.Web.Routing.VirtualPathData.VirtualPath%2A> właściwość <xref:System.Web.Routing.VirtualPathData> obiektu.  
  
 Możesz dodać trasy, o nazwie lub bez nazwy. Łącznie z nazwą pozwala rozróżnić podobne trasy, gdy adresy URL są konstruowane. Jeśli nie określisz nazwy, routingu platformy ASP.NET używa pierwszego dopasowania trasy w kolekcji można skonstruować adres URL.  
  
 Po dodaniu nazwy trasy do <xref:System.Web.Routing.RouteCollection> obiektu, nie można dodać trasę, która jest już w kolekcji. Po dodaniu nazwanej trasy, nie można użyć nazwy, która już identyfikuje trasy w kolekcji.  
  
 Możesz użyć <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
 Aby uzyskać więcej informacji o tym, jak dodać trasę do kolekcji tras, zobacz [routingu platformy ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Routing.RouteCollection" /> klasy.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Routing.RouteCollection" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberSignature Language="F#" Value="new System.Web.Routing.RouteCollection : System.Web.Hosting.VirtualPathProvider -&gt; System.Web.Routing.RouteCollection" Usage="new System.Web.Routing.RouteCollection virtualPathProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">Dostawca do pobierania zasobów z wirtualny system plików.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Routing.RouteCollection" /> klasy przy użyciu dostawcy określonej ścieżki wirtualnej.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.Add : string * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.Add (name, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">Wartość, która identyfikuje trasy. Wartość może być <see langword="null" /> ani być pustym ciągiem.</param>
        <param name="item">Trasa do dodania na końcu kolekcji.</param>
        <summary>Dodaje trasę do końca <see cref="T:System.Web.Routing.RouteCollection" /> obiektu i przypisuje określonej nazwy trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection.Add%2A> Metody umożliwia zdefiniowanie nazwę trasy, po dodaniu go do kolekcji tras. Definiując nazwę trasy, można określić określonej trasy do użycia podczas umożliwia routing skonstruować adres URL. Określanie konkretnej trasy jest ważne, gdy więcej niż jedna trasa pasuje do wartości, które są przekazywane do <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> metody. Jeśli nie określisz nazwanej trasy, routingu platformy ASP.NET użyje pierwszego trasy w kolekcji, który odpowiada wartości. Aby uzyskać więcej informacji, zobacz [jak: konstruowania adresy URL, z tras](https://msdn.microsoft.com/library/1ffd4085-71f6-4822-be8f-f682ca638650).  
  
 Nazwa może być używana tylko jeden raz w <xref:System.Web.Routing.RouteCollection> obiektu.  
  
 Jeśli musisz określić nazwę dla trasy, można dodać trasy, wywołując <xref:System.Collections.ObjectModel.Collection%601.Add%2A> metody.  
  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodać trasę do <xref:System.Web.Routing.RouteCollection> obiektu i przypisać nazwy do trasy.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> jest już używana w kolekcji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AppendTrailingSlash : bool with get, set" Usage="System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy końcowe ukośniki są dodawane, gdy są znormalizowane ścieżek wirtualnych.</summary>
        <value>
          <see langword="true" /> Jeśli zostaną dodane końcowych ukośników; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="routeCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Web.Routing.RouteCollection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberSignature Language="F#" Value="member this.GetReadLock : unit -&gt; IDisposable" Usage="routeCollection.GetReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiera obiekt zarządzania bezpieczeństwo wątków podczas pobierania obiektu z kolekcji.</summary>
        <returns>Obiekt, który zarządza bezpieczeństwo wątkowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Routing.RouteCollection> Obiekt jest dostępny do wielu procesów w aplikacji. W związku z tym, jeśli trzeba pobrać trasę, gdy aplikacja jest uruchomiona, użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody, aby zagwarantować bezpieczeństwo wątków. Uzyskując blokadę odczytu na kolekcję tras, należy upewnić się, że kolekcja nie zostaną zmodyfikowane podczas próby pobrania go.  
  
 <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> Metoda zatrzymuje wątek za kontynuację, dopóki nie można uzyskać blokady. Jeśli blokadę zapisu znajduje się w miejscu, wątek czeka, aż zostanie ukończona i zapisu blokada jest zwalniana. Zwolnieniu blokady odczytu kolekcji tras. gdy <xref:System.IDisposable> usunięciu obiektu, który jest zwracany przez tę metodę.  
  
 Jeśli nie używasz <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>, możesz otrzymać błąd podczas odczytywania za pośrednictwem <xref:System.Web.Routing.RouteCollection> kolekcji. Załóżmy, że pętla do obiektów w <xref:System.Web.Routing.RouteCollection> kolekcji do odczytania, bez wywoływania <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>. Podczas ustalania, może wywołać inny wątek z innego żądania <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> i dodać trasę do kolekcji. Pierwszym wątkiem następnie zakończy się niepowodzeniem z powodu błędu.  
  
 Istnieją dwa scenariusze, w których nie trzeba wywoływać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>:  
  
-   Metody publiczne <xref:System.Web.Routing.RouteCollection> klasy takie jak <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> i <xref:System.Web.Routing.RouteCollection.GetRouteData%2A> wywołania <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> wewnętrznie. W związku z tym, nie trzeba jawnie wywoływać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> gdy zostanie wywołana metoda publiczna <xref:System.Web.Routing.RouteCollection> klasy do pobrania danych z kolekcji.  
  
-   Gdy aplikacja jest uruchamiana i nie jeszcze przetwarzania żądań, takich jak w `Application_Start` procedura obsługi zdarzeń, tylko jeden wątek jest uruchomiony. Ponieważ nie ma innych wątków, które może aktualizować kolekcji podczas jej odczytywania, nie trzeba wywołać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metoda po pobraniu trasę, gdy aplikacja jest uruchomiona. `Using` Instrukcji zapewnia, że niezależnie od tego, co się stanie w czasie wykonywania, gdy umożliwia odczyt z kolekcji (czy kod zakończy się normalnie lub zostanie zgłoszony wyjątek) blokady zostaną bezpiecznie wydane na końcu `Using` bloku kodu.  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberSignature Language="F#" Value="member this.GetRouteData : System.Web.HttpContextBase -&gt; System.Web.Routing.RouteData" Usage="routeCollection.GetRouteData httpContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">Obiekt, który hermetyzuje informacje o żądaniu HTTP.</param>
        <summary>Zwraca informacje dotyczące trasy w kolekcji, który odpowiada określonej wartości.</summary>
        <returns>Obiekt zawierający wartości z definicji trasy.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.HttpContextBase.Request" /> Właściwości obiektu w <paramref name="context" /> parametr <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca informacje o ścieżce URL skojarzonym z trasą.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Obiekt, który hermetyzuje informacje o żądanej trasie.</param>
        <param name="values">Obiekt zawierający parametry trasy.</param>
        <summary>Zwraca informacje o ścieżce URL, który jest skojarzony z trasy, rozpoczynając od podanej wartości określonego kontekstu i parametr.</summary>
        <returns>Obiekt, który zawiera informacje o ścieżce URL skojarzonym z trasą.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * string * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, name, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Obiekt, który hermetyzuje informacje o żądanej trasie.</param>
        <param name="name">Nazwa trasy do użycia po pobraniu informacji o ścieżce URL.</param>
        <param name="values">Obiekt zawierający parametry trasy.</param>
        <summary>Zwraca informacje o ścieżce URL, który jest skojarzony z nazwanej trasy, rozpoczynając od podanej określonego kontekstu, nazwy trasy i wartości parametrów.</summary>
        <returns>Obiekt, który zawiera informacje o ścieżce URL skojarzonym z trasą.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Brak trasy można odnaleźć zawierającej nazwy określonej w <paramref name="name" /> parametru.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberSignature Language="F#" Value="member this.GetWriteLock : unit -&gt; IDisposable" Usage="routeCollection.GetWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zawiera obiekt zarządzania bezpieczeństwo wątków podczas możesz dodawać lub usuwać elementy w kolekcji.</summary>
        <returns>Obiekt, który zarządza bezpieczeństwo wątkowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane podejście do definiowania trasy w aplikacji ASP.NET jest dodanie trasy do <xref:System.Web.Routing.RouteTable.Routes%2A> właściwość w obsłudze zdarzeń dla `Application_Start` zdarzenia w pliku Global.asax. Aby uzyskać więcej informacji, zobacz <xref:System.Web.Routing.RouteCollection>.  
  
 Jeśli trzeba dodać trasę, gdy aplikacja jest uruchomiona, możesz użyć <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metodę, aby zagwarantować bezpieczeństwo wątków. Blokadę zapisu kolekcji tras jest zwalniany podczas <xref:System.IDisposable> usunięciu obiektu, który jest zwracany przez tę metodę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, gdy dodać trasę, gdy aplikacja jest uruchomiona.  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiuje wzorzec adresu URL, który nie powinna być sprawdzana dopasowania dla trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy trasę, która jest mapowana do <xref:System.Web.Routing.StopRoutingHandler> programu obsługi trasy. Po wywołaniu tej metody nie można przetworzyć żądania, które odpowiadają określony wzorzec adresu URL jako kierowanie żądań.  
  
 Automatycznie routingu platformy ASP.NET ignoruje żądania, gdy adres URL jest zgodna z fizycznym pliku, na przykład pliku obrazu. W niektórych przypadkach można także routingu w celu ignorowania żądań, gdy nie ma żadnego pliku fizycznego. Na przykład żądania, które ASP.NET automatycznie sprawia, że w przypadku plików .axd powinna nie traktowane jako kierowanie żądań, nawet jeśli nie ma żadnego pliku fizycznego, odpowiadający .axd rozszerzenia nazwy pliku.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string -&gt; unit" Usage="routeCollection.Ignore url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Wzorzec URL, które mają być ignorowane.</param>
        <summary>Definiuje wzorzec adresu URL, który nie powinna być sprawdzana dopasowania dla trasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy trasę, która jest mapowana do <xref:System.Web.Routing.StopRoutingHandler> programu obsługi trasy. Po wywołaniu tej metody nie można przetworzyć żądania, które odpowiadają określony wzorzec adresu URL jako kierowanie żądań.  
  
 Automatycznie routingu platformy ASP.NET ignoruje żądania, gdy adres URL jest zgodna z fizycznym pliku, na przykład pliku obrazu. W niektórych przypadkach można także routingu w celu ignorowania żądań, gdy nie ma żadnego pliku fizycznego. Na przykład żądania, które ASP.NET automatycznie sprawia, że w przypadku plików .axd powinna nie traktowane jako kierowanie żądań, nawet jeśli nie ma żadnego pliku fizycznego, odpowiadający .axd rozszerzenia nazwy pliku.  
  
   
  
## Examples  
 Domyślny szablon dla projektów MVC używa tej metody wykluczyć pliki .axd z routingu, jak pokazano w poniższym przykładzie:  
  
 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string * obj -&gt; unit" Usage="routeCollection.Ignore (url, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="constraints" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="url">Wzorzec URL, które mają być ignorowane.</param>
        <param name="constraints">Dodatkowe kryteria, które określają, czy żądanie, które pasują do wzorca adresu URL zostaną zignorowane.</param>
        <summary>Definiuje wzorzec adresu URL, który nie powinna być sprawdzana dopasowania dla trasy, jeśli w adresie URL żądania spełnia określone ograniczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy trasę, która jest mapowana do <xref:System.Web.Routing.StopRoutingHandler> programu obsługi trasy. Po wywołaniu tej metody nie można przetworzyć żądania, które odpowiadają określony wzorzec adresu URL jako kierowanie żądań.  
  
 Automatycznie routingu platformy ASP.NET ignoruje żądania, gdy adres URL jest zgodna z fizycznym pliku, na przykład pliku obrazu. W niektórych przypadkach można także routingu w celu ignorowania żądań, gdy nie ma żadnego pliku fizycznego. Na przykład żądania, które ASP.NET automatycznie sprawia, że w przypadku plików .axd powinna nie traktowane jako kierowanie żądań, nawet jeśli nie ma żadnego pliku fizycznego, odpowiadający .axd rozszerzenia nazwy pliku.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można użyć tej metody, aby ignorować wszystkie adresy URL, które mają rozszerzenie aspx. Można to zrobić, jeśli należy zarejestrować niestandardowy program obsługi HTTP do obsługi wszystkich adresów URL dla plików, które mają rozszerzenie ".aspx". Pojedynczy wzorzec adresu URL, który umożliwi dopasowanie wszystkich żądań .aspx wymagałoby dwa parametry przechwytywania wszystkich elementów takich jak `{*path}.aspx/{*pathinfo}`. (Ten wzorzec umożliwi dopasowanie dowolnego adresu URL, które kończy się aspx, łącznie z tymi, które mają parametry ciągu zapytania). Jednak routing zezwala na tylko jeden parametr przechwytywania wszystkich elementów na końcu. Jako alternatywę można określić wzorzec adresu URL, który ma jeden parametr przechwytywania wszystkich elementów, który dopasowuje wszystkie adresy URL, a następnie określ ograniczenia, które wykluczyć wszystkie czynności, które nie ma rozszerzenia .aspx, jak pokazano w poniższym przykładzie:  
  
```vb  
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})  
```  
  
```csharp  
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});  
```  
  
 Zwykle zostaną dodane w poprzednim wierszu kodu do metody, która jest wywoływana z `Application_Start` metody w pliku Global.asax, jak pokazano w przykładzie dla <xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29> przeciążenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> Parametr <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <c>elementu</c> zostanie wstawiona.</param>
        <param name="item">Trasa do wstawienia.</param>
        <summary>Wstawia określoną trasę do <see cref="T:System.Web.Routing.RouteCollection" /> obiektu pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dodaniu nazwy trasy do <xref:System.Web.Routing.RouteCollection> obiektu, nie można dodać trasę, która jest już w kolekcji.  
  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest już w kolekcji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Web.Routing.RouteBase" Usage="System.Web.Routing.RouteCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Wartość, która identyfikuje trasy, aby uzyskać.</param>
        <summary>Pobiera trasę w kolekcji, która ma określoną nazwę.</summary>
        <value>Obiekt, który ma określoną nazwę lub <see langword="null" /> Jeśli <paramref name="name" /> jest <see langword="null" />, to ciąg pusty lub nie odpowiada wszystkie trasy w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LowercaseUrls : bool with get, set" Usage="System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy adresy URL są konwertowane na małe litery, gdy ścieżki wirtualne są znormalizowane.</summary>
        <value>
          <see langword="true" /> Aby przekonwertować adresy URL na małe litery; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ciąg zapytania jest uwzględniona w adresie URL, że część adresu URL nie jest konwertowana na małe litery.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapewnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.Routing.RouteCollection.Add%2A> metody i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób definiowania tras dla aplikacji formularzy sieci Web za pomocą tej metody. W przykładzie pokazano metodę o nazwie `RegisterRoutes` który jest wywoływany z `Application_Start` w pliku Global.asax. Metoda używa przeciążenia każdego <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> Aby dodać trasę do aplikacji. Aby uzyskać więcej informacji na temat sposobu definiowania tras dla aplikacji formularzy sieci Web, zobacz [porady: Definiowanie tras dla aplikacji formularzy sieci Web](https://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678).  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL dla danej trasy.</param>
        <summary>Zapewnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.Routing.RouteCollection.Add%2A> metody i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje jak zdefiniować trasę za pomocą tej metody. Pierwsza instrukcja określa trasę, która nie ma nazwy. Druga instrukcja definiuje trasą mającą nazwę. W tym przykładzie jest częścią większego przykładu, który jest dostępny w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> przegląd metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL dla danej trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia do dostępu do fizycznego adresu URL (trasy, które pole adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <summary>Zapewnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.Routing.RouteCollection.Add%2A> metody i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje jak zdefiniować trasę za pomocą tej metody. W tym przykładzie jest częścią większego przykładu, który jest dostępny w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> przegląd metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL dla danej trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia do dostępu do fizycznego adresu URL (trasy, które pole adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <param name="defaults">Wartości domyślne dla parametrów trasy.</param>
        <summary>Zapewnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.Routing.RouteCollection.Add%2A> metody i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje jak zdefiniować trasę za pomocą tej metody. W tym przykładzie jest częścią większego przykładu, który jest dostępny w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> przegląd metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL dla danej trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia do dostępu do fizycznego adresu URL (trasy, które pole adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <param name="defaults">Wartości domyślne dla trasy.</param>
        <param name="constraints">Ograniczenia, które żądanie adresu URL musi spełniać w celu przetworzenia jako tej trasy.</param>
        <summary>Zapewnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.Routing.RouteCollection.Add%2A> metody i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje jak zdefiniować trasę za pomocą tej metody. W tym przykładzie jest częścią większego przykładu, który jest dostępny w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> przegląd metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints, dataTokens)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nazwa trasy.</param>
        <param name="routeUrl">Wzorzec URL trasy.</param>
        <param name="physicalFile">Fizyczny adres URL dla danej trasy.</param>
        <param name="checkPhysicalUrlAccess">Wartość, która wskazuje, czy program ASP.NET należy sprawdzić, czy użytkownik ma uprawnienia do dostępu do fizycznego adresu URL (trasy, które pole adresu URL jest zawsze zaznaczone). Ten parametr określa <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" /> właściwości.</param>
        <param name="defaults">Wartości domyślne dla parametrów trasy.</param>
        <param name="constraints">Ograniczenia, które żądanie adresu URL musi spełniać w celu przetworzenia jako tej trasy.</param>
        <param name="dataTokens">Wartości, które są skojarzone z tras, które nie są używane do określenia, czy trasa pasuje wzorzec adresu URL.</param>
        <summary>Zapewnia sposób definiowania tras dla aplikacji formularzy sieci Web.</summary>
        <returns>Trasy, który jest dodawany do kolekcji tras.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest udostępniana dla wygody kodowania. Jest to równoważne z wywoływaniem <xref:System.Web.Routing.RouteCollection.Add%2A> metody i przekazywanie <xref:System.Web.Routing.Route> obiekt, który jest tworzony przy użyciu <xref:System.Web.Routing.PageRouteHandler> klasy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje jak zdefiniować trasę za pomocą tej metody. W tym przykładzie jest częścią większego przykładu, który jest dostępny w <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> przegląd metody.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="routeUrl" /> Parametr <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="routeCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks trasy do usunięcia.</param>
        <summary>Usuwa trasę z <see cref="T:System.Web.Routing.RouteCollection" /> obiektu pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteExistingFiles : bool with get, set" Usage="System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy routingu platformy ASP.NET powinna obsługiwać adresy URL, które pasują do istniejącego pliku.</summary>
        <value>
          <see langword="true" /> Jeśli routingu platformy ASP.NET obsługuje wszystkie żądania, nawet tych, które pasuje do istniejącego pliku; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że tę wartość można zmienić dynamicznie, wszelkie zmiany wprowadzone po aktywowaniu usługi zostanie zignorowany, gdy za pomocą integracji routingu platformy ASP.NET. Aby uzyskać więcej informacji, zobacz [integracja routingu platformy ASP.NET](https://go.microsoft.com/fwlink/?LinkId=195235).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks trasy do zastąpienia.</param>
        <param name="item">Trasa do dodania pod określonym indeksem.</param>
        <summary>Zastępuje trasę pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po dodaniu nazwy trasy do <xref:System.Web.Routing.RouteCollection> obiektu, nie można dodać trasę, która jest już w kolekcji.  
  
 Użyj <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> metody i <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> metody, aby upewnić się, że możesz korzystać z kolekcji bez konfliktów z innymi procesami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest już w kolekcji.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Routingu platformy ASP.NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="WorkflowView" FullName="System.Workflow.ComponentModel.Design.WorkflowView">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c1699d67ef9e9621d737e0afaed3be11b17db35a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69429253" /></Metadata><TypeSignature Language="C#" Value="public class WorkflowView : System.Windows.Forms.UserControl, IServiceProvider, System.Windows.Forms.IMessageFilter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WorkflowView extends System.Windows.Forms.UserControl implements class System.IServiceProvider, class System.Windows.Forms.IMessageFilter" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.ComponentModel.Design.WorkflowView" />
  <TypeSignature Language="VB.NET" Value="Public Class WorkflowView&#xA;Inherits UserControl&#xA;Implements IMessageFilter, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowView : System::Windows::Forms::UserControl, IServiceProvider, System::Windows::Forms::IMessageFilter" />
  <TypeSignature Language="F#" Value="type WorkflowView = class&#xA;    inherit UserControl&#xA;    interface IServiceProvider&#xA;    interface IMessageFilter" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.UserControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IMessageFilter</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Workflow.ComponentModel.Design.ActivityDesignerTheme(typeof(System.Workflow.ComponentModel.Design.AmbientTheme), Xml="&lt;AmbientTheme xmlns="http://schemas.microsoft.com/winfx/2006/xaml/workflow" ApplyTo="System.Workflow.ComponentModel.Design.WorkflowView" ShowConfigErrors="True" DrawShadow="False" DrawGrayscale="False" DropIndicatorColor="0xFF006400" SelectionForeColor="0xFF0000FF" SelectionPatternColor="0xFF606060" ForeColor="0xFF808080" BackColor="0xFFFFFFFF" ShowGrid="False" GridColor="0xFFC0C0C0" TextQuality="Aliased" DrawRounded="True" ShowDesignerBorder="True" /&gt;")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia powierzchnię projektową, która renderuje wizualną reprezentację przepływu procesu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>jest powierzchnią projektową, która renderuje wizualną reprezentację przepływu procesu opisaną w znaczniku przepływu pracy. <xref:System.Workflow.ComponentModel.Design.WorkflowView>oferuje bogaty zestaw funkcji interfejsu użytkownika wymaganych przez projektantów działań do renderowania i reagowania na różne zdarzenia generowane przez system Windows. <xref:System.Workflow.ComponentModel.Design.WorkflowView> Ponadto oferuje zestaw typowych funkcji, które mogą być używane przez wszystkich projektantów do wykonywania określonych działań.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można uzyskać wystąpienie <xref:System.Workflow.ComponentModel.Design.WorkflowView> klasy <xref:System.ComponentModel.Design.IRootDesigner.GetView%2A> przy użyciu metody. Następnie kod ustawia <xref:System.Workflow.ComponentModel.Design.WorkflowView> kilka właściwości, w tym <xref:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar%2A> <xref:System.Workflow.ComponentModel.Design.WorkflowView.FitToScreenSize%2A> i <xref:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar%2A>i wywołuje metodę.  
  
 Ten przykład kodu jest częścią przykładu zestawu SDK projektanta profilów śledzenia przepływu pracy z pliku WorkflowDesignerControl.cs. Aby uzyskać więcej informacji, zobacz [Projektant profilów śledzenia przepływu pracy](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742004(v=vs.90)).  
  
 [!code-csharp[wf_samples#126](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#126)]
 [!code-vb[wf_samples#126](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#126)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742004(v=vs.90)">Projektant profilów śledzenia przepływu pracy</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje wystąpienie <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowView();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje wystąpienie <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />elementu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowView (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serviceProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowView(IServiceProvider ^ serviceProvider);" />
      <MemberSignature Language="F#" Value="new System.Workflow.ComponentModel.Design.WorkflowView : IServiceProvider -&gt; System.Workflow.ComponentModel.Design.WorkflowView" Usage="new System.Workflow.ComponentModel.Design.WorkflowView serviceProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">Obiekt, który implementuje <see cref="T:System.IServiceProvider" /> interfejs.</param>
        <summary>Inicjuje wystąpienie <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> z określonym dostawcą usług.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak utworzyć <xref:System.Workflow.ComponentModel.Design.WorkflowView> obiekt. W tym przykładzie tworzony jest nowy <xref:System.ComponentModel.Design.DesignSurface> obiekt `BeginLoad` i wywoływana jest <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerLoader> Metoda przekazująca obiekt jako parametr. Po utworzeniu nowego <xref:System.Workflow.Activities.SequentialWorkflowActivity> <xref:System.Workflow.ComponentModel.Design.WorkflowView>obiektujest tworzony przy użyciu utworzonegowcześniejjakoparametrdokonstruktora.<xref:System.ComponentModel.Design.DesignSurface>  
  
 Ten przykład kodu jest częścią przykładu zestawu SDK kreatora przepływu pracy programu Outlook z pliku WorkflowViewWrapper.cs. Aby uzyskać więcej informacji, zobacz [przykład kreatora przepływu pracy w programie Outlook](https://msdn.microsoft.com/library/7b2ba92b-8456-43f3-87fc-184ffdec4408).  
  
 [!code-csharp[wf_samples#97](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#97)]
 [!code-vb[wf_samples#97](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#97)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741706(v=vs.90)">Monitor przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="AddDesignerMessageFilter">
      <MemberSignature Language="C#" Value="public void AddDesignerMessageFilter (System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter designerMessageFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDesignerMessageFilter(class System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter designerMessageFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.AddDesignerMessageFilter(System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDesignerMessageFilter (designerMessageFilter As WorkflowDesignerMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDesignerMessageFilter(System::Workflow::ComponentModel::Design::WorkflowDesignerMessageFilter ^ designerMessageFilter);" />
      <MemberSignature Language="F#" Value="member this.AddDesignerMessageFilter : System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter -&gt; unit" Usage="workflowView.AddDesignerMessageFilter designerMessageFilter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="designerMessageFilter" Type="System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter" />
      </Parameters>
      <Docs>
        <param name="designerMessageFilter">, <see cref="T:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter" /> Aby dodać <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />do.</param>
        <summary><see cref="T:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter" /> Dodaje<see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter> to składnik, który obsługuje komunikaty <xref:System.Workflow.ComponentModel.Design.WorkflowView>z.  
  
 Korzystając ze `Strategy` wzorca projektowego <xref:System.Workflow.ComponentModel.Design.WorkflowView> , program przekaże komunikaty do <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter> , aby były obsługiwane.  
  
 Zdarzenia myszy, zdarzenia klawiatury, zdarzenia programu Paint i układu są przesyłane do <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter> skojarzone <xref:System.Workflow.ComponentModel.Design.WorkflowView>z.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerLoader> jest tworzony, <xref:System.Workflow.ComponentModel.Design.WorkflowView> a obiekt jest skojarzony z powierzchnią projektu przepływu pracy. Aby można było pobrać powiadomienia o komunikatach, <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter> zostaje utworzony i dodany <xref:System.Workflow.ComponentModel.Design.WorkflowView> do obiektu.  
  
 Ten przykład kodu jest częścią przykładu zestawu SDK kreatora przepływu pracy programu Outlook z pliku WorkflowViewWrapper.cs. Aby uzyskać więcej informacji, zobacz [przykład kreatora przepływu pracy w programie Outlook](https://msdn.microsoft.com/library/7b2ba92b-8456-43f3-87fc-184ffdec4408).  
  
 [!code-csharp[wf_Samples#102](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#102)]
 [!code-vb[wf_Samples#102](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#102)]  
  
 Obiekt utworzony w poprzednim kodzie pochodzi <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter> od klasy. `MessageFilter`  Zastępując metody tej klasy, filtr komunikatów jest powiadamiany za każdym razem, gdy na <xref:System.Workflow.ComponentModel.Design.WorkflowView> obiekcie wystąpi zdarzenie interfejsu użytkownika.  
  
 [!code-csharp[wf_samples#104](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#104)]
 [!code-vb[wf_samples#104](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#104)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientPointToLogical">
      <MemberSignature Language="C#" Value="public System.Drawing.Point ClientPointToLogical (System.Drawing.Point clientPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point ClientPointToLogical(valuetype System.Drawing.Point clientPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ClientPointToLogical(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function ClientPointToLogical (clientPoint As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point ClientPointToLogical(System::Drawing::Point clientPoint);" />
      <MemberSignature Language="F#" Value="member this.ClientPointToLogical : System.Drawing.Point -&gt; System.Drawing.Point" Usage="workflowView.ClientPointToLogical clientPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientPoint" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="clientPoint"><see cref="T:System.Drawing.Point" /> Do konwersji ze współrzędnych klienta na współrzędne logiczne.</param>
        <summary>Konwertuje współrzędne <see cref="T:System.Drawing.Point" /> z klienta na współrzędne logiczne.</summary>
        <returns><see cref="T:System.Drawing.Point" /> Przekonwertowane z współrzędnej klienta na współrzędne logiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
-   W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangleToLogical">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangleToLogical (System.Drawing.Rectangle rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle ClientRectangleToLogical(valuetype System.Drawing.Rectangle rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ClientRectangleToLogical(System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle ClientRectangleToLogical(System::Drawing::Rectangle rectangle);" />
      <MemberSignature Language="F#" Value="member this.ClientRectangleToLogical : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="workflowView.ClientRectangleToLogical rectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rectangle" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rectangle"><see cref="T:System.Drawing.Rectangle" /> Do konwersji z klienta na współrzędne logiczne.</param>
        <summary>Konwertuje współrzędne <see cref="T:System.Drawing.Rectangle" /> z klienta na współrzędne logiczne.</summary>
        <returns><see cref="T:System.Drawing.Rectangle" /> Przekonwertowane z współrzędnej klienta na współrzędne logiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientSizeToLogical">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSizeToLogical (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Size ClientSizeToLogical(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ClientSizeToLogical(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Function ClientSizeToLogical (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Size ClientSizeToLogical(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="member this.ClientSizeToLogical : System.Drawing.Size -&gt; System.Drawing.Size" Usage="workflowView.ClientSizeToLogical clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="clientSize"><see cref="T:System.Drawing.Size" /> Do konwersji z klienta na współrzędne logiczne.</param>
        <summary>Konwertuje wartość <see cref="T:System.Drawing.Size" /> z klienta na współrzędne logiczne.</summary>
        <returns><see cref="T:System.Drawing.Size" /> Przekonwertowane z współrzędnej klienta na współrzędne logiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="workflowView.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy <see cref="T:System.Windows.Forms.AccessibleObject" /> <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />dla.</summary>
        <returns><see cref="T:System.Windows.Forms.AccessibleObject" /> Nowe<see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />dla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Workflow.ComponentModel.Design.WorkflowView.CreateAccessibilityInstance%2A> Metoda nie zostanie jawnie wywołana, zostanie wywołana, <xref:System.Windows.Forms.AccessibleObject> gdy zostanie przywoływana właściwość.  
  
> [!NOTE]
>  Aby utworzyć <xref:System.Windows.Forms.AccessibleObject>, należy dodać odwołanie `Accessibility` do zestawu zainstalowanego z .NET Framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Workflow.ComponentModel.Design.WorkflowView.CreateAccessibilityInstance" /> w klasie pochodnej nie należy wywoływać metody klasy <see cref="M:System.Workflow.ComponentModel.Design.WorkflowView.CreateAccessibilityInstance" /> bazowej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="workflowView.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy parametr likwidacji ma `true`wartość, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, <xref:System.Workflow.ComponentModel.Design.WorkflowView> do których odwołują się te odwołania. Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 Aby uzyskać więcej informacji `Dispose` na `Finalize`temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see langword="Dispose" />w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableFitToScreen">
      <MemberSignature Language="C#" Value="public bool EnableFitToScreen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableFitToScreen" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.EnableFitToScreen" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableFitToScreen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableFitToScreen { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableFitToScreen : bool with get, set" Usage="System.Workflow.ComponentModel.Design.WorkflowView.EnableFitToScreen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Włącza przycisk na powierzchni projektowej, który po kliknięciu zmienia poziom powiększenia powierzchni projektowej przepływu pracy tak, aby cały przepływ pracy był wyświetlany w <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <value><see langword="true" />Jeśli przycisk dynamiczny jest włączony; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak włączyć przycisk Dopasuj do ekranu. Metoda najpierw uzyskuje <xref:System.ComponentModel.Design.IDesignerHost> interfejs projektanta, a następnie <xref:System.Workflow.ComponentModel.Design.WorkflowView> pobiera obiekt przy użyciu <xref:System.IServiceProvider.GetService%2A> metody przed zmodyfikowaniem <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnableFitToScreen%2A> właściwości.  
  
 [!code-csharp[wf_samples#50](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#50)]
 [!code-vb[wf_samples#50](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#50)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureVisible">
      <MemberSignature Language="C#" Value="public void EnsureVisible (object selectableObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnsureVisible(object selectableObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.EnsureVisible(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnsureVisible (selectableObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnsureVisible(System::Object ^ selectableObject);" />
      <MemberSignature Language="F#" Value="member this.EnsureVisible : obj -&gt; unit" Usage="workflowView.EnsureVisible selectableObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectableObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="selectableObject">Obiekt, który ma być widoczny.</param>
        <summary>Zapewnia, że <see cref="T:System.Object" /> przekazanie jest widoczne, rozwijanie obiektów nadrzędnych <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> i przewijanie w razie potrzeby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnsureVisible%2A> podczas pracy z obiektem w przepływie pracy, który wymaga podpowiedzi interfejsu użytkownika. spowoduje rozwinięcie obiektów nadrzędnych i <xref:System.Workflow.ComponentModel.Design.WorkflowView> przewinięcie ich w razie potrzeby, aby obiekt był widoczny w projektancie. <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnsureVisible%2A>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Workflow.ComponentModel.Design.WorkflowView.GetService%2A> metodę <xref:System.Workflow.ComponentModel.Design.WorkflowView> obiektu do zwrócenia <xref:System.ComponentModel.Design.ISelectionService> interfejsu. Jeśli usługa istnieje, <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnsureVisible%2A> nazywa się przekazywaniem aktualnie wybranego działania `PrimarySelection` przy użyciu właściwości <xref:System.ComponentModel.Design.ISelectionService> obiektu.  
  
 [!code-csharp[wf_samples#64](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#64)]
 [!code-vb[wf_samples#64](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="selectableObject" />jest odwołaniem o wartości<see langword="Nothing" /> null (w Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="FitToScreenSize">
      <MemberSignature Language="C#" Value="public void FitToScreenSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FitToScreenSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.FitToScreenSize" />
      <MemberSignature Language="VB.NET" Value="Public Sub FitToScreenSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FitToScreenSize();" />
      <MemberSignature Language="F#" Value="member this.FitToScreenSize : unit -&gt; unit" Usage="workflowView.FitToScreenSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmienia poziom powiększenia powierzchni projektowej przepływu pracy tak, aby cały przepływ pracy był wyświetlany w <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzeczywisty poziom powiększenia zależy od ustawień projektanta przepływu pracy użytkownika.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak włączyć przycisk Dopasuj do ekranu. Metoda najpierw uzyskuje <xref:System.ComponentModel.Design.IDesignerHost> interfejs projektanta, a następnie <xref:System.Workflow.ComponentModel.Design.WorkflowView> pobiera obiekt przy użyciu <xref:System.IServiceProvider.GetService%2A> metody przed zmodyfikowaniem <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnableFitToScreen%2A> właściwości. Na <xref:System.Workflow.ComponentModel.Design.WorkflowView.FitToScreenSize%2A> koniec Metoda jest wywoływana, aby wyświetlić cały przepływ pracy w granicach obszaru <xref:System.Workflow.ComponentModel.Design.WorkflowView>, w którym jest odtwarzany.  
  
 [!code-csharp[wf_samples#50](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#50)]
 [!code-vb[wf_samples#50](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#50)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742004(v=vs.90)">Projektant profilów śledzenia przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="FitToWorkflowSize">
      <MemberSignature Language="C#" Value="public void FitToWorkflowSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FitToWorkflowSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.FitToWorkflowSize" />
      <MemberSignature Language="VB.NET" Value="Public Sub FitToWorkflowSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FitToWorkflowSize();" />
      <MemberSignature Language="F#" Value="member this.FitToWorkflowSize : unit -&gt; unit" Usage="workflowView.FitToWorkflowSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmienia poziom powiększenia na 100 procent, aby wyświetlić pełny rozmiar przepływu pracy w <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład inicjuje właściwości <xref:System.Workflow.ComponentModel.Design.WorkflowView> obiektu, aby ustawić kilka właściwości. Powoduje, że <xref:System.Workflow.ComponentModel.Design.WorkflowView.ViewPortRectangle%2A>obiekt wyświetla pełny rozmiar przepływu pracy w obrębie. <xref:System.Workflow.ComponentModel.Design.WorkflowView> <xref:System.Workflow.ComponentModel.Design.WorkflowView.FitToWorkflowSize%2A>  
  
 [!code-csharp[wf_samples#65](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#65)]
 [!code-vb[wf_samples#65](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#65)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected override object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="override this.GetService : Type -&gt; obj" Usage="workflowView.GetService serviceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType"><see cref="T:System.Type" /> Usługa do pobrania.</param>
        <summary>Pobiera obiekt usługi określonego typu, jeśli jest dostępny.</summary>
        <returns>Jeślifunkcjazwracaokreślony<paramref name="serviceType" /> element;<see langword="GetService" /> w przeciwnym razie zwraca<see cref="T:System.Object" /> implementującą żądaną usługę lub odwołanie o wartości null ( <see langword="GetService" /> <see cref="T:System.ComponentModel.Design.CommandID" /> <see langword="typeof(" /> <see cref="T:System.ComponentModel.Design.CommandID" /> <see langword=")" /> <see langword="Nothing" /> w Visual Basic), jeśli nie można rozpoznać usługi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetService`zwraca implementującą żądaną usługę lub odwołanie o wartości null (`Nothing`), jeśli nie można rozpoznać usługi. <xref:System.Object>  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Workflow.ComponentModel.Design.WorkflowView.GetService%2A> metodę <xref:System.Workflow.ComponentModel.Design.WorkflowView> obiektu do zwrócenia <xref:System.ComponentModel.Design.ISelectionService> interfejsu. Jeśli usługa istnieje, <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnsureVisible%2A> nazywa się przekazywaniem aktualnie wybranego działania `PrimarySelection` przy użyciu właściwości <xref:System.ComponentModel.Design.ISelectionService> obiektu.  
  
 [!code-csharp[wf_samples#64](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#64)]
 [!code-vb[wf_samples#64](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#64)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScrollBar">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HScrollBar HScrollBar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HScrollBar HScrollBar" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HScrollBar As HScrollBar" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HScrollBar ^ HScrollBar { System::Windows::Forms::HScrollBar ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HScrollBar : System.Windows.Forms.HScrollBar" Usage="System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HScrollBar</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera poziomy pasek przewijania dla <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <value><see cref="T:System.Windows.Forms.ScrollBar" /> Można użyć, aby dostosować ustawienia i widoczność poziomego paska przewijania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można uzyskać wystąpienie <xref:System.Workflow.ComponentModel.Design.WorkflowView> klasy.  Następnie kod ustawia <xref:System.Workflow.ComponentModel.Design.WorkflowView> kilka właściwości, w tym <xref:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar%2A> <xref:System.Workflow.ComponentModel.Design.WorkflowView.FitToWorkflowSize%2A> i <xref:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar%2A>i wywołuje metodę.  
  
 [!code-csharp[Wf_samples#65](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#65)]
 [!code-vb[Wf_samples#65](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#65)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742004(v=vs.90)">Projektant profilów śledzenia przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.ComponentModel.Design.WorkflowView.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see langword="WorkflowView" /> zakończeniu przetwarzania i przejściu w stan bezczynności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli masz zadania do wykonania, zanim wątek stanie się bezczynny, Dołącz je do tego zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateClientRectangle">
      <MemberSignature Language="C#" Value="public void InvalidateClientRectangle (System.Drawing.Rectangle clientRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateClientRectangle(valuetype System.Drawing.Rectangle clientRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.InvalidateClientRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateClientRectangle (clientRectangle As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateClientRectangle(System::Drawing::Rectangle clientRectangle);" />
      <MemberSignature Language="F#" Value="member this.InvalidateClientRectangle : System.Drawing.Rectangle -&gt; unit" Usage="workflowView.InvalidateClientRectangle clientRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientRectangle" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="clientRectangle"><see cref="T:System.Drawing.Rectangle" />W przypadku współrzędnych klienta unieważnienie i spowodowanie odświeżenia.</param>
        <summary>Unieważnia określone <see cref="T:System.Drawing.Rectangle" /> i powoduje jego odświeżenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Workflow.ComponentModel.Design.WorkflowView.InvalidateClientRectangle%2A> <xref:System.Drawing.Rectangle>, aby spowodować dodanie współrzędnej klienta do regionu aktualizacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateLogicalRectangle">
      <MemberSignature Language="C#" Value="public void InvalidateLogicalRectangle (System.Drawing.Rectangle logicalRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateLogicalRectangle(valuetype System.Drawing.Rectangle logicalRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.InvalidateLogicalRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateLogicalRectangle (logicalRectangle As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateLogicalRectangle(System::Drawing::Rectangle logicalRectangle);" />
      <MemberSignature Language="F#" Value="member this.InvalidateLogicalRectangle : System.Drawing.Rectangle -&gt; unit" Usage="workflowView.InvalidateLogicalRectangle logicalRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalRectangle" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="logicalRectangle"><see cref="T:System.Drawing.Rectangle" />, W współrzędne logiczne, aby unieważnić i przyczynić się do odświeżenia.</param>
        <summary>Unieważnia określone <see cref="T:System.Drawing.Rectangle" /> i powoduje jego odświeżenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Workflow.ComponentModel.Design.WorkflowView.InvalidateLogicalRectangle%2A> <xref:System.Drawing.Rectangle>, aby spowodować dodanie do regionu aktualizacji, we współrzędnych logicznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="public void LoadViewState (System.IO.Stream viewState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadViewState(class System.IO.Stream viewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.LoadViewState(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadViewState (viewState As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadViewState(System::IO::Stream ^ viewState);" />
      <MemberSignature Language="F#" Value="member this.LoadViewState : System.IO.Stream -&gt; unit" Usage="workflowView.LoadViewState viewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewState" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="viewState"><see cref="T:System.IO.BinaryReader" /> Służy do przywracania stanu widoku.</param>
        <summary>Przywraca informacje o stanie widoku ze strumienia binarnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.LoadViewState%2A>przywraca informacje o stanie widoku zapisane wcześniej przez wywołanie <xref:System.Workflow.ComponentModel.Design.WorkflowView.SaveViewState%2A> metody.  
  
 Zastąp tę metodę, gdy zachodzi potrzeba dostosowania sposobu przywracania stanu widoku przez projektanta niestandardowego.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób ładowania <xref:System.Workflow.ComponentModel.Design.WorkflowView> stanu widoku dla obiektu przez <xref:System.IO.FileStream> utworzenie obiektu z `FileMode.Open` flagą i przekazanie go do <xref:System.Workflow.ComponentModel.Design.WorkflowView.LoadViewState%2A> metody. Plik stanu widoku został utworzony za pomocą <xref:System.Workflow.ComponentModel.Design.WorkflowView.SaveViewState%2A> metody.  
  
 [!code-csharp[wf_samples#60](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#60)]
 [!code-vb[wf_samples#60](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#60)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalPointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point LogicalPointToClient (System.Drawing.Point logicalPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point LogicalPointToClient(valuetype System.Drawing.Point logicalPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.LogicalPointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalPointToClient (logicalPoint As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point LogicalPointToClient(System::Drawing::Point logicalPoint);" />
      <MemberSignature Language="F#" Value="member this.LogicalPointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="workflowView.LogicalPointToClient logicalPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalPoint" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="logicalPoint"><see cref="T:System.Drawing.Point" /> Do przekonwertowania na współrzędne klienta.</param>
        <summary>Konwertuje wartość <see cref="T:System.Drawing.Point" /> ze współrzędnych logicznej na klienta.</summary>
        <returns><see cref="T:System.Drawing.Point" /> Przekonwertowane ze współrzędnych logicznego na klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalPointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point LogicalPointToScreen (System.Drawing.Point logicalPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point LogicalPointToScreen(valuetype System.Drawing.Point logicalPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.LogicalPointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalPointToScreen (logicalPoint As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point LogicalPointToScreen(System::Drawing::Point logicalPoint);" />
      <MemberSignature Language="F#" Value="member this.LogicalPointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="workflowView.LogicalPointToScreen logicalPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalPoint" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="logicalPoint"><see cref="T:System.Drawing.Point" /> Do konwersji na współrzędne ekranu.</param>
        <summary><see cref="T:System.Drawing.Point" /> Konwertuje współrzędne logiczne na ekran.</summary>
        <returns><see cref="T:System.Drawing.Point" /> Konwersja z współrzędnej logicznej na ekran.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalRectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle LogicalRectangleToClient (System.Drawing.Rectangle rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle LogicalRectangleToClient(valuetype System.Drawing.Rectangle rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.LogicalRectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle LogicalRectangleToClient(System::Drawing::Rectangle rectangle);" />
      <MemberSignature Language="F#" Value="member this.LogicalRectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="workflowView.LogicalRectangleToClient rectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rectangle" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rectangle"><see cref="T:System.Drawing.Rectangle" /> Do przekonwertowania na współrzędne klienta.</param>
        <summary>Konwertuje wartość <see cref="T:System.Drawing.Rectangle" /> ze współrzędnych logicznej na klienta.</summary>
        <returns><see cref="T:System.Drawing.Rectangle" /> Konwersja ze współrzędnych logicznego na klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalSizeToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Size LogicalSizeToClient (System.Drawing.Size logicalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Size LogicalSizeToClient(valuetype System.Drawing.Size logicalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.LogicalSizeToClient(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalSizeToClient (logicalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Size LogicalSizeToClient(System::Drawing::Size logicalSize);" />
      <MemberSignature Language="F#" Value="member this.LogicalSizeToClient : System.Drawing.Size -&gt; System.Drawing.Size" Usage="workflowView.LogicalSizeToClient logicalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="logicalSize"><see cref="T:System.Drawing.Size" /> Do przekonwertowania na współrzędne klienta.</param>
        <summary>Konwertuje wartość <see cref="T:System.Drawing.Size" /> ze współrzędnych logicznej na klienta.</summary>
        <returns><see cref="T:System.Drawing.Size" /> Konwersja ze współrzędnych logicznego na klienta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
-   Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected override void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="workflowView.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.ControlEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary>Występuje po dodaniu kontrolki do <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnControlAdded%2A>jest wywoływana po dodaniu kontrolki podrzędnej do <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Dozwolone są <xref:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar%2A> tylko kontrolki podrzędne i <xref:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar%2A> formanty.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Jeśli dodana kontrolka nie <see cref="P:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar" /> jest lub<see cref="P:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar" /></exception>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected override void OnDragDrop (System.Windows.Forms.DragEventArgs dragEventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs dragEventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragDrop(System::Windows::Forms::DragEventArgs ^ dragEventArgs);" />
      <MemberSignature Language="F#" Value="override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="workflowView.OnDragDrop dragEventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dragEventArgs" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="dragEventArgs">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje, gdy przeciągany element zostanie usunięty z <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragDrop%2A>występuje, gdy użytkownik zwolni przycisk myszy nad <xref:System.Workflow.ComponentModel.Design.WorkflowView> operacją przeciągania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected override void OnDragEnter (System.Windows.Forms.DragEventArgs dragEventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs dragEventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragEnter(System::Windows::Forms::DragEventArgs ^ dragEventArgs);" />
      <MemberSignature Language="F#" Value="override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="workflowView.OnDragEnter dragEventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dragEventArgs" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="dragEventArgs">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje, gdy element zostanie przeciągnięty do <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> zakresu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragEnter%2A>występuje, gdy użytkownik po raz pierwszy przeciągnie wskaźnik myszy <xref:System.Workflow.ComponentModel.Design.WorkflowView> nad operację przeciągania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected override void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnDragLeave : EventArgs -&gt; unit" Usage="workflowView.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje, gdy kursor opuszcza <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> operację przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragLeave%2A>występuje, gdy użytkownik przeciągnie kursor myszy z <xref:System.Workflow.ComponentModel.Design.WorkflowView> operacji przeciągania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected override void OnDragOver (System.Windows.Forms.DragEventArgs dragEventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs dragEventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragOver(System::Windows::Forms::DragEventArgs ^ dragEventArgs);" />
      <MemberSignature Language="F#" Value="override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="workflowView.OnDragOver dragEventArgs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dragEventArgs" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="dragEventArgs">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje, gdy operacja przeciągania i upuszczania jest w toku, a wskaźnik znajduje się w <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> granicach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragOver%2A>występuje po przesunięciu kursora myszy w granicach elementu <xref:System.Workflow.ComponentModel.Design.WorkflowView>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected override void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="workflowView.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">A <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje podczas operacji przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnGiveFeedback%2A>występuje po rozpoczęciu operacji przeciągania. <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnGiveFeedback%2A>zezwala na źródło operacji przeciągania, modyfikując wygląd wskaźnika myszy w celu przedstawienia wizualnej opinii użytkownika podczas operacji przeciągania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="workflowView.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje po naciśnięciu klawisza, <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> gdy ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnKeyDown%2A>występuje po naciśnięciu klawisza, <xref:System.Workflow.ComponentModel.Design.WorkflowView> gdy ma fokus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="workflowView.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> , który zapewnia dane dotyczące zdarzenia.</param>
        <summary>Występuje, gdy klucz zostanie wydzierżawiony <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> , gdy ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnKeyUp%2A>występuje, gdy klucz zostanie wydzierżawiony <xref:System.Workflow.ComponentModel.Design.WorkflowView> , gdy ma fokus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="workflowView.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">A <see cref="T:System.Windows.Forms.LayoutEventArgs" /> , która dostarcza dane dla zdarzenia.</param>
        <summary>Występuje, gdy <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> powinny zmieniać położenie formantów podrzędnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnLayout%2A>występuje po dodaniu lub usunięciu formantów podrzędnych, gdy są one powiązane <xref:System.Workflow.ComponentModel.Design.WorkflowView> ze zmianami, a w przypadku innych zmian, które mogą wpływać na układ. <xref:System.Workflow.ComponentModel.Design.WorkflowView>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected override void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="workflowView.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zapewnia dane dotyczące zdarzenia.</param>
        <summary>Występuje, gdy elementy wybrane przez przeciąganie zmienią się myszą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseCaptureChanged%2A>występuje, gdy użytkownik dokonuje wyboru przy użyciu myszy, która różni się od istniejącego zaznaczenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected override void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="workflowView.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje po <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> dwukrotnym kliknięciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwukrotne kliknięcie jest określane przez ustawienia myszy systemu operacyjnego. Użytkownik może ustawić czas między kliknięciami przycisku myszy, który powinien być uważany za dwukrotne kliknięcie, a nie dwoma kliknięciami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="workflowView.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje, gdy wskaźnik myszy znajduje się nad <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> naciśnięciem przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A>lub /  <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 `OnMouseEnter`występuje po umieszczeniu wskaźnika <xref:System.Workflow.ComponentModel.Design.WorkflowView>myszy.  
  
 `OnMouseDown`występuje, gdy wskaźnik myszy znajduje się nad <xref:System.Workflow.ComponentModel.Design.WorkflowView> naciśnięciem przycisku myszy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseEnter : EventArgs -&gt; unit" Usage="workflowView.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający informacje o zdarzeniu.</param>
        <summary>Występuje po umieszczeniu wskaźnika <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A> lub <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>występuje po umieszczeniu wskaźnika <xref:System.Workflow.ComponentModel.Design.WorkflowView>myszy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected override void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseHover : EventArgs -&gt; unit" Usage="workflowView.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje, gdy wskaźnik myszy znajduje się nad <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A> lub <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A>występuje, gdy wskaźnik myszy znajduje się nad <xref:System.Workflow.ComponentModel.Design.WorkflowView>elementem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : EventArgs -&gt; unit" Usage="workflowView.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje po opuszczeniu przez <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />wskaźnik myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A> lub <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>występuje po opuszczeniu przez <xref:System.Workflow.ComponentModel.Design.WorkflowView>wskaźnik myszy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="workflowView.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje, gdy wskaźnik myszy zostanie przesunięty nad <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A> lub <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>występuje, gdy wskaźnik myszy zostanie przesunięty nad <xref:System.Workflow.ComponentModel.Design.WorkflowView>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="workflowView.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje po udostępnieniu przycisku myszy nad <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A> lub <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>występuje, gdy wskaźnik myszy znajduje się nad <xref:System.Workflow.ComponentModel.Design.WorkflowView> elementem i przycisk jest wydawany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="workflowView.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje po przesunięciu kółka myszy, <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> gdy ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
 1.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseEnter%2A>  
  
 2.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseMove%2A>  
  
 3.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseHover%2A> lub <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseDown%2A><xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>  
  
 4.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseUp%2A>  
  
 5.<xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseLeave%2A>  
  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnMouseWheel%2A>występuje po przesunięciu kółka myszy nad <xref:System.Workflow.ComponentModel.Design.WorkflowView>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="workflowView.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje po <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> odświeżeniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnPaint%2A>występuje po <xref:System.Workflow.ComponentModel.Design.WorkflowView> odświeżeniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected override void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="workflowView.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">A <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" /> , który zawiera informacje o zdarzeniu.</param>
        <summary>Występuje podczas operacji przeciągania i umożliwia źródłu przeciągania określenie, czy opcja przeciągania powinna zostać anulowana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnQueryContinueDrag%2A> Zdarzenie jest zgłaszane w przypadku zmiany stanu przycisku klawiatury lub myszy podczas operacji przeciągania. <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnQueryContinueDrag%2A> Zdarzenie umożliwia źródłowe przeciąganie, aby określić, czy operacja przeciągania powinna zostać anulowana.  
  
 Zdarzenia związane z operacjami przeciągania są wywoływane, gdy formant jest prawidłowym obiektem docelowym upuszczania. <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnGiveFeedback%2A> Zdarzenie jest wywoływane z określonym efektem przeciągania. Aby zapoznać się z listą efektów przeciągania, <xref:System.Windows.Forms.DragDropEffects> zobacz Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragLeave%2A> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragEnter%2A> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragOver%2A> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnQueryContinueDrag%2A> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości `Action` właściwości zdarzenia <xref:System.Windows.Forms.QueryContinueDragEventArgs>.  
  
 Jeśli wartość to `DragAction.Continue` <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragOver%2A> , zdarzenie jest wywoływane w celu <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnGiveFeedback%2A> kontynuowania operacji, a zdarzenie jest zgłaszane z nowym efektem, dzięki czemu można ustawić odpowiednie opinie wizualne. Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
> [!NOTE]
>  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnGiveFeedback%2A> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragOver%2A>  
  
 Jeśli wartość to `DragAction.Drop`, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
 Jeśli wartość to `DragAction.Cancel` <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnDragLeave%2A> , zdarzenie jest zgłaszane.  
  
 Domyślnie <xref:System.Workflow.ComponentModel.Design.WorkflowView.OnQueryContinueDrag%2A> zdarzenia są ustawiane `Action` na `DragAction.Cancel` , jeśli klawisz ESC został nacionięty i ustawiony `Action` na `DragAction.Drop` po naciśnięciu przycisku myszy po lewej stronie, Środkowej lub prawej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRootDesignerChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRootDesignerChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRootDesignerChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnRootDesignerChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRootDesignerChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRootDesignerChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnRootDesignerChanged : unit -&gt; unit&#xA;override this.OnRootDesignerChanged : unit -&gt; unit" Usage="workflowView.OnRootDesignerChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana, gdy inny Projektant jest ustawiony jako nowy główny projektant powierzchni projektowej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnZoomChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnZoomChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnZoomChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.OnZoomChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnZoomChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnZoomChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnZoomChanged : unit -&gt; unit&#xA;override this.OnZoomChanged : unit -&gt; unit" Usage="workflowView.OnZoomChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana, gdy zostanie zmieniony poziom powiększenia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (bool immediateUpdate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(bool immediateUpdate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.PerformLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (immediateUpdate As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(bool immediateUpdate);" />
      <MemberSignature Language="F#" Value="override this.PerformLayout : bool -&gt; unit" Usage="workflowView.PerformLayout immediateUpdate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="immediateUpdate" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="immediateUpdate"><see langword="true" />Aby spowodować natychmiastowe zaktualizowanie układu; w przeciwnym razie. <see langword="false" /></param>
        <summary><see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> Wymusza stosowanie logiki układu do wszystkich jej formantów podrzędnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.PerformLayout%2A>aktualizuje wszystkie kontrolki podrzędne w <xref:System.Workflow.ComponentModel.Design.WorkflowView>, zmieniając rozmiar i przenosząc je w razie potrzeby.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrintDocument">
      <MemberSignature Language="C#" Value="public System.Drawing.Printing.PrintDocument PrintDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Printing.PrintDocument PrintDocument" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.PrintDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrintDocument As PrintDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Printing::PrintDocument ^ PrintDocument { System::Drawing::Printing::PrintDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrintDocument : System.Drawing.Printing.PrintDocument" Usage="System.Workflow.ComponentModel.Design.WorkflowView.PrintDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Printing.PrintDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera skojarzenie z <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />. <see cref="T:System.Drawing.Printing.PrintDocument" /></summary>
        <value><see cref="P:System.Workflow.ComponentModel.Design.WorkflowView.PrintDocument" /> Obiekt, który wysyła dane wyjściowe do drukarki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj obiektu, aby ustawić właściwości opisujące sposób drukowania, i `Print` Wywołaj metodę, aby rozpocząć proces drukowania. <xref:System.Workflow.ComponentModel.Design.WorkflowView.PrintDocument%2A>  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób pobierania <xref:System.Drawing.Printing.PrintDocument> obiektu, <xref:System.Windows.Forms.PrintDialog> wyświetlania a i kojarzenia <xref:System.Drawing.Printing.PrinterSettings> , które zostały wybrane przez użytkownika przed wydrukowaniem dokumentu.  
  
 [!code-csharp[Wf_samples#56](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#56)]
 [!code-vb[Wf_samples#56](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#56)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrintPreviewMode">
      <MemberSignature Language="C#" Value="public bool PrintPreviewMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PrintPreviewMode" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.PrintPreviewMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PrintPreviewMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PrintPreviewMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PrintPreviewMode : bool with get, set" Usage="System.Workflow.ComponentModel.Design.WorkflowView.PrintPreviewMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />podglądu wydruku.</summary>
        <value><see langword="true" />Jeśli tryb podglądu wydruku jest aktywny; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład pokazuje, jak zmienić obiekt element WorkflowView, aby wyświetlić bieżący przepływ pracy w trybie Podgląd wydruku.  
  
 [!code-csharp[wf_samples#57](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#57)]
 [!code-vb[wf_samples#57](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#57)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveDesignerMessageFilter">
      <MemberSignature Language="C#" Value="public void RemoveDesignerMessageFilter (System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter designerMessageFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveDesignerMessageFilter(class System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter designerMessageFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.RemoveDesignerMessageFilter(System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveDesignerMessageFilter (designerMessageFilter As WorkflowDesignerMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveDesignerMessageFilter(System::Workflow::ComponentModel::Design::WorkflowDesignerMessageFilter ^ designerMessageFilter);" />
      <MemberSignature Language="F#" Value="member this.RemoveDesignerMessageFilter : System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter -&gt; unit" Usage="workflowView.RemoveDesignerMessageFilter designerMessageFilter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="designerMessageFilter" Type="System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter" />
      </Parameters>
      <Docs>
        <param name="designerMessageFilter"><see cref="T:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter" /> Do usunięcia <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />z.</param>
        <summary>Usuwa skojarzenie <see cref="T:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj odpowiedzi, aby odpowiedzieć na zdarzenia projektanta, takie jak zdarzenia przeciągania. <xref:System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootDesigner">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Design.ActivityDesigner RootDesigner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Design.ActivityDesigner RootDesigner" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.RootDesigner" />
      <MemberSignature Language="VB.NET" Value="Public Property RootDesigner As ActivityDesigner" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::ComponentModel::Design::ActivityDesigner ^ RootDesigner { System::Workflow::ComponentModel::Design::ActivityDesigner ^ get(); void set(System::Workflow::ComponentModel::Design::ActivityDesigner ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RootDesigner : System.Workflow.ComponentModel.Design.ActivityDesigner with get, set" Usage="System.Workflow.ComponentModel.Design.WorkflowView.RootDesigner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Design.ActivityDesigner</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia projektanta głównego dla <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />elementu.</summary>
        <value>Skojarzona<see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />z. <see cref="T:System.Workflow.ComponentModel.Design.ActivityDesigner" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Głównym projektantem przepływu pracy jest projektant skojarzony z powierzchnią projektową przepływu pracy. Zawiera wszystkich podrzędnych projektantów, a następnie wszystkie działania w przepływie pracy.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak pobrać RootDesigner obiektu element WorkflowView. Pole workflowPanel zawiera metodę o nazwie GetWorkflowView, która zwraca aktywne wystąpienie element WorkflowView. RootDesigner jest następnie rzutowane do SequentialWorkflowRootDesigner przed wykonaniem jakiejkolwiek akcji.  
  
 Ten przykład kodu jest częścią podstawowego przykładu zestawu SDK DesignerHosting z pliku DesignerShell.cs. Aby uzyskać więcej informacji, zobacz [przykład podstawowej obsługi projektanta](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741708(v=vs.90)).  
  
 [!code-csharp[wf_samples#236](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#236)]
 [!code-vb[wf_samples#236](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#236)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootDesignerChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RootDesignerChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RootDesignerChanged" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.ComponentModel.Design.WorkflowView.RootDesignerChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event RootDesignerChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RootDesignerChanged;" />
      <MemberSignature Language="F#" Value="member this.RootDesignerChanged : EventHandler " Usage="member this.RootDesignerChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uruchamiany, gdy główny projektant zostanie zmieniony.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="public void SaveViewState (System.IO.Stream viewState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveViewState(class System.IO.Stream viewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.SaveViewState(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveViewState (viewState As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveViewState(System::IO::Stream ^ viewState);" />
      <MemberSignature Language="F#" Value="member this.SaveViewState : System.IO.Stream -&gt; unit" Usage="workflowView.SaveViewState viewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewState" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="viewState"><see cref="T:System.IO.BinaryReader" /> Używany do przechowywania stanu widoku.</param>
        <summary>Zapisuje stan widoku w strumieniu binarnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Stan widoku to akumulacja wartości właściwości i kontrolek podrzędnych widoku. Wartości właściwości są utrwalane w strumieniu po zapisaniu i można je przywrócić <xref:System.Workflow.ComponentModel.Design.WorkflowView.LoadViewState%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład ilustruje zapisywanie <xref:System.Workflow.ComponentModel.Design.WorkflowView> stanu widoku dla obiektu przez <xref:System.IO.FileStream> utworzenie obiektu przy użyciu `FileMode.Create` flagi i przekazanie go do <xref:System.Workflow.ComponentModel.Design.WorkflowView.SaveViewState%2A> metody. Aby załadować ten stan widoku w późniejszym czasie, zobacz <xref:System.Workflow.ComponentModel.Design.WorkflowView.LoadViewState%2A>.  
  
 [!code-csharp[wf_samples#59](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#59)]
 [!code-vb[wf_samples#59](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveWorkflowImage">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje obraz <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> w oparciu o określony format obrazu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveWorkflowImage">
      <MemberSignature Language="C#" Value="public void SaveWorkflowImage (System.IO.Stream stream, System.Drawing.Imaging.ImageFormat imageFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveWorkflowImage(class System.IO.Stream stream, class System.Drawing.Imaging.ImageFormat imageFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.SaveWorkflowImage(System.IO.Stream,System.Drawing.Imaging.ImageFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveWorkflowImage(System::IO::Stream ^ stream, System::Drawing::Imaging::ImageFormat ^ imageFormat);" />
      <MemberSignature Language="F#" Value="member this.SaveWorkflowImage : System.IO.Stream * System.Drawing.Imaging.ImageFormat -&gt; unit" Usage="workflowView.SaveWorkflowImage (stream, imageFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="imageFormat" Type="System.Drawing.Imaging.ImageFormat" />
      </Parameters>
      <Docs>
        <param name="stream">, <see cref="T:System.IO.Stream" /> Aby zapisać obraz widoku przepływu pracy.</param>
        <param name="imageFormat"><see cref="T:System.Drawing.Imaging.ImageFormat" /> Służy do zapisywania obrazu widoku przepływu pracy.</param>
        <summary>Zapisuje obraz <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> do określonego strumienia przy użyciu określonego formatu obrazu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obraz widoku przepływu pracy jest tworzony jako mapa bitowa.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zapisać aktualnie załadowany obraz przepływu pracy przy użyciu <xref:System.IO.Stream>. W tym przykładzie <xref:System.Windows.Forms.SaveFileDialog> tworzony jest monit o podanie nazwy pliku obrazu, który ma zostać zapisany. Obiekt jest następnie tworzony przy użyciu nazwy pliku, a następnie przekazywać <xref:System.Workflow.ComponentModel.Design.WorkflowView.SaveWorkflowImage%2A> do metody. <xref:System.IO.FileStream>  
  
 [!code-csharp[wf_samples#63](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#63)]
 [!code-vb[wf_samples#63](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />lub <paramref name="imageFormat" /> zawiera odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowImage">
      <MemberSignature Language="C#" Value="public void SaveWorkflowImage (string imageFile, System.Drawing.Imaging.ImageFormat imageFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveWorkflowImage(string imageFile, class System.Drawing.Imaging.ImageFormat imageFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.SaveWorkflowImage(System.String,System.Drawing.Imaging.ImageFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveWorkflowImage(System::String ^ imageFile, System::Drawing::Imaging::ImageFormat ^ imageFormat);" />
      <MemberSignature Language="F#" Value="member this.SaveWorkflowImage : string * System.Drawing.Imaging.ImageFormat -&gt; unit" Usage="workflowView.SaveWorkflowImage (imageFile, imageFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFile" Type="System.String" />
        <Parameter Name="imageFormat" Type="System.Drawing.Imaging.ImageFormat" />
      </Parameters>
      <Docs>
        <param name="imageFile">Ścieżka do pliku, w którym ma być przechowywany obraz widoku przepływu pracy.</param>
        <param name="imageFormat"><see cref="T:System.Drawing.Imaging.ImageFormat" /> Służy do zapisywania obrazu widoku przepływu pracy.</param>
        <summary>Zapisuje obraz <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> do określonego pliku przy użyciu określonego formatu obrazu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obraz widoku przepływu pracy jest tworzony jako mapa bitowa.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zapisać aktualnie załadowany obraz przepływu pracy przy użyciu <xref:System.String>. W tym przykładzie <xref:System.Windows.Forms.SaveFileDialog> tworzony jest monit o podanie nazwy pliku obrazu, który ma zostać zapisany. Nazwa pliku i `ImageFormat.Bmp` flaga są następnie przenoszone <xref:System.Workflow.ComponentModel.Design.WorkflowView.SaveWorkflowImage%2A> do metody.  
  
 [!code-csharp[wf_samples#62](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#62)]
 [!code-vb[wf_samples#62](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="imageFile" />lub <paramref name="imageFormat" /> zawiera odwołanie o wartości null<see langword="Nothing" /> (w Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowImageToClipboard">
      <MemberSignature Language="C#" Value="public void SaveWorkflowImageToClipboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveWorkflowImageToClipboard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.SaveWorkflowImageToClipboard" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveWorkflowImageToClipboard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveWorkflowImageToClipboard();" />
      <MemberSignature Language="F#" Value="member this.SaveWorkflowImageToClipboard : unit -&gt; unit" Usage="workflowView.SaveWorkflowImageToClipboard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapisuje obraz element WorkflowView do Schowka.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScreenPointToLogical">
      <MemberSignature Language="C#" Value="public System.Drawing.Point ScreenPointToLogical (System.Drawing.Point screenPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point ScreenPointToLogical(valuetype System.Drawing.Point screenPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ScreenPointToLogical(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function ScreenPointToLogical (screenPoint As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point ScreenPointToLogical(System::Drawing::Point screenPoint);" />
      <MemberSignature Language="F#" Value="member this.ScreenPointToLogical : System.Drawing.Point -&gt; System.Drawing.Point" Usage="workflowView.ScreenPointToLogical screenPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="screenPoint" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="screenPoint"><see cref="T:System.Drawing.Point" /> Do konwersji z Współrzędne ekranu na współrzędne logiczne.</param>
        <summary>Konwertuje Współrzędne ekranu od na współrzędne logiczne. <see cref="T:System.Drawing.Point" /></summary>
        <returns>Współrzędne <see cref="T:System.Drawing.Point" /> ekranu przekonwertowane z na współrzędne logiczne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView>używa dwóch przestrzeni współrzędnych: logiczny i klient:  
  
 Współrzędne klienta są względne w lewym górnym rogu <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Lewy górny róg to 0, 0; Współrzędne x i y zwiększają się w pionie i w poziomie w obszarze widocznym. System współrzędnych klienta ma wpływ na poziom <xref:System.Workflow.ComponentModel.Design.WorkflowView> powiększenia i według pozycji paska przewijania.  
  
 W logicznym systemie koordynacji każdy obiekt jest zawsze mapowany na 0, 0. Pozycja powiększenia lub przewijania nie ma wpływ na położenie w pionie i w poziomie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollPosition">
      <MemberSignature Language="C#" Value="public System.Drawing.Point ScrollPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point ScrollPosition" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.ScrollPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollPosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point ScrollPosition { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollPosition : System.Drawing.Point with get, set" Usage="System.Workflow.ComponentModel.Design.WorkflowView.ScrollPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia położenie paska przewijania w <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <value>Punkt opisujący lokalizację paska przewijania we współrzędnych ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj, <xref:System.Workflow.ComponentModel.Design.WorkflowView.ScrollPosition%2A> Aby uzyskać lub dostosować położenie paska przewijania na powierzchni projektowej.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak ustawić właściwość ScrollPosition wewnątrz implementacji <xref:System.Windows.Forms.Panel> metody OnMouseMove kontrolki.  Ten przykład pochodzi z przykładu zestawu SDK kreatora przepływu pracy programu Outlook.  Aby uzyskać więcej informacji, zobacz [przykład kreatora przepływu pracy w programie Outlook](https://msdn.microsoft.com/library/7b2ba92b-8456-43f3-87fc-184ffdec4408).  
  
 [!code-csharp[wf_samples#105](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#105)]
 [!code-vb[wf_samples#105](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#105)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShadowDepth">
      <MemberSignature Language="C#" Value="public int ShadowDepth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ShadowDepth" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.ShadowDepth" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ShadowDepth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowDepth : int with get, set" Usage="System.Workflow.ComponentModel.Design.WorkflowView.ShadowDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="P:System.Workflow.ComponentModel.Design.WorkflowView.ShadowDepth" /> <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />dla elementu.</summary>
        <value>Głębokość cienia (w pikselach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj, <xref:System.Workflow.ComponentModel.Design.WorkflowView.ShadowDepth%2A> Aby uzyskać lub dopasować głębokość cienia tekstu wyświetlanego na powierzchni projektowej przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można uzyskać wystąpienie <xref:System.Workflow.ComponentModel.Design.WorkflowView> klasy <xref:System.ComponentModel.Design.IRootDesigner.GetView%2A> przy użyciu metody. Następnie kod ustawia kilka <xref:System.Workflow.ComponentModel.Design.WorkflowView> właściwości, w tym <xref:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar%2A> i <xref:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar%2A>, <xref:System.Workflow.ComponentModel.Design.WorkflowView.ShadowDepth%2A>i wywołuje <xref:System.Workflow.ComponentModel.Design.WorkflowView.FitToScreenSize%2A> metodę.  
  
 [!code-csharp[Wf_samples#48](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#48)]
 [!code-vb[Wf_samples#48](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#48)]  
  
 `UnloadWorkflow` Metoda, która jest wywoływana w powyższym kodzie, usuwa aktualnie załadowany przepływ pracy w celu przygotowania do załadowania nowego przepływu pracy i jest implementowana w następujący sposób:  
  
 [!code-csharp[Wf_samples#49](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#49)]
 [!code-vb[Wf_samples#49](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#49)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowInfoTip">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyświetla poradę dla. **** <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyświetla poradę dla. **** <xref:System.Workflow.ComponentModel.Design.WorkflowView>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowInfoTip">
      <MemberSignature Language="C#" Value="public void ShowInfoTip (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ShowInfoTip(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ShowInfoTip(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ShowInfoTip (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ShowInfoTip(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ShowInfoTip : string -&gt; unit" Usage="workflowView.ShowInfoTip text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst, który ma być wyświetlany **** na poradzie.</param>
        <summary>Pokazuje **Porada** dla <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> z określonym tekstem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pokazuje **Porada** dla <xref:System.Workflow.ComponentModel.Design.WorkflowView> z określonym tekstem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="infoTipText" />jest odwołaniem o wartości<see langword="Nothing" /> null (w Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowInfoTip">
      <MemberSignature Language="C#" Value="public void ShowInfoTip (string title, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ShowInfoTip(string title, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ShowInfoTip(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ShowInfoTip (title As String, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ShowInfoTip(System::String ^ title, System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.ShowInfoTip : string * string -&gt; unit" Usage="workflowView.ShowInfoTip (title, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="title" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="title">Tytuł **porady** do wyświetlenia.</param>
        <param name="text">Tekst **porady** do wyświetlenia.</param>
        <summary>Pokazuje **Porada** dla <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> z określonym tytułem i tekstem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pokazuje **Porada** dla <xref:System.Workflow.ComponentModel.Design.WorkflowView> z określonym tytułem i tekstem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="title" />jest odwołaniem o wartości<see langword="Nothing" /> null (w Visual Basic).  
  
—lub— 
 <paramref name="infoTipText" />jest odwołaniem o wartości<see langword="Nothing" />null ().</exception>
      </Docs>
    </Member>
    <Member MemberName="ShowInPlaceToolTip">
      <MemberSignature Language="C#" Value="public void ShowInPlaceToolTip (string toolTipText, System.Drawing.Rectangle toolTipRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ShowInPlaceToolTip(string toolTipText, valuetype System.Drawing.Rectangle toolTipRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.ShowInPlaceToolTip(System.String,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ShowInPlaceToolTip (toolTipText As String, toolTipRectangle As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ShowInPlaceToolTip(System::String ^ toolTipText, System::Drawing::Rectangle toolTipRectangle);" />
      <MemberSignature Language="F#" Value="member this.ShowInPlaceToolTip : string * System.Drawing.Rectangle -&gt; unit" Usage="workflowView.ShowInPlaceToolTip (toolTipText, toolTipRectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toolTipText" Type="System.String" />
        <Parameter Name="toolTipRectangle" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="toolTipText">Tekst do wyświetlenia.</param>
        <param name="toolTipRectangle">Określanie lokalizacji na ekranie, w której ma zostać <see langword="ToolTip" />umieszczony. <see cref="T:System.Drawing.Rectangle" /></param>
        <summary><see langword="ToolTip" /> Pokazuje w określonej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ToolTips`przydatne notatki dla użytkownika, które wyświetlają przydatne informacje dotyczące obiektu pod wskaźnikiem.  
  
 Służy <xref:System.Workflow.ComponentModel.Design.WorkflowView.ShowInPlaceToolTip%2A> do`ToolTip` wyświetlania z określonym tekstem i pożądaną lokalizacją.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType"><see cref="T:System.Type" /> Usługa do pobrania.</param>
        <summary>Pobiera usługę określonego typu, jeśli jest dostępna.</summary>
        <returns>Implementacja żądana usługa lub odwołanie o wartości null (<see langword="Nothing" /> w Visual Basic), jeśli nie można rozpoznać usługi. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `serviceType` Jeśli jest `CommandID` to metoda zwróci określony `CommandID`. W innym `Type` `GetService` przypadku zwróci obiekt implementujący żądaną usługę lub odwołanie o wartości null (`Nothing`), jeśli nie można rozpoznać usługi.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Workflow.ComponentModel.Design.WorkflowView.GetService%2A> metodę <xref:System.Workflow.ComponentModel.Design.WorkflowView> obiektu do zwrócenia <xref:System.ComponentModel.Design.ISelectionService> interfejsu. Jeśli usługa istnieje, <xref:System.Workflow.ComponentModel.Design.WorkflowView.EnsureVisible%2A> nazywa się przekazywaniem aktualnie wybranego działania `PrimarySelection` przy użyciu właściwości <xref:System.ComponentModel.Design.ISelectionService> obiektu.  
  
 [!code-csharp[wf_samples#64](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#64)]
 [!code-vb[wf_samples#64](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#64)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IMessageFilter.PreFilterMessage">
      <MemberSignature Language="C#" Value="bool IMessageFilter.PreFilterMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Forms.IMessageFilter.PreFilterMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.System#Windows#Forms#IMessageFilter#PreFilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Function PreFilterMessage (ByRef m As Message) As Boolean Implements IMessageFilter.PreFilterMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Forms.IMessageFilter.PreFilterMessage(System::Windows::Forms::Message % m) = System::Windows::Forms::IMessageFilter::PreFilterMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IMessageFilter.PreFilterMessage(System.Windows.Forms.Message@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Komunikat do wysłania. Nie można zmodyfikować tej wiadomości.</param>
        <summary>Filtruje komunikat przed jego wysłaniem.</summary>
        <returns><see langword="true" />Aby odfiltrować komunikat i zatrzymać go od wysłania; <see langword="false" /> , aby umożliwić kontynuowanie przez komunikat do następnego filtru lub kontrolki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewPortRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ViewPortRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ViewPortRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.ViewPortRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewPortRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ViewPortRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewPortRectangle : System.Drawing.Rectangle" Usage="System.Workflow.ComponentModel.Design.WorkflowView.ViewPortRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą <see cref="P:System.Workflow.ComponentModel.Design.WorkflowView.ViewPortRectangle" /> <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />dla.</summary>
        <value>A <see cref="T:System.Drawing.Rectangle" /> , który opisuje obszar widoczny na ekranie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Workflow.ComponentModel.Design.WorkflowView.ViewPortRectangle%2A> Zawiera obszar widoczny dla przepływu pracy.  
  
   
  
## Examples  
 Poniższy przykład przedstawia metodę obsługi zdarzenia <xref:System.Workflow.ComponentModel.Design.WorkflowView> Paint obiektu, aby narysować obraz bezpośrednio <xref:System.Workflow.ComponentModel.Design.WorkflowView>na. <xref:System.Workflow.ComponentModel.Design.WorkflowView.ViewPortRectangle%2A> Właściwość zwraca widoczny obszar na powierzchni projektowej w celu poprawnego ograniczenia rysowania obrazu.  
  
 [!code-csharp[wf_samples#58](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#58)]
 [!code-vb[wf_samples#58](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#58)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewPortSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ViewPortSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ViewPortSize" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.ViewPortSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewPortSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ViewPortSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.ViewPortSize : System.Drawing.Size" Usage="System.Workflow.ComponentModel.Design.WorkflowView.ViewPortSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar obszaru widocznego dla <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <value>A <see langword="Size" /> , który opisuje widoczny obszar <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera rozmiar widocznego obszaru <xref:System.Workflow.ComponentModel.Design.WorkflowView>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VScrollBar">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.VScrollBar VScrollBar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.VScrollBar VScrollBar" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VScrollBar As VScrollBar" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::VScrollBar ^ VScrollBar { System::Windows::Forms::VScrollBar ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.VScrollBar : System.Windows.Forms.VScrollBar" Usage="System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VScrollBar</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pionowy pasek przewijania skojarzony z <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</summary>
        <value><see cref="T:System.Windows.Forms.ScrollBar" /> Można użyć, aby dostosować ustawienia i widoczność poziomego paska przewijania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar%2A> do pobierania pionowego paska przewijania <xref:System.Workflow.ComponentModel.Design.WorkflowView>w programie, którego można użyć do wprowadzania zmian w interfejsie użytkownika.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można uzyskać wystąpienie <xref:System.Workflow.ComponentModel.Design.WorkflowView> klasy.  Następnie kod ustawia <xref:System.Workflow.ComponentModel.Design.WorkflowView> kilka właściwości, w tym <xref:System.Workflow.ComponentModel.Design.WorkflowView.HScrollBar%2A> <xref:System.Workflow.ComponentModel.Design.WorkflowView.FitToWorkflowSize%2A> i <xref:System.Workflow.ComponentModel.Design.WorkflowView.VScrollBar%2A>i wywołuje metodę.  
  
 [!code-csharp[Wf_samples#65](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets.cs#65)]
 [!code-vb[Wf_samples#65](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets.vb#65)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms742004(v=vs.90)">Projektant profilów śledzenia przepływu pracy</related>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.Design.WorkflowView.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="workflowView.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Komunikat systemu Windows do przetworzenia.</param>
        <summary>Przetwarza wiadomości systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie komunikaty są wysyłane do <xref:System.Workflow.ComponentModel.Design.WorkflowView.WndProc%2A> metody.  
  
 Metoda odpowiada dokładnie funkcji systemu Windows `WindowProc`. <xref:System.Workflow.ComponentModel.Design.WorkflowView.WndProc%2A> Aby uzyskać więcej informacji o przetwarzaniu komunikatów systemu Windows `WindowProc` , zobacz dokumentację funkcji w dokumentacji dotyczącej zestawu SDK platformy systemu Windows, która znajduje się w bibliotece MSDN.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klasy pochodne powinny wywoływać metodę klasy <see langword="WndProc" /> bazowej, aby przetwarzać wszystkie komunikaty, które nie są obsługiwane.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Zoom">
      <MemberSignature Language="C#" Value="public int Zoom { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Zoom" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.Design.WorkflowView.Zoom" />
      <MemberSignature Language="VB.NET" Value="Public Property Zoom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Zoom { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Zoom : int with get, set" Usage="System.Workflow.ComponentModel.Design.WorkflowView.Zoom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />powiększenia.</summary>
        <value>Poziom powiększenia elementu <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj funkcji zoom, aby powiększyć lub zmniejszyć rozmiar składników wewnątrz <xref:System.Workflow.ComponentModel.Design.WorkflowView>. Ustawia minimalne i maksymalne poziomy powiększenia <xref:System.Workflow.ComponentModel.Design.WorkflowView>dla. <xref:System.Workflow.ComponentModel.Design.AmbientTheme>  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Workflow.ComponentModel.Design.WorkflowView.Zoom%2A> jak ustawić właściwość. <xref:System.Workflow.ComponentModel.Design.WorkflowView>  
  
 Ten przykład kodu jest częścią przykładu zestawu SDK monitora przepływu pracy z pliku MainForm.cs. Aby uzyskać więcej informacji, zobacz [przykładowy Monitor przepływu pracy](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741706(v=vs.90)).  
  
 [!code-csharp[wf_samples#138](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#138)]
 [!code-vb[wf_samples#138](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets1.vb#138)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Jeśli poziom powiększenia jest mniejszy niż minimalny poziom powiększenia<see cref="T:System.Workflow.ComponentModel.Design.AmbientTheme" />  
  
—lub— 
Jeśli poziom powiększenia przekracza maksymalny poziom <see cref="T:System.Workflow.ComponentModel.Design.AmbientTheme" />powiększenia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ZoomChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ZoomChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ZoomChanged" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.ComponentModel.Design.WorkflowView.ZoomChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event ZoomChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ZoomChanged;" />
      <MemberSignature Language="F#" Value="member this.ZoomChanged : EventHandler " Usage="member this.ZoomChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po ustawieniu powiększenia dla <see cref="T:System.Workflow.ComponentModel.Design.WorkflowView" /> zmian.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obraz widoku przepływu pracy jest tworzony jako mapa bitowa.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można przypisać procedurę obsługi do <xref:System.Workflow.ComponentModel.Design.WorkflowView.ZoomChanged> zdarzenia.  
  
 Ten przykład kodu jest częścią przykładu zestawu SDK monitora przepływu pracy z pliku ViewHost.cs. Aby uzyskać więcej informacji, zobacz [Monitor przepływu pracy](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741706(v=vs.90)).  
  
 [!code-csharp[wf_samples#136](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets1.cs#136)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms741706(v=vs.90)">Monitor przepływu pracy</related>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="TcpClient" FullName="System.Net.Sockets.TcpClient">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f9f771b6b7efaf3bac363c5bc85b2f8e27033f3c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36473962" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type TcpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia połączenia klienta dla usługi w sieci TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient> Klasa udostępnia prosty metody łączenia, wysyłania, i odbieranie strumienia danych przez sieć w trybie synchronicznym blokowania.  
  
 Aby <xref:System.Net.Sockets.TcpClient> łączyć się i wymieniać dane, <xref:System.Net.Sockets.TcpListener> lub <xref:System.Net.Sockets.Socket> utworzone za pomocą protokołu TCP <xref:System.Net.Sockets.ProtocolType> musi nasłuchiwać żądań połączenia przychodzących. Nawiązanie połączenia tego odbiornika w jednym z dwóch sposobów:  
  
-   Utwórz <xref:System.Net.Sockets.TcpClient> i wywoływanie jednego z trzech dostępnych <xref:System.Net.Sockets.TcpClient.Connect%2A> metody.  
  
-   Utwórz <xref:System.Net.Sockets.TcpClient> przy użyciu nazwy hosta i portu numer hosta zdalnego. Ten konstruktor automatycznie podejmie próbę połączenia.  
  
> [!NOTE]
>  Jeśli do przesyłania datagramów bez połączenia w trybie synchronicznym blokowania należy użyć <xref:System.Net.Sockets.UdpClient> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa <xref:System.Net.Sockets.TcpClient> połączenia.  
  
 [!code-cpp[System.Net.Sockets.TcpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CPP/tcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CS/tcpclient.cs#1)]
 [!code-vb[System.Net.Sockets.TcpClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/VB/tcpclient.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Uprawnienie do nawiązywania połączenia wychodzącego lub zaakceptuj żądanie przychodzące.</permission>
    <block subset="none" type="overrides">
      <para>Aby wysyłać i odbierać dane, należy użyć <see cref="M:System.Net.Sockets.TcpClient.GetStream" /> metodę, aby uzyskać <see cref="T:System.Net.Sockets.NetworkStream" />. Wywołanie <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> i <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> metody <see cref="T:System.Net.Sockets.NetworkStream" /> do wysyłania i odbierania danych z hosta zdalnego. Użyj <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> metodę, aby zwolnić wszystkie zasoby skojarzone z <see cref="T:System.Net.Sockets.TcpClient" />.</para>
    </block>
    <altmember cref="T:System.Net.Sockets.TcpListener" />
    <altmember cref="T:System.Net.Sockets.NetworkStream" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="T:System.Net.Sockets.ProtocolType" />
    <altmember cref="T:System.Net.IPEndPoint" />
    <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.TcpClient> i umożliwia podstawowego dostawcy usług można przypisać najbardziej odpowiednia lokalnego IP adres i numer portu. Najpierw musisz wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A> metody przed wysyłania i odbierania danych.  
  
> [!NOTE]
>  Ten konstruktor działa tylko z typami adresów IPv4.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak używać domyślnego konstruktora, aby utworzyć nową <xref:System.Net.Sockets.TcpClient>.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> Do której należy powiązać TCP <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy i wiąże go określonym lokalnego punktu końcowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nowy <xref:System.Net.Sockets.TcpClient> i wiąże go do <xref:System.Net.IPEndPoint> określonego przez `localEP` parametru. Przed wywołaniem konstruktora, należy utworzyć <xref:System.Net.IPEndPoint> przy użyciu adresu IP adres i numer portu z którego chcesz wysyłać i odbierać dane. Nie trzeba określić lokalny adres IP i port numer przed łączenie i komunikacji. W przypadku utworzenia <xref:System.Net.Sockets.TcpClient> przy użyciu innego konstruktora, podstawowego dostawcy usług przypisze najbardziej odpowiednia lokalnego IP adres i numer portu.  
  
 Należy wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A> metody przed wysyłania i odbierania danych.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.TcpClient> przy użyciu lokalnego punktu końcowego.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">
          <see cref="P:System.Net.IPAddress.AddressFamily" /> Protokołu IP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy w określonej rodzinie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.TcpClient> klasy.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> Parametru nie jest równa AddressFamily.InterNetwork - lub - <paramref name="family" /> parametru nie jest równa AddressFamily.InterNetworkV6</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : string * int -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, w którym ma się połączyć.</param>
        <param name="port">Numer portu zdalnego hosta, na którym ma się połączyć.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy i nawiązuje połączenie z określonym portem na określonym hoście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.TcpClient> i nawiązuje połączenie synchroniczne próba podanej nazwy hosta i numer portu. Źródłowy dostawca usługi przypisze najbardziej odpowiednia lokalnego IP adres i numer portu. <xref:System.Net.Sockets.TcpClient> blokuje aż do jej łączy się lub kończy się niepowodzeniem. Ten konstruktor umożliwia inicjowanie, rozpoznawanie nazwy hosta DNS i Połącz w jednym kroku wygodne.  
  
 Jeśli włączony jest protokół IPv6 i <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresy IPv4, połączenia protokołu IPv6, adres zostanie podjęto pierwszej przed adresem IPv4. Może to mieć wpływ opóźnienie czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adresie IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.TcpClient> przy użyciu nazwy hosta i numer portu.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Parametr nie jest między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="Overload:System.Net.Sockets.TcpClient.#ctor" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.TcpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy nawiązać połączenia.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie zostało nawiązane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wywodzące się z <xref:System.Net.Sockets.TcpClient> tej właściwości można użyć do określenia, jeśli próba połączenia zakończyła się pomyślnie. Monitoruje stan połączenia trwającej <xref:System.Net.Sockets.TcpClient>. Jeśli host zdalny zamyka połączenie, <xref:System.Net.Sockets.TcpClient.Active%2A> nie będzie aktualizowana. Jeśli są wynikających z <xref:System.Net.Sockets.TcpClient> i wymagają uwagi zbliżonej do stanu połączenia, użyj <xref:System.Net.Sockets.Socket.Connected%2A> właściwość <xref:System.Net.Sockets.Socket> zwrócony przez <xref:System.Net.Sockets.TcpClient.Client%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.Connected" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.TcpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych, które zostały odebrane od sieci i jest dostępny do odczytu.</summary>
        <value>Liczba bajtów danych odebranych z sieci i dostępny do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.Available%2A> jest możliwość określenia, czy data jest w kolejce do odczytu. Jeśli dane są dostępne, wywołanie <xref:System.Net.Sockets.NetworkStream.Read%2A> pobierania danych. Całkowita ilość danych w kolejce w buforze sieciowej dla odczytu jest dostępnych danych. Jeśli żadne dane przechowywane w kolejce w buforze sieci <xref:System.Net.Sockets.TcpClient.Available%2A> zwraca wartość 0.  
  
 Jeśli host zdalny zamyka lub zamyka połączenie, <xref:System.Net.Sockets.TcpClient.Available%2A> może zgłaszać <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do dokumentacji kodów błędów systemu Windows Sockets w wersji 2 interfejsu API w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library) szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.TcpClient.Available%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (address, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Net.IPAddress" /> Hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje o operacji połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Hosta zdalnego określono za pomocą <see cref="T:System.Net.IPAddress" /> i numer portu (<see cref="T:System.Int32" />).</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.TcpClient.BeginConnect%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.TcpClient.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Sockets.TcpClient.Connect%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i łączy się z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (addresses, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">Co najmniej jeden <see cref="T:System.Net.IPAddress" /> który wyznacza hostom zdalnym.</param>
        <param name="port">Numer portu zdalnego hostów.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje o operacji połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Hosta zdalnego określono za pomocą <see cref="T:System.Net.IPAddress" /> tablicy i numer portu (<see cref="T:System.Int32" />).</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.TcpClient.BeginConnect%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.TcpClient.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Sockets.TcpClient.Connect%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Ta metoda jest zwykle używana bezpośrednio po wywołaniu <xref:System.Net.Dns.BeginGetHostAddresses%2A> metodę, która może zwracać wiele adresów IP dla jednego hosta.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i łączy się z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (host, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu hosta zdalnego.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje o operacji połączenia. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Hosta zdalnego określono według nazwy hosta (<see cref="T:System.String" />) i numer portu (<see cref="T:System.Int32" />).</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.TcpClient.BeginConnect%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.TcpClient.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować przed zakończeniem operacji, użyj jednej z <xref:System.Net.Sockets.TcpClient.Connect%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i łączy się z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.TcpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odpowiadającego <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Odnośnej sieci <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient> Tworzy <xref:System.Net.Sockets.Socket> do wysyłania i odbierania danych przez sieć. Klasy wywodzące się z <xref:System.Net.Sockets.TcpClient> tej właściwości można użyć do pobierania lub ustawiania to <xref:System.Net.Sockets.Socket>. Użyj odpowiadającego <xref:System.Net.Sockets.Socket> zwrócony z <xref:System.Net.Sockets.TcpClient.Client%2A> Jeśli potrzebujesz dostępu poza <xref:System.Net.Sockets.TcpClient> udostępnia. Można również użyć <xref:System.Net.Sockets.TcpClient.Client%2A> do ustawienia odpowiadającego <xref:System.Net.Sockets.Socket> do istniejącej <xref:System.Net.Sockets.Socket>. Może to być przydatne, jeśli chcesz móc korzystać z prostotę <xref:System.Net.Sockets.TcpClient> przy użyciu istniejących wcześniej <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.TcpClient.Client%2A> właściwości. W tym przykładzie, rozmiar buforów odbioru podstawowych <xref:System.Net.Sockets.Socket> zostanie zmieniona.  
  
 [!code-csharp[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="tcpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa to <see cref="T:System.Net.Sockets.TcpClient" /> wystąpienia i żądań zamknięte podstawowe połączenie TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.Close%2A> Metoda oznacza wystąpienia, ponieważ usunięty i żądania wysyłane przez skojarzony <xref:System.Net.Sockets.Socket> zamknąć połączenie TCP. Na podstawie <xref:System.Net.Sockets.TcpClient.LingerState%2A> właściwości połączenia TCP może powinny pozostawać otwarte przez pewien czas po <xref:System.Net.Sockets.TcpClient.Close%2A> metoda jest wywoływana, gdy dane pozostają na wysłanie. Nie ma żadnego powiadomienia podany przy wywołaniu metody połączenie podstawowe zostało zakończone zamknięcia.  
  
 Wywołanie tej metody może spowodować w zamknięcia skojarzonego <xref:System.Net.Sockets.Socket> i zostaną także zamknięte skojarzony <xref:System.Net.Sockets.NetworkStream> używany do wysyłania i odbierania danych, jeśli został utworzony.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje zamknięcia <xref:System.Net.Sockets.TcpClient> przez wywołanie metody <xref:System.Net.Sockets.TcpClient.Close%2A> metody.  
  
 [!code-cpp[NCLTCPClientSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLTcpClientSync/CPP/tcpclient.cpp#1)]
 [!code-csharp[NCLTCPClientSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Nawiązuje połączenie klienta z hostem zdalnym TCP przy użyciu określonego hosta nazwa i numer portu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="tcpClient.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.IPEndPoint" /> , Do którego mają zamiar łączyć.</param>
        <summary>Nawiązuje połączenie klienta z hostem zdalnym TCP przy użyciu określonej sieci zdalnego punktu końcowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody można ustanowić połączenia synchroniczne hosta zdalnego na określonym <xref:System.Net.IPEndPoint>. Przed wywołaniem <xref:System.Net.Sockets.TcpClient.Connect%2A> należy utworzyć wystąpienie <xref:System.Net.IPEndPoint> przy użyciu adresu IP i numer portu. Użyj tej <xref:System.Net.IPEndPoint> jako `remoteEP` parametru. <xref:System.Net.Sockets.TcpClient.Connect%2A> Metody zablokuje aż do jej łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md)  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.IPEndPoint> nawiązać połączenia z hostem zdalnym.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEp" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> Jest zamknięty.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="tcpClient.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Net.IPAddress" /> Hosta, na którym ma się połączyć.</param>
        <param name="port">Numer portu, do którego mają zamiar łączyć.</param>
        <summary>Nawiązuje połączenie klienta z hostem zdalnym TCP przy użyciu określonego adresu IP adres i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody można ustanowić połączenia synchroniczne hosta zdalnego na określonym <xref:System.Net.IPAddress> i numer portu. <xref:System.Net.Sockets.TcpClient.Connect%2A> Metody zablokuje aż do jej łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje adres IP i numer portu nawiązać połączenia z hostem zdalnym.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Nie jest pomiędzy <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> jest zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] ipAddresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] ipAddresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (ipAddresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ ipAddresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="tcpClient.Connect (ipAddresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipAddresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ipAddresses">
          <see cref="T:System.Net.IPAddress" /> Tablicy hosta, na którym ma się połączyć.</param>
        <param name="port">Numer portu, do którego mają zamiar łączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP przy użyciu określonych adresów IP i numer portu z klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana bezpośrednio po wywołaniu <xref:System.Net.Dns.BeginGetHostAddresses%2A> metodę, która może zwracać wiele adresów IP dla jednego hosta. Wywołanie <xref:System.Net.Sockets.TcpClient.Connect%2A> metodę ustanawiania połączenia synchroniczne hosta zdalnego hosta określonego przez tablicę <xref:System.Net.IPAddress> elementów i numer portu. <xref:System.Net.Sockets.TcpClient.Connect%2A> Metody zablokuje aż do jej łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do dokumentacji kodów błędów systemu Windows Sockets w wersji 2 interfejsu API w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library) szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje adres IP i numer portu nawiązać połączenia z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#8)]
 [!code-csharp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ipAddresses" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> flagi.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="tcpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, w którym ma się połączyć.</param>
        <param name="port">Numer portu zdalnego hosta, na którym ma się połączyć.</param>
        <summary>Nawiązuje połączenie klienta z określonym portem na określonym hoście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby nawiązać połączenie synchroniczne zdalnego hosta z określonej nazwy hosta i numer portu. <xref:System.Net.Sockets.TcpClient.Connect%2A> Metody zablokuje aż do jej łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
 Jeśli włączony jest protokół IPv6 i <xref:System.Net.Sockets.TcpClient.Connect%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresy IPv4, połączenia protokołu IPv6, adres zostanie podjęto pierwszej przed adresem IPv4. Może to mieć wpływ opóźnienie czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adresie IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Następujące zastosowania przykładowy kod nazwę hosta i port number nawiązać połączenia z hostem zdalnym.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Parametr nie jest między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> jest zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Nawiązuje połączenie klienta z hostem zdalnym TCP przy użyciu określonego hosta nazwa i numer portu jako operację asynchroniczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (address As IPAddress, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <see cref="T:System.Net.IPAddress" /> Hosta, na którym ma się połączyć.</param>
        <param name="port">Numer portu, do którego mają zamiar łączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP za pomocą określony adres IP i port numer jako operację asynchroniczną z klienta.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwraca zwrócony <xref:System.Threading.Tasks.Task> obiektu ukończy po nawiązaniu połączenia TCP. Ta metoda nie blokuje wątek wywołujący podczas żądania połączenia jest przetwarzane.  
  
 Wywołanie tej metody można ustanowić połączenia synchroniczne hosta zdalnego na określonym <xref:System.Net.IPAddress> i numer portu w ramach operacji asynchronicznej. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Nie jest pomiędzy <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> jest zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (addresses As IPAddress(), port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress[] * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">
          <see cref="T:System.Net.IPAddress" /> Tablicy hosta, na którym ma się połączyć.</param>
        <param name="port">Numer portu, do którego mają zamiar łączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP przy użyciu określonych adresów IP i numer portu jako operację asynchroniczną z klienta.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwraca zwrócony <xref:System.Threading.Tasks.Task> obiektu ukończy po nawiązaniu połączenia TCP. Ta metoda nie blokuje wątek wywołujący podczas żądania połączenia jest przetwarzane.  
  
 Ta metoda jest zwykle używana bezpośrednio po wywołaniu <xref:System.Net.Dns.BeginGetHostAddresses%2A> metodę, która może zwracać wiele adresów IP dla jednego hosta. Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego hosta określonego przez tablicę <xref:System.Net.IPAddress> elementów i numer portu w ramach operacji asynchronicznej. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do dokumentacji kodów błędów systemu Windows Sockets w wersji 2 interfejsu API w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library) szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ipAddresses" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań nie ma uprawnienia dla żądanej operacji.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest prawidłowa dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> flagi.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (host As String, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : string * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa DNS hosta zdalnego, w którym ma się połączyć.</param>
        <param name="port">Numer portu zdalnego hosta, na którym ma się połączyć.</param>
        <summary>Klient łączy się z określonego portu TCP na określonym hoście jako operację asynchroniczną.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwraca zwrócony <xref:System.Threading.Tasks.Task> obiektu ukończy po nawiązaniu połączenia TCP. Ta metoda nie blokuje wątek wywołujący podczas żądania połączenia jest przetwarzane.  
  
 Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego określonej nazwy hosta i portu numer jako operację asynchroniczną. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Użyj tej <xref:System.Net.Sockets.NetworkStream> do wysyłania i odbierania danych.  
  
 Jeśli włączony jest protokół IPv6 i <xref:System.Net.Sockets.TcpClient.ConnectAsync%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresy IPv4, połączenia protokołu IPv6, adres zostanie podjęto pierwszej przed adresem IPv4. Może to mieć wpływ opóźnienie czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adresie IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Parametr nie jest między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> jest zamknięty.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.TcpClient.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy odpowiadającego <see cref="T:System.Net.Sockets.Socket" /> dla <see cref="T:System.Net.Sockets.TcpClient" /> jest połączony z hostem zdalnym.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Net.Sockets.TcpClient.Client" /> gniazda został połączony z zasobem zdalnym, począwszy od ostatniej operacji, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.Connected%2A> Właściwości pobiera stan połączenia <xref:System.Net.Sockets.TcpClient.Client%2A> gniazda od ostatniej operacji We/Wy. Gdy zwraca `false`, <xref:System.Net.Sockets.TcpClient.Client%2A> gniazda nigdy nie był połączony lub nie jest już połączony.  
  
 Ponieważ <xref:System.Net.Sockets.TcpClient.Connected%2A> właściwość tylko odzwierciedla stan połączenia od ostatniej operacji, należy próbować wysyłać ani odbierać wiadomości, można określić bieżącego stanu. Po wiadomość wysłana kończy się niepowodzeniem, ta właściwość nie zwraca `true`. Należy pamiętać, że to zachowanie jest celowe. Nie można niezawodnie przetestować stan połączenia, ponieważ w okresie między testu i wysyłania i odbierania, połączenie może zostały utracone. Kod powinien założono, gniazda jest połączony i bezpieczne dojście nie powiodło się transmisji.  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego i następnie sprawdza, czy połączenie.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="tcpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby zarządzane i niezarządzane używane przez <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tcpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ustaw <see langword="true" /> aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.TcpClient" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` Wywołanie tej metody za pomocą `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> Wywołanie tej metody za pomocą `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Net.Sockets.TcpClient> odwołania. Robi to przez wywołanie `Dispose()` metody każdego odwołuje się do obiektu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="tcpClient.EndConnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiektu zwróconego przez wywołanie do <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</param>
        <summary>Kończy się próba oczekujące połączenia asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ukończ ten uniemożliwia metody do czasu tej operacji. Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.TcpClient.Connect%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do dokumentacji kodów błędów systemu Windows Sockets w wersji 2 interfejsu API w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library) szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> Parametr nie został zwrócony przez wywołanie do <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" /> Wcześniej wywołano metodę połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.TcpClient" /> umożliwia korzystanie z portu tylko jednego klienta.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.TcpClient" /> umożliwia tylko jednego klienta do używania konkretnego portu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" /> dla systemu Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 lub nowszej, a <see langword="false" /> dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wielu klientów można użyć określonego portu; jednak tylko jeden klienci mogą wykonywać operacje na ruch sieciowy wysyłane do portu. Można użyć <xref:System.Net.Sockets.TcpClient.ExclusiveAddressUse%2A> właściwości, aby zapobiec wielu klientów przy użyciu określonego portu.  
  
 Tej właściwości należy ustawić przed podstawowej gniazda jest powiązany z portem klienta. Jeśli należy wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A>, <xref:System.Net.Sockets.TcpClient.BeginConnect%2A>, <xref:System.Net.Sockets.TcpClient.%23ctor%28System.Net.IPEndPoint%29>, lub <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29>, port klienta jest powiązany jako efekt uboczny metody i nie można następnie ustawić <xref:System.Net.Sockets.TcpClient.ExclusiveAddressUse%2A> właściwości  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i pobiera i ustawia wartość <xref:System.Net.Sockets.TcpClient.ExclusiveAddressUse%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostępu podstawowej gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Net.Sockets.TcpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Kod aplikacji nie powinny wywoływać tej metody; obiekt <xref:System.Object.Finalize%2A> metoda jest wywoływana automatycznie podczas wyrzucania elementów bezużytecznych, chyba że finalizacji przez moduł garbage collector została wyłączona przez wywołanie do <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
 <xref:System.Net.Sockets.TcpClient> Finalizator klasy zamyka połączenie TCP i zwalnia wszystkie zarządzane zasoby skojarzone z <xref:System.Net.Sockets.TcpClient>. Te zasoby obejmują odpowiadającego <xref:System.Net.Sockets.Socket> służące do połączenia ze zdalnym hostem i <xref:System.Net.Sockets.NetworkStream> używany do wysyłania i odbierania danych. Finalizator nie zwalnia wszystkie zasoby niezarządzane.  
  
 Aby uzyskać więcej informacji, zobacz [metody Finalize i destruktory](http://msdn.microsoft.com/library/fd376774-1643-499b-869e-9546a3aeea70), [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md), i [przesłaniania metody Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.NetworkStream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.NetworkStream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As NetworkStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::NetworkStream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.Net.Sockets.NetworkStream" Usage="tcpClient.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.NetworkStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Net.Sockets.NetworkStream" /> używany do wysyłania i odbierania danych.</summary>
        <returns>Podstawowa <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.GetStream%2A> Zwraca <xref:System.Net.Sockets.NetworkStream> czy służy do wysyłania i odbierania danych. <xref:System.Net.Sockets.NetworkStream> Klasa dziedziczy <xref:System.IO.Stream> klasy, która zapewnia zbiór sformatowanego metody i właściwości używany w celu umożliwienia komunikacji sieciowej.  
  
 Należy wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A> metody najpierw lub <xref:System.Net.Sockets.TcpClient.GetStream%2A> metoda zgłosi <xref:System.InvalidOperationException>. Po uzyskaniu <xref:System.Net.Sockets.NetworkStream>, wywołaj <xref:System.Net.Sockets.NetworkStream.Write%2A> do wysyłania danych do hosta zdalnego. Wywołanie <xref:System.Net.Sockets.NetworkStream.Read%2A> metodę, aby odbierać dane przychodzące z hosta zdalnego. Obie te metody bloku, dopóki wykonać określonej operacji. Należy unikać blokowania na operację odczytu sprawdzając <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> właściwości. A `true` wartość oznacza, że dane dotarła z hostem zdalnym jest dostępna do odczytu. W takim przypadku <xref:System.Net.Sockets.NetworkStream.Read%2A> może zakończyć natychmiast. Jeśli host zdalny został zamknięty swoje połączenie <xref:System.Net.Sockets.NetworkStream.Read%2A> natychmiast zwróci zero bajtów.  
  
> [!NOTE]
>  Należy zamknąć <xref:System.Net.Sockets.NetworkStream> po osiągnięciu przez wysyłania i odbierania danych. Zamykanie <xref:System.Net.Sockets.TcpClient> nie zwalnia <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [śledzenia sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.TcpClient.GetStream%2A> uzyskać podstawową <xref:System.Net.Sockets.NetworkStream>. Po uzyskaniu <xref:System.Net.Sockets.NetworkStream>, jego wysyła i odbiera za pomocą jego <xref:System.Net.Sockets.NetworkStream.Write%2A> i <xref:System.Net.Sockets.NetworkStream.Read%2A> metody.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#14)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#14)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.TcpClient" /> Nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.TcpClient" /> Został zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.TcpClient.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o stanie linger skojarzone gniazda.</summary>
        <value>A <see cref="T:System.Net.Sockets.LingerOption" />. Domyślnie pokutujące jest wyłączone.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.LingerState%2A> Właściwości zmienia sposób <xref:System.Net.Sockets.Socket.Close%2A> zachowuje metody. Tej właściwości, gdy zestaw modyfikuje warunków, w których można zresetować połączenia Winsock. Resetuje połączenie można nadal występują w oparciu o zachowanie protokołu IP.  
  
 Ta właściwość określa długość czasu połączenia TCP pozostanie otwarte po wywołaniu <xref:System.Net.Sockets.TcpClient.Close%2A> kiedy dane pozostają na wysłanie. Podczas wywoływania <xref:System.Net.Sockets.NetworkStream.Write%2A> metody danych znajduje się w buforze wychodzących sieci. Ta właściwość może służyć do zapewnienia, że te dane są wysyłane do hosta zdalnego przed <xref:System.Net.Sockets.TcpClient.Close%2A> metody porzuca połączenie.  
  
 Aby włączyć pokutujące, Utwórz <xref:System.Net.Sockets.LingerOption> wystąpienie zawierającego odpowiednie wartości, a następnie ustaw <xref:System.Net.Sockets.TcpClient.LingerState%2A> właściwości do tego wystąpienia.  
  
 W poniższej tabeli opisano zachowanie <xref:System.Net.Sockets.TcpClient.Close%2A> metodę możliwe wartości <xref:System.Net.Sockets.LingerOption.Enabled%2A> właściwości i <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywanych w <xref:System.Net.Sockets.TcpClient.LingerState%2A> właściwości.  
  
|LingerState.Enabled|LingerState.LingerTime|Zachowanie|  
|-------------------------|----------------------------|--------------|  
|`false` (wyłączone), wartość domyślna|Nie ma zastosowania, limit czasu (domyślnie).|Próbuje wysłać oczekujących danych do momentu wygaśnięcia domyślny limit czasu protokołu IP.|  
|`true` (włączone)|Niezerowe limitu czasu|Próbuje wysłać oczekujących danych dopiero po przekroczeniu określonego limitu czasu i jeśli próba nie powiedzie się, następnie Winsock resetuje połączenie.|  
|`true` (włączone)|Zero przekroczenie limitu czasu.|Odrzuca wszystkie oczekujące dane i przywraca Winsock połączenia.|  
  
 Stos IP oblicza domyślny okres limitu czasu protokołu IP do użycia na podstawie czasu obiegu połączenia. W większości przypadków limit czasu obliczane przez stos jest większe niż określone przez aplikację. Jest to domyślne zachowanie dla gniazda podczas <xref:System.Net.Sockets.TcpClient.LingerState%2A> nie ustawiono właściwości.  
  
 Gdy <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywanych w <xref:System.Net.Sockets.TcpClient.LingerState%2A> właściwość ma wartość większą niż domyślny limit czasu protokołu IP, nadal zastosuje i przesłonić domyślny limit czasu protokołu IP.  
  
   
  
## Examples  
 Poniższy kod przykład ustawia i pobiera gniazdami linger czasu.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#12)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#12)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.LingerOption" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.TcpClient.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która wyłącza opóźnienia podczas wysyłania i odbierania buforów nie są pełne.</summary>
        <value>
          <see langword="true" /> Jeśli opóźnienie jest wyłączone, w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Net.Sockets.TcpClient.NoDelay%2A> jest `false`, <xref:System.Net.Sockets.TcpClient> nie wysyła pakiet za pośrednictwem sieci do czasu zebrania znaczną ilość danych wychodzących. Ze względu na ilość obciążenie w segmencie TCP wysyłania niewielkich ilości danych jest nieefektywne. Jednak sytuacji istnieje, których należy wysłać bardzo małe ilości danych lub oczekiwać natychmiastowe odpowiedzi od każdego pakietu, który możesz wysłać. Zdecydować, czy należy porównać względnego wydajność sieci i wymagania dotyczące aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu wyłącza opóźnienie. Następnie sprawdza wartość <xref:System.Net.Sockets.TcpClient.NoDelay%2A> Aby sprawdzić, czy pomyślnie ustawiono właściwość.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar buforu odbierania.</summary>
        <value>Rozmiar buforu odbioru w bajtach. Wartość domyślna to 8192 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> Właściwość pobiera lub ustawia liczbę bajtów, które są oczekiwane do przechowywania w buforze receive dla każdej operacji odczytu. Ta właściwość obsługuje faktycznie sieci ilość miejsca w buforze przydzielone do odbierania przychodzących danych.  
  
 Bufor Twojej sieci powinien być przynajmniej tak duże jak z buforu aplikacji, aby upewnić się, że żądane dane będą dostępne po wywołaniu <xref:System.Net.Sockets.NetworkStream.Read%2A?displayProperty=nameWithType> metody. Użyj <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> właściwości można ustawić tej wielkości. Jeśli aplikacja będzie otrzymywał zbiorczego danych, należy przekazać <xref:System.Net.Sockets.NetworkStream.Read%2A> metody buforu bardzo dużych aplikacji.  
  
 Jeśli bufor sieci jest mniejsza niż ilość danych, możesz poprosić w <xref:System.Net.Sockets.NetworkStream.Read%2A> metody, nie można pobrać żądanej ilości danych w jednej operacji odczytu. Wiąże się z tym koszty dodatkowe wywołania <xref:System.Net.Sockets.NetworkStream.Read%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera rozmiar buforów odbioru.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas ustawiania rozmiaru buforu.  - lub - aplikacji w programie .NET Compact Framework, nie można ustawić tej właściwości. Obejście tego problemu zobacz Uwaga dotycząca platformy w uwagi.</exception>
        <altmember cref="P:System.Net.Sockets.TcpClient.SendBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas <see cref="T:System.Net.Sockets.TcpClient" /> będzie czekać na odbieranie danych, gdy jest inicjowana operacja odczytu.</summary>
        <value>Wartość limitu czasu połączenia w milisekundach. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.ReceiveTimeout%2A> Właściwość określa czas, przez który <xref:System.Net.Sockets.NetworkStream.Read%2A> — metoda będzie blokować, dopóki nie jest w stanie odbierać dane. Ten czas jest mierzony w milisekundach. Po przekroczeniu limitu czasu przed <xref:System.Net.Sockets.NetworkStream.Read%2A> pomyślnie ukończy <xref:System.Net.Sockets.TcpClient> zgłasza <xref:System.IO.IOException>. Domyślnie jest nie limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera limit czasu odbioru.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.SendTimeout" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar buforu wysyłania.</summary>
        <value>Rozmiar buforów wysyłania, w bajtach. Wartość domyślna to 8192 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> Właściwości pobiera lub ustawia liczbę bajtów, które są oczekiwane do wysyłania w każdym wywołaniu <xref:System.Net.Sockets.NetworkStream.Write%2A?displayProperty=nameWithType> metody. Ta właściwość obsługuje faktycznie sieci ilość miejsca w buforze przydzielone dla operacji wysyłania.  
  
 Buforu z sieci powinien być przynajmniej tak duże jak upewnij się, że żądanych danych będą przechowywane i wysyłane w ramach jednej operacji z buforu aplikacji. Użyj <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> właściwości można ustawić tej wielkości. Jeśli aplikacja będzie wysyła dane zbiorcze, należy przekazać <xref:System.Net.Sockets.NetworkStream.Write%2A> metody buforu bardzo dużych aplikacji.  
  
 Jeśli bufor sieci jest mniejszy niż ilość danych, musisz podać <xref:System.Net.Sockets.NetworkStream.Write%2A> metody kilka sieci wysyłania operacje będą wykonywane dla każdego wywołania upewnij się <xref:System.Net.Sockets.NetworkStream.Write%2A> metody. Większa przepustowość danych można osiągnąć za zapewnienie, że bufor Twojej sieci jest przynajmniej tak duże jak buforu Twojej aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera rozmiar buforów wysyłania.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas <see cref="T:System.Net.Sockets.TcpClient" /> będzie oczekiwał na pomyślne zakończenie operacji wysyłania.</summary>
        <value>Wyślij wartość limitu czasu, w milisekundach. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient.SendTimeout%2A> Właściwość określa czas, przez który <xref:System.Net.Sockets.Socket.Send%2A> metody zablokuje momentu może zwrócić pomyślnie. Ten czas jest mierzony w milisekundach.  
  
 Po wywołaniu metody <xref:System.Net.Sockets.NetworkStream.Write%2A> Metoda podstawowa <xref:System.Net.Sockets.Socket> zwraca liczbę bajtów faktycznie wysyłane do hosta. <xref:System.Net.Sockets.TcpClient.SendTimeout%2A> Właściwość określa ilość czasu <xref:System.Net.Sockets.TcpClient> odczeka przed zwróceniem odbieranie liczba bajtów. Po przekroczeniu limitu czasu przed <xref:System.Net.Sockets.Socket.Send%2A> metody pomyślnym zakończeniu <xref:System.Net.Sockets.TcpClient> zgłosi <xref:System.Net.Sockets.SocketException>. Domyślnie jest nie limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera <xref:System.Net.Sockets.TcpClient.SendTimeout%2A> wartość.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
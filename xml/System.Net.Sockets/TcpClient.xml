<Type Name="TcpClient" FullName="System.Net.Sockets.TcpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3f522b75d1f24f730339ccccb66549177444e9c4" /><Meta Name="ms.sourcegitcommit" Value="9e7aa84070156026697d2898b5311e6c025a1e6a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/28/2019" /><Meta Name="ms.locfileid" Value="56996853" /></Metadata><TypeSignature Language="C#" Value="public class TcpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type TcpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia połączenia klienta dla usługi sieciowe TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TcpClient` Klasy zapewnia proste metody łączenie, wysyłanie, i odbieranie przesyłanie strumieniowe danych przez sieć w trybie synchronicznym blokowania.  
  
 Aby `TcpClient` łączyć się i wymieniać dane, <xref:System.Net.Sockets.TcpListener> lub <xref:System.Net.Sockets.Socket> utworzone przy użyciu protokołu TCP <xref:System.Net.Sockets.ProtocolType> musi nasłuchiwać żądań połączenia przychodzących. Można połączyć tego odbiornika, w jednej z dwóch sposobów:  
  
-   Tworzenie `TcpClient` wywołać jedną z trzech dostępnych <xref:System.Net.Sockets.TcpClient.Connect%2A> metody.  
  
-   Utwórz `TcpClient` przy użyciu nazwy hosta i portu numer hosta zdalnego. Ten konstruktor automatycznie podejmie próbę połączenia.  
  
> [!NOTE]
>  Do przesyłania datagramów bez połączenia w trybie synchronicznym blokowania, należy użyć <xref:System.Net.Sockets.UdpClient> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa `TcpClient` połączenia.  
  
 [!code-cpp[System.Net.Sockets.TcpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CPP/tcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CS/tcpclient.cs#1)]
 [!code-vb[System.Net.Sockets.TcpClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/VB/tcpclient.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Uprawnienie do nawiązywania połączenia wychodzącego, lub zaakceptować żądanie przychodzące.</permission>
    <block subset="none" type="overrides"><para>Aby wysyłać i odbierać dane, należy użyć <see cref="M:System.Net.Sockets.TcpClient.GetStream" /> metodę, aby uzyskać <see cref="T:System.Net.Sockets.NetworkStream" />. Wywołaj <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> i <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> metody <see cref="T:System.Net.Sockets.NetworkStream" /> do wysyłania i odbierania danych z hostem zdalnym. Użyj <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> metodę, aby zwolnić wszystkie zasoby skojarzone z <see cref="T:System.Net.Sockets.TcpClient" />.</para></block>
    <altmember cref="T:System.Net.Sockets.TcpListener" />
    <altmember cref="T:System.Net.Sockets.NetworkStream" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="T:System.Net.Sockets.ProtocolType" />
    <altmember cref="T:System.Net.IPEndPoint" />
    <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP-UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.TcpClient> i umożliwia podstawowego dostawcy usług można przypisać najbardziej odpowiedniego adresu IP adres i port numer lokalny. Najpierw musisz wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A> metody przed wysyłania i odbierania danych.  
  
> [!NOTE]
>  Ten konstruktor działa tylko w przypadku typów adresu IPv4.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak użyć konstruktora domyślnego, aby utworzyć nowy <xref:System.Net.Sockets.TcpClient>.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.IPEndPoint" /> Do której powiązanie TCP <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy i wiąże go z określonego lokalny punkt końcowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.TcpClient> i wiąże go do <xref:System.Net.IPEndPoint> określony przez `localEP` parametru. Przed wywołaniem tego konstruktora musi utworzyć `IPEndPoint` przy użyciu adresu IP adres i numer portu z którego chcesz wysyłać i odbierać dane. Nie trzeba określić lokalny adres IP i port numer przed łączenia i komunikacji. Jeśli tworzysz `TcpClient` przy użyciu dowolnego innego konstruktora, podstawowego dostawcy usług przypisze najbardziej odpowiedniego adresu IP adres i port numer lokalny.  
  
 Należy wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A> metody przed wysyłania i odbierania danych.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wystąpienie <xref:System.Net.Sockets.TcpClient> klasy przy użyciu lokalnego punktu końcowego.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> Parametr <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family"><see cref="P:System.Net.IPAddress.AddressFamily" /> Protokołu IP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy z określonej rodziny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wystąpienie <xref:System.Net.Sockets.TcpClient> klasy.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="family" /> Parametr nie jest równa AddressFamily.InterNetwork 
—lub— 
<paramref name="family" /> Parametr nie jest równa AddressFamily.InterNetworkV6</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : string * int -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, w którym ma się połączyć.</param>
        <param name="port">Numer portu zdalnego hosta, na którym ma się połączyć.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.TcpClient" /> klasy i nawiązanie połączenia z określonego portu na określonym hoście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.TcpClient> i nawiązuje połączenie synchroniczne próba podanej nazwy hosta i numer portu. Źródłowy dostawca usługi spowoduje przypisanie najbardziej odpowiedniego adresu IP adres i port numer lokalny. `TcpClient` blokuje, aż do jego łączy się lub kończy się niepowodzeniem. Ten konstruktor Pozwala zainicjować rozpoznać nazwy hosta DNS oraz połączyć w jednym kroku wygodne.  
  
 Jeśli był włączony protokół IPv6 i <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresów IPv4, połączenia protokołu IPv6 adres będzie próba przed adresem IPv4. Może to mieć wpływu opóźnienia czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adres IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wystąpienie <xref:System.Net.Sockets.TcpClient> klasy przy użyciu nazwy hosta i numer portu.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hostname" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> Parametru nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="Overload:System.Net.Sockets.TcpClient.#ctor" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.TcpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy nawiązać połączenia.</summary>
        <value><see langword="true" /> Jeśli połączenie zostało nawiązane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wywodzące się z <xref:System.Net.Sockets.TcpClient> można użyć tej właściwości, aby określić, jeśli próba połączenia zakończyła się pomyślnie. Monitoruje stan połączenia trwającej `TcpClient`. Jeśli host zdalny zamyka połączenia, `Active` nie będzie aktualizowana. Jeśli są pochodząca od `TcpClient` i wymagają bliżej uwagę na stan połączenia użyj <xref:System.Net.Sockets.Socket.Connected%2A> właściwość <xref:System.Net.Sockets.Socket> zwrócone przez <xref:System.Net.Sockets.TcpClient.Client%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.Connected" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.TcpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych, który otrzymał od sieci i jest dostępny do odczytu.</summary>
        <value>Liczba bajtów danych otrzymanych od sieci i dostępnych do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
`Available` Właściwość jest możliwość określenia, czy dane są umieszczane w kolejce do odczytu. Jeśli dane są dostępne, należy wywołać <xref:System.Net.Sockets.NetworkStream.Read%2A> można pobrać danych. Łączna ilość danych w kolejce w buforze sieci do odczytu jest dostępnych danych. Jeśli żadne dane nie znajduje się w kolejce w buforze sieci `Available` zwraca wartość 0.  
  
 Jeśli host zdalny zamyka lub zamyka połączenia, `Available` może zgłaszać <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony `SocketException`, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie `Available` właściwości.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (address, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> Hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji nawiązywania połączenia. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host zdalny jest określona przez <see cref="T:System.Net.IPAddress" /> i numer portu (<see cref="T:System.Int32" />).</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną `BeginConnect` można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.TcpClient.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednej z <xref:System.Net.Sockets.TcpClient.Connect%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i nawiązanie połączenia z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (addresses, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">Co najmniej jeden <see cref="T:System.Net.IPAddress" /> który wyznacza hostów zdalnych.</param>
        <param name="port">Numer portu hostów zdalnych.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji nawiązywania połączenia. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host zdalny jest określona przez <see cref="T:System.Net.IPAddress" /> tablicy i numer portu (<see cref="T:System.Int32" />).</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną `BeginConnect` można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.TcpClient.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednej z <xref:System.Net.Sockets.TcpClient.Connect%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Ta metoda jest zwykle używana natychmiast po wywołaniu <xref:System.Net.Dns.BeginGetHostAddresses%2A> metody, która może zwrócić wiele adresów IP dla jednego hosta.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i nawiązanie połączenia z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (host, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa hosta zdalnego.</param>
        <param name="port">Numer portu zdalnego hosta.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji nawiązywania połączenia. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Rozpoczyna się asynchroniczne żądanie dla połączenia zdalnego hosta. Host zdalny jest określony przez nazwę hosta (<see cref="T:System.String" />) i numer portu (<see cref="T:System.Int32" />).</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do połączenia asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną `BeginConnect` można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.TcpClient.EndConnect%2A> metody. Zazwyczaj metoda jest wywoływana przez `asyncCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednej z <xref:System.Net.Sockets.TcpClient.Connect%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> i nawiązanie połączenia z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.TcpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podstawową <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Odnośnej sieci <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient> Tworzy <xref:System.Net.Sockets.Socket> do wysyłania i odbierania danych przez sieć. Klasy wywodzące się z `TcpClient` ta właściwość służy do pobierania lub ustawiania to `Socket`. Używają bazowej `Socket` zwróciło `Client` w razie potrzeby dostęp poza tymi, które `TcpClient` udostępnia. Można również użyć `Client` można ustawić podstawowe `Socket` do istniejącego `Socket`. Może to być przydatne, jeśli chcesz móc korzystać z prostoty `TcpClient` przy użyciu istniejących wcześniej `Socket`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie `Client` właściwości. W tym przykładzie rozmiar buforów odbioru w bazowym <xref:System.Net.Sockets.Socket> zostanie zmieniony.  
  
 [!code-csharp[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="tcpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa to <see cref="T:System.Net.Sockets.TcpClient" /> wystąpienie i żądań zamknięte podstawowego połączenia TCP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Close` Metoda oznacza wystąpienia, ponieważ usunięty i żądania wysyłane przez skojarzony <xref:System.Net.Sockets.Socket> zamknij połączenie TCP. Na podstawie <xref:System.Net.Sockets.TcpClient.LingerState%2A> właściwości połączenia TCP może pozostać otwarte przez pewien czas, po `Close` metoda jest wywoływana, gdy dane pozostają do wysłania. Nie ma żadnych powiadomień podany przy wywołaniu metody połączenie podstawowe zostało zakończone zamknięcia.  
  
 Wywołanie tej metody może spowodować w zamknięciu skojarzonego `Socket` i zostaną także zamknięte skojarzonego <xref:System.Net.Sockets.NetworkStream> używany do wysyłania i odbierania danych, jeśli jedna z nich została utworzona.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zamknięcia <xref:System.Net.Sockets.TcpClient> przez wywołanie metody `Close` metody.  
  
 [!code-cpp[NCLTCPClientSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLTcpClientSync/CPP/tcpclient.cpp#1)]
 [!code-csharp[NCLTCPClientSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Klient nawiązanie połączenia z hostem zdalnym TCP przy użyciu określonego hosta, nazwę i numer portu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="tcpClient.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.IPEndPoint" /> Do której zamierzasz połączyć.</param>
        <summary>Łączy z klienta do hosta zdalnego TCP przy użyciu określonej sieci zdalnego punktu końcowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego określonego <xref:System.Net.IPEndPoint>. Przed wywołaniem `Connect`, należy utworzyć wystąpienie `IPEndPoint` przy użyciu adresu IP i numer portu. Użyj tego `IPEndPoint` jako `remoteEP` parametru. `Connect` Metoda zablokuje aż do jego łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md)  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.IPEndPoint> nawiązywanie połączeń z hostem zdalnym.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEp" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> Jest zamknięty.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="tcpClient.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> Hosta, do której chcesz połączyć.</param>
        <param name="port">Numer portu, w którym ma się połączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP przy użyciu określonego adresu IP adres i numer portu z klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego określonego <xref:System.Net.IPAddress> i numer portu. <xref:System.Net.Sockets.TcpClient.Connect%2A> Metoda zablokuje aż do jego łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa adresu IP i numer portu do połączenia z hostem zdalnym.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> Nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> wystąpienie jest zamykane.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] ipAddresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] ipAddresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (ipAddresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ ipAddresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="tcpClient.Connect (ipAddresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipAddresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ipAddresses"><see cref="T:System.Net.IPAddress" /> Tablicy hosta, na którym ma się połączyć.</param>
        <param name="port">Numer portu, w którym ma się połączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP przy użyciu określonych adresów IP i numer portu z klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana natychmiast po wywołaniu <xref:System.Net.Dns.BeginGetHostAddresses%2A> metody, która może zwrócić wiele adresów IP dla jednego hosta. Wywołaj `Connect` metodę ustanawiania połączenia synchroniczne hosta zdalnego hosta określonego przez tablicę <xref:System.Net.IPAddress> elementów i numer portu. `Connect` Metoda zablokuje aż do jego łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa adresu IP i numer portu do połączenia z hostem zdalnym.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#8)]
 [!code-csharp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ipAddresses" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> flagi.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="tcpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, w którym ma się połączyć.</param>
        <param name="port">Numer portu zdalnego hosta, na którym ma się połączyć.</param>
        <summary>Łączy z klienta do określonego portu na określonym hoście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego określona nazwa hosta i numer portu. `Connect` Metoda zablokuje aż do jego łączy się lub kończy się niepowodzeniem. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
 Jeśli był włączony protokół IPv6 i `Connect(String, Int32)` metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresów IPv4, połączenia protokołu IPv6 adres będzie próba przed adresem IPv4. Może to mieć wpływu opóźnienia czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adres IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy kod używa przykład nazwy hosta i numer portu do połączenia z hostem zdalnym  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hostname" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> Parametru nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> wystąpienie jest zamykane.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Klient nawiązanie połączenia z hostem zdalnym TCP przy użyciu określonego hosta, nazwę i numer portu jako operację asynchroniczną.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (address As IPAddress, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> Hosta, do której chcesz połączyć.</param>
        <param name="port">Numer portu, w którym ma się połączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP przy użyciu określonego adresu IP adres i numer portu jako operację asynchroniczną z klienta.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwraca zwrócone <xref:System.Threading.Tasks.Task> obiektu zakończy się po nawiązaniu połączenia TCP. Ta metoda nie blokuje wątek wywołujący podczas żądania połączenia jest w toku.  
  
 Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego określonego <xref:System.Net.IPAddress> i numer portu jako operację asynchroniczną. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> Nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> wystąpienie jest zamykane.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (addresses As IPAddress(), port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress[] * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses"><see cref="T:System.Net.IPAddress" /> Tablicy hosta, na którym ma się połączyć.</param>
        <param name="port">Numer portu, w którym ma się połączyć.</param>
        <summary>Łączy się z hostem zdalnym TCP przy użyciu określonych adresów IP i numer portu jako operację asynchroniczną z klienta.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwraca zwrócone <xref:System.Threading.Tasks.Task> obiektu zakończy się po nawiązaniu połączenia TCP. Ta metoda nie blokuje wątek wywołujący podczas żądania połączenia jest w toku.  
  
 Ta metoda jest zwykle używana natychmiast po wywołaniu <xref:System.Net.Dns.BeginGetHostAddresses%2A> metody, która może zwrócić wiele adresów IP dla jednego hosta. Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego hosta określonego przez tablicę <xref:System.Net.IPAddress> elementów i numer portu jako operację asynchroniczną. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ipAddresses" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Numer portu jest nieprawidłowy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący wyżej w stosie wywołań ma uprawnienie dla żądanej operacji.</exception>
        <exception cref="T:System.NotSupportedException">Ta metoda jest nieprawidłowa dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> flagi.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (host As String, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : string * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nazwa DNS hosta zdalnego, w którym ma się połączyć.</param>
        <param name="port">Numer portu zdalnego hosta, na którym ma się połączyć.</param>
        <summary>Klient łączy się z określonego portu TCP na określonym hoście jako operację asynchroniczną.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwraca zwrócone <xref:System.Threading.Tasks.Task> obiektu zakończy się po nawiązaniu połączenia TCP. Ta metoda nie blokuje wątek wywołujący podczas żądania połączenia jest w toku.  
  
 Wywołaj tę metodę w celu ustanowienia połączenia synchroniczne hosta zdalnego określona nazwa hosta i numer_portu jako operację asynchroniczną. Po nawiązaniu połączenia z hostem zdalnym, należy użyć <xref:System.Net.Sockets.TcpClient.GetStream%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Użyj tego `NetworkStream` do wysyłania i odbierania danych.  
  
 Jeśli był włączony protokół IPv6 i <xref:System.Net.Sockets.TcpClient.ConnectAsync%28System.String%2CSystem.Int32%29> metoda jest wywoływana, aby połączyć się z hostem, który jest rozpoznawany jako IPv6 i adresów IPv4, połączenia protokołu IPv6 adres będzie próba przed adresem IPv4. Może to mieć wpływu opóźnienia czasu do nawiązania połączenia, jeśli host nie nasłuchuje na adres IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hostname" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> Parametru nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> wystąpienie jest zamykane.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.TcpClient.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy bazowego <see cref="T:System.Net.Sockets.Socket" /> dla <see cref="T:System.Net.Sockets.TcpClient" /> jest połączony z hostem zdalnym.</summary>
        <value><see langword="true" /> Jeśli <see cref="P:System.Net.Sockets.TcpClient.Client" /> gniazdo zostało podłączone do zdalnego zasobu, począwszy od najbardziej aktualną operacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected` Właściwości pobiera stan połączenia <xref:System.Net.Sockets.TcpClient.Client%2A> gniazda, począwszy od ostatniej operacji We/Wy. Gdy zwraca `false`, `Client` gniazda nigdy nie był połączony lub nie jest już połączony.  
  
 Ponieważ `Connected` właściwość tylko odzwierciedla stan połączenia od najnowszych operację, należy podjąć próbę wysyłania i odbierania wiadomości, aby określić bieżący stan. Po wiadomości wysłać kończy się niepowodzeniem, ta właściwość nie zwraca już `true`. Należy pamiętać, że takie zachowanie jest celowe. Stan połączenia nie można przetestować niezawodne, ponieważ w okresie między testu i wysyłania i odbierania, połączenie może zostać utracony. Twój kod założyć, że jest połączony gniazda, a następnie bezpiecznie dojścia nie powiodło się transmisji.  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do zdalnego punktu końcowego, a następnie sprawdza połączenie.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="tcpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby zarządzane i niezarządzane używane przez <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tcpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Ustaw <see langword="true" /> aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.TcpClient" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` Wywołanie tej metody za pomocą `disposing` parametr `true`. `Finalize` Wywołanie tej metody za pomocą `disposing` równa `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Net.Sockets.TcpClient> odwołania. Jest to realizowane za pomocą wywołania `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose(Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="tcpClient.EndConnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> Obiektu zwróconego przez wywołanie <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</param>
        <summary>Kończy się próba połączenia asynchronicznego oczekujące.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonaj to bloki metody do czasu tej operacji. Aby wykonać tę operację synchronicznie, należy użyć <xref:System.Net.Sockets.TcpClient.Connect%2A> metody.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu kończy się próba połączenia asynchronicznego.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> Parametr nie został zwrócony przez wywołanie <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" /> Wcześniej wywołano metodę połączenia asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.TcpClient" /> umożliwia korzystanie z portu tylko jednego klienta.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.TcpClient" /> umożliwia tylko jednego klienta do używania konkretnego portu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" /> dla systemu Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 lub nowszą wersją, a <see langword="false" /> dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wielu klientów można użyć określonego portu; jednak tylko jeden z klientów mogą wykonywać operacje na ruch sieciowy, wysyłane do portu. Możesz użyć `ExclusiveAddressUse` właściwości, aby uniemożliwić wielu klientów korzysta z określonego portu.  
  
 Przed podstawowej gniazda jest powiązany z portem klienta, należy ustawić tę właściwość. Jeśli wywołasz <xref:System.Net.Sockets.TcpClient.Connect%2A>, <xref:System.Net.Sockets.TcpClient.BeginConnect%2A>, <xref:System.Net.Sockets.TcpClient.%23ctor%28System.Net.IPEndPoint%29>, lub <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29>, port klienta jest powiązany jako efekt uboczny, metody i nie można następnie ustawić `ExclusiveAddressUse` właściwości.
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.TcpClient> pobiera i ustawia wartość `ExclusiveAddressUse` właściwości.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu bazowego gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Net.Sockets.TcpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Kod aplikacji nie powinna wywołać tę metodę; obiekt `Finalize` metoda jest wywoływana automatycznie podczas wyrzucania elementów bezużytecznych, chyba że finalizacja przez moduł garbage collector została wyłączona przez wywołanie <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metody.  
  
 <xref:System.Net.Sockets.TcpClient> Finalizatory klasy zamyka połączenie TCP i zwalnia wszystkie zarządzane zasoby skojarzone z `TcpClient`. Te zasoby obejmują podstawowe <xref:System.Net.Sockets.Socket> służące do połączenia z hostem zdalnym i <xref:System.Net.Sockets.NetworkStream> używany do wysyłania i odbierania danych. Finalizator zwolnić wszelkie niezarządzane zasoby.  
  
 Aby uzyskać więcej informacji, zobacz [Finalize metody i destruktory](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <related type="Article" href="~/docs/standard/garbage-collection/index.md">Odzyskiwanie pamięci</related>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.NetworkStream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.NetworkStream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As NetworkStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::NetworkStream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.Net.Sockets.NetworkStream" Usage="tcpClient.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.NetworkStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Net.Sockets.NetworkStream" /> używany do wysyłania i odbierania danych.</summary>
        <returns>Podstawowe <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
`GetStream` Metoda zwraca <xref:System.Net.Sockets.NetworkStream> służącego do wysyłania i odbierania danych. `NetworkStream` Klasa dziedziczy <xref:System.IO.Stream> klasy, która zawiera bogaty zestaw metod i właściwości, używany w celu umożliwienia komunikacji sieciowej.  
  
 Należy wywołać <xref:System.Net.Sockets.TcpClient.Connect%2A> metoda najpierw lub <xref:System.Net.Sockets.TcpClient.GetStream%2A> metoda zgłosi <xref:System.InvalidOperationException>. Po uzyskaniu `NetworkStream`, wywołaj <xref:System.Net.Sockets.NetworkStream.Write%2A> metodę, aby wysyłać dane do hosta zdalnego. Wywołaj <xref:System.Net.Sockets.NetworkStream.Read%2A> metodę, aby odbierać dane pochodzące z hosta zdalnego. Obie te metody blokuje, dopóki wykonać określonej operacji. Należy unikać blokowania na operacje odczytu, sprawdzając <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> właściwości. A `true` wartość oznacza, że data jest już dostępna z hosta zdalnego jest dostępny do odczytu. W tym przypadku <xref:System.Net.Sockets.NetworkStream.Read%2A> jest gwarantowane do wykonania od razu. Jeśli host zdalny został zamknięty swoje połączenie <xref:System.Net.Sockets.NetworkStream.Read%2A> natychmiast zwróci zero bajtów.  
  
> [!NOTE]
>  Należy zamknąć `NetworkStream` po osiągnięciu przez wysyłania i odbierania danych. Zamykanie <xref:System.Net.Sockets.TcpClient> nie spowoduje zwolnienia `NetworkStream`.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Ten element członkowski generuje informacje ze śledzenia pod warunkiem włączenia funkcji śledzenia sieci w aplikacji. Aby uzyskać więcej informacji, zobacz [Śledzenie sieci w programie .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje `GetStream` do uzyskania bazowej <xref:System.Net.Sockets.NetworkStream>. Po uzyskaniu <xref:System.Net.Sockets.NetworkStream>, wysyła i odbiera za pomocą jego <xref:System.Net.Sockets.NetworkStream.Write%2A> i <xref:System.Net.Sockets.NetworkStream.Read%2A> metody.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#14)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#14)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.TcpClient" /> Nie jest połączony z hostem zdalnym.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> Zostało zamknięte.</exception>
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.TcpClient.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o stanie linger — skojarzone gniazda.</summary>
        <value>A <see cref="T:System.Net.Sockets.LingerOption" />. Domyślnie lingering jest wyłączona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LingerState` Właściwość zmienia sposób <xref:System.Net.Sockets.Socket.Close%2A> zachowanie metody. Tej właściwości, gdy zestaw modyfikuje warunki, na jakich połączenia można zresetować za Winsock. Resetuje połączenie może nadal występują w oparciu o zachowanie protokołu IP.  
  
 Ta właściwość określa długość czasu, przez jaki połączenie TCP pozostanie otwarte po wywołaniu <xref:System.Net.Sockets.TcpClient.Close%2A> kiedy dane pozostają do wysłania. Gdy wywołujesz <xref:System.Net.Sockets.NetworkStream.Write%2A> metody, dane są umieszczane w wychodzących buforu sieci. Ta właściwość może służyć do zapewnienia, że te dane są wysyłane do hosta zdalnego przed <xref:System.Net.Sockets.TcpClient.Close%2A> metoda spada połączenia.  
  
 Aby włączyć lingering, Utwórz <xref:System.Net.Sockets.LingerOption> wystąpienia, zawierających odpowiednie wartości, a następnie ustaw `LingerState` właściwości dla tego wystąpienia.  
  
 W poniższej tabeli opisano zachowanie <xref:System.Net.Sockets.TcpClient.Close%2A> metodę dopuszczalne <xref:System.Net.Sockets.LingerOption.Enabled%2A> właściwości i <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywane w `LingerState` właściwości.  
  
|LingerState.Enabled|LingerState.LingerTime|Zachowanie|  
|-------------------------|----------------------------|--------------|  
|`false` (wyłączone), wartość domyślna|Nie jest to konieczne, limit czasu (domyślnie).|Próbuje wysłać oczekujących danych do momentu wygaśnięcia ważności domyślny limit czasu protokołu IP.|  
|`true` (włączone)|Wartość różną od zera limitu czasu|Próbuje wysłać oczekujących danych, aż określony limit czasu upłynie, a jeśli próba nie powiedzie się, następnie Winsock resetuje połączenie.|  
|`true` (włączone)|Zero przekroczenie limitu czasu.|Odrzuca wszystkie oczekujące dane i usługi Winsock resetuje połączenie.|  
  
 Stos IP oblicza domyślny okres limitu czasu protokołu IP do użycia na podstawie czasu komunikacji dwustronnej połączenia. W większości przypadków przekroczenia limitu czasu, obliczana przez stos jest większe znaczenie niż jeden zdefiniowany przez aplikację. Jest to domyślne zachowanie dla gniazda podczas `LingerState` nie ustawiono właściwości.  
  
 Gdy <xref:System.Net.Sockets.LingerOption.LingerTime%2A> właściwości przechowywane w `LingerState` właściwość ma wartość większą niż domyślny limit czasu protokołu IP, nadal zastosuje i przesłonić domyślny limit czasu protokołu IP.  
  
   
  
## Examples  
 Poniższy kod przykład ustawia i pobiera linger gniazdami czasu.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#12)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#12)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.LingerOption" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.TcpClient.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która wyłącza opóźnienie podczas wysyłania lub odbierania bufory nie są pełne.</summary>
        <value><see langword="true" /> Jeśli opóźnienie jest wyłączony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `NoDelay` jest `false`, <xref:System.Net.Sockets.TcpClient> nie wysyła pakiet za pośrednictwem sieci do momentu zebrania znaczną ilość danych wychodzących. Ze względu na ilość obciążenie w segmencie TCP wysyłania małe ilości danych jest nieefektywne. Jednak sytuacje istnieją, których należy wysłać bardzo małe ilości danych lub oczekuje się natychmiastowej odpowiedzi od poszczególnych pakietów, które wysyłasz. Decyzji porównać względnego wydajność sieci i wymagania aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu wyłącza opóźnienie. Następnie sprawdza wartość `NoDelay` Aby sprawdzić, czy właściwość została ustawiona pomyślnie.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar buforu odbierania.</summary>
        <value>Rozmiar buforu, w bajtach. Wartość domyślna to 8192 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReceiveBufferSize` Właściwości pobiera lub ustawia liczbę bajtów, które są oczekiwane do przechowywania w buforze receive, dla każdej operacji odczytu. Ta właściwość obsługuje faktycznie miejsca w buforze sieci, przydzielone do odbierania przychodzących danych.  
  
 Usługi buforu sieci powinien wynosić przynajmniej tak duże, jako bufor Twojej aplikacji, aby upewnić się, że żądane dane będą dostępne po wywołaniu <xref:System.Net.Sockets.NetworkStream.Read%2A?displayProperty=nameWithType> metody. Użyj <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> właściwości do ustawienia tej wielkości. Jeśli aplikacja będzie otrzymywał zbiorcze danych, należy przekazać `Read` metoda buforu bardzo dużych aplikacji.  
  
 Jeśli bufor sieci jest mniejsza niż ilość danych, możesz zażądać `Read` metody, nie będzie można pobrać żądanej ilości danych w ramach jednej operacji odczytu. Wiąże się z tym koszty związane z dodatkowych połączeń do `Read` metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera rozmiar buforów odbioru.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas ustawiania rozmiaru buforu.  
  
—lub— 
W aplikacjach platformy .NET Compact Framework nie można ustawić tej właściwości. Obejście tego problemu zobacz Uwaga dotycząca platformy w uwagi.</exception>
        <altmember cref="P:System.Net.Sockets.TcpClient.SendBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas <see cref="T:System.Net.Sockets.TcpClient" /> będzie czekać na odbieranie danych, gdy jest inicjowana operacja odczytu.</summary>
        <value>Wartość limitu czasu połączenia w milisekundach. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReceiveTimeout` Właściwość określa ilość czasu, przez który <xref:System.Net.Sockets.NetworkStream.Read%2A> metoda spowoduje zablokowanie, dopóki nie jest w stanie odbierać dane. Ten czas jest mierzony w milisekundach. Jeśli limit czasu upłynie, zanim `Read` pomyślnym zakończeniu <xref:System.Net.Sockets.TcpClient> zgłasza <xref:System.IO.IOException>. Domyślnie jest nie limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera limit czasu odbioru.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.SendTimeout" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar buforu wysyłania.</summary>
        <value>Rozmiar buforu wysyłania, w bajtach. Wartość domyślna to 8192 bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SendBufferSize` Właściwości pobiera lub ustawia liczbę bajtów, które są oczekiwane wysyłania w każdym wywołaniu <xref:System.Net.Sockets.NetworkStream.Write%2A?displayProperty=nameWithType> metody. Ta właściwość obsługuje faktycznie sieci buforu miejsce przydzielone dla operacji wysyłania.  
  
 Bufor Twojej sieci powinna być przynajmniej tak duże, jako bufor Twojej aplikacji, aby upewnić się, że żądane dane są przechowywane i wysyłane w ramach jednej operacji. Użyj <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> właściwości do ustawienia tej wielkości. Jeśli aplikacja będzie wysyłać zbiorcze danych, należy przekazać `Write` metoda buforu bardzo dużych aplikacji.  
  
 Jeśli bufor sieci jest mniejsza niż ilość danych, musisz podać `Write` metody kilka sieci wysyłania operacje będą wykonywane dla każdego wywołania, można dokonać `Write` metody. Większa przepustowość danych można osiągnąć przez zapewnienie, że bufor Twojej sieci jest przynajmniej tak duże jak buforu Twojej aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera rozmiar buforu wysyłania.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas <see cref="T:System.Net.Sockets.TcpClient" /> będzie czekać na zakończenie pomyślnie operacji wysyłania.</summary>
        <value>Wyślij wartość limitu czasu, w milisekundach. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SendTimeout` Właściwość określa ilość czasu, przez który <xref:System.Net.Sockets.Socket.Send%2A> metoda spowoduje zablokowanie, dopóki nie jest w stanie zwrócić pomyślnie. Ten czas jest mierzony w milisekundach.  
  
 Po wywołaniu metody <xref:System.Net.Sockets.NetworkStream.Write%2A> metodzie bazowej <xref:System.Net.Sockets.Socket> zwraca liczbę bajtów, które faktycznie przesyłane do hosta. `SendTimeout` Właściwość określa ilość czasu <xref:System.Net.Sockets.TcpClient> będzie czekać przed zwróceniem odbieranie liczbę bajtów. Jeśli limit czasu upłynie, zanim `Send` metoda pomyślnym zakończeniu `TcpClient` zgłosi <xref:System.Net.Sockets.SocketException>. Domyślnie jest nie limitu czasu.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera `SendTimeout` wartość.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wywołanie metody IDisposable.Dispose, po zakończeniu przy użyciu <xref:System.Net.Sockets.TcpClient>. Metoda metody IDisposable.Dispose pozostawia <xref:System.Net.Sockets.TcpClient> w stanie uniemożliwiającym jego używanie. Po wywołaniu metody IDisposable.Dispose, trzeba zwolnić wszystkie odwołania do <xref:System.Net.Sockets.TcpClient> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Net.Sockets.TcpClient> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Zawsze wywołuj metody IDisposable.Dispose, przed zwolnieniem swoje ostatnie odwołanie do <xref:System.Net.Sockets.TcpClient>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Net.Sockets.TcpClient> obiektu **Finalize** metody.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>
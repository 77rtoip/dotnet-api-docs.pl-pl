<Type Name="UdpClient" FullName="System.Net.Sockets.UdpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4039322000fbf90b6347b0ae1bb869bdc85bce68" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69112055" /></Metadata><TypeSignature Language="C#" Value="public class UdpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UdpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.UdpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class UdpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UdpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type UdpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zapewnia usługi sieciowe UDP (User Datagram Protocol).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> Klasa zawiera proste metody wysyłania i otrzymywania bezpołączeniowych datagramów UDP w bloku trybu synchronicznego. Ponieważ UDP jest bezpołączeniowym protokołem transportowym, nie musisz nawiązać połączenia z hostem zdalnym przed wysłaniem i odebraniem danych. Istnieje jednak możliwość ustanowienia domyślnego hosta zdalnego na jeden z następujących sposobów:  
  
-   Utwórz wystąpienie <xref:System.Net.Sockets.UdpClient> klasy przy użyciu nazwy hosta zdalnego i numeru portu jako parametrów.  
  
-   Utwórz wystąpienie <xref:System.Net.Sockets.UdpClient> klasy, a następnie <xref:System.Net.Sockets.UdpClient.Connect%2A> Wywołaj metodę.  
  
 Możesz użyć dowolnej z metod wysyłania dostarczonych w programie, <xref:System.Net.Sockets.UdpClient> aby wysyłać dane do urządzenia zdalnego. Użyj metody <xref:System.Net.Sockets.UdpClient.Receive%2A> , aby odbierać dane z hostów zdalnych.  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Net.Sockets.UdpClient.Send%2A> przy użyciu nazwy hosta lub <xref:System.Net.IPEndPoint> Jeśli określono już domyślnego hosta zdalnego. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient> zgłosi wyjątek.  
  
 <xref:System.Net.Sockets.UdpClient>metody pozwalają również wysyłać i odbierać datagramy multiemisji. Użyj metody <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> , aby <xref:System.Net.Sockets.UdpClient> subskrybować grupę multiemisji. Użyj metody <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> , aby <xref:System.Net.Sockets.UdpClient> anulować subskrypcję z grupy multiemisji.  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Net.Sockets.UdpClient> połączenie przy użyciu nazwy `www.contoso.com` hosta na porcie 11000. Mały komunikat ciągu jest wysyłany do dwóch oddzielnych zdalnych komputerów hosta. <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda blokuje wykonywanie do momentu odebrania komunikatu. <xref:System.Net.Sockets.UdpClient.Receive%2A>Przy użyciu <xref:System.Net.IPEndPoint> przekazaną do, tożsamość hosta, który odpowiada, jest ujawniana.  
  
 [!code-cpp[Classic UdpClientExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClientExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClientExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClientExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClientExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Aby nawiązać połączenie wychodzące lub zaakceptować żądanie przychodzące.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP-UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nowy <xref:System.Net.Sockets.UdpClient> i umożliwia dostawcy usługi bazowej przypisanie najbardziej odpowiedniego lokalnego adresu IPv4 i numeru portu. Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienie jest ustawione z rodziną adresów IPv4, którego nie można zmienić ani zastąpić przez wywołanie metody Connect z obiektem docelowym IPv6.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 Ten konstruktor nie jest odpowiedni do dołączania do grupy multiemisji, ponieważ nie wykonuje powiązania gniazda. Ponadto działa tylko z typami adresów IPv4.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób użycia konstruktora bez parametrów w celu utworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Numer portu lokalnego, z którego ma zostać nadana komunikacja.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże je z podanym numerem portu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy źródłowy <xref:System.Net.Sockets.Socket> i wiąże go z numerem portu, z którego ma być przekazywany. Użyj tego konstruktora, Jeśli interesuje Cię tylko ustawienie numeru portu lokalnego. Dostawca usługi podstawowej będzie przypisywać lokalny adres IP. Jeśli przekazujesz wartość 0 do konstruktora, Dostawca usługi bazowej przypisze numer portu. Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienie jest ustawione z rodziną adresów IPv4, którego nie można zmienić ani zastąpić przez wywołanie metody Connect z obiektem docelowym IPv6.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 Ten konstruktor działa tylko z typami adresów IPv4.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie lokalnego numeru portu w celu utworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> Parametr jest <see cref="F:System.Net.IPEndPoint.MaxPort" /> większy lub<see cref="F:System.Net.IPEndPoint.MinPort" />równy.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.IPEndPoint" /> Reprezentuje lokalny punkt końcowy, do którego jest powiązane połączenie UDP.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże je z określonym lokalnym punktem końcowym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nowy <xref:System.Net.Sockets.UdpClient> i wiąże go <xref:System.Net.IPEndPoint> z określonym przez `localEP` parametr. Przed wywołaniem tego konstruktora należy utworzyć <xref:System.Net.IPEndPoint> adres IP i numer portu, z którego zamierzasz wysyłać i odbierać dane. Nie trzeba określać lokalnego adresu IP i numeru portu do wysyłania i otrzymywania danych. W przeciwnym razie Dostawca usługi podstawowej będzie przypisywać najbardziej odpowiedni lokalny adres IP i numer portu.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienie jest ustawione z rodziną adresów określoną `localEP` przez parametr, którego nie można zmienić ani zastąpić przez wywołanie metody Connect z inną rodziną adresów.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób tworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy przy użyciu lokalnego punktu końcowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Jedna z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości, która określa schemat adresowania gniazda.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `family` Parametr określa, czy odbiornik używa adresu IP w wersji 4 (IPv4) lub adresu IP w wersji 6 (IPv6). Aby użyć adresu IPv4, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetwork> wartość. Aby użyć adresu IPv6, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> wartość. Przekazanie dowolnej innej wartości spowoduje, że metoda wygeneruje <xref:System.ArgumentException>.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienie jest ustawione z rodziną adresów określoną `family` przez parametr, którego nie można zmienić ani zastąpić przez wywołanie metody Connect z inną rodziną adresów.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 Jest <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> nieodpowiedni do dołączenia do grupy multiemisji, ponieważ nie wykonuje powiązania gniazda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="family" />nie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> jest ani <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port, System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port, valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer, family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port, System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int * System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (port, family)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="port">Port, na którym nasłuchuje prób połączenia przychodzącego.</param>
        <param name="family">Jedna z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości, która określa schemat adresowania gniazda.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże je z podanym numerem portu lokalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy źródłowy <xref:System.Net.Sockets.Socket> i wiąże go z numerem portu, z którego ma być przekazywany.  
  
 `family` Parametr określa, czy odbiornik używa adresu IP w wersji 4 (IPv4) lub adresu IP w wersji 6 (IPv6). Aby użyć adresu IPv4, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetwork> wartość. Aby użyć adresu IPv6, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> wartość. Przekazanie dowolnej innej wartości spowoduje, że metoda wygeneruje <xref:System.ArgumentException>.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienie jest ustawione z rodziną adresów określoną `family` przez parametr, którego nie można zmienić ani zastąpić przez wywołanie metody Connect z inną rodziną adresów.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby zapoznać się z szczegółowym opisem błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć klienta UDP do użycia w grupie multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#3)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="family" />nie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> jest ani <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" />jest większa niż <see cref="F:System.Net.IPEndPoint.MaxPort" /> lub mniejsza niż <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : string * int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa zdalnego hosta DNS, z którym ma zostać nawiązane połączenie.</param>
        <param name="port">Numer portu zdalnego, z którym ma zostać nawiązane połączenie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Net.Sockets.UdpClient" /> klasy i ustanawia domyślnego hosta zdalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.Net.Sockets.UdpClient> i ustanawia hosta zdalnego `hostname` przy użyciu parametrów i `port` . Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Jeśli używasz tego konstruktora, nie musisz określać hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Domyślny host zdalny można zmienić w dowolnym momencie, wywołując <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę. Jeśli chcesz określić hosta zdalnego w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody, nie używaj tego konstruktora.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak utworzyć wystąpienie <xref:System.Net.Sockets.UdpClient> klasy przy użyciu nazwy hosta i numeru portu.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hostname" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" />nie jest między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.UdpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ustanowiono domyślny host zdalny.</summary>
        <value><see langword="true" />Jeśli połączenie jest aktywne; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne z mogą <xref:System.Net.Sockets.UdpClient> korzystać z tej właściwości w celu ustalenia, czy został ustanowiony domyślny host zdalny. Możesz określić domyślnego hosta zdalnego przy użyciu odpowiedniego konstruktora lub wywołując <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę. W przypadku ustanowienia domyślnego hosta zdalnego nie można określić zdalnego hosta w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.UdpClient" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="udpClient.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="allowed">Wartość logiczna określająca, czy włączyć lub wyłączyć przechodzenie translatora adresów sieciowych.</param>
        <summary>Włącza lub wyłącza przechodzenie translacji adresów sieciowych (NAT) <see cref="T:System.Net.Sockets.UdpClient" /> na wystąpieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest używana do włączania lub wyłączania przechodzenia <xref:System.Net.Sockets.UdpClient> NAT dla wystąpienia. <xref:System.Net.Sockets.UdpClient.AllowNatTraversal%2A> Przechodzenie NAT może być zapewnione przy użyciu protokołu Teredo, 6to4 lub tunelu ISATAP.  
  
 Gdy parametr ma wartość false <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> , opcja w <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>skojarzonym gnieździe ma ustawioną wartość. `allowed` Spowoduje to jawne wyłączenie przechodzenia NAT <xref:System.Net.Sockets.UdpClient> dla wystąpienia.  
  
 Gdy parametr ma wartość true <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> , opcja w <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>skojarzonym gnieździe ma ustawioną wartość. `allowed` Może to umożliwić Przechodzenie <xref:System.Net.Sockets.UdpClient> translatora adresów sieciowych w zależności od reguł zapory w systemie.  
  
 Adres Teredo jest adresem IPv6 z prefiksem 2001::/32. Adresy Teredo mogą być zwracane przez normalne rozpoznawanie nazw DNS lub wyliczane jako adres IPv6 przypisany do interfejsu lokalnego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.UdpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych odebranych z sieci, które są dostępne do odczytu.</summary>
        <value>Liczba bajtów danych odebranych z sieci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Available%2A> Właściwość służy do określania ilości danych umieszczonych w kolejce w buforze sieciowym na potrzeby odczytu. Jeśli dane są dostępne, wywołaj <xref:System.Net.Sockets.NetworkStream.Read%2A> , aby pobrać dane. Jeśli żadne dane nie są dostępne, <xref:System.Net.Sockets.UdpClient.Available%2A> Właściwość zwraca wartość 0.  
  
 Jeśli host zdalny zamknie lub zamknie połączenie, <xref:System.Net.Sockets.UdpClient.Available%2A> Właściwość <xref:System.Net.Sockets.SocketException>zgłasza.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu, i zapoznaj się z dokumentacją dotyczącą [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.Available%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginReceive (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji odbierania. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Asynchronicznie odbiera datagram z hosta zdalnego.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznego odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> musi być zakończona przez <xref:System.Net.Sockets.UdpClient.EndReceive%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj <xref:System.Net.Sockets.UdpClient.Receive%2A> metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> , aby asynchronicznie odebrać odpowiedź serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronicznie wysyła datagram do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="datagram"><see cref="T:System.Byte" /> Tablica zawierająca dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji wysyłania. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Asynchronicznie wysyła datagram do hosta zdalnego. Miejsce docelowe zostało określone wcześniej przez wywołanie metody <see cref="Overload:System.Net.Sockets.UdpClient.Connect" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.UdpClient.BeginSend%2A> musi być zakończona przez <xref:System.Net.Sockets.UdpClient.EndSend%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu zakończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do asynchronicznego wysyłania żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * System.Net.IPEndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, endPoint, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="datagram"><see cref="T:System.Byte" /> Tablica zawierająca dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="endPoint"><see cref="T:System.Net.EndPoint" /> Reprezentuje miejsce docelowe dla danych.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji wysyłania. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Asynchronicznie wysyła datagram do lokalizacji docelowej. Miejsce docelowe jest określone przez <see cref="T:System.Net.EndPoint" />.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.UdpClient.BeginSend%2A> musi być zakończona przez <xref:System.Net.Sockets.UdpClient.EndSend%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do asynchronicznego wysyłania żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, string hostname, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, hostname As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, hostname, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hostname" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="datagram"><see cref="T:System.Byte" /> Tablica zawierająca dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="hostname">Host docelowy.</param>
        <param name="port">Numer portu docelowego.</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> Delegat, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje o operacji wysyłania. Ten obiekt jest przesyłany do <paramref name="requestCallback" /> delegata po zakończeniu operacji.</param>
        <summary>Asynchronicznie wysyła datagram do lokalizacji docelowej. Miejsce docelowe jest określone przez nazwę hosta i numer portu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do wysyłania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna <xref:System.Net.Sockets.UdpClient.BeginSend%2A> musi być zakończona przez <xref:System.Net.Sockets.UdpClient.EndSend%2A> wywołanie metody. Zazwyczaj Metoda jest wywoływana przez `requestCallback` delegata.  
  
 Ta metoda nie jest blokowana do momentu ukończenia operacji. Aby zablokować do momentu ukończenia operacji, użyj jednego z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążeń metody.  
  
 Aby uzyskać szczegółowe informacje na temat korzystania z modelu programowania asynchronicznego, zobacz [Asynchroniczne wywoływanie metod synchronicznych](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do asynchronicznego wysyłania żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.UdpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podstawową sieć <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Źródłowa sieć <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient><xref:System.Net.Sockets.Socket> tworzy używany do wysyłania i odbierania danych przez sieć. Klasy pochodne z <xref:System.Net.Sockets.UdpClient> mogą używać tej właściwości do uzyskania lub <xref:System.Net.Sockets.Socket>ustawienia. Użyj zwróconego wyniku z <xref:System.Net.Sockets.UdpClient.Client%2A> , jeśli potrzebujesz dostępu poza tym, <xref:System.Net.Sockets.UdpClient> który zapewnia. <xref:System.Net.Sockets.Socket> Można również użyć <xref:System.Net.Sockets.UdpClient.Client%2A> , aby ustawić element źródłowy <xref:System.Net.Sockets.Socket> na istniejący. <xref:System.Net.Sockets.Socket> Jest to przydatne, jeśli chcesz wykorzystać prostotę <xref:System.Net.Sockets.UdpClient> korzystania z istniejących <xref:System.Net.Sockets.Socket>wcześniej.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Net.Sockets.UdpClient.Client%2A> właściwości. W tym przykładzie emisja jest włączona dla źródłowej <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="udpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie UDP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyłącza i zwalnia wszystkie zasoby zarządzane i <xref:System.Net.Sockets.UdpClient>niezarządzane skojarzone z. <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.UdpClient.Close%2A>  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie zademonstrowano zamykanie <xref:System.Net.Sockets.UdpClient> przez <xref:System.Net.Sockets.UdpClient.Close%2A> wywołanie metody.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia domyślny host zdalny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (endPoint As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="udpClient.Connect endPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="endPoint">Określa punkt końcowy sieci ,doktóregomająbyćwysyłanedane.<see cref="T:System.Net.IPEndPoint" /></param>
        <summary>Ustanawia domyślny host zdalny przy użyciu określonego punktu końcowego sieci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ustanawia domyślny host zdalny przy użyciu wartości określonej `endPoint` w parametrze. <xref:System.Net.Sockets.UdpClient.Connect%2A> Po ustanowieniu nie trzeba określać hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Aby wysłać datagramy do innego hosta zdalnego, należy wykonać inne wywołanie <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inną <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego. W przypadku ustanowienia domyślnego hosta zdalnego, a także udostępnienia hosta zdalnego w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody, <xref:System.Net.Sockets.UdpClient.Send%2A> program wygeneruje <xref:System.Net.Sockets.SocketException>. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 W <xref:System.Net.Sockets.Socket.Connect%2A> przypadku wywołania metody wszystkie datagramy, które docierają z adresu innego niż określona wartość domyślna zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, chyba że dziedziczysz <xref:System.Net.Sockets.UdpClient>z, użyj metody klienta, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Można jednak emitować dane do domyślnego adresu emisji (255.255.255.255), jeśli określisz <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większej kontroli nad adresami emisji, można również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest bezpołączeni, <xref:System.Net.Sockets.UdpClient.Connect%2A> Metoda nie jest blokowana. Nie wywołuj metody, <xref:System.Net.Sockets.UdpClient.Connect%2A> Jeśli zamierzasz odbierać wielorzutne datagramy.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Net.IPEndPoint> do ustanowienia domyślnego hosta zdalnego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="endPoint" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress addr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress addr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ addr, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.Connect (addr, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addr" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addr"><see cref="T:System.Net.IPAddress" /> Hosta zdalnego, do którego mają być wysyłane dane.</param>
        <param name="port">Numer portu, do którego mają być wysyłane dane.</param>
        <summary>Ustanawia domyślny host zdalny przy użyciu określonego adresu IP i numeru portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ustanawia domyślny host zdalny przy użyciu wartości określonych `addr` w parametrze i `port`. <xref:System.Net.Sockets.UdpClient.Connect%2A> Po ustanowieniu nie trzeba określać hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Aby wysłać datagramy do innego hosta zdalnego, należy wykonać inne wywołanie <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inną <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego. W przypadku ustanowienia domyślnego hosta zdalnego, a także udostępnienia hosta zdalnego w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody, <xref:System.Net.Sockets.UdpClient.Send%2A> program wygeneruje <xref:System.Net.Sockets.SocketException>. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 W <xref:System.Net.Sockets.Socket.Connect%2A> przypadku wywołania metody wszystkie datagramy, które docierają z adresu innego niż określona wartość domyślna zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, chyba że dziedziczysz <xref:System.Net.Sockets.UdpClient>z, użyj metody klienta, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Można jednak emitować dane do domyślnego adresu emisji (255.255.255.255), jeśli określisz <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większej kontroli nad adresami emisji, można również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest bezpołączeni, <xref:System.Net.Sockets.UdpClient.Connect%2A> Metoda nie jest blokowana. Nie wywołuj metody, <xref:System.Net.Sockets.UdpClient.Connect%2A> Jeśli zamierzasz odbierać wielorzutne datagramy.  
  
   
  
## Examples  
 Poniższy przykład używa adresu IP i numeru portu do łączenia się z hostem zdalnym.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" />jest zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="addr" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" />nie jest między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="udpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, do którego mają być wysyłane dane.</param>
        <param name="port">Numer portu na hoście zdalnym, do którego mają być wysyłane dane.</param>
        <summary>Ustanawia domyślny host zdalny przy użyciu określonej nazwy hosta i numeru portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ustanawia domyślny host zdalny przy użyciu wartości określonych `port` w parametrze i `hostname`. <xref:System.Net.Sockets.UdpClient.Connect%2A> Po ustanowieniu nie trzeba określać hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Aby wysłać datagramy do innego hosta zdalnego, należy wykonać inne wywołanie <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inną <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego.  
  
 W przypadku ustanowienia domyślnego hosta zdalnego, a także udostępnienia hosta zdalnego w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody, <xref:System.Net.Sockets.UdpClient.Send%2A> program wygeneruje <xref:System.Net.Sockets.SocketException>. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 W <xref:System.Net.Sockets.Socket.Connect%2A> przypadku wywołania metody wszystkie datagramy, które docierają z adresu innego niż określona wartość domyślna zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, chyba że dziedziczysz <xref:System.Net.Sockets.UdpClient>z, użyj metody klienta, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Można jednak emitować dane do domyślnego adresu emisji (255.255.255.255), jeśli określisz <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większej kontroli nad adresami emisji, można również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest bezpołączeni, <xref:System.Net.Sockets.UdpClient.Connect%2A> Metoda nie jest blokowana. Nie wywołuj metody, <xref:System.Net.Sockets.UdpClient.Connect%2A> Jeśli zamierzasz odbierać wielorzutne datagramy.  
  
   
  
## Examples  
 Poniższy przykład używa nazwy hosta i numeru portu do łączenia się z hostem zdalnym.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" />nie jest między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="udpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby zarządzane i niezarządzane używane przez <see cref="T:System.Net.Sockets.UdpClient" />program.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="udpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Net.Sockets.UdpClient" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość true, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Net.Sockets.UdpClient> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.UdpClient.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.UdpClient" /> czy mają być pofragmentowane datagramy protokołu IP.</summary>
        <value><see langword="true" />Jeśli zezwala <see cref="T:System.Net.Sockets.UdpClient" /> na fragmentację datagramów; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramy wymagają fragmentacji, gdy ich rozmiar przekracza maksymalną jednostkę transferu (MTU) nośnika transmisji. Datagramy mogą być pofragmentowane przez hosta wysyłającego lub przez router pośredni. Jeśli datagram musi być pofragmentowany, a <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram zostaje odrzucony, a komunikat o błędzie protokołu ICMP (Internet Control Message Protocol) zostanie wysłany z powrotem do nadawcy datagramu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tę właściwość można ustawić tylko dla gniazd korzystających z <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> lub flagi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DropMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pozostawia grupę multiemisji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.DropMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr"><see cref="T:System.Net.IPAddress" /> Grupa multiemisji do opuszczenia.</param>
        <summary>Pozostawia grupę multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wycofuje <xref:System.Net.Sockets.UdpClient> z grupy multiemisji identyfikowanej przez określony <xref:System.Net.IPAddress>. <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Po wywołaniu <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metody źródłowy <xref:System.Net.Sockets.Socket> wysyła pakiet protokołu IGMP (Internet Group Management Protocol) do routera, usuwając router z grupy multiemisji. <xref:System.Net.Sockets.UdpClient> Po wycofaniu z grupy nie będą już mogły odbierać datagramów wysyłanych do tej grupy.  
  
> [!NOTE]
>  Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak usunąć grupę multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartością, która definiuje schemat adresowania gniazda.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="multicastAddr" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr, int32 ifindex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress, ifindex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr, int ifindex);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.DropMulticastGroup (multicastAddr, ifindex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="ifindex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr"><see cref="T:System.Net.IPAddress" /> Grupa multiemisji do opuszczenia.</param>
        <param name="ifindex">Adres lokalny grupy multiemisji do opuszczenia.</param>
        <summary>Pozostawia grupę multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wycofuje <xref:System.Net.Sockets.UdpClient> z grupy multiemisji identyfikowanej przez określony <xref:System.Net.IPAddress>. <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Po wywołaniu <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metody źródłowy <xref:System.Net.Sockets.Socket> wysyła pakiet protokołu IGMP (Internet Group Management Protocol) do routera, usuwając router z grupy multiemisji. <xref:System.Net.Sockets.UdpClient> Po wycofaniu z grupy nie będą już mogły odbierać datagramów wysyłanych do tej grupy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony komunikat <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Użyj właściwości, aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak usunąć grupę multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartością, która definiuje schemat adresowania gniazda.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="multicastAddr" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.UdpClient" /> czy może wysyłać lub odbierać pakiety emisji.</summary>
        <value><see langword="true" />Jeśli zezwala <see cref="T:System.Net.Sockets.UdpClient" /> na pakiety emisji, <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emisja jest ograniczona do określonej podsieci. Możesz emitować do podsieci lokalnej, wysyłając pakiet do 255.255.255.255; można też użyć adresu emisji kierowanej, który jest częścią sieci adresu IP, ze wszystkimi bitami ustawionymi w części hosta. Na przykład, jeśli adres IP to 192.168.1.40 (adres klasy C, z częścią sieciową jako pierwsze trzy oktety, a część hosta jest ostatnim oktetem), kierowany adres emisji to 192.168.1.255.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.EnableBroadcast%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] EndReceive(class System.IAsyncResult asyncResult, class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ EndReceive(IAsyncResult ^ asyncResult, System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; byte[]" Usage="udpClient.EndReceive (asyncResult, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Obiekt zwracany przez <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />wywołanie metody. <see cref="T:System.IAsyncResult" /></param>
        <param name="remoteEP">Określony zdalny punkt końcowy.</param>
        <summary>Zamyka oczekujące asynchroniczne odbieranie.</summary>
        <returns>Jeśli to się powiedzie, tablica bajtów, która zawiera dane datagramu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu ukończenia operacji.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.UdpClient.Receive%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do uzupełniania asynchronicznego odbioru odpowiedzi serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do podstawowego <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="udpClient.EndSend asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Obiekt zwracany przez <see cref="Overload:System.Net.Sockets.UdpClient.BeginSend" />wywołanie metody. <see cref="T:System.IAsyncResult" /></param>
        <summary>Zakończenie oczekiwania na wysłanie asynchroniczne.</summary>
        <returns>Jeśli to się powiedzie, liczba bajtów wysyłanych <see cref="T:System.Net.Sockets.UdpClient" />do.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest blokowana do momentu ukończenia operacji.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do wykonania asynchronicznego wysyłania żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" />nie został zwrócony przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />zostało wcześniej wywołane dla odczytu asynchronicznego.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do podstawowego gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, <see cref="T:System.Net.Sockets.UdpClient" /> czy zezwala tylko jednemu klientowi na używanie portu.</summary>
        <value><see langword="true" />Jeśli zezwala tylko jednemu klientowi na użycie określonego portu; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Net.Sockets.UdpClient" /> Wartość domyślna to <see langword="true" /> Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 lub nowszym <see langword="false" /> oraz dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wielu klientów może używać określonego portu; jednak tylko jeden z klientów może wykonywać operacje związane z ruchem sieciowym wysyłanym do portu. Możesz użyć <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości, aby uniemożliwić wielu klientom korzystanie z określonego portu.  
  
 Ta właściwość musi być ustawiona przed powiązaniem bazowego gniazda z portem klienta. Jeśli wywołasz <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, Port klienta jest powiązany jako <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> efekt uboczny konstruktora, a następnie nie można ustawić właściwości  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.UdpClient>i pobiera i <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> ustawia właściwość.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do podstawowego gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!UdpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="udpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="JoinMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.UdpClient" /> Dodaje do grupy multiemisji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Multiemisja <see cref="T:System.Net.IPAddress" /> grupy, do której chcesz dołączyć.</param>
        <summary><see cref="T:System.Net.Sockets.UdpClient" /> Dodaje do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda subskrybuje <xref:System.Net.Sockets.UdpClient> grupę multiemisji za pomocą określonego <xref:System.Net.IPAddress>. <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Po wywołaniu <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody źródłowy <xref:System.Net.Sockets.Socket> wysyła pakiet protokołu IGMP (Internet Group Management Protocol) do routera żądającego członkostwa w grupie multiemisji. Zakres adresów multiemisji ma wartość od 224.0.0.0 do 239.255.255.255. Jeśli określisz adres spoza tego zakresu lub jeśli router, do którego jest wykonywane żądanie, nie jest włączona Multiemisja, <xref:System.Net.Sockets.UdpClient> spowoduje <xref:System.Net.Sockets.SocketException>zgłoszenie. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu. Gdy zostanie on wyświetlony wraz z routerem jako członka grupy multiemisji, będzie można odbierać dane z multiemisji wysłanych do określonego <xref:System.Net.IPAddress>. <xref:System.Net.Sockets.UdpClient>  
  
> [!NOTE]
>  Należy utworzyć <xref:System.Net.Sockets.UdpClient> przy użyciu numeru portu multiemisji; w przeciwnym razie nie będzie można odbierać datagramów z wieloma multiemisjami. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody przed <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> wywołaniem metody lub <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda nie będzie działała. Nie musisz należeć do grupy multiemisji, aby wysłać datagramy do adresu IP multiemisji.  
  
 Przed przystąpieniem do grupy multiemisji upewnij się, że gniazdo jest powiązane z portem lub punktem końcowym. Można to zrobić, wywołując jeden z konstruktorów akceptujących port lub punkt końcowy jako parametr.  
  
 Aby zrezygnować z otrzymywania multiemisji datagramów, <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Wywołaj metodę i <xref:System.Net.IPAddress> Podaj grupę, z której chcesz ją wycofać.  
  
> [!NOTE]
>  W przypadku protokołu IPv6 istnieje kilka zakresów adresów multiemisji, spośród których można dokonać wyboru. Zapoznaj się z dokumentem RFC 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> <xref:System.Net.Sockets.UdpClient> dla skonstruowanego bez określonego portu lokalnego (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor> konstruktora lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> ).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak dołączyć do grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#1)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartością, która definiuje schemat adresowania gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(int32 ifindex, class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (ifindex As Integer, multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(int ifindex, System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : int * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (ifindex, multicastAddr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifindex" Type="System.Int32" />
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="ifindex">Indeks interfejsu skojarzony z lokalnym adresem IP, na który ma zostać przyłączony do grupy multiemisji.</param>
        <param name="multicastAddr">Multiemisja <see cref="T:System.Net.IPAddress" /> grupy, do której chcesz dołączyć.</param>
        <summary><see cref="T:System.Net.Sockets.UdpClient" /> Dodaje do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed przystąpieniem do grupy multiemisji upewnij się, że gniazdo jest powiązane z portem lub punktem końcowym. Można to zrobić, wywołując jeden z konstruktorów akceptujących port lub punkt końcowy jako parametr.  
  
 Ten `infindex` parametr służy do identyfikowania interfejsu sprzętowego w tym samym łączu.  
  
> [!NOTE]
>  Istnieje kilka zakresów adresów multiemisji do wyboru. Zapoznaj się z dokumentem RFC 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> <xref:System.Net.Sockets.UdpClient> dla skonstruowanego bez określonego portu lokalnego (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=nameWithType> konstruktora lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> ).  
  
   
  
## Examples  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#5)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, int32 timeToLive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, timeToLive As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, int timeToLive);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, timeToLive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="timeToLive" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr"><see cref="T:System.Net.IPAddress" /> Grupy multiemisji do przyłączenia.</param>
        <param name="timeToLive">Czas wygaśnięcia (TTL) mierzony w przeskokach routera.</param>
        <summary><see cref="T:System.Net.Sockets.UdpClient" /> Dodaje do grupy multiemisji o określonym czasie wygaśnięcia (TTL).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda subskrybuje <xref:System.Net.Sockets.UdpClient> grupę multiemisji za pomocą określonego <xref:System.Net.IPAddress>. <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Po wywołaniu <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody źródłowy <xref:System.Net.Sockets.Socket> wysyła pakiet protokołu IGMP (Internet Group Management Protocol) do routera żądającego członkostwa w grupie multiemisji. Zakres adresów multiemisji ma wartość od 224.0.0.0 do 239.255.255.255. Jeśli określisz adres spoza tego zakresu lub jeśli router, do którego jest wykonywane żądanie, nie jest włączona Multiemisja, <xref:System.Net.Sockets.UdpClient> spowoduje <xref:System.Net.Sockets.SocketException>zgłoszenie. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu. Ten `timeToLive` parametr określa, ile przeskoków między routerami będzie można używać dla datagramcy z multiemisją przed odrzuceniem. Gdy zostanie on wyświetlony wraz z routerem jako członka grupy multiemisji, będzie można odbierać dane z multiemisji wysłanych do określonego <xref:System.Net.IPAddress>. <xref:System.Net.Sockets.UdpClient>  
  
> [!NOTE]
>  Należy utworzyć <xref:System.Net.Sockets.UdpClient> numer portu multiemisji, w przeciwnym razie nie będzie można odbierać danych z multiemisji. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody przed <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> wywołaniem metody lub metoda Receive nie będzie działała. Nie musisz należeć do grupy multiemisji, aby wysłać datagramy do adresu IP multiemisji.  
  
 Przed przyłączeniem do grupy multiemisji upewnij się, że gniazdo jest powiązane z portem lub punktem końcowym. Można to zrobić, wywołując jeden z konstruktorów, które akceptują jako parametr port lub punkt końcowy.  
  
 Aby zrezygnować z otrzymywania multiemisji datagramów, <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Wywołaj metodę i <xref:System.Net.IPAddress> Podaj grupę, z której chcesz ją wycofać.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> <xref:System.Net.Sockets.UdpClient> dla skonstruowanego bez określonego portu lokalnego (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor> konstruktora lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> ).  
  
   
  
## Examples  
 Poniższy przykład ilustruje, jak dołączyć do grupy multiemisji, podając dwa parametry, adres multiemisji i liczbę, która reprezentuje czas wygaśnięcia.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podany czas TTL nie należy do przedziału od 0 do 255</exception>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="multicastAddr" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartością, która definiuje schemat adresowania gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, class System.Net.IPAddress localAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, localAddress As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, System::Net::IPAddress ^ localAddress);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, localAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="localAddress" Type="System.Net.IPAddress" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Multiemisja <see cref="T:System.Net.IPAddress" /> grupy, do której chcesz dołączyć.</param>
        <param name="localAddress">Lokalna <see cref="T:System.Net.IPAddress" />.</param>
        <summary><see cref="T:System.Net.Sockets.UdpClient" /> Dodaje do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed przystąpieniem do grupy multiemisji upewnij się, że gniazdo jest powiązane z portem lub punktem końcowym. Można to zrobić, wywołując jeden z konstruktorów akceptujących port lub punkt końcowy jako parametr.  
  
> [!NOTE]
>  Istnieje kilka zakresów adresów multiemisji do wyboru. Można je znaleźć w dokumencie RFC 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> <xref:System.Net.Sockets.UdpClient> dla skonstruowanego bez określonego portu lokalnego (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor> konstruktora lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> ).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.UdpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określającą, czy wychodzące pakiety multiemisji są dostarczane do aplikacji wysyłającej.</summary>
        <value><see langword="true" />Jeśli odbiera wychodzące pakiety multiemisji; <see langword="false" />w przeciwnym razie. <see cref="T:System.Net.Sockets.UdpClient" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiemisja to skalowalna Metoda komunikacji wiele-do-wielu w Internecie. Jeśli proces subskrybuje adres multiemisji, wszystkie pakiety wysyłane przez ten proces są odbierane przez każdy inny proces, który subskrybuje adres multiemisji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.MulticastLoopback%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.UdpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public byte[] Receive (ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Receive(class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Receive(System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Receive :  -&gt; byte[]" Usage="udpClient.Receive remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.IPEndPoint" /> Reprezentuje hosta zdalnego, z którego dane zostały wysłane.</param>
        <summary>Zwraca datagram UDP, który został wysłany przez hosta zdalnego.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> , który zawiera dane datagramu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda zostanie Zablokowani do momentu, gdy datagram zostanie odebrany z hosta zdalnego. Gdy dane są dostępne, <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda odczytuje pierwszy datagram w kolejce i zwróci część danych jako tablicę bajtów. Ta metoda wypełnia `remoteEP` parametr <xref:System.Net.IPAddress> numerem portu i nadawcy.  
  
 W przypadku określenia domyślnego hosta zdalnego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metodzie <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda akceptuje datagramy tylko z tego hosta. Wszystkie inne datagramy zostaną odrzucone.  
  
 Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli zamierzasz odbierać wielorzutne datagramy, nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody przed <xref:System.Net.Sockets.UdpClient.Receive%2A> wywołaniem metody. <xref:System.Net.Sockets.UdpClient> Aby odbierać datagramy, należy utworzyć za pomocą numeru portu multiemisji.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Net.Sockets.UdpClient.Receive%2A> metodę. <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda blokuje wykonywanie do momentu odebrania komunikatu. <xref:System.Net.Sockets.UdpClient.Receive%2A>Przy użyciu <xref:System.Net.IPEndPoint> przekazaną do, tożsamość hosta, który odpowiada, jest ujawniana.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;valuetype System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.ReceiveAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync () As Task(Of UdpReceiveResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::UdpReceiveResult&gt; ^ ReceiveAsync();" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;" Usage="udpClient.ReceiveAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca datagram UDP asynchronicznie, który został wysłany przez hosta zdalnego.</summary>
        <returns>Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócony <xref:System.Threading.Tasks.Task%601>Obiekt > zostanie ukończony po odebraniu pakietu UDP.  
  
 W przypadku określenia domyślnego hosta zdalnego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metodzie ta metoda akceptuje datagramy tylko z tego hosta. Wszystkie inne datagramy zostaną odrzucone.  
  
 Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
> [!WARNING]
>  Jeśli zamierzasz odbierać wielorzutne datagramy, nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody przed wywołaniem tej metody. <xref:System.Net.Sockets.UdpClient> Aby odbierać datagramy, należy utworzyć za pomocą numeru portu multiemisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Bazowy <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła datagram UDP do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int -&gt; int" Usage="udpClient.Send (dgram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> , która określa datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <summary>Wysyła datagram UDP do hosta zdalnego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wysyła datagramy do hosta zdalnego ustanowionego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metodzie i zwraca liczbę wysłanych bajtów. Jeśli nie wywołasz <xref:System.Net.Sockets.UdpClient.Connect%2A> przed wywołaniem tego przeciążenia <xref:System.Net.Sockets.UdpClient.Send%2A> , metoda wygeneruje <xref:System.Net.Sockets.SocketException>. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 Aby wysłać datagramy do innego hosta zdalnego, należy wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i określić żądanego hosta zdalnego. Użyj dowolnego z przeciążeń <xref:System.Net.Sockets.UdpClient.Send%2A> metody, aby wysłać datagramy do adresu emisji.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Net.Sockets.UdpClient.Send%2A> metodę. Przed użyciem tego przeciążenia należy określić domyślnego hosta zdalnego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.UdpClient" /> Ma już domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.IPEndPoint -&gt; int" Usage="udpClient.Send (dgram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> , która określa datagram UDP, który ma zostać wysłany, reprezentowane jako tablica bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="endPoint"><see cref="T:System.Net.IPEndPoint" /> Reprezentuje hosta i port, do którego ma zostać wysłany datagram.</param>
        <summary>Wysyła datagram UDP do hosta w określonym zdalnym punkcie końcowym.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A> Metoda wysyła datagramy do określonego punktu końcowego i zwraca liczbę pomyślnie wysłanych bajtów. Przed wywołaniem tego przeciążenia należy najpierw utworzyć <xref:System.Net.IPEndPoint> adres IP i numer portu hosta zdalnego, do którego zostaną dostarczone datagramy. Można wysłać datagramy do domyślnego adresu emisji (255.255.255.255), określając <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> <xref:System.Net.IPAddress.Address%2A> właściwość dla właściwości <xref:System.Net.IPEndPoint>. Po utworzeniu <xref:System.Net.IPEndPoint>należy przekazać go <xref:System.Net.Sockets.UdpClient.Send%2A> do metody jako `endPoint` parametr.  
  
 Jeśli chcesz wysłać datagramy do dowolnego innego adresu emisji, użyj <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowego <xref:System.Net.Sockets.Socket>i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Nie dostarczaj `endPoint` parametru do tej metody, jeśli już nawiązano hosta zdalnego <xref:System.Net.Sockets.UdpClient.Connect%2A> za pomocą metody. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient.Send%2A> Metoda <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Net.Sockets.UdpClient.Send%2A> metodę. W tym przykładzie używa <xref:System.Net.IPEndPoint> się, aby określić hosta docelowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.UdpClient" />ma już domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" />jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, hostname As String, port As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * string * int -&gt; int" Usage="udpClient.Send (dgram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hostname" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> , która określa datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="hostname">Nazwa hosta zdalnego, do którego zamierzasz wysłać datagram.</param>
        <param name="port">Numer portu zdalnego, z którym ma zostać nadana komunikacja.</param>
        <summary>Wysyła datagram UDP do określonego portu na określonym hoście zdalnym.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wysyła datagramy do wartości określonych `hostname` przez parametry i `port` i zwraca liczbę pomyślnie wysłanych bajtów. <xref:System.Net.Sockets.UdpClient.Send%2A> Można wysłać datagramy do domyślnego adresu emisji, określając wartość "255.255.255.255" dla `hostname` wartości parametru.  
  
 Jeśli chcesz wysłać datagramy do dowolnego innego adresu emisji, użyj <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowego <xref:System.Net.Sockets.Socket>i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Nie podawanie nazwy hosta ani numeru portu dla tej metody, jeśli już nawiązano hosta zdalnego przy użyciu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient.Send%2A> Metoda <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Net.Sockets.UdpClient.Send%2A> metodę. Ten przykład używa nazwy hosta i numeru portu do identyfikowania hosta docelowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.UdpClient" /> Ma już domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> , która określa datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie wysyła datagramy do hosta zdalnego ustanowionego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metodzie. Jeśli nie wywołasz <xref:System.Net.Sockets.UdpClient.Connect%2A> przed wywołaniem tego przeciążenia, Metoda <xref:System.Net.Sockets.SocketException>wygeneruje. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 Aby wysłać datagramy do innego hosta zdalnego, należy wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i określić żądanego hosta zdalnego. Użyj dowolnego z przeciążeń <xref:System.Net.Sockets.UdpClient.SendAsync%2A> metody, aby wysłać datagramy do adresu emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.UdpClient" /> Ma już domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * System.Net.IPEndPoint -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> , która określa datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="endPoint"><see cref="T:System.Net.IPEndPoint" /> Reprezentuje hosta i port, do którego ma zostać wysłany datagram.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wysyła datagramy do określonego punktu końcowego. Przed wywołaniem tego przeciążenia należy najpierw utworzyć <xref:System.Net.IPEndPoint> adres IP i numer portu hosta zdalnego, do którego zostaną dostarczone datagramy. Można wysłać datagramy do domyślnego adresu emisji (255.255.255.255), określając <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> <xref:System.Net.IPAddress.Address%2A> właściwość dla właściwości <xref:System.Net.IPEndPoint>. Po utworzeniu <xref:System.Net.IPEndPoint>należy przekazać go do tej metody `endPoint` jako parametr.  
  
 Jeśli chcesz wysłać datagramy do dowolnego innego adresu emisji, użyj <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowego <xref:System.Net.Sockets.Socket>i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!WARNING]
>  Nie dostarczaj `endPoint` parametru do tej metody, jeśli już nawiązano hosta zdalnego <xref:System.Net.Sockets.UdpClient.Connect%2A> za pomocą metody. Jeśli to zrobisz, ta metoda spowoduje zgłoszenie <xref:System.Net.Sockets.SocketException>. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.UdpClient" />ma już domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" />jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, hostname As String, port As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * string * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hostname" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> , która określa datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="hostname">Nazwa hosta zdalnego, do którego zamierzasz wysłać datagram.</param>
        <param name="port">Numer portu zdalnego, z którym ma zostać nadana komunikacja.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />wartość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wysyła datagramy do wartości określonych przez `hostname` parametry i. `port` Można wysłać datagramy do domyślnego adresu emisji, określając wartość "255.255.255.255" dla `hostname` wartości parametru.  
  
 Jeśli chcesz wysłać datagramy do dowolnego innego adresu emisji, użyj <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowego <xref:System.Net.Sockets.Socket>i ustaw opcję gniazdo na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić użycie <xref:System.Net.Sockets.Socket> klasy.  
  
> [!WARNING]
>  Nie podawanie nazwy hosta ani numeru portu dla tej metody, jeśli już nawiązano hosta zdalnego przy użyciu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, ta metoda spowoduje zgłoszenie <xref:System.Net.Sockets.SocketException>. Jeśli otrzymujesz <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , aby uzyskać określony kod błędu. Po uzyskaniu tego kodu można odwołać się do dokumentacji [kodu błędu interfejsu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , aby uzyskać szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.UdpClient" /> Ma już domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Net.Sockets.UdpClient" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wywołaj metodę IDisposable. Dispose po zakończeniu korzystania z <xref:System.Net.Sockets.UdpClient>. Metoda IDisposable. Dispose Pozostawia <xref:System.Net.Sockets.UdpClient> stan w stanie niezdatnym do użytku. Po wywołaniu metody IDisposable. Dispose należy wydać wszystkie odwołania do <xref:System.Net.Sockets.UdpClient> tak, aby moduł wyrzucania elementów bezużytecznych mógł odzyskiwać pamięć <xref:System.Net.Sockets.UdpClient> , która zajmuje. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Zawsze Wywołaj metodę IDisposable. Dispose przed wydaniem ostatniego odwołania do <xref:System.Net.Sockets.UdpClient>. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu wywołania <xref:System.Net.Sockets.UdpClient> `Finalize` metody obiektu przez moduł zbierający elementy bezużyteczne.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.UdpClient.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą wartość czasu wygaśnięcia (TTL) pakietów protokołu IP wysyłanych przez <see cref="T:System.Net.Sockets.UdpClient" />program.</summary>
        <value>Wartość TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość TTL wskazuje maksymalną liczbę routerów, które może przekroczyć pakiet, zanim router odrzuci pakiet i komunikat o błędzie "czas wygaśnięcia protokołu ICMP (Internet Control Message Protocol)" zostanie zwrócony do nadawcy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.Ttl%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="UdpClient" FullName="System.Net.Sockets.UdpClient">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="245b7bab0477b3744774cfadd7975c02388156f5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36474043" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UdpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UdpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.UdpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class UdpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UdpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type UdpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia usługi sieciowe protokołu UDP (User Datagram).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> Klasa udostępnia prosty metod wysyłania i odbierania przesyłanie datagramy protokołu UDP w trybie synchronicznym blokowania. Ponieważ protokół UDP jest protokołem transportu bez połączenia, nie trzeba ustanowić połączenie przed wysyłania i odbierania danych hosta zdalnego. Jednak istnieje możliwość utworzenia domyślnego hosta zdalnego w jednym z dwóch sposobów:  
  
-   Utwórz wystąpienie <xref:System.Net.Sockets.UdpClient> przy użyciu nazwy hosta zdalnego i numer portu jako parametry.  
  
-   Utwórz wystąpienie <xref:System.Net.Sockets.UdpClient> klasy, a następnie wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metody.  
  
 Można użyć dowolnego z metody send dostarczone w <xref:System.Net.Sockets.UdpClient> do przesyłania danych do urządzenia zdalnego. Użyj <xref:System.Net.Sockets.UdpClient.Receive%2A> metody na odbieranie danych z hostów zdalnych.  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Net.Sockets.UdpClient.Send%2A> przy użyciu nazwy hosta lub <xref:System.Net.IPEndPoint> zdefiniowano już domyślnego hosta zdalnego. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient> spowoduje zgłoszenie wyjątku.  
  
 <xref:System.Net.Sockets.UdpClient> metody umożliwiają również wysyłać i odbierać datagramy multiemisji. Użyj <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody do subskrybowania <xref:System.Net.Sockets.UdpClient> do grupy multiemisji. Użyj <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metodę, aby anulować subskrypcję <xref:System.Net.Sockets.UdpClient> z grupy multiemisji.  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Net.Sockets.UdpClient> połączenia na porcie 11000 przy użyciu nazwy www.contoso.com hosta. Mała komunikat są wysyłane do dwóch oddzielnych hosta zdalnego maszyn. <xref:System.Net.Sockets.UdpClient.Receive%2A> Metody blokuje wykonywanie do momentu otrzymania wiadomości. Przy użyciu <xref:System.Net.IPEndPoint> przekazany do <xref:System.Net.Sockets.UdpClient.Receive%2A>, tożsamość odpowiadający host zostanie ujawniony.  
  
 [!code-cpp[Classic UdpClientExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClientExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClientExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClientExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClientExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">do nawiązywania połączenia wychodzącego, lub zaakceptować żądania przychodzącego.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.UdpClient> i umożliwia podstawowego dostawcy usług można przypisać najbardziej odpowiednia lokalnego IPv4 adres i numer portu. Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została skonfigurowana z rodziny adres IPv4, którego nie można zmienić ani zastąpione przez wywołanie metody Połącz z elementem docelowym IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Ten konstruktor nie jest odpowiedni dla dołączanie do grupy multiemisji, ponieważ nie wykonuje powiązanie gniazda. Ponadto działa tylko z typami adresów IPv4.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak używać domyślnego konstruktora do utworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Numer portu lokalnego, z którego chcesz nawiązać połączenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże go z numerem portu lokalnego pod warunkiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy podstawowej <xref:System.Net.Sockets.Socket> i wiąże go z numeru portu, z którego chcesz nawiązać połączenia. Jeśli interesuje Cię tylko ustawienie numerem portu lokalnego, należy użyć tego konstruktora. Źródłowy dostawca usługi przypisze lokalny adres IP. Jeśli przekazujesz 0 do konstruktora podstawowego dostawcy usług przypisze numeru portu. Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została skonfigurowana z rodziny adres IPv4, którego nie można zmienić ani zastąpione przez wywołanie metody Połącz z elementem docelowym IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Ten konstruktor działa tylko z typami adresów IPv4.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tworzenie wystąpienia przy użyciu numeru portu lokalnego <xref:System.Net.Sockets.UdpClient> klasy.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Parametru jest większa niż <see cref="F:System.Net.IPEndPoint.MaxPort" /> lub mniej niż <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> Tego respresents lokalny punkt końcowy, do którego powiązać połączenia protokołu UDP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże go określonym lokalnego punktu końcowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nowy <xref:System.Net.Sockets.UdpClient> i wiąże go do <xref:System.Net.IPEndPoint> określonego przez `localEP` parametru. Przed wywołaniem konstruktora, należy utworzyć <xref:System.Net.IPEndPoint> przy użyciu adresu IP adres i numer portu z którego chcesz wysyłać i odbierać dane. Nie trzeba określić lokalny adres IP i port numer do wysyłania i odbierania danych. Jeśli nie chcesz, podstawowego dostawcy usług przypisze najbardziej odpowiednia lokalnego IP adres i numer portu.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia jest ustawiony w rodzinie adresu określonego przez `localEP` parametr, który nie można zmienić ani zastąpione przez wywołanie metody connect w rodzinie inny adres.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> przy użyciu lokalnego punktu końcowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Jeden z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości, które określa schemat adresowania gniazda.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `family` Parametr określa, czy odbiornik używa adresu IP w wersji 4 (IPv4) lub adresu IP w wersji 6 (IPv6) adres. Aby używać adresu IPv4, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetwork> wartość. Aby użyć adresu IPv6, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> wartość. Przekazywanie wszelkie inne wartości spowoduje, że metoda throw <xref:System.ArgumentException>.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia jest ustawiony w rodzinie adresu określonego przez `family` parametr, który nie można zmienić ani zastąpione przez wywołanie metody connect w rodzinie inny adres.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> Nie jest odpowiedni dla dołączanie do grupy multiemisji, ponieważ nie wykonuje powiązanie gniazda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> nie jest <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port, System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port, valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer, family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port, System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int * System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (port, family)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="port">Port do nasłuchiwania przychodzących prób połączenia.</param>
        <param name="family">Jeden z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości, które określa schemat adresowania gniazda.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże go z numerem portu lokalnego pod warunkiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy podstawowej <xref:System.Net.Sockets.Socket> i wiąże go z numeru portu, z którego chcesz nawiązać połączenia.  
  
 `family` Parametr określa, czy odbiornik używa adresu IP w wersji 4 (IPv4) lub adresu IP w wersji 6 (IPv6) adres. Aby używać adresu IPv4, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetwork> wartość. Aby użyć adresu IPv6, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> wartość. Przekazywanie wszelkie inne wartości spowoduje, że metoda throw <xref:System.ArgumentException>.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia jest ustawiony w rodzinie adresu określonego przez `family` parametr, który nie można zmienić ani zastąpione przez wywołanie metody connect w rodzinie inny adres.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po uzyskaniu ten kod, zapoznaj się z usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacją w witrynie MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia klienta UDP do używania grupy multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#3)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> nie jest <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> jest większa niż <see cref="F:System.Net.IPEndPoint.MaxPort" /> lub mniej niż <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : string * int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa hosta DNS zdalnego, do którego mają zamiar łączyć.</param>
        <param name="port">Numer portu zdalnego, do którego mają zamiar łączyć.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i ustanawia domyślnego hosta zdalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nowy <xref:System.Net.Sockets.UdpClient> i ustanawia hosta zdalnego przy użyciu `hostname` i `port` parametrów. Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Jeśli używasz tego konstruktora nie trzeba określić hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. W dowolnym momencie można zmienić domyślnego hosta zdalnego, wywołując <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli chcesz określić hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody, nie używaj tego konstruktora.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> przy użyciu nazwy hosta i numer portu.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> nie jest pomiędzy <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.UdpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy została ustanowiona domyślnego hosta zdalnego.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie jest aktywne; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wywodzące się z <xref:System.Net.Sockets.UdpClient> tej właściwości można użyć do określenia, czy została ustanowiona domyślnego hosta zdalnego. Można utworzyć domyślnego hosta zdalnego przy użyciu odpowiedniego konstruktora lub poprzez wywołanie <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli ustanowić domyślnego hosta zdalnego, nie można określić hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.UdpClient" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="udpClient.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Wartość logiczna określająca, czy włączyć lub wyłączyć przechodzenia translatora adresów Sieciowych.</param>
        <summary>Włącza lub wyłącza funkcję translacji adresów sieciowych (NAT) przechodzenie na <see cref="T:System.Net.Sockets.UdpClient" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.AllowNatTraversal%2A> Metoda służy do włączania lub wyłączania przechodzenia translatora adresów Sieciowych dla <xref:System.Net.Sockets.UdpClient> wystąpienia. Przechodzenie translatora adresów Sieciowych mogą być dostarczane za pomocą protokołu Teredo, 6to4 lub tunelu protokołu ISATAP.  
  
 Gdy `allowed` parametr ma wartość false, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> ma ustawioną wartość opcji dla gniazda skojarzone <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Powoduje wyłączenie jawnie przechodzenia translatora adresów Sieciowych dla <xref:System.Net.Sockets.UdpClient> wystąpienia.  
  
 Gdy `allowed` parametr ma wartość true, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> ma ustawioną wartość opcji dla gniazda skojarzone <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Może to umożliwić Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.UdpClient> w zależności od reguły zapory w miejscu, w systemie.  
  
 Adresu Teredo jest adres IPv6 z prefiksem 2001:: / 32. Adresy protokołu Teredo można zwrócony przez normalne rozpoznawanie nazw DNS lub wyliczone jako adres IPv6 przypisany do interfejsu lokalnego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.UdpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych otrzymywanych z sieci, która jest dostępna do odczytu.</summary>
        <value>Liczba bajtów danych odebranych z sieci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Available%2A> Właściwość jest używana do określenia ilości danych w kolejce w buforze sieciowej dla odczytu. Jeśli dane są dostępne, wywołanie <xref:System.Net.Sockets.NetworkStream.Read%2A> pobierania danych. Jeśli dane są niedostępne, <xref:System.Net.Sockets.UdpClient.Available%2A> właściwość zwraca wartość 0.  
  
 Jeśli host zdalny zamyka lub zamyka połączenie, <xref:System.Net.Sockets.UdpClient.Available%2A> zgłasza właściwości <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu i zapoznaj się z dokumentacją kodu błąd interfejsu API w wersji 2 w Windows Sockets w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)/ szczegółowy opis Wystąpił błąd.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.UdpClient.Available%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginReceive (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowane przez użytkownika, który zawiera informacje na temat operacji odbioru. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Asynchronicznie odbiera datagram z hosta zdalnego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznego odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.UdpClient.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować aż do zakończenia operacji, należy użyć <xref:System.Net.Sockets.UdpClient.Receive%2A> metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> asynchronicznie otrzymywać odpowiedź serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła asynchronicznie datagram do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">A <see cref="T:System.Byte" /> tablicy, która zawiera dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt użytkownika, który zawiera informacje na temat operacji wysyłania. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Wysyła asynchronicznie datagram do hosta zdalnego. Docelowy został wcześniej określony przez wywołanie do <see cref="Overload:System.Net.Sockets.UdpClient.Connect" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginSend%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.UdpClient.EndSend%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> asynchronicznie wysłać żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * System.Net.IPEndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, endPoint, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">A <see cref="T:System.Byte" /> tablicy, która zawiera dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="endPoint">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący miejsca docelowego dla danych.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt użytkownika, który zawiera informacje na temat operacji wysyłania. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Wysyła asynchronicznie datagram do miejsca docelowego. Miejsce docelowe jest określona przez <see cref="T:System.Net.EndPoint" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginSend%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.UdpClient.EndSend%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> asynchronicznie wysłać żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, string hostname, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, hostname As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, hostname, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">A <see cref="T:System.Byte" /> tablicy, która zawiera dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="hostname">Komputer docelowy.</param>
        <param name="port">Numer portu docelowego.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po zakończeniu operacji.</param>
        <param name="state">Obiekt użytkownika, który zawiera informacje na temat operacji wysyłania. Ten obiekt jest przekazywany do <c>requestCallback</c> delegować po zakończeniu operacji.</param>
        <summary>Wysyła asynchronicznie datagram do miejsca docelowego. Miejsce docelowe jest określony przez nazwę hosta i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiekt, który odwołuje się do asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginSend%2A> musi być zakończona, wywołując <xref:System.Net.Sockets.UdpClient.EndSend%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegowanie.  
  
 Ta metoda nie blokuje przed zakończeniem operacji. Aby zablokować do czasu tej operacji, użyj jednej z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje o korzystaniu z modelem programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> asynchronicznie wysłać żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.UdpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odnośnej sieci <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Odnośnej sieci <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> Tworzy <xref:System.Net.Sockets.Socket> używany do wysyłania i odbierania danych przez sieć. Klasy wywodzące się z <xref:System.Net.Sockets.UdpClient> tej właściwości można użyć do pobierania lub ustawiania to <xref:System.Net.Sockets.Socket>. Użyj odpowiadającego <xref:System.Net.Sockets.Socket> zwrócony z <xref:System.Net.Sockets.UdpClient.Client%2A> Jeśli potrzebujesz dostępu poza <xref:System.Net.Sockets.UdpClient> udostępnia. Można również użyć <xref:System.Net.Sockets.UdpClient.Client%2A> do ustawienia odpowiadającego <xref:System.Net.Sockets.Socket> do istniejącej <xref:System.Net.Sockets.Socket>. Jest to przydatne, jeśli chcesz móc korzystać z prostotę <xref:System.Net.Sockets.UdpClient> przy użyciu istniejących wcześniej <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Net.Sockets.UdpClient.Client%2A> właściwości. W tym przykładzie emisji jest włączona dla podstawowych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="udpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie protokołu UDP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Close%2A> Wyłącza odpowiadającego <xref:System.Net.Sockets.Socket> i zwalnia wszystkie zasoby zarządzane i niezarządzane skojarzone z <xref:System.Net.Sockets.UdpClient>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zamknięcia <xref:System.Net.Sockets.UdpClient> przez wywołanie metody <xref:System.Net.Sockets.UdpClient.Close%2A> metody.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia domyślnego hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (endPoint As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="udpClient.Connect endPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> , Który określa punktu końcowego sieci, do którego chcesz wysyłać dane.</param>
        <summary>Ustanawia domyślnego hosta zdalnego przy użyciu określonej sieci punktu końcowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A> Metody ustanawia domyślnego hosta zdalnego przy użyciu wartości określonej w `endPoint` parametru. Po jest konieczne określanie hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Jeśli chcesz wysłać datagramy do innego hosta zdalnego, należy się upewnić innym wywołaniu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inną <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego. Jeśli ustaleniu domyślna zdalnego hosta, a także podać hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody <xref:System.Net.Sockets.UdpClient.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metoda, datagramów odbierane z adresu innego niż określoną wartość domyślną zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, o ile nie dziedziczy z <xref:System.Net.Sockets.UdpClient>, użyj metody klienta można uzyskać podstawową <xref:System.Net.Sockets.Socket>i ustaw opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Możesz natomiast, emisji danych domyślne emisji adres 255.255.255.255, jeśli określono <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większej kontroli nad adresy emisji, możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest przesyłanie, <xref:System.Net.Sockets.UdpClient.Connect%2A> — metoda nie są blokowane. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę, jeśli chcesz otrzymywać multicasted datagramów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Net.IPEndPoint> ustanowienie domyślnego hosta zdalnego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endPoint" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress addr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress addr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ addr, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.Connect (addr, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addr">
          <see cref="T:System.Net.IPAddress" /> Hosta zdalnego, do którego chcesz wysyłać dane.</param>
        <param name="port">Numer portu, do którego ma wysyłać dane.</param>
        <summary>Ustanawia domyślnego hosta zdalnego przy użyciu określonego adresu IP adres i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A> Metody ustanawia domyślnego hosta zdalnego przy użyciu wartości określonej w `addr` i `port` parametrów. Po jest konieczne określanie hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Jeśli chcesz wysłać datagramy do innego hosta zdalnego, należy się upewnić innym wywołaniu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inną <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego. Jeśli ustaleniu domyślna zdalnego hosta, a także podać hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody <xref:System.Net.Sockets.UdpClient.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metoda, datagramów odbierane z adresu innego niż określoną wartość domyślną zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, o ile nie dziedziczy z <xref:System.Net.Sockets.UdpClient>, użyj metody klienta można uzyskać podstawową <xref:System.Net.Sockets.Socket>i ustaw opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Możesz natomiast, emisji danych domyślne emisji adres 255.255.255.255, jeśli określono <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większej kontroli nad adresy emisji, możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest przesyłanie, <xref:System.Net.Sockets.UdpClient.Connect%2A> — metoda nie są blokowane. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę, jeśli chcesz otrzymywać multicasted datagramów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto adres IP i port numer nawiązać połączenia z hostem zdalnym.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> jest zamknięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addr" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> nie jest pomiędzy <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="udpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, do którego ma wysyłać dane.</param>
        <param name="port">Numer portu na hoście zdalnym, do którego chcesz wysyłać dane.</param>
        <summary>Ustanawia domyślnego hosta zdalnego przy użyciu określonego hosta nazwa i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A> Metody ustanawia domyślnego hosta zdalnego przy użyciu wartości określonej w `port` i `hostname` parametrów. Po jest konieczne określanie hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Jeśli chcesz wysłać datagramy do innego hosta zdalnego, należy się upewnić innym wywołaniu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inną <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego.  
  
 Jeśli ustaleniu domyślna zdalnego hosta, a także podać hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody <xref:System.Net.Sockets.UdpClient.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli należy wywołać <xref:System.Net.Sockets.Socket.Connect%2A> metoda, datagramów odbierane z adresu innego niż określoną wartość domyślną zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, o ile nie dziedziczy z <xref:System.Net.Sockets.UdpClient>, użyj metody klienta można uzyskać podstawową <xref:System.Net.Sockets.Socket>i ustaw opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Możesz natomiast, emisji danych domyślne emisji adres 255.255.255.255, jeśli określono <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większej kontroli nad adresy emisji, możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest przesyłanie, <xref:System.Net.Sockets.UdpClient.Connect%2A> — metoda nie są blokowane. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę, jeśli chcesz otrzymywać multicasted datagramów.  
  
   
  
## Examples  
 Następujące przykładowe zastosowania nazwę hosta i port number nawiązać połączenia z hostem zdalnym.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> nie jest pomiędzy <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="udpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby zarządzane i niezarządzane używane przez <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="udpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.UdpClient" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Net.Sockets.UdpClient> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenia Resources](~/docs/standard/garbage-collection/unmanaged.md) niezarządzane i [zastąpienie metody Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.UdpClient.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia datagramów protokołu internetowego (IP) do fragmentacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> zezwala na fragmentację datagram; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramy wymagają fragmentacji, gdy ich rozmiar przekracza maksymalny Transfer jednostki (MTU) nośnika transmisji. Datagramy może fragmentacji przez hosta lub przez router pośrednie. Jeśli datagram musi być pofragmentowane i <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram zostaną odrzucone i komunikat o błędzie komunikat protokołu sterowania Internetem (ICMP) są wysyłane do nadawcy datagram.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tej właściwości można ustawić tylko dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> flagi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DropMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pozostawia grupę multiemisji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.DropMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> Grupy multiemisji, aby pozostawić.</param>
        <summary>Pozostawia grupę multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Wycofuje metody <xref:System.Net.Sockets.UdpClient> z grupy multiemisji identyfikowana na podstawie określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Metoda podstawowa <xref:System.Net.Sockets.Socket> wysyła pakiet grupy zarządzania IGMP (Internet Protocol) do routera, usuwanie router z grupy multiemisji. Po <xref:System.Net.Sockets.UdpClient> wycofuje z grupy, go nie będzie już otrzymywać datagramów wysyłanych do tej grupy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak można usunąć grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr, int32 ifindex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress, ifindex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr, int ifindex);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.DropMulticastGroup (multicastAddr, ifindex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="ifindex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> Grupy multiemisji, aby pozostawić.</param>
        <param name="ifindex">Lokalny adres grupy multiemisji, aby wyjść.</param>
        <summary>Pozostawia grupę multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Wycofuje metody <xref:System.Net.Sockets.UdpClient> z grupy multiemisji identyfikowana na podstawie określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Metoda podstawowa <xref:System.Net.Sockets.Socket> wysyła pakiet grupy zarządzania IGMP (Internet Protocol) do routera, usuwanie router z grupy multiemisji. Po <xref:System.Net.Sockets.UdpClient> wycofuje z grupy, go nie będzie już otrzymywać datagramów wysyłanych do tej grupy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwość, aby otrzymać kod błędu. Po uzyskaniu ten kod, mogą odwoływać się do usługi Windows Sockets w wersji 2 interfejsu API błąd kodu dokumentacji w witrynie MSDN szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można usunąć grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.UdpClient" /> może wysłać lub odbierania pakietów emisji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia pakietów emisji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emisja jest ograniczona do określonej podsieci. Można emisji do podsieci lokalnej, wysyłając pakiet do 255.255.255.255; lub skorzystać z adres ukierunkowanej emisji, co jest częścią sieci adresu Internet Protocol (IP) z wszystkie bity w części dotyczącej hosta. Na przykład jeśli adres IP jest 192.168.1.40 (klasy C adresu z części sieci jako pierwsze trzy oktety i część hosta jest ostatni oktet), adres ukierunkowanej emisji jest 192.168.1.255.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.UdpClient.EnableBroadcast%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] EndReceive(class System.IAsyncResult asyncResult, class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ EndReceive(IAsyncResult ^ asyncResult, System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; byte[]" Usage="udpClient.EndReceive (asyncResult, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiektu zwróconego przez wywołanie do <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />.</param>
        <param name="remoteEP">Określony zdalny punkt końcowy.</param>
        <summary>Kończy się oczekujących asynchronicznych odbierania.</summary>
        <returns>W przypadku powodzenia zawierającego datagram dane tablicy bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ukończ ten uniemożliwia metody do czasu tej operacji.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.UdpClient.Receive%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> przeprowadzenie asynchronicznego odbioru odpowiedź serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" /> wcześniej została wywołana dla odczyt asynchroniczny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostępu do podstawowych <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="udpClient.EndSend asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiektu zwróconego przez wywołanie do <see cref="Overload:System.Net.Sockets.UdpClient.BeginSend" />.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
        <returns>Jeśli się powodzeniem, liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.UdpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ukończ ten uniemożliwia metody do czasu tej operacji.  
  
 Aby wykonać tę operację synchronicznie, użyj <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> przeprowadzenie asynchronicznego wysyłania żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie został zwrócony przez wywołanie do <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wcześniej została wywołana dla odczyt asynchroniczny.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostępu podstawowej gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia korzystanie z portu tylko jednego klienta.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia tylko jednego klienta do używania konkretnego portu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" /> dla systemu Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 lub nowszej, a <see langword="false" /> dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wielu klientów można użyć określonego portu; jednak tylko jeden klienci mogą wykonywać operacje na ruch sieciowy wysyłane do portu. Można użyć <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości, aby zapobiec wielu klientów przy użyciu określonego portu.  
  
 Tej właściwości należy ustawić przed podstawowej gniazda jest powiązany z portem klienta. Jeśli należy wywołać <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, port klienta jest powiązany jako efekt uboczny konstruktora, a następnie nie można ustawić <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.UdpClient>, pobiera i ustawia <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostępu podstawowej gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!UdpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="udpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="JoinMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Multiemisji <see cref="T:System.Net.IPAddress" /> chcesz dołączyć do grupy.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Subskrybuje metody <xref:System.Net.Sockets.UdpClient> do grupy multiemisji przy użyciu określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Metoda podstawowa <xref:System.Net.Sockets.Socket> wysyła pakiet grupy zarządzania IGMP (Internet Protocol) do routera żądającego członkostwa w grupie multiemisji. Zakres adresów multiemisji został od 224.0.0.0 do 239.255.255.255. Określ adres znajdujący się poza tym zakresem lub routera, który żądań nie jest multiemisji włączony, <xref:System.Net.Sockets.UdpClient> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu. Raz <xref:System.Net.Sockets.UdpClient> jest wymieniony jako członek grupy multiemisji z routera, będą mogli otrzymywać kierowany datagramy wysyłane do określonego <xref:System.Net.IPAddress>.  
  
> [!NOTE]
>  Należy utworzyć <xref:System.Net.Sockets.UdpClient> przy użyciu numeru portu multiemisji; w przeciwnym razie nie będzie mogła odbierać kierowany datagramy. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody, lub <xref:System.Net.Sockets.UdpClient.Receive%2A> metoda nie będzie działać. Nie trzeba należeć do grupy multiemisji do przesyłania datagramów na adres IP multiemisji.  
  
 Przed przyłączeniem grupy multiemisji, upewnij się, że gniazda jest powiązany z portem lub punktu końcowego. Można to zrobić przez wywoływanie jednej z konstruktorów akceptujących portu lub punktu końcowego jako parametr.  
  
 Aby zrezygnować z otrzymywania datagramy multicasted, należy wywołać <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> — metoda i podaj <xref:System.Net.IPAddress> grupy, z którego chcesz wycofać.  
  
> [!NOTE]
>  W przypadku protokołu IPv6 istnieje kilka zakresów adresów multiemisji, możesz wybrać z. Zapoznaj się 2375 RFC organizacji IETF.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> wykonane bez określonych portów lokalnych (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> konstruktora).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sprzęgać grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#1)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(int32 ifindex, class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (ifindex As Integer, multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(int ifindex, System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : int * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (ifindex, multicastAddr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifindex" Type="System.Int32" />
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="ifindex">Indeks skojarzony z lokalny adres IP, na których chcesz dołączyć do grupy multiemisji.</param>
        <param name="multicastAddr">Multiemisji <see cref="T:System.Net.IPAddress" /> chcesz dołączyć do grupy.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed przyłączeniem grupy multiemisji, upewnij się, że gniazda jest powiązany z portem lub punktu końcowego. Można to zrobić, wywołując jedną z konstruktorów, które akceptuje portu lub punktu końcowego jako parametr.  
  
 `infindex` Parametr jest używany do identyfikowania interfejs sprzętu tego samego łącza.  
  
> [!NOTE]
>  Istnieje kilka zakresów adresów multiemisji do wyboru. Zapoznaj się RFC organizacji IETF 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> wykonane bez określonych portów lokalnych (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=nameWithType> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> konstruktora).  
  
   
  
## Examples  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#5)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, int32 timeToLive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, timeToLive As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, int timeToLive);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, timeToLive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="timeToLive" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> Grupy multiemisji do przyłączenia.</param>
        <param name="timeToLive">Czas wygaśnięcia (TTL), mierzony w przeskoków.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji o określony czas wygaśnięcia (TTL).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Subskrybuje metody <xref:System.Net.Sockets.UdpClient> do grupy multiemisji przy użyciu określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Metoda podstawowa <xref:System.Net.Sockets.Socket> wysyła pakiet grupy zarządzania IGMP (Internet Protocol) do routera żądającego członkostwa w grupie multiemisji. Zakres adresów multiemisji został od 224.0.0.0 do 239.255.255.255. Określ adres znajdujący się poza tym zakresem lub routera, który żądań nie jest multiemisji włączony, <xref:System.Net.Sockets.UdpClient> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu. `timeToLive` Parametr określa liczbę przeskoków między routerami mogą być dla datagramu, zanim zostanie usunięty. Raz <xref:System.Net.Sockets.UdpClient> jest wymieniony jako członek grupy multiemisji z routera, będą mogli otrzymywać kierowany datagramy wysyłane do określonego <xref:System.Net.IPAddress>.  
  
> [!NOTE]
>  Należy utworzyć <xref:System.Net.Sockets.UdpClient> przy użyciu numeru portu multiemisji w przeciwnym razie nie będzie mogła odbierać kierowany datagramy. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody lub metody receive nie będą działać. Nie trzeba należeć do grupy multiemisji do przesyłania datagramów na adres IP multiemisji.  
  
 Przed przyłączeniem grupy multiemisji upewnij się, że gniazda jest powiązany z portem lub punktu końcowego. Można to zrobić przez wywoływanie jednej z konstruktorów, które akceptują parametr portu lub punktu końcowego.  
  
 Aby zrezygnować z otrzymywania datagramy multicasted, należy wywołać <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> — metoda i podaj <xref:System.Net.IPAddress> grupy, z którego chcesz wycofać.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> wykonane bez określonych portów lokalnych (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> konstruktora).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak sprzęgać grupy multiemisji, zapewniając dwa parametry, adres multiemisji i liczba, która reprezentuje czas wygaśnięcia.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podany czas wygaśnięcia nie jest od 0 do 255</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, class System.Net.IPAddress localAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, localAddress As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, System::Net::IPAddress ^ localAddress);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, localAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="localAddress" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Multiemisji <see cref="T:System.Net.IPAddress" /> chcesz dołączyć do grupy.</param>
        <param name="localAddress">Lokalna <see cref="T:System.Net.IPAddress" />.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed przyłączyć się do grupy multiemisji, należy pamiętać, że gniazda jest powiązany z portu lub punktu końcowego. Można to zrobić, wywołując jedną z konstruktorów, które akceptuje portu lub punktu końcowego jako parametr.  
  
> [!NOTE]
>  Istnieje kilka zakresów adresów multiemisji do wyboru. Można je znaleźć w 2375 RFC organizacji IETF.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> wykonane bez określonych portów lokalnych (czyli przy użyciu <xref:System.Net.Sockets.UdpClient.%23ctor> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> konstruktora).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.UdpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która określa, czy wychodzących pakietów multiemisji są dostarczane do aplikację wysyłającą.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> odbiera wychodzących pakietów multiemisji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiemisja to metoda skalowalne wiele do wielu komunikacji w Internecie. Jeśli proces subskrybuje adresu multiemisji, wszystkie pakiety wysyłane przez otrzymanie procesu przez każdy proces, które subskrybuje adres multiemisji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.UdpClient.MulticastLoopback%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.UdpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public byte[] Receive (ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Receive(class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Receive(System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Receive :  -&gt; byte[]" Usage="udpClient.Receive remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący hosta zdalnego, z którego wysłano danych.</param>
        <summary>Zwraca datagramów protokołu UDP, który został wysłany przez hosta zdalnego.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierającego datagram danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Receive%2A> Metody zablokuje dopóki datagram dociera z hosta zdalnego. Jeśli dane są dostępne, <xref:System.Net.Sockets.UdpClient.Receive%2A> — metoda odczytuje pierwszy datagram dodawanych do kolejki i zwróć części danych w postaci tablicy bajtów. Ta metoda umożliwia wypełnienie `remoteEP` parametr <xref:System.Net.IPAddress> i numer portu nadawcy.  
  
 Jeśli określisz domyślnego hosta zdalnego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metody <xref:System.Net.Sockets.UdpClient.Receive%2A> metoda będzie akceptować datagramy z tylko tego hosta. Wszystkie inne datagramy zostaną odrzucone.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli chcesz otrzymywać datagramy multicasted, nie należy wywoływać <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.UdpClient.Receive%2A> metody. <xref:System.Net.Sockets.UdpClient> Używane do odbierania datagramy musi być utworzony przy użyciu numeru portu multiemisji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Receive%2A> metody. <xref:System.Net.Sockets.UdpClient.Receive%2A> Metody blokuje wykonywania, dopóki nie odbierze komunikatu. Przy użyciu <xref:System.Net.IPEndPoint> przekazany do <xref:System.Net.Sockets.UdpClient.Receive%2A>, tożsamość odpowiadający host zostanie ujawniony.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;valuetype System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.ReceiveAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync () As Task(Of UdpReceiveResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::UdpReceiveResult&gt; ^ ReceiveAsync();" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;" Usage="udpClient.ReceiveAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca datagramów protokołu UDP, asynchronicznie przesłanym przez hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.  Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócona <xref:System.Threading.Tasks.Task%601>> obiekt ukończy po otrzymaniu pakietów UDP.  
  
 Jeśli określisz domyślnego hosta zdalnego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metody, ta metoda przyjmuje datagramy z tylko tego hosta. Wszystkie inne datagramy zostaną odrzucone.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
> [!WARNING]
>  Jeśli chcesz otrzymywać datagramy multicasted, nie należy wywoływać <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem tej metody. <xref:System.Net.Sockets.UdpClient> Używane do odbierania datagramy musi być utworzony przy użyciu numeru portu multiemisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowa <see cref="T:System.Net.Sockets.Socket" /> został zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła datagramów protokołu UDP do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int -&gt; int" Usage="udpClient.Send (dgram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> , który określa datagramów protokołu UDP, który ma zostać wysłany reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <summary>Wysyła datagramów protokołu UDP do hosta zdalnego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie datagramu z hostem zdalnym w <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i zwraca liczbę bajtów wysłanych. Jeśli nie zostanie wywołana <xref:System.Net.Sockets.UdpClient.Connect%2A> przed wywołaniem tego przeciążenia <xref:System.Net.Sockets.UdpClient.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli chcesz wysłać datagramy do innego hosta zdalnego, należy wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i określić żądaną hosta zdalnego. Użyj jednej z innych <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody do przesyłania datagramów na adres emisji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Należy ustanowić domyślnego hosta zdalnego przed użyciem tego przeciążenia.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Już przejęło domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.IPEndPoint -&gt; int" Usage="udpClient.Send (dgram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> , który określa datagramów protokołu UDP, który chcesz wysłać, reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący hosta i portu do przesyłania datagramów.</param>
        <summary>Wysyła datagramów protokołu UDP do hosta w określonym zdalny punkt końcowy.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A> Metoda datagramu do określonego punktu końcowego i zwraca liczbę bajtów wysłanych pomyślnie. Przed wywołaniem tego przeciążenia, należy najpierw utworzyć <xref:System.Net.IPEndPoint> przy użyciu adres i port numer IP hosta zdalnego, do którego będą dostarczane z datagramów. Datagramy można wysyłać do emisji domyślny adres, 255.255.255.255, określając <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> dla <xref:System.Net.IPAddress.Address%2A> właściwość <xref:System.Net.IPEndPoint>. Po utworzeniu to <xref:System.Net.IPEndPoint>, przekaż go do <xref:System.Net.Sockets.UdpClient.Send%2A> metodę jako `endPoint` parametru.  
  
 Do przesyłania datagramów na inne adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, a ustawiona opcja gniazda <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Nie podawaj `endPoint` parametru do tej metody, jeśli już zostało ustanowione zdalnego hosta z <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Send%2A> metody. W tym przykładzie użyto <xref:System.Net.IPEndPoint> określić hosta docelowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> już zostało ustanowione domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, hostname As String, port As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * string * int -&gt; int" Usage="udpClient.Send (dgram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> , który określa datagramów protokołu UDP, który ma zostać wysłany reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="hostname">Nazwa hosta zdalnego, do którego ma zostać wysłany datagram.</param>
        <param name="port">Numer portu zdalnego, z którym zamierzasz do komunikacji.</param>
        <summary>Wysyła datagramów protokołu UDP do określonego portu na określony host zdalny.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A> Metody datagramu wartości określonych przez `hostname` i `port` parametrów i zwraca liczbę bajtów pomyślnie wysłane. Możesz wysłać datagramy domyślny adres emisji, określając "255.255.255.255" dla `hostname` wartość parametru.  
  
 Do przesyłania datagramów na inne adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, a ustawiona opcja gniazda <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Podaj nazwę hosta lub nie numer_portu do tej metody, jeśli już zostało ustanowione zdalnego hosta z <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Send%2A> metody. W tym przykładzie użyto nazwy hosta i numer portu do identyfikacji hosta docelowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Już przejęło domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> , który określa datagramów protokołu UDP, który ma zostać wysłany reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie datagramu z hostem zdalnym w <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli nie zostanie wywołana <xref:System.Net.Sockets.UdpClient.Connect%2A> przed wywołaniem tego przeciążenia, metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli chcesz wysłać datagramy do innego hosta zdalnego, należy wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i określić żądaną hosta zdalnego. Użyj jednej z innych <xref:System.Net.Sockets.UdpClient.SendAsync%2A> przeciążenia metody do przesyłania datagramów na adres emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Już przejęło domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * System.Net.IPEndPoint -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> , który określa datagramów protokołu UDP, który ma zostać wysłany reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący hosta i portu do przesyłania datagramów.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda datagramu do określonego punktu końcowego. Przed wywołaniem tego przeciążenia, należy najpierw utworzyć <xref:System.Net.IPEndPoint> przy użyciu adres i port numer IP hosta zdalnego, do którego będą dostarczane z datagramów. Datagramy można wysyłać do emisji domyślny adres, 255.255.255.255, określając <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> dla <xref:System.Net.IPAddress.Address%2A> właściwość <xref:System.Net.IPEndPoint>. Po utworzeniu to <xref:System.Net.IPEndPoint>, przekaż go do tej metody jako `endPoint` parametru.  
  
 Do przesyłania datagramów na inne adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, a ustawiona opcja gniazda <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!WARNING]
>  Nie podawaj `endPoint` parametru do tej metody, jeśli już zostało ustanowione zdalnego hosta z <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, ta metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> już zostało ustanowione domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, hostname As String, port As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * string * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> , który określa datagramów protokołu UDP, który ma zostać wysłany reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="hostname">Nazwa hosta zdalnego, do którego ma zostać wysłany datagram.</param>
        <param name="port">Numer portu zdalnego, z którym zamierzasz do komunikacji.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda datagramu wartości określonych przez `hostname` i `port` parametrów. Możesz wysłać datagramy domyślny adres emisji, określając "255.255.255.255" dla `hostname` wartość parametru.  
  
 Do przesyłania datagramów na inne adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metodę, aby uzyskać podstawową <xref:System.Net.Sockets.Socket>, a ustawiona opcja gniazda <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Możesz również przywrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!WARNING]
>  Podaj nazwę hosta lub nie numer_portu do tej metody, jeśli już zostało ustanowione zdalnego hosta z <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, ta metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, można odwoływać się do dokumentacji na platformie MSDN na temat kodów błędu API usługi Windows Sockets w wersji 2, aby uzyskać szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Już przejęło domyślnego hosta zdalnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.UdpClient.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa czas wygaśnięcia (TTL) wartość pakietów protokołu internetowego (IP) wysyłane przez <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <value>Wartość TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość TTL wskazuje maksymalną liczbę routery pakietu można przechodzić między nimi przed routera odrzuca pakiet i kontroli protokołu ICMP (Internet Message) "Przekroczono TTL" nadawcy jest zwracany komunikat o błędzie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Net.Sockets.UdpClient.Ttl%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
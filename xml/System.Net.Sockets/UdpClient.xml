<Type Name="UdpClient" FullName="System.Net.Sockets.UdpClient">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5627e91be2cb0efb52fa79ce1dc1d7e11fb567e8" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52591872" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UdpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UdpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.UdpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class UdpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UdpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type UdpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia usługi sieciowe protokołu UDP (User Datagram).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> Klasy zapewnia proste metody wysyłania i odbierania przesyłanie datagramy protokołu UDP w trybie synchronicznym blokowania. Ponieważ UDP protokołu transportu bez połączenia, nie musisz ustanowić połączenia zdalnego hosta przed wysyłania i odbierania danych. Masz jednak opcja ustanowienie domyślnego hosta zdalnego w jednym z dwóch sposobów:  
  
-   Utwórz wystąpienie obiektu <xref:System.Net.Sockets.UdpClient> przy użyciu nazwy hosta zdalnego i numer portu jako parametry.  
  
-   Utwórz wystąpienie obiektu <xref:System.Net.Sockets.UdpClient> klasy, a następnie wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metody.  
  
 Możesz użyć dowolnej metody wysyłania dostarczone w <xref:System.Net.Sockets.UdpClient> wysyłać dane do urządzenia zdalnego. Użyj <xref:System.Net.Sockets.UdpClient.Receive%2A> metody na odbieranie danych z hostów zdalnych.  
  
> [!NOTE]
>  Nie wywołuj <xref:System.Net.Sockets.UdpClient.Send%2A> przy użyciu nazwy hosta lub <xref:System.Net.IPEndPoint> zdefiniowano już domyślnego hosta zdalnego. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient> spowoduje zgłoszenie wyjątku.  
  
 <xref:System.Net.Sockets.UdpClient> metody umożliwiają także wysyłać i odbierać datagramy multiemisji. Użyj <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody do subskrybowania <xref:System.Net.Sockets.UdpClient> do grupy multiemisji. Użyj <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metodę, aby anulować subskrypcję <xref:System.Net.Sockets.UdpClient> z grupy multiemisji.  
  
   
  
## Examples  
 Poniższy przykład ustanawia <xref:System.Net.Sockets.UdpClient> połączenia przy użyciu hosta nazwa www.contoso.com na porcie 11000. Komunikat w formacie ciągu małych są wysyłane do dwóch oddzielnych hosta zdalnego maszyn. <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda blokuje wykonywanie otrzymanie komunikatu. Za pomocą <xref:System.Net.IPEndPoint> przekazany do <xref:System.Net.Sockets.UdpClient.Receive%2A>, tożsamość odpowiadający host jest ujawniona.  
  
 [!code-cpp[Classic UdpClientExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClientExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClientExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClientExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClientExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Aby ustanowić połączenia wychodzącego, lub zaakceptuj żądanie przychodzące.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP I UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.UdpClient> i umożliwia podstawowego dostawcy usług można przypisać najodpowiedniejsze IPv4 adres i port numer lokalny. Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została ustawiona za pomocą rodziny adresów IPv4, którego nie można zmienić ani zastąpiona przez wywołanie metody connect za pomocą obiektu docelowego protokołu IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Ten konstruktor nie jest odpowiednia dla dołączanie do grupy multiemisji, ponieważ nie wykonuje wiązanie gniazda. Ponadto działa tylko z typów adresu IPv4.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać konstruktora domyślnego w celu utworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Numer portu lokalnego, z którego chcesz nawiązać połączenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże go numer portu lokalnego pod warunkiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy podstawowej <xref:System.Net.Sockets.Socket> i wiąże go do numeru portu, z którego chcesz nawiązać połączenia. Jeśli interesuje Cię tylko ustawienie numer portu lokalnego, należy użyć tego konstruktora. Źródłowy dostawca usługi spowoduje przypisanie lokalny adres IP. Jeśli przekażesz 0 do konstruktora podstawowego dostawcy usług przypisze numeru portu. Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została ustawiona za pomocą rodziny adresów IPv4, którego nie można zmienić ani zastąpiona przez wywołanie metody connect za pomocą obiektu docelowego protokołu IPv6.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Ten konstruktor działa tylko w przypadku typów adresu IPv4.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano tworzenie wystąpienia przy użyciu numeru portu lokalnego <xref:System.Net.Sockets.UdpClient> klasy.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> Parametru jest większa niż <see cref="F:System.Net.IPEndPoint.MaxPort" /> lub mniej niż <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> Tego respresents lokalny punkt końcowy, do którego można powiązać połączenia protokołu UDP.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże go z określonego lokalny punkt końcowy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Net.Sockets.UdpClient> i wiąże go do <xref:System.Net.IPEndPoint> określony przez `localEP` parametru. Przed wywołaniem tego konstruktora musi utworzyć <xref:System.Net.IPEndPoint> przy użyciu adresu IP adres i numer portu z którego chcesz wysyłać i odbierać dane. Nie trzeba określić lokalny adres IP i port numer do wysyłania i odbierania danych. Jeśli tego nie zrobisz, podstawowego dostawcy usług przypisze najbardziej odpowiedniego adresu IP adres i port numer lokalny.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została ustawiona za pomocą rodziny adresów, określony przez `localEP` parametr, który nie można zmienić ani zastąpiona przez wywołanie metody connect z rodziną inny adres.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy przy użyciu lokalnego punktu końcowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Jedną z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości, które określa schemat adresowania gniazda.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `family` Parametr określa, czy odbiornik używa adresu IP w wersji 4 (IPv4) lub adresu IP w wersji 6 (IPv6) adres. Aby używać adresu IPv4, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetwork> wartość. Aby użyć adresu IPv6, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> wartość. Przekazywanie innych wartości spowoduje, że metoda zgłosić <xref:System.ArgumentException>.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została ustawiona za pomocą rodziny adresów, określony przez `family` parametr, który nie można zmienić ani zastąpiona przez wywołanie metody connect z rodziną inny adres.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> Nie nadaje się na dołączenie do grupy multiemisji, ponieważ nie wykonuje wiązanie gniazda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> nie jest <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port, System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port, valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer, family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port, System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int * System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (port, family)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="port">Port do nasłuchiwania dla przychodzących próby nawiązania połączenia.</param>
        <param name="family">Jedną z <see cref="T:System.Net.Sockets.AddressFamily" /> wartości, które określa schemat adresowania gniazda.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i wiąże go numer portu lokalnego pod warunkiem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy podstawowej <xref:System.Net.Sockets.Socket> i wiąże go do numeru portu, z którego chcesz nawiązać połączenia.  
  
 `family` Parametr określa, czy odbiornik używa adresu IP w wersji 4 (IPv4) lub adresu IP w wersji 6 (IPv6) adres. Aby używać adresu IPv4, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetwork> wartość. Aby użyć adresu IPv6, należy przekazać <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> wartość. Przekazywanie innych wartości spowoduje, że metoda zgłosić <xref:System.ArgumentException>.  
  
 Jeśli ten konstruktor jest używany, <xref:System.Net.Sockets.UdpClient> wystąpienia została ustawiona za pomocą rodziny adresów, określony przez `family` parametr, który nie można zmienić ani zastąpiona przez wywołanie metody connect z rodziną inny adres.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu można znaleźć [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak można utworzyć klienta UDP służące do grupy multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#3)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="family" /> nie jest <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> jest większa niż <see cref="F:System.Net.IPEndPoint.MaxPort" /> lub mniej niż <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : string * int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa hosta DNS zdalnego, do której chcesz połączyć.</param>
        <param name="port">Numer portu zdalnego, w którym ma się połączyć.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Sockets.UdpClient" /> klasy i ustanawia domyślnego hosta zdalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor inicjuje nową <xref:System.Net.Sockets.UdpClient> i ustanawia z hostem zdalnym za pomocą `hostname` i `port` parametrów. Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Jeśli używasz tego konstruktora, nie należy określić hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. W dowolnym momencie można zmienić domyślnego hosta zdalnego, wywołując <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli chcesz określić hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody, nie używaj tego konstruktora.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób tworzenia wystąpienia <xref:System.Net.Sockets.UdpClient> klasy przy użyciu nazwy hosta i numer portu.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hostname" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.UdpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy została ustanowiona domyślnego hosta zdalnego.</summary>
        <value>
          <see langword="true" /> Jeśli połączenie jest aktywne; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy wywodzące się z <xref:System.Net.Sockets.UdpClient> można użyć tej właściwości, aby określić, jeśli została ustanowiona domyślnego hosta zdalnego. Można utworzyć domyślnego hosta zdalnego za pomocą odpowiedniego konstruktora lub przez wywołanie metody <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli ustanowisz domyślnego hosta zdalnego hosta zdalnego nie można określić w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.UdpClient" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="udpClient.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Wartość logiczna określająca, czy włączyć lub wyłączyć Przechodzenie translatora adresów Sieciowych.</param>
        <summary>Włącza lub wyłącza translacji adresów sieciowych (NAT) przechodzenie na <see cref="T:System.Net.Sockets.UdpClient" /> wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.AllowNatTraversal%2A> Metoda jest używana do włączania lub wyłączania Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.UdpClient> wystąpienia. Przechodzenie translatora adresów Sieciowych, mogą być udostępniane przy użyciu protokołu Teredo, 6to4 lub tunel protokołu ISATAP.  
  
 Gdy `allowed` parametr ma wartość FAŁSZ, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> ustawiono opcję w gnieździe skojarzone <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Jawnie wyłącza Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.UdpClient> wystąpienia.  
  
 Gdy `allowed` parametr ma wartość true, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> ustawiono opcję w gnieździe skojarzone <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Może to umożliwić Przechodzenie translatora adresów Sieciowych dla <xref:System.Net.Sockets.UdpClient> w zależności od reguły zapory w miejscu w systemie.  
  
 Adres Teredo nie jest adresem IPv6 z prefiksem 2001:: / 32. Adresy protokołu Teredo można zwrócone za pośrednictwem normalne rozpoznawanie nazw DNS lub wyliczenia jako adres IPv6 przypisany do interfejsu lokalnego.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.UdpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ilość danych odebranych z sieci, który jest dostępny do odczytu.</summary>
        <value>Liczba bajtów danych odebranych z sieci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Available%2A> Właściwość jest używana do określenia ilości danych w kolejce w buforze sieci do odczytu. Jeśli dane są dostępne, należy wywołać <xref:System.Net.Sockets.NetworkStream.Read%2A> można pobrać danych. Jeśli dane są niedostępne, <xref:System.Net.Sockets.UdpClient.Available%2A> właściwość zwraca wartość 0.  
  
 Jeśli host zdalny zamyka lub zamyka połączenia, <xref:System.Net.Sockets.UdpClient.Available%2A> zgłasza właściwości <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu i odwoływać się do dokumentacji kodów błędów systemu Windows Sockets w wersji 2 interfejsu API w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library)/ szczegółowy opis działania Wystąpił błąd.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.Available%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostęp do gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> Zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginReceive (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji odbierania. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Asynchronicznie odbiera datagram z hosta zdalnego.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do asynchronicznego odbioru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.UdpClient.EndReceive%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, należy użyć <xref:System.Net.Sockets.UdpClient.Receive%2A> metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> asynchronicznie czekać na odpowiedź serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła asynchronicznie datagram do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">A <see cref="T:System.Byte" /> tablicy, która zawiera dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji wysyłania. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Wysyła asynchronicznie datagram do hosta zdalnego. Miejsce docelowe określono wcześniej przez wywołanie <see cref="Overload:System.Net.Sockets.UdpClient.Connect" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginSend%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.UdpClient.EndSend%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> asynchronicznie wysłanie żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * System.Net.IPEndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, endPoint, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">A <see cref="T:System.Byte" /> tablicy, która zawiera dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="endPoint">
          <see cref="T:System.Net.EndPoint" /> Reprezentujący obiekt docelowy danych.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji wysyłania. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Wysyła asynchronicznie datagram do miejsca docelowego. Miejsce docelowe jest określona przez <see cref="T:System.Net.EndPoint" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginSend%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.UdpClient.EndSend%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> asynchronicznie wysłanie żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, string hostname, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, hostname As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, hostname, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="datagram">A <see cref="T:System.Byte" /> tablicy, która zawiera dane do wysłania.</param>
        <param name="bytes">Liczba bajtów do wysłania.</param>
        <param name="hostname">Host docelowy.</param>
        <param name="port">Numer portu docelowego.</param>
        <param name="requestCallback">
          <see cref="T:System.AsyncCallback" /> Delegata, który odwołuje się do metody do wywołania po ukończeniu operacji.</param>
        <param name="state">Obiekt zdefiniowany przez użytkownika, który zawiera informacje na temat operacji wysyłania. Ten obiekt jest przekazywany do <paramref name="requestCallback" /> po zakończeniu operacji.</param>
        <summary>Wysyła asynchronicznie datagram do miejsca docelowego. Miejsce docelowe jest określony przez nazwę hosta i numer portu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Obiektu, który odwołuje się do asynchronicznego wysyłania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczną <xref:System.Net.Sockets.UdpClient.BeginSend%2A> można ukończyć operacji, przez wywołanie metody <xref:System.Net.Sockets.UdpClient.EndSend%2A> metody. Zazwyczaj metoda jest wywoływana przez `requestCallback` delegować.  
  
 Ta metoda nie blokuje, aż do zakończenia operacji. Aby zablokować, aż do zakończenia operacji, użyj jednej z <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody.  
  
 Aby uzyskać szczegółowe informacje dotyczące korzystania z modelu programowania asynchronicznego, zobacz [wywołanie asynchroniczne synchroniczne metody](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> asynchronicznie wysłanie żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.UdpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odnośnej sieci <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Odnośnej sieci <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> Tworzy <xref:System.Net.Sockets.Socket> używany do wysyłania i odbierania danych przez sieć. Klasy wywodzące się z <xref:System.Net.Sockets.UdpClient> ta właściwość służy do pobierania lub ustawiania to <xref:System.Net.Sockets.Socket>. Używają bazowej <xref:System.Net.Sockets.Socket> zwróciło <xref:System.Net.Sockets.UdpClient.Client%2A> w razie potrzeby dostęp poza tymi, które <xref:System.Net.Sockets.UdpClient> udostępnia. Można również użyć <xref:System.Net.Sockets.UdpClient.Client%2A> można ustawić podstawowe <xref:System.Net.Sockets.Socket> do istniejącego <xref:System.Net.Sockets.Socket>. Jest to przydatne, jeśli chcesz móc korzystać z prostoty <xref:System.Net.Sockets.UdpClient> przy użyciu istniejących wcześniej <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Net.Sockets.UdpClient.Client%2A> właściwości. W tym przykładzie emisji jest włączona dla podstawowych <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="udpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka połączenie protokołu UDP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Close%2A> Wyłącza bazowego <xref:System.Net.Sockets.Socket> i zwalnia wszystkie zasoby zarządzane i niezarządzane skojarzone z <xref:System.Net.Sockets.UdpClient>.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zamknięcia <xref:System.Net.Sockets.UdpClient> przez wywołanie metody <xref:System.Net.Sockets.UdpClient.Close%2A> metody.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustanawia domyślnego hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (endPoint As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="udpClient.Connect endPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> , Który określa punkt końcowy sieci, do którego ma zostać wysłany danych.</param>
        <summary>Ustanawia domyślnego hosta zdalnego przy użyciu punktu końcowego określonej sieci.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A> Metoda ustanawia domyślnego hosta zdalnego przy użyciu wartości określonej w `endPoint` parametru. Gdy nawiązane, nie należy określić hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Jeśli chcesz do przesyłania datagramów na inny host zdalny, należy innym wywołaniu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inny <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego. Jeśli ustalonymi domyślnego elementu zdalnego hosta, a także podać hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody <xref:System.Net.Sockets.UdpClient.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metody, datagramów i odbierane z adresu innego niż określoną wartość domyślną, zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, o ile nie dziedziczą z <xref:System.Net.Sockets.UdpClient>, użyj metody klienta do uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Możesz jednak znajduje się w emisji dane do domyślnego emisji adres 255.255.255.255, jeśli określisz <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większą kontrolę nad adresy emisji, można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest przesyłanie, <xref:System.Net.Sockets.UdpClient.Connect%2A> metody nie są blokowane. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody, jeśli chcesz otrzymywać multicasted datagramów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Net.IPEndPoint> ustanowienie domyślnego hosta zdalnego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="endPoint" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress addr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress addr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ addr, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.Connect (addr, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addr">
          <see cref="T:System.Net.IPAddress" /> Zdalnego hosta, do którego ma zostać wysłany danych.</param>
        <param name="port">Numer portu, do którego ma wysyłać dane.</param>
        <summary>Ustanawia domyślnego hosta zdalnego przy użyciu określonego adresu IP adres i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A> Metoda ustanawia domyślnego hosta zdalnego przy użyciu wartości określonej w `addr` i `port` parametrów. Gdy nawiązane, nie należy określić hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Jeśli chcesz do przesyłania datagramów na inny host zdalny, należy innym wywołaniu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inny <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego. Jeśli ustalonymi domyślnego elementu zdalnego hosta, a także podać hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody <xref:System.Net.Sockets.UdpClient.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metody, datagramów i odbierane z adresu innego niż określoną wartość domyślną, zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, o ile nie dziedziczą z <xref:System.Net.Sockets.UdpClient>, użyj metody klienta do uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Możesz jednak znajduje się w emisji dane do domyślnego emisji adres 255.255.255.255, jeśli określisz <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większą kontrolę nad adresy emisji, można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest przesyłanie, <xref:System.Net.Sockets.UdpClient.Connect%2A> metody nie są blokowane. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody, jeśli chcesz otrzymywać multicasted datagramów.  
  
   
  
## Examples  
 W poniższym przykładzie użyto IP adres i numer portu do połączenia z hostem zdalnym.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> wystąpienie jest zamykane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addr" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="udpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nazwa DNS hosta zdalnego, z którym zamierzasz wysłać dane.</param>
        <param name="port">Numer portu na hoście zdalnym, do którego ma zostać wysłany danych.</param>
        <summary>Ustanawia domyślnego hosta zdalnego, korzystając z określonego hosta, nazwę i numer portu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Connect%2A> Metoda ustanawia domyślnego hosta zdalnego przy użyciu wartości określonej w `port` i `hostname` parametrów. Gdy nawiązane, nie należy określić hosta zdalnego w każdym wywołaniu <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
 Ustanowienie domyślnego hosta zdalnego jest opcjonalne. Określenie domyślnego hosta zdalnego ogranicza użytkownika tylko do tego hosta. Jeśli chcesz do przesyłania datagramów na inny host zdalny, należy innym wywołaniu <xref:System.Net.Sockets.UdpClient.Connect%2A> metody lub utworzyć inny <xref:System.Net.Sockets.UdpClient> bez domyślnego hosta zdalnego.  
  
 Jeśli ustalonymi domyślnego elementu zdalnego hosta, a także podać hosta zdalnego w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody <xref:System.Net.Sockets.UdpClient.Send%2A> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli wywołasz <xref:System.Net.Sockets.Socket.Connect%2A> metody, datagramów i odbierane z adresu innego niż określoną wartość domyślną, zostaną odrzucone. Nie można ustawić domyślnego hosta zdalnego na adres emisji przy użyciu tej metody, o ile nie dziedziczą z <xref:System.Net.Sockets.UdpClient>, użyj metody klienta do uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.  
  
 Możesz jednak znajduje się w emisji dane do domyślnego emisji adres 255.255.255.255, jeśli określisz <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> w wywołania do <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Jeśli aplikacja wymaga większą kontrolę nad adresy emisji, można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Ponieważ protokół UDP jest przesyłanie, <xref:System.Net.Sockets.UdpClient.Connect%2A> metody nie są blokowane. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metody, jeśli chcesz otrzymywać multicasted datagramów.  
  
   
  
## Examples  
 Następujące przykład zastosowania nazwy hosta i numer portu do połączenia z hostem zdalnym.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> nie przypada między <see cref="F:System.Net.IPEndPoint.MinPort" /> i <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="udpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby zarządzane i niezarządzane używane przez <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="udpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Net.Sockets.UdpClient" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną `Dispose()` metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Net.Sockets.UdpClient> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" /> Uważaj, aby nie odwołują się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose(Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.UdpClient.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia datagramów protokołu internetowego (IP) do fragmentacji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia fragmentacji datagram; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramy wymaga fragmentacji, gdy ich rozmiar przekracza maksymalny transferu jednostki (MTU) nośnika transmisji. Datagramy może fragmentacji przez hosta wysyłającego lub router pośrednich. Jeśli datagram musi fragmentacji i <xref:System.Net.Sockets.Socket.DontFragment%2A> opcja jest ustawiona, datagram jest odrzucana i komunikat o błędzie kontroli komunikat ICMP (Internet Protocol) są wysyłane do nadawcy datagram.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.Socket.DontFragment%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tę właściwość można ustawić tylko dla gniazda, które używają <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> flagi lub <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> flagi.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DropMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pozostawia grupę multiemisji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.DropMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> Grupy multiemisji, aby wyjść.</param>
        <summary>Pozostawia grupę multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Wycofa metoda <xref:System.Net.Sockets.UdpClient> z grupy multiemisji identyfikowane za pomocą określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metodzie bazowej <xref:System.Net.Sockets.Socket> wysyła pakiet zarządzania protokołu IGMP (Internet Group) z routerem, usuwając router z grupy multiemisji. Po <xref:System.Net.Sockets.UdpClient> wycofuje się z grupy, nie jest już będzie mogła odbierać datagramów wysyłanych do tej grupy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można usunąć grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr, int32 ifindex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress, ifindex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr, int ifindex);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.DropMulticastGroup (multicastAddr, ifindex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="ifindex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> Grupy multiemisji, aby wyjść.</param>
        <param name="ifindex">Lokalny adres grupy multiemisji, aby wyjść.</param>
        <summary>Pozostawia grupę multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> Wycofa metoda <xref:System.Net.Sockets.UdpClient> z grupy multiemisji identyfikowane za pomocą określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metodzie bazowej <xref:System.Net.Sockets.Socket> wysyła pakiet zarządzania protokołu IGMP (Internet Group) z routerem, usuwając router z grupy multiemisji. Po <xref:System.Net.Sockets.UdpClient> wycofuje się z grupy, nie jest już będzie mogła odbierać datagramów wysyłanych do tej grupy.  
  
> [!NOTE]
>  Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> właściwości, aby uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można usunąć grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.UdpClient" /> może wysyłania lub odbierania pakietów emisji.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia pakietów emisji; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emisja jest ograniczona do określonej podsieci. Emisja na do podsieci lokalnej, wysyłając pakiet do 255.255.255.255; Ewentualnie można użyć adres ukierunkowanej emisji, czyli części sieci adres protokołu internetowego (IP) z wszystkie bity w części hosta. Na przykład jeśli adres IP jest 192.168.1.40 (adresu klasy C z części sieciowej jako pierwsze trzy oktety i część hosta jest ostatni oktet), adres ukierunkowanej emisji jest 192.168.1.255.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.EnableBroadcast%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] EndReceive(class System.IAsyncResult asyncResult, class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ EndReceive(IAsyncResult ^ asyncResult, System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; byte[]" Usage="udpClient.EndReceive (asyncResult, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiektu zwróconego przez wywołanie <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />.</param>
        <param name="remoteEP">Określonego zdalnego punktu końcowego.</param>
        <summary>Kończy się oczekiwanie asynchroniczne odbierania.</summary>
        <returns>Jeśli to się powiedzie, tablicę bajtów, która zawiera dane datagram.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonaj to bloki metody do czasu tej operacji.  
  
 Aby wykonać tę operację synchronicznie, należy użyć <xref:System.Net.Sockets.UdpClient.Receive%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do ukończenia asynchronicznego odbioru odpowiedź z serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" /> był wcześniej nazywany programem do asynchronicznego odczytu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby dostępu do podstawowych <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="udpClient.EndSend asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> Obiektu zwróconego przez wywołanie <see cref="Overload:System.Net.Sockets.UdpClient.BeginSend" />.</param>
        <summary>Kończy się oczekujące asynchronicznego wysyłania.</summary>
        <returns>Jeśli operacja się powiedzie, liczba bajtów wysłanych do <see cref="T:System.Net.Sockets.UdpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonaj to bloki metody do czasu tej operacji.  
  
 Aby wykonać tę operację synchronicznie, należy użyć <xref:System.Net.Sockets.UdpClient.Send%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Net.Sockets.UdpClient.BeginSend%2A> do ukończenia asynchronicznego wysyłania żądania serwera.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> nie została zwrócona przez wywołanie <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> metody.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> był wcześniej nazywany programem do asynchronicznego odczytu.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu bazowego gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość określająca, czy <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia korzystanie z portu tylko jednego klienta.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> umożliwia tylko jednego klienta do używania konkretnego portu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" /> dla systemu Windows Server 2003 i Windows XP z dodatkiem Service Pack 2 lub nowszą wersją, a <see langword="false" /> dla wszystkich innych wersji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie wielu klientów można użyć określonego portu; jednak tylko jeden z klientów mogą wykonywać operacje na ruch sieciowy, wysyłane do portu. Możesz użyć <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości, aby uniemożliwić wielu klientów korzysta z określonego portu.  
  
 Przed podstawowej gniazda jest powiązany z portem klienta, należy ustawić tę właściwość. Jeśli wywołasz <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>, lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, port klienta jest powiązany jako efekt uboczny konstruktora, a następnie nie można ustawić <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Net.Sockets.UdpClient>i pobiera i ustawia <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas próby uzyskania dostępu bazowego gniazda.</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!UdpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="udpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="JoinMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Multiemisji <see cref="T:System.Net.IPAddress" /> grupy, którą chcesz przyłączyć.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Metoda subskrybuje <xref:System.Net.Sockets.UdpClient> do grupy multiemisji przy użyciu określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metodzie bazowej <xref:System.Net.Sockets.Socket> wysyła pakiet zarządzania protokołu IGMP (Internet Group) do routera żądającego członkostwa grupy multiemisji. Zakres adresów multiemisji został od 224.0.0.0 do 239.255.255.255. Jeśli określisz adres poza tym zakresem lub jeśli routera, do której żądania nie jest multiemisji włączone, <xref:System.Net.Sockets.UdpClient> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu. Gdy <xref:System.Net.Sockets.UdpClient> znajduje się na liście z routerem, który jest członkiem grupy multiemisji, będą mogli otrzymywać kierowany datagramy wysyłane do określonego <xref:System.Net.IPAddress>.  
  
> [!NOTE]
>  Należy utworzyć <xref:System.Net.Sockets.UdpClient> za pomocą numeru portu multiemisji; w przeciwnym razie nie będzie mogła odbierać datagramy kierowany. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody lub <xref:System.Net.Sockets.UdpClient.Receive%2A> metoda nie będzie działać. Nie trzeba należeć do grupy multiemisji do przesyłania datagramów na adres IP multiemisji.  
  
 Przed dołączeniem do grupy multiemisji, upewnij się, że gniazdo jest powiązany z portem lub punktu końcowego. Można to zrobić, wywołując jedną z konstruktorów, które akceptuje portu lub punkt końcowy jako parametr.  
  
 Aby zrezygnować z otrzymywania datagramy multicasted, należy wywołać <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metody i podaj <xref:System.Net.IPAddress> grupy, z którego chcesz wycofać.  
  
> [!NOTE]
>  W przypadku protokołu IPv6 istnieje kilka zakresów adresów multiemisji, których mogą wybierać. Zapoznaj się IETF RFC 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> skonstruowany bez określonych portów lokalnych (czyli używania <xref:System.Net.Sockets.UdpClient.%23ctor> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> konstruktora).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób dołączenia do grupy multiemisji, podając adres multiemisji.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#1)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(int32 ifindex, class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (ifindex As Integer, multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(int ifindex, System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : int * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (ifindex, multicastAddr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifindex" Type="System.Int32" />
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="ifindex">Indeks interfejsu skojarzony z lokalny adres IP, na którym należy dołączyć do grupy multiemisji.</param>
        <param name="multicastAddr">Multiemisji <see cref="T:System.Net.IPAddress" /> grupy, którą chcesz przyłączyć.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed dołączeniem do grupy multiemisji, upewnij się, że gniazdo jest powiązany z portem lub punktu końcowego. Można to zrobić, wywołując jedną z konstruktorów, które akceptuje portu lub punkt końcowy jako parametr.  
  
 `infindex` Parametr jest używany do identyfikowania interfejsu sprzętu, tego samego łącza.  
  
> [!NOTE]
>  Istnieje kilka zakresów adresów multiemisji do wyboru. Zapoznaj się z IETF RFC 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> skonstruowany bez określonych portów lokalnych (czyli używania <xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=nameWithType> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> konstruktora).  
  
   
  
## Examples  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#5)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, int32 timeToLive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, timeToLive As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, int timeToLive);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, timeToLive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="timeToLive" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">
          <see cref="T:System.Net.IPAddress" /> Grupy multiemisji do przyłączenia.</param>
        <param name="timeToLive">Czas wygaśnięcia (TTL), mierzone w przeskoków między routerami.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji z określonym czasem wygaśnięcia (TTL).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> Metoda subskrybuje <xref:System.Net.Sockets.UdpClient> do grupy multiemisji przy użyciu określonego <xref:System.Net.IPAddress>. Po wywołaniu <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metodzie bazowej <xref:System.Net.Sockets.Socket> wysyła pakiet zarządzania protokołu IGMP (Internet Group) do routera żądającego członkostwa grupy multiemisji. Zakres adresów multiemisji został od 224.0.0.0 do 239.255.255.255. Jeśli określisz adres poza tym zakresem lub jeśli routera, do której żądania nie jest multiemisji włączone, <xref:System.Net.Sockets.UdpClient> zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu. `timeToLive` Parametr określa liczbę przeskoków między routerami może być dla datagramu, zanim zostanie usunięty. Gdy <xref:System.Net.Sockets.UdpClient> znajduje się na liście z routerem, który jest członkiem grupy multiemisji, będą mogli otrzymywać kierowany datagramy wysyłane do określonego <xref:System.Net.IPAddress>.  
  
> [!NOTE]
>  Należy utworzyć <xref:System.Net.Sockets.UdpClient> za pomocą numeru portu multiemisji w przeciwnym razie nie będzie mogła odbierać datagramy kierowany. Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metodę lub metodę odbioru nie będzie działać. Nie trzeba należeć do grupy multiemisji do przesyłania datagramów na adres IP multiemisji.  
  
 Przed dołączeniem do grupy multiemisji upewnij się, że gniazdo jest powiązany z portem lub punktu końcowego. Można to zrobić, wywołując jedną konstruktory, które akceptują parametr, portu lub punktu końcowego.  
  
 Aby zrezygnować z otrzymywania datagramy multicasted, należy wywołać <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A> metody i podaj <xref:System.Net.IPAddress> grupy, z którego chcesz wycofać.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> skonstruowany bez określonych portów lokalnych (czyli używania <xref:System.Net.Sockets.UdpClient.%23ctor> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> konstruktora).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dołączenia do grupy multiemisji, zapewniając dwóch parametrów adresu multiemisji i numer, który reprezentuje czas wygaśnięcia.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podany czas wygaśnięcia nie jest pomiędzy 0 a 255</exception>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="multicastAddr" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Adres IP nie jest zgodny z <see cref="T:System.Net.Sockets.AddressFamily" /> wartość, która definiuje schemat adresowania gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, class System.Net.IPAddress localAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, localAddress As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, System::Net::IPAddress ^ localAddress);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, localAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="localAddress" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Multiemisji <see cref="T:System.Net.IPAddress" /> grupy, którą chcesz przyłączyć.</param>
        <param name="localAddress">Lokalny <see cref="T:System.Net.IPAddress" />.</param>
        <summary>Dodaje <see cref="T:System.Net.Sockets.UdpClient" /> do grupy multiemisji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed można dołączyć do grupy multiemisji, należy pamiętać, że gniazdo jest powiązany z portu lub punktu końcowego. Można to zrobić, wywołując jedną z konstruktorów, które akceptuje portu lub punkt końcowy jako parametr.  
  
> [!NOTE]
>  Istnieje kilka zakresów adresów multiemisji do wyboru. Można je znaleźć w IETF RFC 2375.  
  
> [!NOTE]
>  Nie można wywołać <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> na <xref:System.Net.Sockets.UdpClient> skonstruowany bez określonych portów lokalnych (czyli używania <xref:System.Net.Sockets.UdpClient.%23ctor> lub <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> konstruktora).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> metody.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.UdpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Boolean" /> wartość, która określa, czy wychodzących pakietów multiemisji są dostarczane do aplikacji wysyłającej.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Net.Sockets.UdpClient" /> odbiera wychodzących pakietów multiemisji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiemisja to metoda skalowalne komunikacji wiele do wielu w Internecie. Jeśli proces subskrybuje adresu multiemisji, wszystkie pakiety wysyłane przez jaką proces są odbierane przez każdy proces, który ma adres multiemisji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.MulticastLoopback%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.UdpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public byte[] Receive (ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Receive(class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Receive(System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Receive :  -&gt; byte[]" Usage="udpClient.Receive remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="remoteEP">
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący hosta zdalnego, z którego wysłano danych.</param>
        <summary>Zwraca datagram UDP, który został wysłany przez hosta zdalnego.</summary>
        <returns>Tablica typu <see cref="T:System.Byte" /> zawierającego datagram danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda zablokuje aż datagram dociera z hosta zdalnego. Jeśli dane są dostępne, <xref:System.Net.Sockets.UdpClient.Receive%2A> metoda odczytuje pierwszy datagram umieszczonych w kolejce i zwraca część danych w postaci tablicy bajtów. Ta metoda wypełni `remoteEP` parametrem <xref:System.Net.IPAddress> i numer portu nadawcy.  
  
 W przypadku określenia domyślnego hosta zdalnego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metody <xref:System.Net.Sockets.UdpClient.Receive%2A> metoda będzie akceptować datagramy z tylko tego hosta. Wszystkie inne datagramy zostaną odrzucone.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!NOTE]
>  Jeśli zamierzasz odbierają datagramy multicasted Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem <xref:System.Net.Sockets.UdpClient.Receive%2A> metody. <xref:System.Net.Sockets.UdpClient> Używane do odbierania datagramy musi zostać utworzona za pomocą numeru portu multiemisji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Receive%2A> metody. <xref:System.Net.Sockets.UdpClient.Receive%2A> Metoda blokuje wykonywanie, dopóki nie odbierze komunikatu. Za pomocą <xref:System.Net.IPEndPoint> przekazany do <xref:System.Net.Sockets.UdpClient.Receive%2A>, tożsamość odpowiadający host jest ujawniona.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;valuetype System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.ReceiveAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync () As Task(Of UdpReceiveResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::UdpReceiveResult&gt; ^ ReceiveAsync();" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;" Usage="udpClient.ReceiveAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca datagram UDP asynchronicznie przesłanym przez hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.  
  
Obiekt zadania reprezentujący operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja nie będzie blokować. Zwrócony <xref:System.Threading.Tasks.Task%601>> obiekt zostanie ukończone po otrzymaniu pakietów UDP.  
  
 W przypadku określenia domyślnego hosta zdalnego w <xref:System.Net.Sockets.UdpClient.Connect%2A> metody, Metoda ta będzie akceptować datagramy z tylko tego hosta. Wszystkie inne datagramy zostaną odrzucone.  
  
 Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
> [!WARNING]
>  Jeśli zamierzasz odbierają datagramy multicasted Nie wywołuj <xref:System.Net.Sockets.UdpClient.Connect%2A> metoda przed wywołaniem tej metody. <xref:System.Net.Sockets.UdpClient> Używane do odbierania datagramy musi zostać utworzona za pomocą numeru portu multiemisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podstawowe <see cref="T:System.Net.Sockets.Socket" /> zostało zamknięte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesyła UDP datagram do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int -&gt; int" Usage="udpClient.Send (dgram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> określająca datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <summary>Przesyła UDP datagram do hosta zdalnego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie datagramu z hostem zdalnym z tym <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i zwraca liczba bajtów wysłanych. Jeśli nie zostanie wywołana <xref:System.Net.Sockets.UdpClient.Connect%2A> przed wywołaniem tego przeciążenia <xref:System.Net.Sockets.UdpClient.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli chcesz do przesyłania datagramów na inny host zdalny, należy wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i określić odpowiednią hosta zdalnego. Użyj jednej z innych <xref:System.Net.Sockets.UdpClient.Send%2A> przeciążenia metody do przesyłania datagramów na adres emisji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Send%2A> metody. Należy ustanowić domyślnego hosta zdalnego przed użyciem tego przeciążenia.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Ustanowiła już zdalnego hosta domyślnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.IPEndPoint -&gt; int" Usage="udpClient.Send (dgram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> określająca datagram UDP, który ma zostać wysłany, reprezentowane jako tablicę bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący hosta i portu, do którego należy wysłać datagram.</param>
        <summary>Przesyła UDP datagram do hosta w określonym zdalnego punktu końcowego.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A> Metoda datagramu do określonego punktu końcowego i zwraca liczbę bajtów wysłanych pomyślnie. Przed wywołaniem tego przeciążenia, należy najpierw utworzyć <xref:System.Net.IPEndPoint> za pomocą numeru adres i port IP hosta zdalnego, do którego będą dostarczane usługi datagramów. Datagramy można wysyłać do emisji domyślnego adresu 255.255.255.255, określając <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> dla <xref:System.Net.IPAddress.Address%2A> właściwość <xref:System.Net.IPEndPoint>. Po utworzeniu to <xref:System.Net.IPEndPoint>, przekazać go do <xref:System.Net.Sockets.UdpClient.Send%2A> metodę jako `endPoint` parametru.  
  
 Do przesyłania datagramów na inny adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Nie wpisuj `endPoint` parametru tej metody, jeśli masz już ustanowione zdalnego hosta za pomocą <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Send%2A> metody. W tym przykładzie użyto <xref:System.Net.IPEndPoint> określić hosta docelowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> czy ustanowiła już zdalnego hosta domyślnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> wystąpienie jest zamykane.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, hostname As String, port As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * string * int -&gt; int" Usage="udpClient.Send (dgram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dgram">Tablica typu <see cref="T:System.Byte" /> określająca datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="hostname">Nazwa hosta zdalnego, do którego ma zostać wysłany datagram.</param>
        <param name="port">Numer portu zdalnego, z którym zamierzasz nawiązać połączenia.</param>
        <summary>Przesyła UDP datagram do określonego portu na określony host zdalny.</summary>
        <returns>Liczba wysłanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient.Send%2A> Metoda datagramu wartości określonych przez `hostname` i `port` parametrów i zwraca liczbę bajtów pomyślnie wysłane. Możesz wysłać datagramy domyślny adres emisji, określając "255.255.255.255" dla `hostname` wartość parametru.  
  
 Do przesyłania datagramów na inny adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!NOTE]
>  Podaj nazwę hosta lub nie numer_portu do tej metody, jeśli masz już ustanowione zdalnego hosta za pomocą <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, <xref:System.Net.Sockets.UdpClient.Send%2A> metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Net.Sockets.UdpClient.Send%2A> metody. W tym przykładzie używa nazwy hosta i numer portu w przypadku identyfikowania hosta docelowego.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Ustanowiła już zdalnego hosta domyślnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> określająca datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie datagramu z hostem zdalnym z tym <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli nie zostanie wywołana <xref:System.Net.Sockets.UdpClient.Connect%2A> przed wywołaniem tego przeciążenia, metoda wygeneruje <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 Jeśli chcesz do przesyłania datagramów na inny host zdalny, należy wywołać <xref:System.Net.Sockets.UdpClient.Connect%2A> metodę i określić odpowiednią hosta zdalnego. Użyj jednej z innych <xref:System.Net.Sockets.UdpClient.SendAsync%2A> przeciążenia metody do przesyłania datagramów na adres emisji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Ustanowiła już zdalnego hosta domyślnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * System.Net.IPEndPoint -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> określająca datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="endPoint">
          <see cref="T:System.Net.IPEndPoint" /> Reprezentujący hosta i portu, do którego należy wysłać datagram.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wysyła datagramy do określonego punktu końcowego. Przed wywołaniem tego przeciążenia, należy najpierw utworzyć <xref:System.Net.IPEndPoint> za pomocą numeru adres i port IP hosta zdalnego, do którego będą dostarczane usługi datagramów. Datagramy można wysyłać do emisji domyślnego adresu 255.255.255.255, określając <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> dla <xref:System.Net.IPAddress.Address%2A> właściwość <xref:System.Net.IPEndPoint>. Po utworzeniu to <xref:System.Net.IPEndPoint>, przekazać go do tej metody jako `endPoint` parametru.  
  
 Do przesyłania datagramów na inny adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!WARNING]
>  Nie wpisuj `endPoint` parametru tej metody, jeśli masz już ustanowione zdalnego hosta za pomocą <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, ta metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> czy ustanowiła już zdalnego hosta domyślnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> wystąpienie jest zamykane.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, hostname As String, port As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * string * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" />
        <Parameter Name="bytes" Type="System.Int32" />
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="datagram">Tablica typu <see cref="T:System.Byte" /> określająca datagram UDP, który ma zostać wysłany w postaci tablicy bajtów.</param>
        <param name="bytes">Liczba bajtów w datagramie.</param>
        <param name="hostname">Nazwa hosta zdalnego, do którego ma zostać wysłany datagram.</param>
        <param name="port">Numer portu zdalnego, z którym zamierzasz nawiązać połączenia.</param>
        <summary>Przesyła datagram UDP asynchronicznie do hosta zdalnego.</summary>
        <returns>Zwraca <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wysyła datagramy do wartości określonych przez `hostname` i `port` parametrów. Możesz wysłać datagramy domyślny adres emisji, określając "255.255.255.255" dla `hostname` wartość parametru.  
  
 Do przesyłania datagramów na inny adres emisji, należy użyć <xref:System.Net.Sockets.UdpClient.Client%2A> metody w celu uzyskania bazowej <xref:System.Net.Sockets.Socket>i ustawić opcję gniazda na <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Można także powrócić za pomocą <xref:System.Net.Sockets.Socket> klasy.  
  
> [!WARNING]
>  Podaj nazwę hosta lub nie numer_portu do tej metody, jeśli masz już ustanowione zdalnego hosta za pomocą <xref:System.Net.Sockets.UdpClient.Connect%2A> metody. Jeśli to zrobisz, ta metoda zgłosi <xref:System.Net.Sockets.SocketException>. Jeśli zostanie wyświetlony <xref:System.Net.Sockets.SocketException>, użyj <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> uzyskać kod błędu. Po otrzymaniu tego kodu, możesz zapoznać się z [kod błędu API Windows Sockets w wersji 2](/windows/desktop/winsock/windows-sockets-error-codes-2) dokumentacji, aby uzyskać szczegółowy opis błędu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dgram" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Ustanowiła już zdalnego hosta domyślnego.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.UdpClient" /> Jest zamknięty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas uzyskiwania dostępu do gniazda.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wywołanie metody IDisposable.Dispose, po zakończeniu przy użyciu <xref:System.Net.Sockets.UdpClient>. Metoda metody IDisposable.Dispose pozostawia <xref:System.Net.Sockets.UdpClient> w stanie uniemożliwiającym jego używanie. Po wywołaniu metody IDisposable.Dispose, trzeba zwolnić wszystkie odwołania do <xref:System.Net.Sockets.UdpClient> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Net.Sockets.UdpClient> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Zawsze wywołuj metody IDisposable.Dispose, przed zwolnieniem swoje ostatnie odwołanie do <xref:System.Net.Sockets.UdpClient>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Net.Sockets.UdpClient> obiektu `Finalize` metody.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.UdpClient.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która określa czas wygaśnięcia (TTL) wartości protokołu internetowego (IP) pakiety wysłane przez <see cref="T:System.Net.Sockets.UdpClient" />.</summary>
        <value>Wartość czasu wygaśnięcia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość TTL wskazuje maksymalną liczbę routerów, które mogą przechodzić przez pakiet, zanim routera odrzuca pakiet i kontroli komunikat ICMP (Internet Protocol) "Przekroczono czas wygaśnięcia" komunikat o błędzie jest zwracany przez nadawcę.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Net.Sockets.UdpClient.Ttl%2A> właściwości.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>